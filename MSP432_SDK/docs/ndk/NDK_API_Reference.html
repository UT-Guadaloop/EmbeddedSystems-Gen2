<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>NDK API Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,%0A%0A%0A%0A%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20400%3B%0Asrc%3A%20url%28%27data%3Afont%2Fwoff2%3Bbase64%2Cd09GMgABAAAAADzUABIAAAAAhjgAADxwAAEZmgAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbDBx0BmAAgUwIgSIJjzQREAqBpESBjUIBNgIkA4ZsE70QC4M8AAQgBYIyB4QoDIIJG8J3CQg7WxX5j0PthLRbJVvedpUoKlTzFUWwcUCG52fZ%2F%2F%2F%2F%2F3lJxxAlWAMiaNd12%2F9PqJmJKW5iyEExieloQ9KxVuZAQ07T1g7vfgVloomBA%2FUEiuEMCGVsPBsLc9rD3dPKhTisOejgNULCLyjxoeYlBGuZsjRKads6GS6b8QRDIttvKSa68bAbLrwP31TZsuGVyrv7lPcTS4bG9tKpUh76wlIon84X%2FsDUs5lHxlTP%2Fif%2BNs2eosU%2Fnf%2FBfw%2FriGqqb%2BffLOvzVA9JiiYPkV3xr7qrZ%2Fbum4pAxULkIPkZgBBQJu%2F2AG2zs1GxcgYq2FMQpj1RETESsbAKmzJyopiJzNnDKkTX5pwurDm2%2Fl%2BkLvK%2F%2Bx%2FAP6A2ZgrZRvjS1KSQBer9XuGyk3Iw3zfX%2B1eWZFmG4CQDj7CYnr8CXBV4ueyfuup7tsiSJbYtuxH%2FjmfaSz7qPupZoCCZ%2BkF0QXRpQIvhcQTov6omea3KKY0pFP4oK73IomFDl%2BISgLSDg2T3m9LqWHnZhsdUX6Zbs2x9S8bARE7Ay%2By7Qf%2FnllVniRftubDauc4suapKNQPzE8citiadRhUeQAB2Or6gcE01zLrqvv3azJyYfdvFLJRBRNN%2BrORtiKb4r90jEQolkS9CXdeapUUtovJYdjvKac7KcpzMaA1l%2FuGrT4aVVrGvMVAuLrBgPpJTtAv0AsQv4mpVYhTdrISsR3HVOUDRuJh4nIdPy752XK3pgwsJHaOiCfRBCMYnBZa2NQIs0MJBCLKQcLAUFiLHsSb1NBwDuVM%2B%2BS0pbMpCb4wnNT80UzMTE9QxNEqUXUj%2BXtWyBRikfCGFLhWNnelMh67A%2Bx%2BBHyAogRS0C1I6L0lJt9RGUJGUzgZAjQekU04ENxHSBYHaRMdLMVd257vKTeW69pbnoi9NTzZ4puUyQp2QCOOWBcHlBVHZINQPsqpeQjArJqPxaQKweFrTR1P%2Fk%2BXq%2B%2FE66DKZ2KGI2ZjJZNOIfxEploB4nMfYbCEuPnLbpwkSihwCCsbniQTAguiPVErkU4mUNL%2BUgcJFiymBc06kZQAgwjK%2Bx5hwzplJMQDIJhWEDSTOGJKlWpoIMEUadBm6RwiOj8PFkZ74BMmB3NPHvuQZdmtwhPKxaCIC1O5pSECsQvXqWxLjy0SwLDAMtWW45JcEf9qVQU4AAOvKcpvthncBrrn3f6P2TFH5pL6ErAoIPAgbyH0bD2BVQtHJQvXeU9iytiHI6oIFw3FX7KYd%2Fws48OV6eVger6oIUYdoQXQh%2BhBbCAZCg0ws5P%2F%2F30%2BhOw99btm1DAYcrQBRhWi8jM0FaH419ud9hVS%2F0ut62vSv6Q%2FT11%2BiySYajVNbtUV%2Fb5%2FexPSeyXTDklT41IpZiv4R2m3Dfcp9KWoG9CMAOmZLgoOTwv9t%2FXjG7O9no%2FSNV51dlkUn2AXcpNQTLI0adKlSGjJgNWg3YlhoCCEQH%2BDv5%2Bvj7eXp4Y5zw7piXJyd0I6nHeztbG2srSxPIeDmZidNDQ30YVA9XR1tprpw1uhWsieLKhwIhGlDCFAphITMFTNSlJXCvFS7BnGYV1RMYWUSk86rwpJKpWQBZbBSCbm2Z1laCiZ6RfcBbuU87snz7Dx7R5L4WZIjvKrod%2BrtYCMx9O8mwhLRGcX3ibFESNJCqbD2cGBXU%2FncuJtPLlOhOxfmmcPUG5mPZuIouu1w9CKPimlUnXUEk4VEgpJLUlkHBxWtYuH7JsyXkXXj7AS4sDsaU8uIxeWw2Z6h9iA3uWnrBnnWSoOFDnWyWxohn666Da3a54egEGCM4tGe%2Fq6VLupikmKFCY7LkmodtkTc48IxKTyS9g%2BEon9%2FU0Gfmor%2F91YEWgYeaf9eEUU9e7fPaySLVll%2FZPSApEe2n04%2F31YHDfx09bMcma9lC2vvLpFPB%2FysabdbsZqgVGlqkCjKQZaCw9RL5J8Wfq78fbpRRBgkAAxoN%2B77EOTWB8wGH4agD%2FWBsmqI94A%2BFBiQym357qjcbDkjVNVS8mFxqGkbhEW5Q0rbxes%2B9DWsbK1TFiIP2X%2Fhky3m5JlDhoxIiRi5oUREAgQUJuwkwnKXsPYD82bP2nAFm5nLbZFniAVCw4pU%2Bqg9HOyqPE6GeWwEVpAL1OD4ReXMWGnlZg8RK1l6TAzjjnw3zNBtlCkyLGpSVg1rGp%2BrMhHlAiC6HaUwo4ZUViqrXkR1biihit4A5P8VJcWHBXYcMDHm%2BVEtaISkshedHnqp6MBKe1ILH2yAviHdNTbXS94mvwv%2FXjJusom6TmqUVBr6dCPYTMTqM4WFYrEPaeGMiEBczEg9JsYNFvESiiy%2BaBSdP6UREzNPxAMb5yCrnRydl5oLRghNYHpYqm5Mgj6bGcLtSEgUSpzEqZvZQFUoCd%2F491qYH9vIUigQkxnUr0rZ1DjE2gzGWOAk0qO4y%2BJrS01dMjSQ4BtaLQQN1jAHBNY3Z6by%2BicjUAwNoFPEHxGQX4a1QACbwPpnIaq0UdSymS9t3E1qlrFMKJ%2FBEWWA%2FWb4dE4kRd6bmY5kiLfD64zt8%2BWeHB%2BcZTDDLXesW9PnCSGUaC%2FE0%2Fg8RZElPKlHYd4R7O5c%2FqbimL%2BpNfRGnjFI1Yl%2BT0jLaWSclz9Gb1iMoXN8hCL0wWchLqS69sXHGrHBDM6USOEEjrLDEcJdS7xNCJA%2Fn3BSiMbMyQ2EY0xIu4G4X%2BP7uAO45rs8N8kzl2cvL4xlqOUwSd5HLl85EA942MMMthyFVM0aP%2BLaJViU0jrK0n3ILadidX5Df0hDFXwCIWJ0r4T58QM6uleTuOxYSd5zM7DK9LQcKM%2BQeJzGwd2LDM6BRtSKpoM5txsh5UZ5vkuBS74pKpYGVnlVvQ5o%2BQbwNE%2B9qX3yYO35Jmz%2Bn5HIpUfJ2vyfcGnkNDFvIWM3%2Bl0SAJ48tws8taOvAL%2BPojsDoRsZILghY5rGbIwyhURLrWp55YC9KERyteUrrJvBxgK83RyXPcVHMCoV1zkeyAymKLA4qBuCE17rUFLPeFWiZKX9NFIPkWfjuZHm4voKGHuz5gt7xXpTvCZPhpARHTMjea8%2FwnPKhOSEpZhhrY3kuKgm88Euz4ZRsxiLqrUUXDCM2Sh%2FKjJmOI83BylGUktaOGk4F61UfJ35fCC5yHDGsBjkhYxBFaw8KhGxVNLhVakk7yq4dSzlWFZijCc1zkeTkYwYnyJoLlobOWOUa2uxks1KRCtDLiVjk7zikMsiyxS%2FO%2BRxwCZCqTBKXOZTycx5EuMsI%2Fy25wHe4lzgXyOx2rgm%2FVNMKc6TRgCgiHfgRiM%2FFYcSvBA7nUJ2UqhAvL6znIECFAsKRIF0WBJkLQgKX9nAKe6KytVSyscM%2FYoBzpAcZ0LQDwAHwYTaxCTnK7Eg7dJpjEys%2BmX%2BymSpJybTABwIUK3FISB%2BvfEPpaYfX6dhYCS%2FArvbXpMxAOujddHcKCy9oAuosBwO%2Fd66aodBZ6D7bZbgOVjxhKzQcG9DNEl3hATNHPFDklxcc4NylfRkG88t2VfSoUwj1nL97IcKprRrU0xLaftUQLvKqBE0YCLFJ3XjQTVlx5kKoTYQIvTnMDpYqQumFfIquUaT3%2BTlFnBAUcDaS6Ykgm4D6mHZ3T5LS7ASqCHVNII69RkiqGYX8m%2BKFuRyLBfKpASn%2BovFuh8NjOEFNgt3km%2FK1AYKDnTQbKHVKfxpUg74CJVZ%2FQzVmPSrAGHPRrKIU8EQJywFPBHiZyoRp9ZiqatfCUYZAy10RUjDNhY0ApFk%2FRCyRru7v1GbH2EdpTUYrJNxdP9Ib3%2BKy%2BLdDlcvu7brITIlW20bGBWyvH0bbUTBXw42%2BLKEajBc93Xyvzg460i8KDqQpbI8P3hvRfdjuH3yYpVuP7ea3AJpxwwZtyHxnXa%2FnKVrKjEQL0ouoeIxVpsuMrmtKoWLpgAemjUmg13xepWbjuhaStVsQCvFIriQZRKfAWu5xpjxjqLR%2B92hNWoQUpec70wOSdjJSPAalndek2pgvd9VjXFyCq44wwNIpqzRTtwaEINuYuVywyQb9DmkDnaB%2BQq%2FKBrBntgVwLySNWNI3LTiTgU3U4wpJTHRMn%2BLtfsYleDP1XfFrU2cbdHOGW1GMxq7WE17UZzrbpJsXeX1zvkSyQmmvmRPyMTrQqFtbSYuvTlGSycJKvDElm2kcqatiRtM%2BXAOliz6XR6Ql9bpw5unABUyOZmgUjozRPHLFnqBm%2FwT1OcWK8qbpMEwmn6fkxQEFdGYoZxDwFdZbaHVC%2FztMekCVCMn9lawhkKL7TRk45pkUC%2B5tZSrFzs5CgqwTej3T7yWhaE5gLHwn%2B0h%2B1rVeqVTATVL7Tx7iWvUzv%2FJv4Af1N%2B6fX3rQ6vzx0zd7AM9pZGZ08pB7ixFyHMPMxRekmvk8%2B3fknvFVjbKAAscRdHPQn3bUdqk4DItx4uAP4uJoEdaEbR9%2BhVL1jrs8QEmOsah78uflhUlTGTIDO74%2BgLrewWOW3kkDAFWPFFoTSDBczNkV%2BTIpFW0FdcpU7qk8OkJ36V4143X8%2FRiB6b0k02n%2BPhuQfsjDBbaNp6O24mTETI5ypKMLGM%2BSlrrls1SDdfGMEMfrBVHTthLvtRiagZGJqAA2xWj%2FLQSS0wDnrjYqKDWY%2FRsARcIH4dVTFwMoU%2Bztku1jDMPKPHUi0CfPBUERXHmkBwha9YGGWoT4OvQAnlRhh0FcT9RN9eB9p2k9lUBEL4Kdj9SqUBb3XloMCJaYYQk4unEKTGtoGNjJ0UjPt%2BF0WKcKYdukt4QMO73z5xqVuff5E9rtA%2FfYyz%2FMnjX2wNnKQ6l27H9CWD%2BRO1%2B1pn9i7z%2FJfyrHBDGtR4e3FSyagyypIf%2BrO7UH43VZHiezC5WmiLqWU%2BxfgZqHdvoYE0uUczILmJXnvYQMuvrM9eFXgB8GyglGRDci42j%2F97nBN%2Fc2w9KTWDMBTid2ylcc0NoRoKMCdY%2B9XNfyvR1x19xfBrMibf6RUaTKowUrS5N7Dy3sl8q6yweBdOJHvfOYiQnu8iCUlX75Ez%2ByPPLUvSO5cXrlTFVGP2yqazi%2BDhaRUHVMTJzYyZcq0nRnU9ws8xROWtlaAxirS8Tbqt4mbE2nUu2ExdSdJ1Dt2%2FjOykL4PKLdSEIpa8QNypx84hVFSRca1604waGkUD0TyhAH%2FRT2vxpWMp0yEZk9toonGknwSgn97RBT1ampeL6tJ%2FCfGT4kdwVLcjyqvbqO67OKxmgbJzJWVBM5mqTNsYBERk3uj8adjIxDI%2BZHZM8eh835zUILIO2%2BSXKwJp9UIGbuKzbWJZ2NadauiyPJhjjgDOiMrQMWYVi8Vc2bUH2U%2BrnIASPySLy%2B6FkoLOAyxMMvE85z04IXu4pv%2BjPSofeKtXzYo3loMlVucEoR1aBZtgFt7Uk1A8CTZfhJlFQSN9GQQcIfRJ%2F0WFcWY1XK0BA4YkZuXRbkev7njNeq0XSet7ub29Cdc6t6TT5P6n%2FDEquLSQhlN6OtJJXVa7taVdntCPWBuVy2kThB89AhmQoY9JUclVtB3yZE%2F5EKRI%2FWR31zf0nq3wnRUu1XfBKJSb%2B87VxAAI%2FX7ErAZUgZgPNnfDmXeiVlaqbMzzlt6XPsvZ0nbW6A6D3zUKXbqGHxqvKtoc5crxS7qLwGAbJaLPtkpjrRpyNdM8fjceFhJSYMO9r6iLFvEKJGYZlsTIJ4YkyUMEx91H8UGDAEN59eGv0JettWx37%2BNmLtlctzWeP1eNg4%2B4jgYG%2BnMlx36HAQPeh7bEXxQc1sI6fag097394Tlss8Fq3N2tXtZetrm6FQcFnPOKL8d6J0UGhGVHi3LgvPV3c4QwXYohJghOdXYX9k1GzOZ8QGGkfo0ey6Vgbnh64wGlPreR2h3dUFDlzlGNHXDSrWo11Xy3N0knfiB38owN%2FfZ1biv5wcfbt5smBxuWm298%2Ft27VXO5rGe3a0JCEi7E3mof7ai61bn%2F%2B%2FvdtpXF5oGWq646GkbKicU19htpCodYv1%2FGIaVIvaTrii2uulsZCRYZxDdzwQKW7pnusdoxdw56oNYw4fq0WFwNCkYvUk9AIMFEOf5%2F1gSXXSXKxx9jYojEuTk6uNkjn06onF3i6SjzO5v9mKzjvPyn4SP959KOYUnxM%2Fv7xZyniS4Zju%2B4Qp03fzq4NyhlqhxjeHJBniFExDgfjwWSGcR0UttJ4hjE9m9lp1Yin11cVEwfs4nyCs7aGP955tz9Xe1bmcMfRGvTZ5PTLyLru2UZN0LTS6HzLns5vkrRl3TCTnkize%2FDoAiOJgabGlvHNjorUlrzi6FFkmis%2BMxT73o9x%2BGHVBdvv98Cv12%2Bz2STuyQz%2FQe7rRvF5kHlUz41qe92Dojegl5svIAL%2F%2FSr16XM13bFImFk9f84iJ6pHg2BpOc7vcofyKMq2tKxpnzEcGS3f6KUa9%2BEXVNIGnD7%2BceP58a2XfwjffSEe%2BH6zoXtutLn5fHNYu3tIKTbJd7YlCaMJe6Wp2XWbCUtAaEOZN2%2B8uzCUxpxtwc0Gtl8s4P17%2F8n7v29d%2FhtRW%2B2dw83qfX9ZjBaWy2F2tp%2BvzY8527GCbXNkshUGk4rqc%2BLD6WU9Tg122dXhCU3Z3s54bBiL5qLQ6KuW%2BPm7oYQF2DJgIYiy%2BuLN7sv%2FxHbbn7JyoB%2FMG88uDjU1DrUSWe7BJViS%2F2xLgpP51lyqzC6ofLfu9CHFj5U5JdVs7V11nZu%2B2stxYmfls3b479R2wimJUcOqB6ptdbpO6xknVcG%2FYCn09kLAeMFzlCAtlnS3jhh8JQVLDUhkZBT4tkOj4bYVl2PvXDu4NO6un%2BEZW5QeT0CTo3RmDX3DSy6bVMaDhuAPvaXJQfQkCT%2BQQVBbTGLHyK2ZWx%2F%2BW8aMq2KUVA%2BV55hE8r2JhVYZ2ZbZZ%2B5Lk0G%2FI5zczPd%2FJzCv4b%2BnNjUkCh%2B21z4F%2BD5cnhe6P%2Fy%2FtR05aylhNwUCo2XeNXph12N%2BdwIKu9yo9%2BMymzS6DiHoFipFGVLG123A7bxzekKTlxlNIzWqEl7WsHXQo4%2F%2FSQxiVLnnsioKptOW%2F8rUQ8zOVbVU8UouuSMXkF%2BU0SraYOs%2Fu9Ys2zutn7lEVpKej%2BBPL95%2FPY53az7vrU9gvEupKia3AyK8ZUJe3nyIlpbOiV9NO3CEseEf5jkbNe9k8iM7ItWZttSxj5eTSmRnpAVq9b8vm1ToJ1iPF7km%2FiUvKJj75v0Wwal9A78oaeKgbghBqLKadFfdbP0%2FA2MzgjMVGxjLEMwYQ0qeiQxrxip4xyXmkDOY2eDI1Wu7mu9uKK6zKh1IZh123N3yzDfeKnLRYLK1%2FbRFZEFSXXcHzqFTAhrfeSBNFO%2B%2FxqYGpK6AtF2lLfCfgVXE95sgGT7XkeBcXkbcvQ5Sl4JqufWaEZ8%2FiYpttneJrElOiKrC2MU04vaijf6x%2BPLtF8LY4Cf867dvDUNsOfip2Uf1Ccf63Qqg3192Pd9q7m%2B%2BUr91FVX5wa72O%2FW2E5H0S8M9hkcGRYmKvrquNksBt3d0YQl1TVsxUfDmd9zhhsbmsZIrT3BoHeaKCv%2BzcK3zUCjswCR5bPwM1cs%2BusG%2FGXkTN7XZP%2Frv5t5Dni%2Bqles5XtlJTfKyii73q4K%2F8p%2B4hKplu0vT3unEde5A%2Fdt5c3%2Bd1ASBINr%2FTI1dXNxcW72wub60BENv8BYhP3gjkA0eV0lozmZAp0uv36ZPPdwPGJGnHiiikRtCSmXm3XIvbo%2BoEnhcaWql%2BRWlLnUeako2Lo8rhyw1Z0NW5etRN6XjmFxox0oVo5HBffX3%2BoXLKc7pzgvr83r2D5kPl7TKSqwmzLWolRchjsdMeDnrc9e1s8dOLZMMly1A9K%2Bteh1A5JkORPI8T%2FdUKKZEEhYLSam%2B6KUEBK5%2FQo8dp3nAZlHfer9Vtem36ynrkUNAH2SgkbPXipVuamPIXK5CAOQsyD9xAJc%2FuDR81kte5oIIpjQjP796Am9R7GeyjIhZvzy5fPSFdnZmtCvuvOiG6FQaNSwtws34Zdj9j%2FrS0p%2BN76XO%2BNj5g3XrcgBRRU5%2BiVg8iDp4s2asffXNm67rY13tT%2Ffute9hEhQ%2BCkPBCiCTH77ndK5b1CWUalj4jG0P8PuqG21b0631bfpaxSmcV%2FyPMBmZTyb3nmX3S4n6CHld5bD8H6EyJnuMtXRH7x37%2BlgL%2B%2FnOftehc7HCN1UDMXFhq8d3Pkk%2FJX0TXl7aHJmdcG8LhnVDxNdelXePS3U6nKvl2Bm92FTZ5Gyue67ZObTFBNN0jcujtDCRoYU1bio2Loo40rbKnEmWW%2F%2Bja8uIYZIV4aS7cdjq3NX2Rp7eVVX%2B296W%2BJJmqlqLte8pe8dQjFGgbspwGpe%2Fej0Io6D1AwhtJ9bt3ShMDU3HsDbJRakig%2FbUUjrt29Gvn%2FSiooyejYq8MsZkz6V7Dkr8e3L4hBwJuA83jLZ14%2BruTWQQB8eZN7ShGRu2W1t3GBpn6xl%2FiBqpxCi4%2BOACg%2F%2FhfMZIukVsPJni4RPBsTHZG5f2H9K2GCKFqeyhzdghGysximUQ9%2FmUY%2F2ArbJMRvbZ1tkL8Zy3vzinu%2BnioSMHV6neDjLzHQtNEfC5AIITLsTlXFy6un8T28Dhid4L9zD0Fn6LIeTrm%2FkXIgKrCwNLmX5sfVFdIDAJljT%2B%2BFoagUKI7A8%2FGhwceXiwN3L%2F%2FOD5Q8NJBRdIS0YFrTXBBVWp3A5yDB31zXh4ZCRlI8XSL16MtF8Q2IZZREMNfa%2B2b%2Fc9dPTO5nTOCu%2FDXp%2FdGjWppx3W%2FcKau8dGklKfTt77PXdUXKW9jM8dnnMYL%2BEqReFgjDHh7meVu1ykUczL%2FH4vDq5afhtknzJONbZCmHS9OH%2FnYR6G7WPAPRnIqA0goDPC%2BhxY1mcCT6d6VjxgX50dcbOtGHKpyM5xdzK9HWdVj1rFVjVaytFM%2FcHZJRPJssanfevO%2BXVjXN9F%2F3e69DQzLoKEUlzHbQJzQM%2BlQ%2FQB1Sot4s1wCbQb16%2Fs3Ub1qQvj5j5U%2B76QcgEN0bxums8lLlVV8xsMY%2BQuyGBKM%2FLOmWV5Lm6K1J0xLeYBGoFzFW%2FQuGs0q3EFGgip23710YT8d5zpIrxQ%2BQpkUHvwEsfr1tAEv2xx6dSly7oAFDf3KcvnUD4StBrw81XBnCbtN9eli%2BwqL3dZZipmHHfN%2Fiw0%2FQQZFheEKH1TCn2BjTB5KJlII2YJ1F0R2BllmycXheTWlwpQidEWZ%2FnjvNpXIisG%2FKf64Hbmm2q9VqwHQML1yuKn15syWHkuUru0P9llEUMPKxWozy8KSTbvujV2RaAuw%2FU8TzSipOdkKZj63zhV7EzojEtrwmSdCIE5nYhRN7cscQzpSEhvwBVB3LQ9tENVoA%2FHB%2F8%2BnVxlnr0d9r011xk3G6Sro4n9zOfkUy0iN5h3trWXZf%2F6p9ZhonLIQ7AeIgqvLbdIn%2Bjff3C3Z3u4vt72tPH5raujePvyLq%2FGgsKCOgNOCedJPLryZeJrO1uk%2FpbZ92fXS67bzz27hVvcz3dPqaiNIFaUJ%2BEYJQm4qvJIIrPaPSu7zD2RUUEkVpUnYEsq4nAV5URieaV7ypmCrO5eGu1cD5nS20%2BhdQ9C3J7m35tSFxIULXEYc5gTgofA9iX2Y3mA2rzgXBBHt2lQ%2Fbd68XooaN4oiFDlDXU3wGcQ8u7UbET2aETroxgx%2BhXqXjSqLdo%2BH99lecGlvSM1zL%2FO3ZDl11L3jnX3YQm6zRu6YhpQUefpZvZnqg3FuB7JDHUiN8d4lyVz7AWrfDPxLZlL1i7ygXEuCgQyyhumn46yiNaHoQsRaz4YBbvhaVnd1SuqmGSPFPeXBRWaFn6LP4Fd3fl8f%2B%2Fxj2tn6HY29FQLy2bcjc2IiK3tGxGbWxHbGyuhETu7OxF3VkOTNyYnTU0nJqaMJqcMZ6YmjQynZvb%2BkxWr46KjgidG10VlxCYmdiUPidCEDJht8UkWxlFkKyajKjlvffpSfNYWFxEjlCmUaG3lr0%2FoyMZAIiCR2VhCR416cAcNoxWhFUnDBncYObeqyFQzrWtO7P%2BZ5hcdgPYkoCNSZiv9AvO9NI9rRu7EVMa2FYhw2KXOcnabee5EoBMVwSVgObHvrQzuAoOxwC0L9G9oxgcyuPMURgCN7O9HyXrelrOyAvAUsk6de3jyh1chBP9oiKclxhfjiIqBYRBOwYwMVnlLaZZfSEdL9eTQkp4B6o2ff6KL8rTZwJnFhhEW1aqgxaXgYKD5DT01JynWB%2BPg6%2BLinGlMwYQe1Z6KrOrOtlFt%2B%2FpvxrQ2elvJBD155VumAqFQ9L%2Fxnst3e4f5qtRaJDI4rzqCiRLi%2BD50P%2BjAOYUVEKYAojOHuScqci%2Fw%2Fvaffws%2F%2BPftSYPOfWcHjHViHnS%2BtqnMQ2JYpA7kjZRNO18%2FA0sTH1SabPBshiVlXh%2BqBOM1pjFdiCKhhPCKSOcoiMnLzKExXkfLyIX%2BwWFuJ2toQaA%2FPywvmUTMyy8g0klJ0jBbBrhxZmG1IrUiaJjgphJKl7WeuJi49zgy36M1Gp9LsvdQ9bKOL8vK92uHxZjbVqxHXb%2FKvzCG1U12DAnxj4wPRlMjtOeNK%2FPsHDDOaCes1WNacQJlf5pEsizwcU%2Fw%2Be6MyXneVieGr9mhqY7xWNm%2FupDtY4oGDoQbZlazO9idc%2F4F2Vwi2uaNcEFHwc%2BrscEgqiJhu86Kio2KiYhaXUwkMTI%2BdjUhKi4%2BOlYtvez90PqrqC7HJ7VrdiM9PfS41x0RXZHjS2q9tjWfIpveZSzEpfjPpIqODs3GovFdRgfTJNzIkBEHnwlya5V9YXasvZR%2B3qjHAL6a0h14rPLI862GofYr1du3LJ3avlY2UIJdrZx1IKNYa2%2BL2siE7oS%2BlbH5yykY9uuzZjg%2BzzMgJd212D8qP9ARQ8KiPKwdQ0%2F5VQaWKD7jcubmHl18eue3bjYKJSLM%2Bn%2FN%2FSu2mEzdIKn5OU0DeGSxu%2BF1VCxjKMgwEhU8FpWx%2FEbiaeoVsRpbYrcuXr%2BNAGuDJOgUvvUrXidVDC6NTnZEpYSENA%2BPsOPOiV4QG0yz27fIqzkvcU6su2Q4pj6QX%2FlYXaSa8MlfT5XBz1%2BLijx%2BHpdLtT68dVWajUt9W050iIBjaGdxCR7H1Z4pd7I7G4bqh1Va50e7%2FZOHp3gD0303PO75ZzOprmalxl%2FFfsIS1WNrM41E3fleyMgEoCY7E4Onkb0jGGc6gTTAI5vqic%2BmeUaXF3ei4H%2BOoxJ2mR4oSirg0HEwZBG3y8BakAcIkmec56NSGdcpZNQnhf%2FJRBL82fTe07w%2BMELMy%2FEmBwABnH2USKib%2BkjnosANo7N88xl%2B6%2B5pidTov65yRhYAdBXC3aKrUpKJTHRiqLJ0pzffoMNA3dtu%2FdyfANzACLD4lRUEoQdp4kOjFWGF7x2ou9nVzyThIHERkw9lt7IdyDaZ13KLt45Bz0kPxKo8Ivt0g%2FTbgvU7tb2%2F2hx0PhweZN3de8K%2Be57Txsdk3S9pGpQ8B%2BkpGyTIrn8urkwoSeaEppUXlqrkBFuWMyqZAUiqqsXhXGx%2BdmJCDi02NpcSn1CQnRph7WSPRM5lYW192QaFttdCYB6Z%2BEN9THFQXQuTx7HgXEoV0YwA9TZ1g0IQfx3HgXOzqqD%2B91nhLDm59fRlgCUniF9ZUAqNkbTKLXD6F%2FpTXoHAezU5Xy%2FfVUObL%2F99DCuvrO7liRVoUmwh4GijW74i9RcDg0OVsChxq7witTgnJDhcHTL4IS%2BrKI1ELSjIoZxJSSUzFPrxT1PXkNwyFKgb%2FuBZ03mN%2BRWmgFg45ejT8l8pWBWtsVN6DTq%2FvT7WzXLqaEaPH0PAJwFOKUvNVMCXVTqkL6ynd7w1FI2tOU8gP6T%2BKiUTF8Wi7ebtloRO51pkkfRahYiHZ%2Fbjx33DP%2BxHofEc2GOLtY8LsAxkAWVt0gCjPcD0EgZ2ShnA2vI7sNHdqjld1AQcfV%2FvSa0%2Bq%2FTR%2FgH0fc%2FYUenZog9aOt65r0ZAOB0zfJle%2BCrh%2FUisKEeusFHKQEjlFcFoZUPv%2FsWgod2Rwpf733uTyMvwUP5WP%2BJTneUhnB4S4cu44avYe5McylYe7FiE0%2B0w7EXYm4Ql21n5EbTLuoHzrTgLoW8QsvxhyOqzIaSvO1b%2Birpy1BnYqJtH26MUQj84ZPmvDtJ89Eo9PmXm7zyc3iHhy7PhvUmzxahfVL6F%2Ff4f4vyuCKEfbV82h6z%2B0kFawR%2F8Ic6vIIR%2BYcjy4h2k1aJE2BYHIdUzNZCJ7ARbgP%2B2NVMOYB1yRZ6XlFzCWrGEK4V7Fp7fh1rnw8qM%2BaO1dE2rD7IXBwyXtd1nTypsUPk%2B7MYlhv0SGJFdZbJpZdWx%2BL9vP%2Fw058WPYbhNLhAYD4pjIUsmkOvlGk9Ae6vxmAHaJ6pAHTCs1rbQ19IWHakImgdhbqKKZoq5027aAtS%2FbeYAH8yh7TKaK%2BpH7SrmAN60J8xFWm0OwKGVvJqoyK%2Bh3h50qLs9kQ8wnYk6U6y1GY6hpLxNaSpoB%2F0hIE6mI0YBZXOlz4M%2Bij6KrEJnBpB7%2Bka2cqyLteJNIMgQaJvSAkAEOSSiwALKzo6zPyLdR2qzPwsXC7H6izblK01ArjhoLwILdg%2FvBF5ub68UiQDi1pEq5siO2vsmdSbSLab049%2FvbP01kQZhA9pT2yXN1Pl4d3txEfcg0g9JUkONP5BVivDf%2Beg89HXrfNK7rnO3c9aATViSx2BsTnb%2FOP0N9jEuj%2FdsOipxwZ2UPhldJM%2BhqMYThuMeJzjimpC4o%2BIGDSKqRT2bZ%2B%2Ftq%2FKdUaKuwDr7qdaU7r2W%2FLASNVbDJAYkFFt37nzft%2B3Dn%2Bu6o4NIOIUDkwi8ASkf%2Bxyv%2Bk4nAVs26jy%2Fb916HDF%2BWShyA9AQx8nbdq1o%2Bwai9%2Fqg3zA%2BHEfF6C3xUNCHMaQisLUik74%2FxR%2FqulPCJyJId6%2B6TjNeW7BErLvRYnGzE7eWnjqkro7qweX2jt7WzbphgcF%2F3Uo6M0WVBS6c%2Fi6jU6hgTJeH483x0VJvmnHFnz7r5Eu6YLaP9C1pUbNBh8Os9TP%2BihmG%2F45Q81rRxt43MpiZWf5XlUWDoaL%2F6EbY11IZskC6vjxFZedYU3Eu%2BcnQ9ZnlKc5LEBGyf1x30PsBC2qh1pZNYuqA819OQlH9QLq9DmBx1drYkv0ETKKE7QE%2B3qVmfm7gWYFWOtInTlBABRTsFrgoFJDN%2BQe8ghZKvWLvUkCUOUyNhGN914OMiMeal6%2FhjPvtQ42Gyo4tacDkQIlKFTcjj3SALhlsfY%2BBogaDOmEzBJ3IaWjFayxLDm%2FA41m1xPrtEAJj4HWh6PMexarqvCZGsV5PXrNmYlybaAIaVPhsqv535p7wEIoxWHkuEjKRN3Bjk0cssmwm54t1LuNcGHQssiIifD6EenIAdCnl%2FMlLSusXaK2GGhfTDFw%2BnwPQEW3WMu8u3nKcuh0q4muKBmX9o5xRlvfOz%2BpxvoQoAlvi8BVEseIFQLzIKZpN8R0ac85xLAzdbqnbz2raa%2FZ7CfVkhWxguR8FGDgV%2B8FRWA%2FdQggAy6pt9STWF1qHXVGjPVhqFdKWfgbfH6%2FPybWUVqCKOrxHW4virYMPdNXNRDV134XcvmewdVqU6iQMJVF4BGhbi6%2FrsVQQ4En0JzjB6TVJgs33LaD1lj4nEQqoGhpZyead99yzOcBI46cdwMquJu9ZVVa8xGKlLPZN1Mubp%2FqHrBgC7At9Qy4v9fPn%2BMeZyx9%2BxHF6QpujH%2F0y35%2B6wMOjCyFPdUmkYBiLyWB0%2BEROuk6UIROcO%2FczqMD518X0AY%2BFOTZaiHVys8jMoeq8wpgO3fEV2kPcjxWQ9fOGcUV6xzXvaw8v8TiPdVcIQw0R1NXYIZgCUZ8hSLpFkln38GYKKjIJEklt0T9BKYWgn0gR6fJjTHyfuL9iCkg4EedSyTaNjGbinSqKrEnT7izD52MYvgSA1Dq%2BRGLd78dIQj1Lj3hCSCIKbTXxJ7JMc2RSsEmHjDGLX6jlKXW9M%2BTpgwVbIbSLHp%2BMhpJ5RYKXc7O%2FOZmOAByNgMfLeBY1HGZEY%2Bm6FtuuTMSIaDHuELcIfcTYy6R5nN48lr6HYfQ5sj4xmVgzoTFMUy8pTH16ZUGJhQxQ5%2FMIcyHwZ4SIZtMrGIodYeuHQmFiRQWAOd84IWXt%2BBKFbTYCYajnb8i0b%2BtUE6H6yPKczYOskSs0fEapwCxfFqESFJmb%2FeKdezIJElAHgh82coKqyha%2BvMLI21YBusHRhkSJObmx7GLYyoQwC%2BUulk2Ekc3eZUga4jiVdUDVUhKpJTGEmVruJjPYn6nZiOGg1Fr94AQiNwlGwiRbZGOqJSNajU9egUDxozGwBjX2DCVjFcBJWCfIEjaYkOSiEl9OEKWeZnS9BSgJCMk1cKSnWoxqfOavNZnaD9QR6DdMDntCmPEfxUUCtqQBErC1Ldd91kgonepcgrXZL7Lk%2BAthG%2Fxjs5hukeWXk6bxGXrYJGm5vOfMX7CU5kppyeAKqaDskrmPhZ5rEaMx9QJJvp4rqIt3wlGItBT99uIKWAf40K5eYvH9wsEgXjg6RKoo9rTgK1ch0Gs1phF0N1I3m%2FvSABKq7C7kAG5ReCNRxUZLLGoRc8SjQOfDmF%2BJEWjciXt5bQpYLHLJCinnNDVWXioBT00BpKbvCczwAS9SDP0Y1vHOQ7wzj2PzfC2nPyZ3IQkkfbkYTdeN%2BNnbyDypqleyH94jFtnBZLHeejik9%2Fz07s57wM5WN2o1bI7Qpt9J3bbO9%2F2xJ9aPtEzJsfIq1ppPHtuStwLAFzh3Zw%2FAax5FxCqqjYkGp9hHVNqTIuX%2FnPY9%2BCHPW0rHQWVfUF0kg1bLIFeFAdlflFgtcikpiiYZvQRYm2VsZUGm55B2HT03O9Y3YIYERKIBgoWw7rkpnfMZxx33S7Raj6qy9A1WRwcpmjY2GI5JJbnT%2FE%2FsfF%2B33VeMZAgFIAU7XpWSDzam7KtkIHJyAyiDnRpRmfjTLbJuZRh4%2F5iyybFZuvKZXyxxjr5frhjLTTqDkSvZzt5P0Dk7aE5qxxUaDBrbVB0MoxlPJpUKgcUBwSp4n5U1c%2BsFFPecw%2Bhz05AXkwTsh%2Fv%2Bu0w09dG7k0BdT7cUecveW3vjNbFFwXOfED5EEWy4R19MwxoWZB8%2B%2BEc4gHgJURKYrHkWZSVVG7LC6Lu%2Fyj1Jf%2BfDrwD3TDnJtalTH2x6ugD%2B3Lh8OJ7ESiuWJunkuUFagviyrgvk%2BRYjEaRfm35SSmXBSX9EVQt4jVihTdBqwwyK7adx0dqbUx8owyxySevNjnjNYJBHAGM7hKzwxSR8hzTOM%2FHuPkgpsyifAVj3c%2BSVREw%2BbWA81vpI0OW03FJEbZir1rOQOTRefgB5QyOuLVHYjmDrv7R%2FOUK1wRQLu%2FcDAKq%2FbbwDFi285lWmmLNgsDjj83FD0lmo8DBFiskRvrN%2Fls51y%2BYXxb4OXLVT5dJ8DWQylXVTv4M3TYBg3xBqIF%2B%2B3pi%2Fx3HRc6mNYKGhe95Py3LNYOu6dnQ7t3avWSmDJB6c606XLNZCd9bHySOYSxOmITVzjZPJQuXBu6CfTvos%2F4NI6UV%2Fzkxp5EG73IUraubALTXq5tzoTxDoYfK8aSaS4o7%2B5FyiHz4dPaJzPt%2FeMy%2B53Q%2FhoFzlOLcHmvutTuDrxqCFw%2Fbr0c4N24jMNp0W3OzJs%2BdUYjLySqaYrE8xNXl4XIZuiC2Y%2FT2okht7i9JIhyKhtR%2F%2FM6%2FnIyGmpgI0oJTbNIVz9%2F%2BH9fi%2BVR9izUG0o5%2FPUtylRen6qomwdW0nf9WUhKKp%2FISkIcw64Za66sA5j3kLdlbxOkX67Lm0FkDP2mfB%2BKlPYbYh9aHm1hIkV%2BVuFLNevIxedIV57pw3sOIPK2Ly4YO%2F69LBYiEmSTcD9tpr7TQms7lSS7w4akMUPE0EvV%2F7B%2BdXTvrGSfJ5GNIQssF8qrKbLyCRhzQsQ3%2FNlzmci%2FxKzJ0ai4nIaYAQiqyoIy1NMVRpuI5xH2c77%2Fn1dtiYEEAKDy7LlHuln%2FvKWhnPQaaAquw%2FQLAdA0W%2B6XQO6N9K7oN2LkMDtH8%2FmRX2J9ZTMOc6ytcULn0b5sv%2FwqO3JZ2Awh1ZB%2BlY%2BEf4ywOMD2TOJYAtZI9uwTiVmh9rOtVwfvLk98UqKPtfvSAvdVZMlsnIjJYF3h9gnEi%2BGLvNZvaejXX5S9yyR%2Fj07%2F8fWvOmPhZLNnB88rHUonwssp9qer%2BvPbmsvcCixgRSpYGQhRQ80PASi0YRSkVE%2Fagksk6JHoyzW7TIMRMOWlWPT%2B4GPoYKoUap%2FIPhTyW5CeXl4soyww0ImMqhKSiLd8XBsP%2FYb2L%2FsmfWpPfZTNyHV3Akyxidu5tWs6nsPw0M1NKo4Lx8U4Y7HXxz3yTmTE61JRzb%2F5puraZxgud11xMFgDdQK%2FdQTeaNmr%2FE%2BIwIDwrz2LCfolHhV%2Fybj%2F3ME57jGPwYgQV5qGIzNgJPqY%2Fhr9wuqeKqcQSKNSp81%2BGgV%2FGS44SVY9wq6fzz6v2BjJcQpcSFO5C7k%2FeHm5vNlRs4lGkUnzyVeAaIfZh0bZx8o8q7MlDnnw5WgWf95XqAlbvdpl%2Bs%2BLav6%2BltDvr3j4ePto%2BuNHf47p7nq63DuLvdVk8ynd5TaAuJPU5cuRlJy0aM%2Bm3i0McychfySsX2GxJ4N%2FAxiFYNRap3nMrHDfyXWeZUno8A6qbSLljKn3Z8eiVHq2u00R3nvC8SdD8oRVF9Rh%2F7Z%2F8GP8YkAnmggovybRkiC7ytcQkrIQacCg0I8kNIWGs0qwdH%2BB74lLZz%2FYDczXf%2BRNNRUYhRe9u9uR5o0fz6Kq%2F%2BvqtyXMyDsXTofuk6p66pYkaHhbWOutXSgxvKiiO%2FvMIrFDkxTzitx4HgK%2FAKjztUlSmPAPe9pmYOY1DjmJLrufFdJ21QSj%2Bi5mj2hj77FA%2FhmSTzOM0054UPvW3TTIe1WrdlOVpn%2BLfuuMt3D3QYYTyXKenK2xviclsvyOIKkLW9Eb9ffrzgjnQXiWEwuyWS3Ve7QXIB50Oqp7KP1%2FiCbrbYTcIN%2BrpxQCqW0vKkZv%2F7KzTs%2FMGnFdHXJKyvTf4SJDnklRZ02taSdrWev8WwJUzNZXCQcX0FTYraWryRyugVGdii5W9n9jXA%2FtfUR%2BGb2XxVqjbny2E85uCTJ19eG%2BFeP2F3lvcZB44hJlPCtj38aWQECQjatV%2B1IHMt3ABj55%2FGcVpVgzw1O60cFqdIt7s81vEdWU3Gk%2FFVPZ2YyXTSThDnw6QKw2IBb1iw8JLaZwgNTNLRbq30q2jGMcE7odKxOL70RUFyY9aLYabhrBOi3u%2BmRVoUSNsVmo2h7Q9pLd%2BmJ8fYeSDcopo%2FQo%2BmLpHGP7Wp8g2dy7WtAAQAYrl7ur8Qd39v7P8AiX9fXfbNrRC16qx%2BXFn5mz09nBuYxALMfZNNtQBMbpmOAOYe%2BqdtVmD9zXxHfZS3rYzmkoCSN7sGVj2F2Uwgs1XZ0CG58ZFjA7NECljkHDJFkN49OX5yLK0Ciw5W%2BUyxShKJvkzH05G0Cc2U6WU6WUqxHdThCDFHLbJmOjEi5DVZQNvEVgMraoehJDUnOkQfUG9OUPR6dL7rTQNto037AFpjpyj3BPW1IOOlZDp5ey8Xcw0wnuFE9gDl1YC8I35tACdWoiK8IzMIonb0f6QnqpMqMt%2BYqTuoiz2oWVRQeDQzlkG4Dc0UUQNFtDcnshidGclmdIk8tBVn7JWKcSV79dMOaFNzQykIGLajkggGCSJYnxNQQRwyOT4qEVdvnnMoyNUccUIXiNpmJXXEQj1xahgRXw5h618C7IFzVD1VAv%2F%2FxelKtE2IXNKpR%2F53M80Bmed07IHpcl4VAHZ37fUbEM%2BcNiPqnEtIvktRZvi%2Fvwkw%2F0YaaZvMObcEamqkEO8mgTH2G1v5lxmOS1Hb8ARThSIcUET7Q8UoyDzWHeUGMueWQO0JKcS7SQBw84DCzeYUq2isRs7LAeaKZJIOlIDDJ%2FnBEU4Nte3kbWporw5OgoYGLFbJFLCY6BcSsytzqQ0nL9PEKcomxZFOs62lOxQ7W0TM9015QkAAVr7ZpS21LADMD9cRAe3kxUtcS0as2Vw7incZj6nrw%2BQXuCFrEpKldNJlCtlypBAJEwWBiIH2QlaiyoGrCFU1dY2aVAvaOrp6%2BgaGRo46jqsTOHX25wYA3AAAAAAAAAAAAAAAAH%2FrgH3t1NJ7bPjslz%2BXQ742%2FGfH4OBq0ZwEMoVKs9mWc9uwY7c9H%2Bf6v2ucKYgCAIAFAAAAAAAAAPDZeoZMxu57fJ%2Fv1%2BlX0R%2FEma%2FdVA5sLGdbGouxcizGgjYW7dm6Tvf0TPq3axrD7HuLcTlr1%2B6II6cuV5EbkUoUCYKIgfasMrw%2BS7bXzz788sciiUyh0mxu7DFeRERERERERET829HX5puaxiSz73U%2BNuRAUAIRAxkOz0KqPRERERERfc6eCYex3lf6DL%2F8wT2bGNkFx3VZs0hKBoVKs9mWc9uwY7c9Hz9ioR%2Bzc8MwMzMzMzMzM%2FPn1vT%2Fhdn7Fnu9jvU3xlaiRCBiIMPtWShRi4iIiIiIDGwhIl2t6ffVTGF229ThHhn3PX6fpV%2F%2BxJmvxxYPz2eVnwSEbgJbshSVLmRkywWrgJDXMCnim4srQmgCEgUGWkSSJFOoNJuVbCvHXoVU1dQ1alrVgraOrp6%2BgaGRo45r1gmcOuscXaMb9FDLHimDlWfh62ka3%2Bx96whBCUQMZNj%2B38Ju09gwu0177G8K4x1hLMZiLPI45AO%2FQCFDCUiWQulCRrYcKiASJioJRAy0aJUEMoVKs1kpQGWoqKqpa2hqaevo6ukbGBo56jhYJ3DqzHU36NKbjL5timPYAAAAAAAAABQJ9UmSqvNLklRdLj1f%2BjyOa4sF8JEHG%2Fkkv0Ahw6bOHIvFscXieFNY%2FNacQyRYVBKIGGjRKglkCpVms1KYylBRVVPX0NTS1tHV0zcwNHK0STbwC6%2FdiAw8SzYdwBgzLJLIFCrN5rnupe%2Bf3zNHMEY%2FZquz4772CMOK%2BOYMztOLdfvy%2FOOTMEY%2FZgF%2FAAAAAHDeNw9j9DEKwzfoaxt7AsTY7WOHjx0ydjZERERExNidOuEdx%2BnqXNclShwQERFRdmNmZmbmL79vBz%2BzvsvrwXz8AoWsShVlSElZRVVNXUNTS1tHV0%2FfwNDIkZv06J6J8u1IXl4%2BVA8olORBob4n5BxKzkI%2BQila2AGGYRiGYbgiQyKFG5FSbxERERER6R8dHo%2FH4%2FF4fP%2B78SGXjKy877HPO%2FlEVBEEQVRVVRVRJBoeRc1QMxRFUTMzM0MNZUeSJEmSJEmSJNu2bdu2bdu2AQAAAACACgAAAAAAAAAAAACghQl%2Fi4GZIZm%2BSZJMr52nlqUVq611VGvjvsW%2FnLVrd8SRU5eryI1IJYoEQcRAe1YZXp8lk8KQSCIiIiIiAwMLIZHJZFVVVVXVgYGFkikUipmZmZnZwMDCKHhUKhUAAAAYGFiASqPRSJIkyYGBBWnOWlVVVVVVVVVV9XwfHzDeEdw9PL28ffrZ%2Fvlj42yMMcYYY4wfkyRJkmTbtm37uCztTrrJDwAAAAAAAAAAAEDAnyMU8SLee%2B%2B9VFBKaV3rtDHGWGutc8557z0QyT0AAEg3kiRJkgcAAAAAQEREREQkIiIiImJmZmZmFhERERFRVVVVVT3vsTRGP2bzZ2ZmZmZ9EwYz58595ty6COacc8455%2FzuLl363aV3nSTxM1MHBAA%2BU0N5YrdpQbLMhQNiYX%2F8umRyFLY6Q84RIA841ARJH7I4Vog9iF3YfKwIVeHHipJFuyClBSrnK0uCDBB4MTJQBUiQhC5NDAonVHEHJF7mKCBO5iUcNAjnA0KCPh4EAnwpBVmvoiLJtEshmGl5R%2F5AS0ZbHpnFlrk%2FJ2cmRlZO4gwkoZTLRJGEwTSkWGiqG5U5L%2B5cuPKBl5NPsmAG%2FgtSy3uiKpkNfQaIX2VaSJgIUWJAxEmQ%2FNb%2BO540GbLkyFOgSIkyFarUqDtBgyYt2iB06NIDBaPPgCEjxkycZMYcHIIFJJRTLFmxZsOWHXsOTnOE5sSZCwxXWG6%2FFnqd8%2BDJizcfvvz4C4AXiCBIsBChwhCFixApSrQYEwaVY7qiw1sVGtQ6Z9RQCKkJYROyO4yvvqnXqcqap77oMeaH734aMGnLpimx4jSJd1OCG7a9k%2BjArj3TknzW7J67DiX74Fi1FCSp0qXJ0CcTWVYTX3%2FpaLLleC9XvjwFihRa0q9EsTNKHfnoIr4Zs%2B574oE583gWreNasKHSuKuuuRwiPoVojDGJuV9fOJ%2BY2nHLbXcy49K0NDH6eSQ43AkjnnlZAoUal0lJEHa9lJJ50zDWGY5QZ2EBTjyfTqHSsxIopEzKmYzEIlCCiaehu1xnXwgBIqB1lDZOaM4NLQGZlXfRmp4IeR%2Bgr%2B3lidT2xMK09VGyBBgSSlBT%2BF%2FbhKMtCuU%2BuyO13fUOCkh5gohAPSqRjpTQTtRd6nQV2mdvNe0Pfq63hS5BA3mCoIxUIshZftSiyPu0RWQOWURwlUV2zh6LLNLXH0ogBNL5dz5QYtonwhO1KOM37OCTOOCf7qQWBMkoZo4SJA6awEeImlzJlQaij6aA0Ghqh%2FhuXr69gfO%2BBPM1DWufSXB7NW9%2Bn6uyyNy7FwSr9%2B4%2FCLLe%2B8GnLABej%2B9aBQA%3D%27%29%20format%28%27woff2%27%29%3B%0Aunicode%2Drange%3A%20U%2B0000%2D00FF%2C%20U%2B0131%2C%20U%2B0152%2D0153%2C%20U%2B02C6%2C%20U%2B02DA%2C%20U%2B02DC%2C%20U%2B2000%2D206F%2C%20U%2B2074%2C%20U%2B20AC%2C%20U%2B2212%2C%20U%2B2215%3B%0A%7D%0A%0A%40font%2Dface%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%3B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20600%3B%0Asrc%3A%20url%28%27data%3Afont%2Fwoff2%3Bbase64%2Cd09GMgABAAAAAD8kABIAAAAAiowAAD7AAAEZmgAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbDBx0BmAAgUwIgSYJjzQRDAqBrFiBlGQBNgIkA4ZsE70QC4M8AAQgBYJoB4QoDIIYG6l7Z9BbO0QSerOUWMD9%2F1cTRZXq2KKIMQ6wzSjJ%2Fv%2F%2F%2F7TkRIYSYiG1VafTff%2BDiA2TMhx6R6GCiKKipNXRGIIlEUHG3ELP2MRhdzx4LfCiOw5RpfZw4irWRaVroe2CMIx3WUxkQNxk6z461hFuVKenMJLHnEzY2FGtGIcST7Sp1cxTYd8E50vso%2FyPErfe33BNR2HDauKu3AktsDKFzxgVf7HfsTCZGph8ip%2F4Uwt9iS3xxX%2Fjfik50%2BuSSvluohaoxGhW%2BQffZ0VxQ%2FGM8sOOfD3skKRo8vC8f%2F27ju6d9yKpcgWhygSeSCgqcvLLdBLvHsBtzrwRdYwKMEHBAIxCG6PBxMBITIzIX70341Y99elDvde3%2F30frfnvzA4t8N0FHiQ%2FnyhlhYpTFKZKttIVlLGFqAtdnOXCPfh%2Fppp%2F5s%2FMptmdsGE2YZeAAAIiCELEKsEJcKJwJ%2FKynfnO1bVyn4tOV3TO9YVUOtHOcq59RemitP%2BpqmCq3alMuiDl8%2F5IMr1QhE46pskVkHI%2B0pVKL2OFsw0Pdt%2ByZtn6Fo%2BZb26vHjKL5K9xJojdAa1M3xoi2sTMDYexavi4tFLAtdy6hn5NhRHIvdLOsRxnVwW7mrbd%2FdLaMceF1hxqKaWqy1M0wnGOUpUjcZlXCIOSPyiwgRYekEwk0wQSeYETiachON3GSksRmej5eOx5AgFckz8qFxU4sFuBDwh2aNMare3AjGQ4P3L7FXIFJNjEd3EIjsBrNet%2Fjg%2FqRyg6IBQYDvgdMlk3NkNNgB%2BqwG7TqarbF%2FI8LPB7hDBogrwqc%2B2nJJCrmTE6e%2FO3AQw9WXmJicB2G0w%2BCQKLMusyiTVt%2B7VeBVQSlulYqexUqapgXzGwx058eVSam5Ez%2F%2BqsWpG8bIipC1c0vuzbiq7kJ8HXR3gQZsaCScAk2ZMEttfCnh1JcHeCS9i7uQq5uxgQkxCzfoeYlIwvhVCl0IVcNN12t9cdPdngmZbLCHVCIoxbFgSXF0Rlg1A%2FyKp6CYHaWA%2Bi8bm1dBjU8NCvvWp%2Bi8tPihQN4Xy4MWSPrDmG2TSlyfUr8c9%2BGtZUM29n7LsMByrIY8kQ1PSvN5MwN7xjeYm%2BZ6Fjs63IOyxLAcXRh0WHA3Sqhv%2FAGHf0OMAboONkkhqh6SqMber2rJnbwoSAyHiIyrZsPBhdDfcIJb1nz97ZXbZD3r3ZFlX9JDujMWp3NHVAWo4OtbwMm74D8lx9V0Y15%2FoRyh%2B3InYAAFhd436DrdGmAGD5%2BNuJDlyQOSrMzssDFPcaaerubRRgeZJJFtd9djWV1yY2p3ObD5ylFJt2%2FadoQueV%2FDg%2FXT4TExATEQOJSYnpiZmJRYvdAHH8%2Fy%2BjtWSl2ZY9ZgB1bSrGJybUT%2FcDGJ8qjlexgDmei4II%2Ff%2FX39P%2FTz7C0c2jG0c9R51H5Uf5R14frfzfuZJeMY2qWxgvm6qGecX0LG078j3V3XHJBsQFAKcMC4MEe%2F7%2FyuP9kBhfhu4hm%2F7KaGIj0k6NG9SmfP41vG3Zrkm1SRWSNuu%2Fe%2Faao7dacorBO2u0EiaE6x12ujLc4K%2FPVqeL%2BfFsemsy7svMaJWUFIM3FSaHwOESCaBWCCiq1AtWXDTiiFS1TONIcT2HKAj3o0GLG41VDRcQOcGCtdgk52DWC7r180lc4Pl0QVx4gd6WCT%2BHaQMvW%2FrMvV1qCH3fTjJoJZ5UIggyI4IgoVpSWH1R2pWcPCfPJeJLXJvrm4iEiydOtD%2BeimF%2B5HD4kheX0rA65wh6RJWAyj1SxSz2W1qlMghMHDWRluntJCyhuxbhJUQk6uLtGl6EG%2F9mC7ysmM7DgVmeLW5rBOxijW1gxT4%2FOLkQI5yW%2FObPgeqSOYxzqjBW4pJspA5LVt3PxUNI%2BUz2D1Dz1r8%2FAZsLS%2F%2BdSkBLwEMdfCVknc3u7fMqU91qa2%2F4psvks3WTyec7tZBhX%2Befc8PvvTSw%2BvUC2bz05k2zneojGQqtjgapOpXFH7C442UOzsig8vzVuvWICkgAMIC5UhBAoCx6LLoXq2AO9IITTeQS8OHQgPTdvu9TSuN9JpJXzjmAxWZUWyeomrOsmF26aMN0IYo7XNkd%2B0j%2FywvbfIXOHjbZKBEUpnQJIQsgUMCQOo2gNUva6kX4jXdyX9qbSmUPnWUUMFmtWOU%2F8ouymnsMxRHWQylQjjU4PaS4EFZWuenDmRNFvkx2U05uhSl%2BhCIngoU45VV3VKcnecajWAPomTiDKaVTeVJWHwS16yrjlt6EOf8jaZBcnhMnwKQpF6Jc0whYyp7PzqOTy1mIfJ60DMAGaBvWc0bmFrHf6R8y%2BGJGTXYwprNRzlptfQYLfBOierCgUijOYy3tEVKIqh7S2xrbTSrq%2F0pQ%2FSBzcmGbRUT1rKkPNroDpXZicoG01xAZAQ7hXE1qLs0Cr40IwceagKo1ShLC79OButaQgQm%2B5DjaNhGpUpCZ9iSLVeM2FwBTuQeEAv2GbBSqEt%2BcNM%2Bx4ZLAtzRdEBrEYAIEYjcRU%2FXYlR6oMBkw8IhfQiAfhtVQApvE2nUkrrX%2BqG%2BjkGxUZqMWschJoQCpJkB%2Bc3ymIn8LXmsOZ7RA%2FRmKctblKy1ZKs8hmCKbs1aO6gsZgS2R38s3086QF5m3NZbEkSNInPQ%2BHzg%2B3B219WZWCPF4rJcIaSlPjBu8X6Q3hRB8x0swhhdeAUuhI5E3WmzkJgswT1jwF4rzVxsIn33RIIKffNmksyqRWdBdfzDOGT1Bf9Rn0JfkAK52V%2FpC3MO9PEApajj8TZdihx6CiDFYTmIKG64AG7k11kPjxlg%2B9ZghNsRaTqpVnbT1chLyoC2oREi%2BEnHkPgCnF2km0ayUFLwzpdWmpSlQdkj9TPKA8pIAHQCLZuGkE5dzCRIyuee97L%2FsDXORLLDs5VUbh5ZuAbdtxjo6YB9i73dps1tCohcGpb3N%2Fo2lChSykdkIjUYjvG9OTk8f6PeAeeZl4RsBoOwLyHOz%2FE0A5RAStnLRutoJ1uwgiYXLr%2BE0HccEPK%2FCdjBLBFKtnFrhVBQxFIHMI0VgGb0ci4Z3ZZbMgg9AZQaF9dd6qiT1BRASK6uXNStArgxCupzRTBgjKtNNyxe1MAojJoOOa6Kkt6kTKaP2VfKjQzFXSlVy5E3XjHlt%2Bip6X4dQBZNhk4sS%2BXzgfAY6h3jmZ3nMIfSZ77GwTWveLWWz3fuSCs6xVGy6lrA75Hw83W35lLf4yOfNDUanh7xnPst5ddz7IZonglh3LlIy9zwee55J3vPavK7JvI%2BDu6%2FissBTOysy5%2BmULZZbAVsOD9ilPSn%2FQWZz%2Fr8P7Ttkj9mdcGtYwrZodSLJQ%2B6QwW7EqQrd1qYCeIoNvJiJBj%2BHUloE21dP0OZOArKgmfeqoENgiIYReCWDTpT3sjOR42oe2bZzNvekQiDdTIY3kYWQzzZk2y20TNXjMTKEmU3WNYvOQe5npVEGnBXPzeRCNNRrmWtXTDiJ88ey%2BfTQkOtB3lcYBvue6kmMQ4aBJt%2B36ZyanpCTqW7MmpnJNc5EgRIBPME5l%2BLH0xqsAgYEiMWH66keclCIIam%2F%2FSlPGhZigOzVcLRjPnRSL1G9ypYipsukjrlHnZRQYQ%2F1l%2BnjnCxKkrKsdUYHsv5BhLzFBAtlZmmEeKFj0Mll2z0B%2BekC3QSnu183K1BOP4rN5ytSUDSVUl3jTyPDYKaLA4SqRMwyq0H8nLLp%2BgGD4ox9qVaOSYG%2Bzjm7njrpFQUJ%2B1SV0oMszjTQ8aQY%2F5N8fzYDLlAVQFoyilNy7kI2Wqb%2BlNg2s7D9sWSAdYnbu5Nl0Lo%2F9IDx8VOdA0hzsrzyuCbBM8yrFPJ548FJ5PEePHVGyIDEOssj1SnSiX7r2XDD%2FMqVq0%2BWU7QiW518PVzmZGrFAUh5cSzHbuepYnJUzfVe8vUXBJ0XGSUDJPQo2vZM%2Biz3MTpUq9oasCSV9WKB51W2UnR4SP%2BLPDnkaUDV1hS4xVK5iJaKlRJNiHSbJDYpy53lq%2FKmczRL4rQkS2MVqBGwD3NZZLSejKXO8HJsWS6lfDLy8oBVIgjXlM4zrUqIalKrbIJnWX7gxPZPoMZAU%2B56EbNGQMA5VPDU9ApfLcGKKov0G0MhorJE%2FbCv%2BDhndWCyI7k7jtgtazSSe8pCs9TCNmXeXxnj9WTbvB0ue9Nd0eJTUzdGVYzG7kHcuM5Xl%2FnaqlhZE8u2preKWGqL%2BgYmvy7HDm4F8EzYDNtKWM5Exps5DwBXl7Mqq9kQ7mXC%2B3ugpiQPEueMNhYXt3YjM9kucrbbT1q1vUaJlpLcXUBRpSOyfb%2FYss49aSU3Nhj43W0xAoqiwLaKx2l0uhuryEPut4BaROoDlOFSDDjXRmkjQrB8BEeRpRyMrBsDwoL8lZzd2K6QykvH%2BeSp0XwamLEbvLa1LkVft6S40qV1LFXOis34riXFSJmcOE6T7ZOXtrN2GrO2b9K1z4L5Fb4oE%2BVLSLHVl5YeJzWNaQKVjtwu8zyRiRpCAyQw%2BoFkpUUWDFbBlnWNHkqmL2VhxHShTTlPC922JexLPaXgzXpFJv5eCp14MTrbvUH%2BWI9gica0DOFbhQxEEMO4o21dAx87XIWKzBgCAbwYEcVYWqlY8z5XGhNt2uQVRdOkVn0qTGJPbuR%2Fp8XLm2LTW%2F7KJ0A1gxMNAFRuno%2BLh4l34i2hZ6DH%2FkAyplaVVm30WOpw60ZGug0V5yDJJfjtiFcQQosvxpncSRafyoaFXT5o1l01obLuYI3uMcZsQeGYfBIM4GhoUsbpJuoQs853zYBh6HTjaJ9TxoIB6aZQU7oCGxYrDRkpjM2O0UYx7CKjpM9JJTWgm6Q2wSgZiLNrtEy5IQIJWTBvwxmtkqURTNaCVU4cg5oirAdlYdnCdoMICCI9xaug%2Fh7myP0D%2Bd8Og5yRteexX3IbNBKgHWp1zHoa8p4Lu%2FPA5P0TpFPDDmCZ1V%2BnlYzBmrgTlgQNkJLp1lxS8wtycW6XtlgwGrw2%2FejN5HICJzHBUdH19Tx0A6vb9mMEyxBSFM%2BzGsR11sUN%2FkuOKndSCrsd9OyB8XJ01p4zD%2Bm%2FeLsjFuN9Av52cimX1Bgq71KNL7WnKRlazHD057DpoZFGEydpIXfh3A%2Bqvxi0oaq%2Bl31YMubDz6WeIxmqmhb12Hm9tGgWpnfCPkzjTplElR457RnWkMKJ1QJP0da7wnxblLCrHCkho1J3mX96gA6ITIfWkGIOSPM6BZY4bGuhJGbTjm69Txi2c2WDG4MNnQH0Doni%2Fpa%2BeVjXCYjsj4RYg4hvMQJjON4RJm3cyBjWEQJIoOxDO836oQNqX2gbM9LCZEiUlCIYyiDPBkAZdX7ANZzMv92vn3b0jTZFbY1kvrV0RsV5Kv2ktHK19mfBLbd09PIflDaaRshdSal4TSIvmLGT6QKCRa%2Bz1dBisAY2CVimm%2FGQ7deOsxOK%2B%2BbpXJFBzIQy0OR3JJFFI7wClRCkxAJ4w1b%2BZ9fDyCMlugBY0ogh5xqhXIFZsFcMuYek9fyILz3Nxgb1JM7eH0J7Jzazqp67Msis1by9KNuIHsf2KSgK0SEdCvBLQHiLuQn4pdbI6DJmJkJktySDcJJxbsWarFGROOsYd3ewtXnG%2BX3APWoJ0NQ8BQQknCSI4Kb6qUx%2FcXNw61pZI2BQuC0UikBZQG1sZXkejMqwVibDbxuKGt7DagmydCvbtgzhrlr0w1t%2BdQvqCNJ1S9p2DAf3h%2FZH67r%2Fy186PptJJlHL5HtTq9yHWfd%2BUDVC7znIHuu4ArE2kTajyv400sNbYxzdWR0btCNWsNF6w1rGULjQDIzccp6hZ2flAQIPCBy80rWAu0to2zKiLQPYo4EKXbJJprR0psn5sVgoPWk%2Faanu%2FPB8HdzQfSHqK1WhV2aSISuZYaJXvFB%2B0nHcVN118WIdUtt7zlF2XW1kdHH9ZeokpJEINomYjQS7hpsbO1rDbN3t6O3px9KCU%2BKDTG1jET4kQvpWBnGx09Mj3KwaVX0wMHZrvZeMy55ocHextgvW3PliLlgzpABSLi%2FxR56gCk5oDu0Z9FXLhVShr90m39wmTZXdvbwsW88d3yztqVkW1VK5VrtM7trMmyxdvfxWtkea3i7tr9kRlaPlkklODRE8CBA611oJ7kCWI7eCT7T8hUAHcSEyyYLv44uGiqqHq4uHiiuHFeoeKk8QJW6aMV8%2FPRWBzq9RrnFnJlnCrWESdhbCmm8YDI7kUzkeBdGMPgdxjwqZlj5Jvoz6c%2Fk7OSrjMvz3t9%2FEL1HyhP85OUlU0lJJtOf%2FbQgUMkzngz3XfAJMdGdrY8pvIu9c130xFE%2Fo7A0tUk2G%2BcZGBdnXG2LtUmoTsMcO6Vvf7g%2F7Wtwqne5t%2FvuNYVQVIoHNbxkvFaUb4B7oJ9%2BTfcP5tdNm311xV9Wrtys5M2YibJU4l%2BbxxSPBPw5doxRoimtbK2N49mPG1GIfvAw%2BBtePyC6tHI8v90bcoU%2BiEzTWxwSzwiTayM8ozjbeSdCyfMu3eWCnuK%2Fq2tRRmEdro5zHoR9oqL1%2BtS8rFiTpx6qHCXedCoez3YFz%2B52f%2F6bnZlKy63HGrz77un8ChM8bTiuTxP5%2BS0ivI6cQihMRRIhlpH5h9bwZICFxfLX7tV38G5ukRNb63ufZ5pfMmX0OJTMxI%2FSHrz%2FQbE4Rchfr4Fm2Ubcimn5OU%2FvZBJJxyWlFsVhkRlaWzlaGLp7Edg%2Fsl%2BDjoCGPRJv4KsVp%2BETbOBB8tE3xFoNuPR5ZTcvOfK4fzv5jZ9Jz6bSNXHz2%2Bd4xkDyvP61KxqglIa2xJDm%2BKDGupdDTxaw2cTfn42hjVTncsh3Cq7UyBe9PeD8T9Ob%2BJDVTtmeG7P0J1eHbpadOT5WkaH3Bt5duG6gWDy0NKXq23OSnTksPwMOPUb%2BUwBQk3Jbsax2LMQuA2Ue4BHm2aCIk0QMbkW%2FvHM%2F1wOWjnYNC7d1hRp5IxQujqjIY3AZWx9ccFAq3Mw559brY5aI1I8QWj%2BaEMqlYF1u7tk3u3975AbyMGBeA8nLv8TUH2rpvNvblU1Lkdz3QG%2BiwOABpaoOefXRp33f4gWso8qd5UVnw6Pch6vYkAmLscja2wC7B%2BOEIllrUg0CQK5SLKv6ANKep1047vrmFpxp9VQIEdXJGkra9%2BhweUmIamE3N6EnkZqgRKuktXeZ4%2Fo2N5avrSWWeBy6g3K1113H3X2U1LglXF9ZkqXb5b%2BdcnIL5FecjzE0JjNB2H%2BSxsVNm8JtOB%2F2RB0czGIcVS1C7hpSjz1mwcripAdroHUxG3G935vNdyV42mT%2F6f2z1NxBF0mvSmwjD%2FvdzTje6%2FvwYSOuo4vkFnmfIfREvRATkYr0rivyOt5zQK7eQQ%2B9YJf%2FLlzwn0RlCCcp69mLAJ1rLPubr7KNjq%2BMn9WtVPsZ862guoztXQMv7VLtJO7p%2FIYrcA%2FKNigKceKo2k95xXuGku2wpCx2zmgsTh7OQbVFdgcxlOjbWD6uHf7RIfr98WgGJfNS5%2B5N7YQwYDTrB6CUjZxVAUuGykI4awjxRe%2FXvJw6kcD%2BHlodRDPnviRpG7Zm%2FXz4U7pMbHOyXAbfwzTNfwLIc8jx8cMDJzvyQ%2B8Gjx9wysLI%2Fx%2FJfuavxaNvBwfbi4Iw43kfMTalJbOvM%2F8POsBGyYImJN%2BGESpfSVl%2BQiqWzqyKRkNQS0tbYDivrv4sGQdZ7D9kF8fXZbBioGWShcIn%2F2dVVA%2BKVr9KRpndRdogbKjFqwXrVrm23dIxq%2F8ndXTf44iKyJjrOD62rbBcGLdJrNqnAm5M1Jj%2Be9W%2FDt%2Fsl0SOjQ62kL7TpY2yKon%2F6PzWMdPX1o3zrJCGSo1diNKN%2FRI9Hv3NyFvJCNLeimOCaq6xyXl4ANWtG4JXyQ8smhc2XrOJ%2B1NNP5g4vmTntVba46hns5ffZISyvHd%2BzmrqCYqUuWIp0njJTob5AvnOGOUQ6AG%2B%2BLc8xIGXmJ4JybUlT8rWgSy21CJ6o%2FUlZBJ1DreDM06nEZbq9%2FaFbycz4SifS9BEgfj0aBNzWAMuxmGbvs6Ra6e%2FEgw8ePXs%2FEBXiETTtShBBdy26j6iNSGurguNy4tjlJQ7N1O%2Fe%2BcnNLmmePjLEz%2BmuVENn69cCI7aNDrT0%2Fb1JdW2WRj%2FYJzDQoU4Veh3e5aL0QMXz3sOx5TOaptTaojSvQpoOmkofrJWTnaXifezuiTwr25nS3l18JZtc%2BiDQcZ3jZK%2B1cDNEtNfPFSV1UiyxbRCHycmpy1MJEH%2FO39QSHLxs8pQD%2BRCL6XJdb9HkyaJJUkO%2B9fabIlEpIc7dU1TcO%2B3jqGYmtljzsovZ%2FyjjMiWMke21M%2BSMVorR6%2Fs5A%2BSkrLXJ8bR5CImTEqRAx8qsefHkL%2F0Z8SV1c9uNCp9uCS%2B5OQeZgev0S2uR2YVMOd8pcokFUEX1Zpbmi%2BbR8BEo7M7Y9ExSnIzhLUdBWzuYjy%2BMRd%2FsDSptGlR63V%2B373xpV7MLrgSWspD0XBibqSub1tyUfPW%2BqRybSsILvDZwVjUydzCTdZAI7owcfrV8VxnLVCni9w%2BRi0yanwpzg2ENCob8Yz1o0dDA4Ai%2FrcehftEB2EA8LuaiOxWbHFlOGtyTPGdSx%2FmejCGsyra9TrjSCvWyc9T5lQTYzBRiVDcBG5iZGUF%2BtbS0zoPN%2BSZN2aGVvffOX%2FcNDVAH%2BD53Y0qCZnZY%2B7JOPz6I5fJ5kxqUeIa46OwH4329sio%2B9DyIi16iZxI2N2VwR%2FocNS5WwqRo0%2B8Q9B%2FVbCrIW274leHV7f3zXqJXEjYvpfeWBZarK%2FIGdrP2UtVmzCGyqEIVeleelVv5qu59PpHmJjOn4u9PvBpqSFqiIB8xUaA8c0nmgFMJFBbmfJHlakuNZlP4opnCup4qSDPWd8psGZMFqW3D4srQS0LG6sRk%2BiwY01We2ntTcjvzdnlKxupU4uLU9qkCC8u5ym5gOwLiRMdfsoTE9cUDhWvesswB7RDFciz0kOexoFZh%2F1iZCWGfyyKLTFo%2Bg3hxnc%2F6rec3nj7LMtlcdOk%2BzJD7EabvLTlrmV0WW%2FSmfnnppg18cMiSMBms4QVtNcrVSHTSx2mY9jg6CNzyIvCY2HjZVwW2ONiekb%2FrD%2BnbOdjbGQ43uq0KYtgpen15dfPe%2B15iQEoE5zqSvkCptAuYoa6O0nVbGH3p6KAGM9dzwl8CfigZ9SIqfqSpHL0u8%2FXIUgpqTj%2FUpwIx5XXOYlp6mMz0hy5zylbzI4V1bToWgtbTIrELzkyUUYMGTojpd%2FrfdAa8ULYGA1sDawODOgo4wqllscXQZSvXH9f%2BEy4%2FTnVWtLFkm4Sb9ZrdkQlQz4eSQV%2BZmYe520E%2F1XW0RCYZ5nLSXTHa9Qelh6NR1FgUSnb1jRTTG%2FF1eZQ%2FGkcxdkKxUd1nLlzJNgz0n4e5djjrV8iPKcY8gCDGnTYhKIPAxfRGalUW5YoKox59sVjdL%2BqXgk6eS0y19ze3vK1G0N%2Ba8wmpMonhd5JI13LRSDKsmQ0MJxsniaBBKVqQ%2Bcx%2BKvWrYF%2FRsbKytnLvzyqW5nA0DIawkzEc%2FBCrR6JerF%2FbEVnl%2FfVvTXhbtLextYo63cB8iqwXWJo%2Fs7BYfIsEzxZ2lLCSl1xfHEbCR1osCNtPLgtvFI66GRNtFS53WZa8hTEZkePTN6aBZ1%2Fdc5i4GwYOyMyMj01P9TXC470hmenx0emZRr74OCPv1NTY2MxUHwNcirNBekrs88lgny68T06mh3dxPguR443JzdGTyBCGVF8W%2FXhdxV%2FLX8N%2F%2BfJSsEawVrDqKO%2FHdzeQvkEFhqeGhYYl6Dil7RDpMDkyqjrtMXnCreO6j6xpC141jt9wMUwrzCZHrd%2B0oj7sFsmZZFtcdN6%2Bdz%2FL4jZCek4NeZ4hX%2BGr6SVZoJXmbhA95qWobB5qmq8dCgmAJ2IbNTzNXK05HOKMTLRUNN9ra%2F5fqpjo5updqv5qaxkbqSefdSLa9xki4pqLykIaErWThe834tTilw8%2BPX%2F45PsdUo45pChIS7tFeW0Vg1nfWMOsrmM2lhdcMLt7u5idRRfCcm83SLyru1e8t1Osp7tbQqLr9VEX6%2BgTtwCpswh5PYzRhEZFBgYHdoV30QRTwcyg5q5x2pq4YvNCUl5S8hyFvgVFKFjV2cvNDYmS10Wq%2BA50Yfinxq3Ly7d%2Fgd9vFRUAon%2Bw%2BvXLmrIDQwmiQ%2FviSkuU5lZwc2MYTMfWtDqpr9rwouDenIur60wObX9Ljgm7PqY9x0CwXEztTOy099NyZhbzSTNzpPy56VznakenqmpnC%2F8AKyt%2FLBQR4A%2BDBQSIvq%2Fq35xbNVz1jVhIMbQ%2FpN1hic85PoqOgATpa3xTx4Q4YeJJsb25lRk4tFtlbgoptVBaxv413M7DRgrD5RFmTZzIu1meYNhQYpN8Oyd5FZ8VNJ6mYaato%2BslnYmO2ibr%2BWTXE3R52g%2F5dczj%2BxTYuQ125i00OEs7%2FjwuzbMNXYxdL2VWRhWhAwtsXKjlaW9JQEyhzbk%2BNIo6D%2BiIc%2BufW576vv3Bxs%2Ff1Id%2F35opZt711D87eHuYn6uahOdhzLWOFB2G%2BNAd1TJOtlwuHoqclpNAxlK7UpzHODtF8O11gRQu%2Fdr7ZxoqB2bbegYnaqoHpj92RFiHOTvLRkRZh%2B5dhUqacPBi%2B7u8BNwEMF0Y7MAiv%2F%2FV2fxu%2FP%2BR%2FAck6a%2FRkzLBwcgKf9tEb0NvuE0IJsS1SwspiRx6Era1ezrbYykb5RAQ5YKBG3rZKn4Aa3gCRvd1mAz0YSqAfOXVVMV3Of9R5Q39Iq41rk19BLmmMS3R%2F%2BHhO7w6CySnEsgRpWulxFm3jPjfbtRXdJfLY%2Bpr6p3NHFC6qAHD2l1z86QUqDmsGxBglmZQQhLM3PSTShLyNZs%2BKLPD5BZgvIunlhI8RZertUiX1EI3n%2FzFlb8RL21zJNpQXvr5XqOt5kv2U%2Bt0idsoN7380FGwQdyEzpKT7rX4V%2B5u1eUX%2FMevy0ysL47eZU31JRcQ6wg32i2g94%2BtEJnGai5mLkIii1keYDdDRw%2F5CGjHg76t2VDIanmLiul8laGZU7xlLCwg0R5sGmihYaUFtleHZdlFELNCggrPyQvAXz%2B%2BpOoypqV3DC4GN77cuLo2RYNYXC%2FsQFp2OCntqfh%2B9qmNq32185XpDXGN3lZ8vM82YPmA9l4PLzgINQnDJM1jyB2Tt7%2FW1nUmFZcQvbJpammKvfRM2CPTSXSkw%2FToMvwSrL8YoHe1eTnUf58Lsx6f0jA9fegYjjecbq%2F7WeGUuRnroGcnhybnG8XYneQ5pU5FVuU3Jn7kIVZWZFRltTXWlLXklWeN2IGe8IzXlF%2BhACqIkQXEEAwFg00tdQ1MLP5cixoeQNOSIB14aLYLMrqwlt4PcFcSZWTmm%2BNmHZJdpYYEciTQ2UqjTuHAttRGE8SQ6TJ2jny2xC4cv%2FqCgUOrTfDOqSIz21ul7Sfh5SzXoDRu6%2BeAD5z30%2BbJ8QkUpbYNSfoIhf%2FSZgmTxgye0XMGnqhBYGN%2FzjCIa25woFMWGI%2Fh0duAFAmuCW5CIBKaew%2B4mZnv8e6loUGALeLocsTFT1rIWGC64NWkZ2OX%2B5aw6W3smb5w9ey%2Ft8RXDG3lPbXYHglPuTm0dD8IXgqeSV8oLUyfnZ7PmCUXp84Yl2yFZ5MYSJ%2Bzk4sjNPwOCbDAYCw2AdHIP7tsFEhtFDY%2Fzy%2BjPjKNTU8JDSUmYf1TksICsxMz%2FdXGlZTH1YJDlEblVDIP5exA1nKWIBBSEEdgJKWTsfLIXxzMyVYAl8yYlVaphlyZdZ9l3w7HzAPnH5kSvTDCifLn14zqBf%2BvL3l5zEePNfYIzL1mYiL3eEdrflrBjEcaG0mcvWbSIltnN7kL3HgG4tVsTp8OcJ%2B7u2HGcv34FJT9UOtBPN0NYyrxz28HeFDh6FdZNv2clFFMSMgs0XjzcrLK4uOzSjhHD%2B6RAvRXDeXu4QF8GB4TM698Mt9GN8kandf8xaiA6uW%2Fwoe7hHvWah8JPeCprskBaysUVxhuphv0fzaa4t%2B3PcvlkqSAXFZbKflL9fHL2t1O6MkaeJR87jn%2F%2FZ%2FJD84P5hLzTabVkw2HvGl8NwrQLDsw6teCtbCAlB1R7swPsJrd3AmwKsJXKHqvFff%2FxywD%2FgzvO%2BefVFrZFX%2F4fin7bZZonTwL5FVJiG%2FaJt4k1FXoRG%2FolH7oHIoXjlkonRf3PmYadmtA7%2FTMgigj7RsLyFhtEDqNn%2BeOUYsqmXxDPtX7byMOoZMkHTo1GTpH%2F7ljm6K2gFUboRMfwqz5OHesWtRn%2BZyZaZ0rtrkd8AMmOw6YfjVgzmcDxr%2Bf8uK8MXONTk1%2BMaig5QEaMDl0wBQbJ8Zm6rjfgLQUOgm10Okwce54WIzZFeVdwYes2%2BaZqwGT4wZM5x4wJ04ZL%2BhzOmObJ6A2dfmCddMV6JTxaj63%2FpOLxi8BGEyDh%2ByQT1333%2Fnc1cBA%2FK7abqD%2Fzv4%2BmokH2rCS50s8gNVyKcx6F2HRp6o0k7L%2BnH%2B%2Fnv5Yh%2FIWsNlpACwtZKucxwDQbdBGKQG6bZ1HO3tEW0ePpW3f4xGABYyc6J0%2BcPFu27QAKP9xKoDXKNEuTFUS4qLdowqIj51tZNijXwFQ7kR9ljjXx1CpuxXo9PaH%2BB0m3wU7cNFwxQKgupzypGkXMQVI99NV9YB8gRDw3AOfE7qvlNINqBNpyBWTU8wdHwOGNsITVt4AUEBDagVkwHKxOKBe3onCf8bp%2FQn%2Bw4PdGi3iFyB91OPdBuTb4%2BQYoU%2FAQ9H4xN7IH3f3MiNx5Hyw4AZw3awHY8l2awYznN%2FZWyEyOTc0IcVRsb%2FEKeyWUO7sdv2g08yQVTyG2fcUvDojgu%2BGZxuJj8rD79ucZYGRMkyVJI5LmhWjzmO6ZwSOrORcVxFesHZYhuXR2GfsHkh8Bq2r3MRtA%2B5SDGXCbohCu92u12bYcny4R9uizqGMGeu2HZoPbTYGFPHR2snMjWYngrFcYG6A%2B1Hx9RkXu71mD67bJ%2FEUT06Em0mR%2F4DiXZs5127bdLBeGhjMUK6HsWAzratL%2FWyZGcNBrkCLtzEP09XJ8rTu8xkPoYe6n52civVZ%2B%2BM5mc9X%2BK2b%2FL9vu5T3Kzy1nmXlJO3fJGEHafb6N5itdVEejsDnh3h8urT5fCHG0CzzZrzgd4dZsjphp3Oclqhedae2Cx7r2B156Q6fMK9EA4ZJiaXndz4CImHHMdgEtq3DRkVOFA0icArejq8FGXOPuMixh2%2BfI9WQSWj%2FUTs1tO4nAN%2FdVAluu3YFxpgSeio5oMO%2FiTUlDmjFgCLCJLvN5qiBkHij7%2FOl%2FIeiphD%2FdYC5LCAkOfgN4Qq8BaZZSQAgzdFfgoZHaPmZZAR0DoSJ3ITdTi1b2xakKhzLIL8i8Kh1CiumGbJ0oQPzgRFzYsOgeABesW35qMndh15WU1rXho1aE14xHr0j5O4F0q1fGgvb0vrcwdep1wCwlf1ELOboytK9SFmG02l3xdQLe1tCIvKwLdc7Q35XnYBgTcaTcwZaU8Inp6Ct%2BPMlavaWWovKlMgUBrWa8RlYHDY0DPM%2F9UzhXY7%2BVrJuBOYKAN0V1QsUQuTfCAJ0tXdUNWYShgAy8HgWZklyepHjh3ul1P5AvbW8IiMfzfbGFIACTsgbHJD%2BDkV6QyUHkaBf1%2BVYbM65GY%2BXywjg%2BYuApbuoEaGPDSJByvbHqyZSwoMFMXF%2BLNWm%2BhdRira8uiL30P8h6EpIk2yjHFvDwSXZyyRatfgVr6yuI%2BmhKhstloF28aZiIQ0trU8%2Fbf369%2Fr3DSpwOQFkmh0a4Xf4ZD2l%2FxEjsAB8FlhmK%2BYBcfAsf2MEoW0UuZIX55PJMN0dBlDq3y%2Fbl0K4E0X3IuufYTFuG%2FAWSJaWLebMOQ3wXOvwMc2m3ctMU0CYtaKG5QewbeCT2Se84n5y6wyStVicic%2F%2BfvSNMZvy4UMWpXf9Bo%2BXsB6UThiKgF2VhZUvx10qeAYjRsfmc7OhFb0JaLwAT8nJ3OtVDqxg9a4y1kW6rhXzqfGziV9pXWFvpxXA4RKgdlfCq28Fi2e%2FSFShbVhXKVxKmdQb%2BQ%2BB69fLjlkAhm64vOHI5YZZIzElZ6AxIhi43ygaboRA5%2BSGIsYbYlsSgaEUANmQYsrHqbGJVB3O3BHHC6To%2BZY2WUlTn%2Fq7mIkUNNkWQFLql0RMdoS%2BmmnrPeDAZywBEQRy8XTj%2BxKV0M1a1pSR9Co1JLOakgJGS%2BCZnsa2IhmJI4lQogqc5CqcfL2VPEta1nbst1MRBEyRgJb9ZmxL22HaKKllhcB5EdVQaJdTG6AmI6j6aZbwqgWTA%2FUk6RowmnkPi0Xpe4DoPYlI4yKZf71sKSYIOFRBfknAqN1gyulcoCBho8CWRQzqtxeZTi%2B9xOOTATq4tOWMdAc6BNboJrYRV5fETIysCJzIBgZtnnUnz56SyuZMZym4T21Pc%2BYKG0BXrwHIa2SlL7OkSjYks8Pg6l3sIwmPllsH7OVMjjDPJeXhOcNA20zYdjBBE%2BYipeBxesh0w5BAy65t%2FBSGJpH3uFgToFR1qxo%2B9s5GGgCFkQPVEgiYaDoms5Z99AWBQxj0PONNG0vJvWx5N9K8xPA%2Bk4iRc2ZyRH6gBGoJhGhKzMkt1MfkS3Y0RFUscmP0q%2BEQ6g2YxYlRDCBoJKRZbFfk4HkHjo1TNBYR%2FHiOziN6%2FY509ibuuqnCQBEheEVpzTUGf%2FtNlykCEfopFysImA4eeGCejzOhWqUBqBNNCzDq2Z5tmKr5ALljdFCMkSI7%2FdDHFOU%2FgGv9zIuaj1aSc99MfX9tcDGnfC%2BPnkdK2UPu9AGnedt1vPAuY0bKawMPNwtKg%2FEpO0uJLke%2BEZAhbZBdAF00bRXFYaJrh9ijsrNjJD%2FRFSJKKWvQuWrvzLJdoV2AOddHTGq4KDAg8m0Tdfr%2BaSVRtlOFJXYNKQ4ctWV0IMvVhGosSxC6HUqYkfxYKbSgRvOLZiVpnGUedQS%2Bsi8wjwh9hggEV3LgZQq%2BG1qM3q8RrW2bx9OSzj7DtzPZb9LTCvhS9TPxxTPx%2Fa%2Bfx%2Fd3i%2Fa%2BUl9doNTVYvHZx9cWekmfs1TFuuuKhjITF4eO5hYAeyonGBBoJYQIcV%2BocEn5hVRHgHGD3bBT2YhNBPODK0NgQBw67r21R%2F%2BpJ%2FWD%2BpG9ZR%2Fb%2F2zIrmExuvMyqp4NC3vUT8OwEJndVcVe071e6xf11%2FWn%2Bkf67%2FqFpk%2Bo%2BwqqFoEGyFQsh0PGLdUZRZWaCd0nYrEoXSXemKNL4JoSW8tYfrSiwjwv7ICoyFCgsGqbFACbbo%2FxHmfTLA5HpB6m8hE3eKxwRgtq8TDIS2R4h0tgflEFIqx5DPM8BqMjBR6KbezYG%2BDBzoXquDLUqPousQgehNLh29rJeGY8wQhq1RWaMOghdg%2BNIlt2Zposk8OQ96C6Auu6CtVRTcZ141RfSGu9C1ZLiCopw%2FXb0ryQooJO001cnCZS73jj0GG32W2tkDYK4d6AGIXPBcD7HrKsekSm0f%2BpMWYdSC5TcglPfqFxMFfE6vu2UrV5QCkFI5A3MJghtbEneGAeMSaL%2FNUvcspnoGDjyQ%2FWh9hmPczUIl5AvUtG6WfmmsDWBF4P%2BCw9KkbgUst8q%2FdtGHCo%2B5b3HcR79LegYTgVfOeGn%2FIOxjH0PRaHMQGKWtJa3k2UGJtP25vbMAuZDwjAofEuZ1nuQ8uDJ%2F7mwYbdYD9RJwPieIi4n3yK%2B%2BlFzD9Ynai0NLEtb2nZYjcylDb6dz2lt%2BiX9HcSRPFQRaETgQNDQweX3pptsuVHFEmYAHr4BOnfRo1lLvEMgO%2FxqJdNo%2BofhE%2Frt%2Bpf1n%2Bvaes6ZTjTf6TBCLPrWuG%2BSAQNE70ChjY0oCH2ObB5XnEWO%2FEkmUJJgIZ2AujyRq%2B4p%2B2ajEZHNDRAGZciwyuzyLaX0ORk53Pf24FtllN3nA27TnMzpHxMUk2jNyup2eC7Z9cb%2BNnvzLqhj4ymvRjXfpT2KqVBT10p%2Bi4qq%2FJFfHUkER0rCyCl3tkWZdULbOkf6VyFybAbS7VdM0laACch1xIL6vD2IpAHLeX%2BnM%2BUdzawMhqw74E3G17eTlmA1zFKuZjjzL3SCZvalwBqS4%2Fh%2FtCSyjxMWv2Tp1rGTchXAGROCDIkeOyqkY5UhDl44pm1e4AiaLxN39PtfHjXHTdnYPimeoBAkvZVM%2FY%2F%2BQn8bpFtTkTn%2B%2B1nPjlN29rZA%2FPxJzj7ue1lOQVMqEqFWwDXscMPXxfVtZ%2B7QK2u5w8fAExtqbWNUPksf5Qx52dDw5a30sFK7evxM9iG7CJyGbvG84bD%2F1GmVRQtIwLAnVGuCzM6%2FOf6Zowx072rLBSxOKUQuCjXlsUjXEVhqtdz6wQITJGZ%2FrZmhHvmlpshzEULFiRthq7NWXdcCG2fRtGJB%2FcVwIzV6A01pvYb90ZONjU7mVBkRpyu7od%2FAIJBXZu9kooYFO4qHRTYvOoblrL0RVyD3NAnGVrGkZL2hVz%2FH%2Bn8LPzZnSVMTmkeBStdkJxpnpMjIE5vtcDcVeZAC9C0dCheTDFN%2B4z8bJ1lQT3uk%2BDSpKpf4A9C0dvncAhJyMUPyPOi8OvKRInuVbAVTUKdYsQVlunHgXi%2FHQIsIImGJtz7KpV%2BlcDVTBjJZeLoYZCCiGOKaOnWUzICSKbFSvX9lfy0VTV3XwIeZBnf0jqwnmUTzMkCPmHBqZF81yS4idq0IBVU0acAdaS0BWKpvk66MaOAHZC5GLQ2j5hF4izrpM35nfeQjhJ29%2B69S%2FU%2B%2Fx4ldt35vm0n0Hhp2kzw9oI5B41uaET3a8xs1r%2FMbJyn5sSbNR3jeTvv0Yofw%2FLePtD6yvz7SF8k9B4epzzHf4v9WqSpMWFS0QOLAOZueZ6F8U0Yona8pDURMoNUpJcIxPpCBA8oyUCCf02hC1oJSaeRPLInpJxHyeXPcd%2FEMP2iYMC6srrKhac31vM4hHFJgLx7dQPrMXv9jD%2F89Wx0vA9M40cg%2BD8U7jVCYsET2MkVXh8O4Li%2BHplbkFHhup5lbQZtCOJjkxdT1xU9G1fK%2BpyplMtYwCx0HIqbjtwjE73sPdI0nN%2FHOwD8rzLvEXso2jcG4vCKQtoXLzPsIfSAZgpBrXBlby9WI52w24FO%2BjbG0P9PZwbiXCWnK0jWfsXv3a1m5nyVny8uOAfjDpjBoKnns%2Bo9escAxu8DQ2ptADz1awOO%2Fre931%2FGqmCru0WxupfPAeJWr%2Fj2oRpPY%2FbheRh7Ht8tnuPu3Wlszg%2FEHgG7j3VXPmJ6%2B0A3LWA3LEOqquWwiOxe5Xa57D06w4nfxxe4%2BT9d%2Bh6J70YmKW2YLh5x7n4g2xYmArSnJb%2B9KCqTaO6UWhm%2By%2FMjgoD2GcEXj4Ll%2BO%2FZTu3MZEwDillsyajV7wOTeEee%2F92e7MNChwyIOxu1XnxM43TcOLMmZMT4HRoYhnI9rO0WG6vmdW3WQvZIU0xvJcHjxQM1joctFUUYI90%2BNTYTIlj%2BrsO%2B7IWcec1U61q8rtfmAQ7QDRZVDOtg1K9W0H%2FH%2FUMdOr6%2F9wJaF5MY2pKOSgE6Rmx8pOzLZRlTMjxDEb7gC%2BKykqTYdB3amioZqUWznp1i%2BnyVZdOztPO8pZ6yzXlMOX7IDshVu6IaVysWtrcDnLPC%2BEobanCPAGbovGy5gcHkGXXOVC7R9E9obwa%2Bg8ziJFMtLvwnANdN%2FWwTrHTrSphCwMGpbzdp4RysAwwrLmpcdzAOvk09f%2FFdoYEn%2BN7%2Bv9%2FTlKY%2F9OFa%2F%2FWa%2FCnWejOwp3%2BAIAwI1w3lVnayF4iZBA98PhFPtAJRZW%2Bsm%2Fr9Pq2BHKqq5BTf%2B9W9GIQkFe5KVBfPK%2Bs%2BayVPRsfGzK1GOlVQ%2FXu8AFe%2FFZPHET88c1gH17Ogbb2utFIA5APOpo3C8z7SOJ%2Fh78xmw8sREdXxiZenCML15uCUSkQAx6GXReGktYLOHehj5FHoZvLRvkv0ftdjw8NRNqOpt5iLUTd6CVSnvlt3v%2BxYQCcXlK58CYl7kqFz6WQCVyZemvSsafXJLg4HlcFfy%2BZLTnSvl5h8MlX%2F7kCeSps8IJiMh4CqoovVXDQMUjd4%2BCTxhjZAyQcMgzmtCMfCh4%2B4mOAoJvw4OC0W3qU0x6lHvhdAAACPxahdZ7c292Q1%2BEZH%2F4OS%2BRPiXTLN9RYR%2F9v%2B7ywDL51m4gcw81NTjRKjq%2F%2BvA2aX%2BRMcEs1%2FOvOat%2Bu2hZG6MCB3V20iqyS7bvKUK1lEd8y%2BXfBKX2TlPKiRYlh9WIUbeWVx4FwGltUjW0SxrVNn8tR6XD2OHmlPjMdDtIoJjtxc1gVOBxCwrsPSjK1XFtGsAG1bC41DQnsRiRrXcSabtV0JHaWbZL%2Fwa8KLqqNg73NyZ7YeIaFeAIXdYPnVHMLtk%2BH6C9BfjwnNqeuzgHoHk9yutlQA9%2BoVQbhExJ86nYJrO9f6R3f5DjsKF1ffMp8Sr3i8jUt31lcb%2BcipZX64u%2B8EQ8n6mit08xMFn6o%2B5lMkSeNQGysM0F2Oqwbir1aA8iqzwkuxBqbDfOWghkRz4GlnJ8L0Ejji2UrppLK0kl03v%2FyFbhkMxQeaw%2FXnqUD8KmHC5FPqnaBYR0kT1t0MRemcTZOAkGJfmGxOil3XzqDzKFFtzZm23uUo1%2B8Y%2F54DpL%2Be1rRDypqbIlfJMhzU3UAI9Le0jL1ujcuZYM%2BPTI16AL3pFHnqIW06rU9gNTcFfD2x17GqRspXK8DzAxx63pRKCX0%2FV73pdW1MXqS6qIDdR90lKR%2F%2FZlkSuChCUAbJF8q61IWy8qAOeTB2p6fhRvk1nGsGmAAaj%2FQRAwOCbXc7OcqPf3Si139duThdJdsiBxG7cxQkZF%2Fifll%2B%2FN5%2F46LRf%2FHIQiAvHUtMzFlCrNk8ew7iSsyTBDKFSiuZswyVzVzOyCsoKlWmKlBVU9fQ1NLW0atfVgMYGv1ZhIo2AAAAAAAAAAAAAADA3xqjh84Oz8Pw2idf7iB0h8EbYRib1uI5hFR6i5bJrWBt01bi3P33NIigCABgAAAAAAAAfC5nEUWu7%2FPA6%2Fs26ZPvCxrE7yjSGFvKuZbGYqyVYzEWY9GW666d0DvSv40HGB69pxh3EHdHUeMmoaa%2BGcK1CLEhlLVltRd9J9tdn3v45IvGhVR6iy09yyVJkiRJkuTfHm%2F90PMgssij97gbm3NAhAll7RPeCaV6ERERERH5vM7CHa57vtZr%2BOSLwRua0cgY32mcxgtIpbdomdwK1jZtJX6UYneOzZ4ZVVVVVVVVVVX9fB4M33h0n4ZXdKzcGLsWESaUtU97J7SizczMzMzMBl2YWf%2Br6ffvofdoX1Nn8IT7POi19cmXBvFrbtB44awIQqKvKcychbJ6NvYc2XIhIBokbp68ZSUSKRkphkpLRz7LLyAoJFKGW7b0ciSvoKhUmVUFqmrqGppa2jp69StrAEOjxmiOFmhTZVvqoMo742t5D3xeJEokkSlUWgfu%2F8%2BBw3sYPve5PT8vGK8Yi7EYi9CEcCCQ0ZFMYM6CrJ6NPQdyITFPkiVTqLR0Vj7wCwgKiTT0zNCC7biez89CKiCB5Obg7tl6wNPL2Rt9FX1%2FSmNcAQAAAAAAALKi%2B5EEAKH3AwAAhD4XP%2FjCRx6c%2F%2FULRPwQGka4RSCjIzt0xsPF4nD94vAFi9%2FkTUjMlmTJFCotnZUP%2FAKCQiJl8pSFnLyCopKyiqqauoamlraO3g6yEfEXdW1hOuCdbdcDLMsadD5%2BAUEhkTPvHL5%2FvtsoPNmfU3fIPS4IQG6evBHj9n7Tvjz%2FkDWe7M8pUo6IiIiIzvsS4cl%2BjBj4hv1y8wcBc%2B73ucfnHpl7GzMzMzNz7k9NfmNMO2TbtkjRQERERGqaqqqqqn75v01%2F2n23Fw3gCGQ0K4vPRjKycvIKikrKKqpq6hqaWto6ehbti3sn5HwdcXJyBuoAAoM8jB89geTA4CxKBIZoKQEEiUCQwLY%2FUAiAQBsAgroBAAAAAAAAdcXpdDodj06n63s%2FPngF197nw%2Bvd%2B4QQQgghhBBCCCGEUX6EEEIIIYQQQgghhBBCGGOMMcYYY4wxxhhjjDEhhBBCCCGEEEIIIYQQQimllFJKKaWUUkoppZQyxhhjjDHGGGOMMcYYY%2F3c469l1mo5tZq0pmmaptVE%2ByXUb%2BuPv%2F3rqf6N%2B3Tcwe6OVuMmoaa%2BGcK1CLEhlLVltRd9J5vn4ZxzzjnnnPNB2YJzIYQQQgghhBCDsoUQUkoppZRSSikHZQsplVJKKaWUUkoNyhZKAdfr9QAAAMCgbAG9hYUFSZIkSZIWZ%2FmAR%2BMVEGFCWXvun1OgZEmSJMm2bdu2iSciIiIiosNVlvZLOvZ%2BAAAAAAAAAAAAAAAAAAAAAAD0GKFhaBiqajRhmqZltUKWbdu24ziO67qu53kecx7cMzMzc5EmhBBCCCGklFJKKaVUSimllFJKa6211lprhwQAAAAAICIiIiISEREREZ3jYV18zi%2FLMTMzM3PZYxARERGp2VRVVVXVzMzMzDoHSdCxaDdS4H0kPJzQyOanzB2Qis8u%2F5ru7T%2Ffos5IVgbM5GzeGcb1xc7UrDV%2BfbO41Os7K6re03ntaZKtSP7CiUHzFg4%2Fd%2FIXJoiPCKH8oK7kADEmTMYxnjFfPvWzCo4YRbzcErIYk6kY5GVVKi1zTB%2FFCxKRmFGlFOSl%2BOkLVpQDRbdXR9Kj7ItTlHiL7KhvhPovKRFwArAsVFC5HrwTnjIES6bM2UDbiYrUKFG5MNxwYM2yzar3Aelia89QNZ3eyIxZv8HxjTev%2BcyPHQdOXLjx4MWHnwBBQoSJECXmOhBxEiRJkSZDlhx5ipQoU6FKjToNmrRo06FLjz4DhoyAQRgzYcqMOQvQiwB%2FzlmBQ7Bmw5YdJBQ0ew4cOXHmwpUbdxgePHnxdkObTFlmVHorW5F8DXq0JypXJGr7cd8wvviqUJVcS577rFGvby591%2Bqmdav6%2BfBVws8mf2s2nMG6Z8%2B%2BAQE%2BIXvovgcCnXsvT7AgIcKECtcsQpTIZ%2F3zN0a0WHHeiUeQIFGyJONaEKVIlebCB5MeGXTLgWcODblt1Jg7ho1YlqPPrDnTicaPiTb1aZRmfktlgaxt15ZtOzV8Ehp6LebYIBUVYzP6iFP8cXjfCJw%2FtfkEF7FptYWJiqqbQ40Je1wMDh8T6Y8LisBdiepw1qB8b2%2B8sf9FXw5HXzoi3Zf6QzcfHVHdrnvrhC9etP0LV01%2FdVH3x3f1l2bTQ1%2Bl%2F8%2BMRVCxg9vjtn980fTpYL%2FEEb%2FE5qJlj0ThDt9C%2BgvzhDlnlpqmWL%2Bw%2FSN09twFkYfJl9qh%2BVIx5F8yRH1JD7Hy7%2B%2BpzxZKffweCkWYEMK4N2fhHop78QW%2Foiq8vOztRA8%2F3ePRMMw2In4zxPY7wEdHjdp13Goj%2FDgkOGl3tEN8v%2Fjw9gaL%2BzPMjmqI%2FSbD9Z%2B22f2uLBLz9GkYTj199ixsgIk%2BhT0PdCtVpwAA%27%29%20format%28%27woff2%27%29%3B%0Aunicode%2Drange%3A%20U%2B0000%2D00FF%2C%20U%2B0131%2C%20U%2B0152%2D0153%2C%20U%2B02C6%2C%20U%2B02DA%2C%20U%2B02DC%2C%20U%2B2000%2D206F%2C%20U%2B2074%2C%20U%2B20AC%2C%20U%2B2212%2C%20U%2B2215%3B%0A%7D%0A%0Ahtml%2C%20body%2C%20div%2C%20span%2C%20applet%2C%20object%2C%20iframe%2C%20h1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%2C%20p%2C%20blockquote%2C%20pre%2C%20a%2C%20abbr%2C%20acronym%2C%20address%2C%20big%2C%20cite%2C%20code%2C%20del%2C%20dfn%2C%20em%2C%20img%2C%20ins%2C%20kbd%2C%20q%2C%20s%2C%20samp%2C%20small%2C%20strike%2C%20strong%2C%20sub%2C%20sup%2C%20tt%2C%20var%2C%20b%2C%20u%2C%20i%2C%20center%2C%20dl%2C%20dt%2C%20dd%2C%20ol%2C%20ul%2C%20li%2C%20fieldset%2C%20form%2C%20label%2C%20legend%2C%20table%2C%20caption%2C%20tbody%2C%20tfoot%2C%20thead%2C%20tr%2C%20th%2C%20td%2C%20article%2C%20aside%2C%20canvas%2C%20details%2C%20embed%2C%20figure%2C%20figcaption%2C%20footer%2C%20header%2C%20hgroup%2C%20menu%2C%20nav%2C%20output%2C%20ruby%2C%20section%2C%20summary%2C%20time%2C%20mark%2C%20audio%2C%20video%20%7B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%0Aborder%3A%200%3B%0A%7D%0A%0A%23tiHeader%20ul%20%7B%0Alist%2Dstyle%2Dtype%3A%20none%3B%0A%7D%0A%23tiHeader%20%2Enav%20%7B%0Abackground%3A%20%23c00%3B%0Aheight%3A%2041%2E375px%3B%0A%7D%0A%23tiHeader%20%23top%5Flogo%20%7B%0Aheight%3A%2036px%3B%0A%7D%0A%23content%20%7B%0Apadding%3A%201em%3B%0Amax%2Dwidth%3A%201200px%3B%0Aoverflow%3A%20auto%3B%0Amargin%3A%200%20auto%3B%0A%7D%0A%23tiFooter%20%7B%0Aclear%3A%20both%3B%0Acolor%3A%20%23b0b0b0%3B%0Afont%2Dsize%3A%20%2E9em%3B%0Apadding%3A%201em%202em%3B%0Apadding%3A%201em%202rem%3B%0Aborder%2Dtop%3A%201px%20solid%20%23e0e0e0%3B%0Abackground%3A%20%23fff%3B%0A%7D%0A%23tiFooter%20p%20%7B%0Amax%2Dwidth%3A%2060em%3B%0A%7D%0A%23tiFooter%20a%20%7B%0Acolor%3A%20%23b0b0b0%3B%0A%7D%0A%23tiFooter%20a%3Ahover%20%7B%0Acolor%3A%20%23c00%3B%0A%7D%0A%0Abody%20%7B%0Afont%2Dfamily%3A%20%27Open%20Sans%27%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E6%3B%0Acolor%3A%20%23555%3B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%200%20auto%3B%0A%7D%0Abody%3E%2A%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%20%21important%3B%0A%7D%0Abody%3E%2A%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%20%21important%3B%0A%7D%0A%0Ap%2C%20blockquote%2C%20ul%2C%20ol%2C%20dl%2C%20table%2C%20pre%20%7B%0Amargin%3A%2015px%200%3B%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Amargin%3A%200%200%20%2E5em%200%3B%0Apadding%3A%200%3B%0Afont%2Dweight%3A%20600%3B%0Acolor%3A%20%23333%3B%0A%2Dwebkit%2Dfont%2Dsmoothing%3A%20antialiased%3B%0A%7D%0Ah1%20tt%2C%20h1%20code%2C%20h2%20tt%2C%20h2%20code%2C%20h3%20tt%2C%20h3%20code%2C%20h4%20tt%2C%20h4%20code%2C%20h5%20tt%2C%20h5%20code%2C%20h6%20tt%2C%20h6%20code%20%7B%0Afont%2Dsize%3A%20inherit%3B%0A%7D%0Ah1%20%7B%0Afont%2Dsize%3A%202em%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%201%2E6em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%201%2E4em%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ah6%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Abody%3Eh2%3Afirst%2Dchild%2C%20body%3Eh1%3Afirst%2Dchild%2C%20body%3Eh1%3Afirst%2Dchild%2Bh2%2C%20body%3Eh3%3Afirst%2Dchild%2C%20body%3Eh4%3Afirst%2Dchild%2C%20body%3Eh5%3Afirst%2Dchild%2C%20body%3Eh6%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%0A%7D%0Aa%3Afirst%2Dchild%20h1%2C%20a%3Afirst%2Dchild%20h2%2C%20a%3Afirst%2Dchild%20h3%2C%20a%3Afirst%2Dchild%20h4%2C%20a%3Afirst%2Dchild%20h5%2C%20a%3Afirst%2Dchild%20h6%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dtop%3A%200%3B%0A%7D%0Ah1%2Bp%2C%20h2%2Bp%2C%20h3%2Bp%2C%20h4%2Bp%2C%20h5%2Bp%2C%20h6%2Bp%20%7B%0Amargin%2Dtop%3A%2010px%3B%0A%7D%0A%0Aa%20%7B%0Acolor%3A%20%23189%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Atext%2Ddecoration%3A%20underline%3B%0A%7D%0A%0Aul%2C%20ol%20%7B%0Apadding%2Dleft%3A%2030px%3B%0A%7D%0Aul%20li%20%3E%20%3Afirst%2Dchild%2C%0Aol%20li%20%3E%20%3Afirst%2Dchild%2C%0Aul%20li%20ul%3Afirst%2Dof%2Dtype%2C%0Aol%20li%20ol%3Afirst%2Dof%2Dtype%2C%0Aul%20li%20ol%3Afirst%2Dof%2Dtype%2C%0Aol%20li%20ul%3Afirst%2Dof%2Dtype%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Aul%20ul%2C%20ul%20ol%2C%20ol%20ol%2C%20ol%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Adl%20%7B%0Apadding%3A%200%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dsize%3A%2014px%3B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dstyle%3A%20italic%3B%0Apadding%3A%200%3B%0Amargin%3A%2015px%200%205px%3B%0A%7D%0Adl%20dt%3Afirst%2Dchild%20%7B%0Apadding%3A%200%3B%0A%7D%0Adl%20dt%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Adl%20dt%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%3A%200%200%2015px%3B%0Apadding%3A%200%2015px%3B%0A%7D%0Adl%20dd%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Adl%20dd%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0A%0Apre%2C%20code%2C%20tt%20%7B%0Afont%2Dsize%3A%2012px%3B%0Afont%2Dfamily%3A%20Consolas%2C%20%22Liberation%20Mono%22%2C%20Courier%2C%20monospace%3B%0A%7D%0Acode%2C%20tt%20%7B%0Amargin%3A%200%200px%3B%0Apadding%3A%200px%200px%3B%0Awhite%2Dspace%3A%20nowrap%3B%0Aborder%3A%201px%20solid%20%23eaeaea%3B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%2Dradius%3A%203px%3B%0A%7D%0Apre%3Ecode%20%7B%0Amargin%3A%200%3B%0Apadding%3A%200%3B%0Awhite%2Dspace%3A%20pre%3B%0Aborder%3A%20none%3B%0Abackground%3A%20transparent%3B%0A%7D%0Apre%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0Aborder%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%2019px%3B%0Aoverflow%3A%20auto%3B%0Apadding%3A%206px%2010px%3B%0Aborder%2Dradius%3A%203px%3B%0A%7D%0Apre%20code%2C%20pre%20tt%20%7B%0Abackground%2Dcolor%3A%20transparent%3B%0Aborder%3A%20none%3B%0A%7D%0Akbd%20%7B%0A%2Dmoz%2Dborder%2Dbottom%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dleft%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dright%2Dcolors%3A%20none%3B%0A%2Dmoz%2Dborder%2Dtop%2Dcolors%3A%20none%3B%0Abackground%2Dcolor%3A%20%23DDDDDD%3B%0Abackground%2Dimage%3A%20linear%2Dgradient%28%23F1F1F1%2C%20%23DDDDDD%29%3B%0Abackground%2Drepeat%3A%20repeat%2Dx%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%20%23CCCCCC%20%23CCCCCC%20%23DDDDDD%3B%0Aborder%2Dimage%3A%20none%3B%0Aborder%2Dradius%3A%202px%202px%202px%202px%3B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%2Dwidth%3A%201px%3B%0Afont%2Dfamily%3A%20%22Helvetica%20Neue%22%2CHelvetica%2CArial%2Csans%2Dserif%3B%0Aline%2Dheight%3A%2010px%3B%0Apadding%3A%201px%204px%3B%0A%7D%0A%0Ablockquote%20%7B%0Aborder%2Dleft%3A%204px%20solid%20%23DDD%3B%0Apadding%3A%200%2015px%3B%0Acolor%3A%20%23777%3B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ablockquote%3E%3Afirst%2Dchild%20%7B%0Amargin%2Dtop%3A%200px%3B%0A%7D%0Ablockquote%3E%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200px%3B%0A%7D%0A%0Ahr%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%2015px%200%3B%0Aheight%3A%200px%3B%0Aoverflow%3A%20hidden%3B%0Aborder%3A%20none%3B%0Abackground%3A%20transparent%3B%0Aborder%2Dbottom%3A%201px%20dotted%20silver%3B%0Apadding%3A%200%3B%0A%7D%0A%0Atable%20%7B%0Aborder%2Dcollapse%3A%20collapse%3B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Atable%20th%20%7B%0Abackground%3A%20%23F0F0F0%3B%0Acolor%3A%20%23555%3B%0Atext%2Dalign%3A%20left%3B%0Avertical%2Dalign%3A%20middle%3B%0A%7D%0Atable%20th%2C%20table%20td%20%7B%0Aborder%3A%201px%20solid%20%23ccc%3B%0Apadding%3A%206px%2013px%3B%0A%7D%0Atable%20tr%20%7B%0Aborder%2Dtop%3A%201px%20solid%20%23ccc%3B%0Abackground%2Dcolor%3A%20%23fff%3B%0A%7D%0Atable%20tr%3Anth%2Dchild%282n%29%20%7B%0Abackground%2Dcolor%3A%20%23f8f8f8%3B%0A%7D%0A%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%0A%7D%0A%2Eplatform%20%7B%0Abackground%3A%20%23cc0000%3B%0Atext%2Dalign%3A%20right%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
    <script>
    /**
    * @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
    */
    !function(a,b){function c(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=t.elements;return"string"==typeof a?a.split(" "):a}function e(a,b){var c=t.elements;"string"!=typeof c&&(c=c.join(" ")),"string"!=typeof a&&(a=a.join(" ")),t.elements=c+" "+a,j(b)}function f(a){var b=s[a[q]];return b||(b={},r++,a[q]=r,s[r]=b),b}function g(a,c,d){if(c||(c=b),l)return c.createElement(a);d||(d=f(c));var e;return e=d.cache[a]?d.cache[a].cloneNode():p.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!e.canHaveChildren||o.test(a)||e.tagUrn?e:d.frag.appendChild(e)}function h(a,c){if(a||(a=b),l)return a.createDocumentFragment();c=c||f(a);for(var e=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)e.createElement(h[g]);return e}function i(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return t.shivMethods?g(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+d().join().replace(/[\w\-:]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(t,b.frag)}function j(a){a||(a=b);var d=f(a);return!t.shivCSS||k||d.hasCSS||(d.hasCSS=!!c(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),l||i(a,d),a}var k,l,m="3.7.3",n=a.html5||{},o=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,p=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,q="_html5shiv",r=0,s={};!function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",k="hidden"in a,l=1==a.childNodes.length||function(){b.createElement("a");var a=b.createDocumentFragment();return"undefined"==typeof a.cloneNode||"undefined"==typeof a.createDocumentFragment||"undefined"==typeof a.createElement}()}catch(c){k=!0,l=!0}}();var t={elements:n.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",version:m,shivCSS:n.shivCSS!==!1,supportsUnknownElements:l,shivMethods:n.shivMethods!==!1,type:"default",shivDocument:j,createElement:g,createDocumentFragment:h,addElements:e};a.html5=t,j(b),"object"==typeof module&&module.exports&&(module.exports=t)}("undefined"!=typeof window?window:this,document);
    </script>
  <![endif]-->
  <link href="data:image/x-icon;base64,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" id="favicon" rel="shortcut icon" type="image/x-icon">
</head>
<body>
<header id="tiHeader">
  <div class="top">
    <ul>
      <li id="top_logo">
        <a href="https://www.ti.com">
          <img src="data:image/png;base64,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" />
        </a>
      </li>
    </ul>
  </div>
  <div class="nav">
  </div>
</header>
<div id="content">
  <h1>NDK API Guide</h1>
  <h2>Table of Contents</h2>
<div id="TOC">
<ul>
<li><a href="#introduction">1 Introduction</a><ul>
<li><a href="#what-this-document-covers">1.1 What This Document Covers</a></li>
<li><a href="#introduction-1">1.2 Introduction</a></li>
<li><a href="#supplemental-api-information">1.3 Supplemental API Information</a></li>
</ul></li>
<li><a href="#operating-system-abstraction-api">2 Operating System Abstraction API</a><ul>
<li><a href="#operating-system-configuration">2.1 Operating System Configuration</a></li>
<li><a href="#semaphore-support">2.3 Semaphore Support</a></li>
<li><a href="#memory-allocation-support">2.4 Memory Allocation Support</a></li>
<li><a href="#print-and-debug-support">2.5 Print and Debug Support</a></li>
</ul></li>
<li><a href="#sockets-and-stream-io-api">3 Sockets and Stream IO API</a><ul>
<li><a href="#file-descriptor-environment">3.1 File Descriptor Environment</a></li>
<li><a href="#file-descriptor-programming-interface">3.2 File Descriptor Programming Interface</a></li>
<li><a href="#sockets-programming-interface">3.3 Sockets Programming Interface</a></li>
<li><a href="#raw-ethernet-sockets-programming-interface">3.4 Raw Ethernet Sockets Programming Interface</a></li>
<li><a href="#full-duplex-pipes-programming-interface">3.5 Full Duplex Pipes Programming Interface</a></li>
<li><a href="#internet-group-management-protocol-igmp">3.6 Internet Group Management Protocol (IGMP)</a></li>
</ul></li>
<li><a href="#configuration-and-initialization">4 Configuration and Initialization</a><ul>
<li><a href="#configuration-methods">4.1 Configuration Methods</a></li>
<li><a href="#configuration-manager-api">4.2 Configuration Manager API</a></li>
<li><a href="#configuration-specification">4.3 Configuration Specification</a></li>
<li><a href="#initialization-procedure">4.4 Initialization Procedure</a></li>
<li><a href="#network-control-initialization-procedure-netctrl">4.5 Network Control Initialization Procedure (NETCTRL)</a></li>
</ul></li>
<li><a href="#network-tools-library---support-functions">5 Network Tools Library - Support Functions</a><ul>
<li><a href="#generic-support-calls">5.1 Generic Support Calls</a></li>
<li><a href="#dns-support-calls">5.2 DNS Support Calls</a></li>
<li><a href="#tftp-support">5.3 TFTP Support</a></li>
<li><a href="#tcpudp-server-daemon-support">5.4 TCP/UDP Server Daemon Support</a></li>
</ul></li>
<li><a href="#network-tools-library---services">6 Network Tools Library - Services</a><ul>
<li><a href="#service-calling-conventions">6.1 Service Calling Conventions</a></li>
<li><a href="#telnet-server-service">6.2 Telnet Server Service</a></li>
<li><a href="#dhcp-server-service">6.3 DHCP Server Service</a></li>
<li><a href="#dhcp-client-support">6.4 DHCP Client Support</a></li>
<li><a href="#dns-server-service">6.5 DNS Server Service</a></li>
<li><a href="#network-address-translation-nat-service">6.6 Network Address Translation (NAT) Service</a></li>
</ul></li>
<li><a href="#registering-ndk-hook-functions">7 Registering NDK Hook Functions</a><ul>
<li><a href="#operation-4">7.1 Operation</a></li>
<li><a href="#hook-function-types">7.2 Hook Function Types</a></li>
</ul></li>
<li><a href="#a-internal-stack-functions">A Internal Stack Functions</a><ul>
<li><a href="#a.1-overview">A.1 Overview</a></li>
<li><a href="#a.2-stack-executive-exec">A.2 Stack Executive (Exec)</a></li>
<li><a href="#a.3-packet-buffer-manager-pbm-object">A.3 Packet Buffer Manager (PBM) Object</a></li>
<li><a href="#a.4-packet-buffer-manager-queue-pbmq-object">A.4 Packet Buffer Manager Queue (PBMQ) Object</a></li>
<li><a href="#a.5-jumbo-packet-buffer-manager-jumbo-pbm-object">A.5 Jumbo Packet Buffer Manager (Jumbo PBM) Object</a></li>
<li><a href="#a.6-stack-event-stkevent-object">A.6 Stack Event (STKEVENT) Object</a></li>
<li><a href="#a.7-link-layer-information-lli-object">A.7 Link Layer Information (LLI) Object</a></li>
<li><a href="#a.8-binding-object">A.8 Binding Object</a></li>
<li><a href="#a.9-route-object">A.9 Route Object</a></li>
<li><a href="#a.10-route-control-object">A.10 Route Control Object</a></li>
<li><a href="#a.11-configuring-the-stack">A.11 Configuring the Stack</a></li>
<li><a href="#a.12-network-address-translation">A.12 Network Address Translation</a></li>
<li><a href="#a.13-network-interface-management-unit-nimu">A.13 Network Interface Management Unit (NIMU)</a></li>
<li><a href="#a.14-virtual-lan-vlan-support">A.14 Virtual LAN (VLAN) Support</a></li>
<li><a href="#a.15-raw-ethernet-module">A.15 Raw Ethernet Module</a></li>
<li><a href="#a.16-obtaining-stack-statistics">A.16 Obtaining Stack Statistics</a></li>
</ul></li>
<li><a href="#b-network-address-translation">B Network Address Translation</a><ul>
<li><a href="#b.1-nat-operation">B.1 NAT Operation</a></li>
<li><a href="#b.2-nat-port-mapping">B.2 NAT Port Mapping</a></li>
<li><a href="#b.3-nat-proxy-filters">B.3 NAT Proxy Filters</a></li>
</ul></li>
<li><a href="#c-point-to-point-protocol">C Point-to-Point Protocol</a><ul>
<li><a href="#c.1-low-level-ppp-support">C.1 Low Level PPP Support</a></li>
<li><a href="#c.2-serial-hdlc-client-and-server-support">C.2 Serial HDLC Client and Server Support</a></li>
<li><a href="#c.3-pppoe-client-and-server-support">C.3 PPPoE Client and Server Support</a></li>
<li><a href="#c.4-creating-ppp-server-user-accounts">C.4 Creating PPP Server User Accounts</a></li>
</ul></li>
<li><a href="#d-hardware-adaptation-layer-hal">D Hardware Adaptation Layer (HAL)</a><ul>
<li><a href="#d.1-overview">D.1 Overview</a></li>
<li><a href="#d.2-low-level-led-driver-lluserled">D.2 Low-Level LED Driver (llUserLed)</a></li>
<li><a href="#d.3-low-level-timer-driver-lltimer">D.3 Low-Level Timer Driver (llTimer)</a></li>
<li><a href="#d.4-low-level-packet-driver-llpacket">D.4 Low-Level Packet Driver (llPacket)</a></li>
<li><a href="#d.5-low-level-serial-port-driver-llserial">D.5 Low-Level Serial Port Driver (llSerial)</a></li>
</ul></li>
<li><a href="#e-web-programming-with-the-http-server">E Web Programming with the HTTP Server</a></li>
<li><a href="#f-bsd-sockets-support">F BSD Sockets Support</a><ul>
<li><a href="#f.1-using-bsd-sockets-provided-by-slnetsock">F.1 Using BSD Sockets Provided by SlNetSock</a></li>
<li><a href="#f.2-things-to-remember-about-bsd-compatibility">F.2 Things to Remember About BSD Compatibility</a></li>
</ul></li>
<li><a href="#g-ip-version-6-ipv6-stack-api">G IP Version 6 (IPv6) Stack API</a><ul>
<li><a href="#g.1-synopsis">G.1 Synopsis</a></li>
<li><a href="#g.2-initialization-and-deinitialization">G.2 Initialization and Deinitialization</a></li>
<li><a href="#g.3-api-functions-and-data-structures">G.3 API Functions and Data Structures</a></li>
</ul></li>
<li><a href="#related-documentation-from-texas-instruments">Related Documentation From Texas Instruments</a></li>
</ul>
</div>
<h1 id="introduction">1 Introduction</h1>
<p>This chapter serves as an introduction to the programming API reference for the NDK software.</p>
<h2 id="what-this-document-covers">1.1 What This Document Covers</h2>
<p>This Reference for the NDK is mainly a programming API reference guide. It is intended to aid in the development of network applications and describes the various API functions provided by the stack libraries.</p>
<p>Although this guide is the central reference document used when programming the stack, you should first see the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) to familiarize yourself with the stack libraries and with using the stack.</p>
<h2 id="introduction-1">1.2 Introduction</h2>
<p>The Network Developers Kit (NDK) is a platform for development and demonstration of network enabled applications on TI embedded processors. The code included in this NDK release is generic C code, which runs on a variety of TI devices.</p>
<p>Within the SimpleLink SDK, the Network Services SlNetSock module configures the NDK as the network stack for wired Ethernet communications.</p>
<p>The NDK stack serves as a rapid prototyping platform for the development of network and packet processing applications. It can be used to add network connectivity to existing applications for communications, configuration, and control. Using the components provided in the NDK, developers can quickly move from development concepts to working implementations attached to the network.</p>
<p><img src="data:image/png;base64,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" alt="Figure 1-1 Components of an NDK-Enabled Application" /></p>
<p>As Figure 1-1 shows, a user application can make calls using the standard BSD sockets APIs, or it can directly call into the SlNetSock layer to communicate with a network connection. The SlNetSock layer is a stack-independent layer between the user application and the service-specific stacks.</p>
<p>Within the SimpleLink SDK, the Network Services <code>SlNetSock</code> module configures the NDK as the network stack for wired Ethernet communications. <code>SlNetIfNDK</code> is the implementation of the SlNetSock interface for the NDK.</p>
<p>The NDK stacks settings may be configured at run time by making calls to the NDKs <em>Cfg()</em> functions.</p>
<p>The NDK is designed to provide a platform-independent, device-independent, and RTOS-independent API interface for use by the application. Many of the API modules described in this document and in the <em>TI Network Developers Kit (NDK) API Reference Guide</em> (<a href="NDK_API_Reference.html">SPRU524</a>) are rarely used by applications. Instead they are available to those who are writing device drivers and network stacks.</p>
<p>A user application typically uses the following APIs provided by the NDK:</p>
<ul>
<li><strong>Cfg functions</strong> add settings to the configuration database that determine which network services will be available to the application. See <a href="#configuration-manager-api">Section 4.2</a>.</li>
<li><strong>NC_ functions</strong> cause the network services system to be initialized, started, and stopped. See <a href="#initialization-procedure">Section 4.4</a>.</li>
<li><strong>TaskCreate() or native OS functions</strong> to handle application threading. The NDKs TaskCreate() API can be used to create a thread for any RTOS supported for the target device by the SimpleLink SDK. For most targets, this includes TI-RTOS Kernel and FreeRTOS. Alternatively, the native thread creation APIs can be used for the supported RTOS being used. For details, see the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>).</li>
<li><strong>NDK socket APIs</strong> to perform socket actions such as accept, send, and receive. For a pure NDK application, these are the BSD-like NDK_*() functions described in <a href="#sockets-programming-interface">Section 3.3</a>. For SimpleLink SDK applications, you can use the standard BSD APIs provided via SlNetSock, which are described in <a href="#ApxF">Appendix F</a>.</li>
</ul>
<h2 id="supplemental-api-information">1.3 Supplemental API Information</h2>
<p>The following information appears as appendices to this document. These sections contain optional information that may be useful in understanding the low-level application interface, but is not required when developing traditional network applications.</p>
<ul>
<li><strong><a href="#ApxA">Appendix A</a> Internal Stack Functions</strong> The stack library internal function specification describes a subset of the low-level programming interface to the stack. These functions allow the application writer to make use of kernel level function APIs. As a general rule, it is not necessary to use this API for application development, although some of the sample applications included in the NDK make use of these function calls.</li>
<li><strong><a href="#ApxB">Appendix B</a> Network Address Translation (NAT)</strong> The stack library includes Network Address Translation module. This appendix describes the operational theory of NAT, and how to use the NAT functions included in the library.</li>
<li><strong><a href="#ApxC">Appendix C</a> Point-to-Point Protocol (PPP)</strong> The stack library has internal device sections for both traditional Ethernet, and PPP. The PPP module can act as PPP client, server, or both (assuming multiple interfaces). This appendix describes the operation of the PPP module, the PPP over Ethernet (PPPoE) module, and how to interface an HDLC based serial device.</li>
<li><strong><a href="#ApxD">Appendix D</a> Hardware Adaptation Layer (HAL)</strong> This appendix describes the hardware and operating system interfaces used by the stack. The information allows application programmers to call device drivers directly when needed. This appendix does not supply information about porting the HAL to a new platform.</li>
<li><strong><a href="#ApxE">Appendix E</a> Web Programming with the HTTP Server</strong> This appendix describes how to make use of the HTTP server included in the NDK. The main topics covered are adding Web content and writing CGI functions. There is also a description of the HTTP API used by CGI functions, and some CGI example applications.</li>
<li><strong><a href="#ApxF">Appendix F</a> BSD Sockets Support</strong> This appendix provides pointers to the Berkeley Software Distribution (BSD) API socket support layer, which is now provided by SlNetSock, which is part of the SimpleLink SDK.</li>
<li><strong><a href="#ApxG">Appendix G</a> IPv6 Stack API</strong> This appendix contains the data structure and API definitions exported by the IPv6 stack in the NDK. All IPv6 socket level APIs are also documented so that the application can use them for communication over IPv6 networks.</li>
</ul>
<h1 id="operating-system-abstraction-api">2 Operating System Abstraction API</h1>
<p>The NDK OS Abstraction Layer (OSAL) uses a combination of native OS and POSIX APIs as a means of OS abstraction. In general, application writers should not use the OSAL APIs, with a few exceptions. One is the <em>TaskCreate()</em> function, which may be used as a convenience function for creating an NDK user thread that will make socket calls. Another is <em>TaskSelf()</em>, which can be used as an argument to <em>fdOpenSession()</em>.</p>
<p>To keep the stack system portable, it was coded to a very compact operating system abstraction. The stack can execute in any operating environment by porting the functions described here. Most of these functions will map directly to their native OS counterpart.</p>
<p>If you program to this API, your applications will execute on any system to which this abstraction is ported, but more importantly, because all the NDK functions are written to this layer, the behavior of the NDK can be altered by altering the implementation of this layer. This allows the stack to be tuned in how it interfaces to the native operating system.</p>
<h2 id="operating-system-configuration">2.1 Operating System Configuration</h2>
<p>If you are using the Configuration Manager API to configure your application, the configuration options that regulate OS behavior are stored in a data structure. The types of properties defined in the structure are those that would typically be macros, but using a data structure allows the values to be changed without rebuilding the libraries. The structure is described here for completeness, but applications should use the configuration system to make alterations to these values.</p>
<p>If you are using XGCONF to configure your application, you can configure several aspects of the OS behavior in the <strong>Scheduling</strong> tab of the Global NDK module property page. When you build the *.cfg configuration file, the data structure described in the following section is generated internally and linked into your application. See the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) and the context-sensitive help for details.</p>
<p>Configuration methods are described in <a href="#configuration-and-initialization">Section 4</a>.</p>
<p><a name="configuration-structure"></a></p>
<h3 id="configuration-structure">2.1.1 Configuration Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here. If you are using the Configuration Manager API to configure your application, you will use this structure.</p>
<p>The stack internal configuration structure is <code>_oscfg</code>. Any element in this structure may be modified before the system is booted. System initialization is covered later in this document.</p>
<p>The <code>_oscfg</code> structure is of type <code>OSENVCFG</code>, which is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Configuration Structure</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _osenvcfg {
    <span class="dt">uint32_t</span> DbgPrintLevel; <span class="co">// Debug message print threshold</span>
    <span class="dt">uint32_t</span> DbgAbortLevel; <span class="co">// Debug message sys abort threshold</span>
    <span class="dt">int</span> TaskPriLow;         <span class="co">// Lowest priority for stack task</span>
    <span class="dt">int</span> TaskPriNorm;        <span class="co">// Normal priority for stack task</span>
    <span class="dt">int</span> TaskPriHigh;        <span class="co">// High priority for stack task</span>
    <span class="dt">int</span> TaskPriKern;        <span class="co">// Kernel-level priority (highest)</span>
    <span class="dt">int</span> TaskStkLow;         <span class="co">// Minimum stack size</span>
    <span class="dt">int</span> TaskStkNorm;        <span class="co">// Normal stack size</span>
    <span class="dt">int</span> TaskStkHigh;        <span class="co">// Stack size for high volume tasks</span>
    <span class="dt">int</span> TaskStkBoot;        <span class="co">// Stack size for NS_BootTask</span>
} OSENVCFG;</code></pre></div>
<p>The structure entries are defined as follows:</p>
<p><strong>_oscfg.DbgPrintLevel</strong> <em>Debug message print threshold</em></p>
<p>Default Value: DBG_INFO</p>
<p>Description: This is the lowest severity level of a system debug message (call to <em>DbgPrintf()</em> function) that will be recorded into the debug log. The threshold may be raised. The legal values for this variable are: DBG_INFO, DBG_WARN, DBG_ERROR, and DBG_None.</p>
<p><strong>_oscfg.DbgAbortLevel</strong> <em>Debug message abort threshold</em></p>
<p>Default Value: DBG_ERROR</p>
<p>Description: This is the lowest severity level of a system debug message (call to <em>DbgPrintf()</em> function) that will result in a system shutdown (call to <em>NC_NetStop()</em>). The threshold may be raised. The legal values for this variable are: DBG_INFO, DBG_WARN, DBG_ERROR, and DBG_None.</p>
<p><strong>_oscfg.TaskPriLow</strong> <em>Priority Level for Low Priority Stack Task</em></p>
<p>Default Value: 3</p>
<p>Description: This is the priority at which low priority stack task threads are set. Setting a thread to a lower priority than this will not disrupt the system, but no system or service supplied in this package will attempt it.</p>
<p><strong>_oscfg.TaskPriNorm</strong> <em>Priority Level for Normal Priority for Stack Task</em></p>
<p>Default Value: 5</p>
<p>Description: This is the priority at which most stack task threads are set. Task threads that are created by the system or services will usually run at this level.</p>
<p><strong>_oscfg.TaskPriHigh</strong> <em>Priority Level for High Priority for Stack Task</em></p>
<p>Default Value: 7</p>
<p>Description: This is the priority at which high priority stack task threads are set. Setting a thread at a higher priority than this may disrupt the system and cause unpredictable behavior if the thread calls any stack related functions. High priority tasks (like interrupts) can execute at higher priority levels, but should signal lower priority tasks to perform any required stack functions.</p>
<p><strong>_oscfg.TaskPriKern</strong> <em>Priority Level of High Priority Kernel Tasks</em></p>
<p>Default Value: 9</p>
<p>Description: This is the priority that task threads execute at when they are inside the kernel. Setting tasks to this priority level ensures that they will not be disrupted by another task calling stack functions. Note that this priority should be 2 higher than _oscfg.TaskPriHigh, to allow the scheduler thread to occupy a priority in between. The proper method of entering the kernel is to call <em>llEnter()</em> and <em>llExit()</em>. These functions are discussed in the appendices, as they are not required for applications programming.</p>
<p><strong>_oscfg.TaskStkLow</strong> <em>Minimum Task Stack Size</em></p>
<p>Default Value: 3072</p>
<p>Description: This is the stack size used for network task that do very little network processing, or do not use TCP.</p>
<p><strong>_oscfg.TaskStkNorm</strong> <em>Normal Task Stack Size</em></p>
<p>Default Value: 4096</p>
<p>Description: This is the stack size used for a network task with an average network bandwidth using TCP. It is used for the majority of network tasks in the network tools library that use TCP.</p>
<p><strong>_oscfg.TaskStkHigh</strong> <em>High Volume Task Stack Size</em></p>
<p>Default Value: 5120</p>
<p>Description: This is the stack size used to network tasks that require a high network bandwidth using TCP.</p>
<p><strong>_oscfg.TaskStkBoot</strong> <em>Boot Task Stack Size</em></p>
<p>Default Value: 2048</p>
<p>Description: This is the stack size used for the boot task (NS_BootTask).</p>
<h3 id="task-support">2.2 Task Support</h3>
<p>The task object provides a method of manipulating task threads using a generic task handle.</p>
<p>Internally, task threads are implemented using native threads of the RTOS the app is built to use. Therefore, the rules governing scheduling and stacks are determined by the underlying RTOS. The documentation for the RTOS being used should be consulted for more info.</p>
<h3 id="function-overview">2.2.1 Function Overview</h3>
<p>The Task Object access functions (in functional order) are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TaskCreate()</td>
<td>Create new task thread</td>
</tr>
<tr class="even">
<td>TaskDestroy()</td>
<td>Destroy a task thread</td>
</tr>
<tr class="odd">
<td>TaskSelf()</td>
<td>Get handle to current task thread</td>
</tr>
<tr class="even">
<td>TaskExit()</td>
<td>Exit (terminate) current task thread</td>
</tr>
<tr class="odd">
<td>TaskYield()</td>
<td>Yield to another task thread at the same priority</td>
</tr>
<tr class="even">
<td>TaskSleep()</td>
<td>Block a task thread for a period of time</td>
</tr>
<tr class="odd">
<td>TaskSetPri()</td>
<td>Set task thread priority level</td>
</tr>
<tr class="even">
<td>TaskGetPri()</td>
<td>Get task thread priority level</td>
</tr>
<tr class="odd">
<td>TaskSetEnv()</td>
<td>Assign one of three private environment handles to task thread</td>
</tr>
<tr class="even">
<td>TaskGetEnv()</td>
<td>Retrieve one of three private environment handles</td>
</tr>
</tbody>
</table>
<p><a name="task-api-functions"></a></p>
<h3 id="task-api-functions">2.2.2 Task API Functions</h3>
<h4 id="taskcreate-create-a-task-thread">TaskCreate  Create a Task Thread</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *TaskCreate( <span class="dt">void</span>(*pFun)(),
                  <span class="dt">char</span>      *Name,
                  <span class="dt">int</span>       Priority,
                  <span class="dt">uint32_t</span>  StackSize,
                  <span class="dt">uintptr_t</span>  Arg1,
                  <span class="dt">uintptr_t</span>  Arg2,
                  <span class="dt">uintptr_t</span>  argReserved);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pFun: Pointer to task entry-point function</li>
<li>Name: NULL terminated task name (truncated after 11 characters)</li>
<li>Priority: Task priority level (0-15)</li>
<li>StackSize: Task stack size</li>
<li>Arg1: Optional task function argument 1</li>
<li>Arg2: Optional task function argument 2</li>
<li>argReserved: reserved</li>
</ul>
<p><strong>Return Value</strong> Returns a Task Handle on success or NULL on memory failure.</p>
<p><strong>Description</strong> This function creates a task thread and automatically initializes and closes the NDK file descriptor table for this thread. If successful, <em>TaskCreate()</em> returns a handle to the newly created task.</p>
<p>This API automatically calls the NDK APIs <em>fdOpenSession()</em> and <em>fdCloseSession()</em> to initialize and close the file descriptor table, respectively, for this thread. When using <em>TaskCreate()</em> to create a thread for sockets programming, it is not necessary to call <em>fdOpenSession()</em> and <em>fdCloseSession()</em> in the function pFun, as this will be done automatically.</p>
<p>The task name supplied in <em>Name</em> is used for informational purposes only, and does not need to be unique.</p>
<p>The task priority specified in <em>Priority</em> determines the task threads priority relative to other tasks in the system. The priority should not be higher than the configured value for the NDKs Global.highTaskPriLevel property (the priority for high priority NDK tasks), which is 7 by default. 0 is the lowest priority and should be reserved for an idle task. If the specified priority is negative, the task is blocked.</p>
<p>The task stack size specified by <em>StackSize</em> is not examined or adjusted by the create function. The size should be made compatible with the native environment (a multiple of 4 bytes should be sufficient).</p>
<p><em>Arg1</em> and <em>Arg2</em> are optional arguments that can be passed to the calling function (they are always pushed onto the stack, but the task function need not reference them). <em>argReserved</em> is reserved for future use.</p>
<p>There is no limit to the number of tasks that can be installed in the system.</p>
<p>If the priority level of the new task is higher than the priority level of the current task, the entry-point function pFun is executed immediately (before <em>TaskCreate()</em> returns to the caller).</p>
<p>Calling this function may cause a task switch.</p>
<h4 id="taskdestroy-destroy-a-task-thread">TaskDestroy  Destroy a Task Thread</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> TaskDestroy(<span class="dt">void</span> *hTask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to target task</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Terminates execution of the task object specified by the supplied handle <em>hTask</em>, and frees task object from system memory. Note that memory allocated by the task thread is not associated with the task thread and must be freed manually.</p>
<h4 id="taskexit-exit-a-task-thread">TaskExit  Exit a Task Thread</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> TaskExit();</code></pre></div>
<p><strong>Parameters</strong> None</p>
<p><strong>Return Value</strong> Does not return.</p>
<p><strong>Description</strong> This function exits a task thread. It should always be called immediately before the task entry-point function is about to return, but it may be called from anywhere.</p>
<h4 id="taskgetenv-get-task-environment-handle">TaskGetEnv  Get Task Environment Handle</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *TaskGetEnv(<span class="dt">void</span>  *hTask,
                 <span class="dt">int</span>   Slot);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to target task</li>
<li>Slot: Environment slot to use (1-3)</li>
</ul>
<p><strong>Return Value</strong> Private environment handle or NULL.</p>
<p><strong>Description</strong> Returns a private environment handle for the supplied task handle hTask that was previously stored with the <em>TaskSetEnv()</em> function. The slot specified in <em>Slot</em> specifies the address (1-3) of the environment handle. There are actually four slots, but slot 0 is reserved.</p>
<blockquote>
<p><strong>NOTE:</strong> This function returns without setting or getting an environment variable if the slot parameter is non-zero. All internal stack functions use slot zero.</p>
</blockquote>
<blockquote>
<p><strong>TI-RTOS Kernel Users Note:</strong> The OS adaptation layer (OS.LIB) implements this function for slot 0 only. The reserved slot 0 is the only slot required by the NDK. Slots 1 to 3 are not implemented. You should use the standard TI-RTOS Kernel functions <em>Task_setEnv()</em> and <em>Task_getEnv()</em> for private environment pointer storage and retrieval.</p>
</blockquote>
<h4 id="taskgetpri-get-task-priority">TaskGetPri  Get Task Priority</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> TaskGetPri(<span class="dt">void</span> *hTask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to target task</li>
</ul>
<p><strong>Return Value</strong> Task priority level.</p>
<p><strong>Description</strong> Returns the priority of the target task. See <em>TaskSetPri()</em> for more information on priority.</p>
<h4 id="taskself">TaskSelf</h4>
<p>Get the Handle to the Currently Executing Task Thread</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *TaskSelf();</code></pre></div>
<p><strong>Parameters</strong> None.</p>
<p><strong>Return Value</strong> Handle to currently executing thread, or NULL on error.</p>
<p><strong>Description</strong> Returns the task handle of the currently executing task thread. This function is used mainly in other task object calls where the caller wishes to operate on the current thread, but does not know the current threads handle.</p>
<p>If called on an illegal (system) thread, this function returns NULL. Only certain implementations of the OS even have a system thread, and no user code should ever be executed on it. A NULL may also result if Task functions are called before the operating system is initialized.</p>
<h4 id="tasksetenv-set-task-environment-handle">TaskSetEnv  Set Task Environment Handle</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> TaskSetEnv(<span class="dt">void</span>  *hTask,
                <span class="dt">int</span>   Slot,
                <span class="dt">void</span>  *hEnv);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to target task</li>
<li>Slot: Environment slot to use (1-3)</li>
<li>hEnv: Private environment handle</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Sets and stores a private environment handle for the supplied task handle <em>hTask</em>. This handle can be later retrieved by <em>TaskGetEnv()</em>. The slot specified in Slot assigns an address (1-3) to the environment handle. There are actually four slots, but slot 0 is reserved.</p>
<blockquote>
<p><strong>NOTE:</strong> This function returns without setting or getting an environment variable if the slot parameter is non-zero. All internal stack functions use slot zero.</p>
</blockquote>
<blockquote>
<p><strong>TI-RTOS Kernel Users Note:</strong> The OS adaptation layer (OS.LIB) implements this function for slot 0 only. The reserved slot 0 is the only slot required by the NDK. Slots 1 to 3 are not implemented. Application programmers should use the standard TI-RTOS Kernel functions <em>Task_setEnv()</em> and <em>Task_getEnv()</em> for private environment pointer storage and retrieval.</p>
</blockquote>
<h4 id="tasksetpri-set-task-priority">TaskSetPri  Set Task Priority</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> TaskSetPri(<span class="dt">void</span> *hTask,
               <span class="dt">int</span>  Priority);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to target task</li>
<li>Priority: Task priority level</li>
</ul>
<p><strong>Return Value</strong> Previous task priority level.</p>
<p><strong>Description</strong> Sets the priority of the target task to the specified value. The priority should not be higher than the configured value for the NDKs Global.highTaskPriLevel property (the priority for high priority NDK tasks), which is 7 by default. 0 is the lowest priority and should be reserved for an idle task. If the specified priority is negative, the task is blocked.</p>
<p>Calling this function may cause a task switch.</p>
<h4 id="tasksleep-sleep-task-for-period-of-time">TaskSleep  Sleep Task for Period of Time</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> TaskSleep(<span class="dt">uint32_t</span> Delay);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Delay: Time (in milliseconds) of sleep</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Sleeps the calling task for a period of time as supplied in <em>Delay</em>. The sleep time cannot be zero.</p>
<p>Calling this function may cause a task switch.</p>
<h4 id="taskyield-yield-execution-to-another-task-thread">TaskYield  Yield Execution to Another Task Thread</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> TaskYield();</code></pre></div>
<p><strong>Parameters</strong> None.</p>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function yields execution to another thread by causing a round-robin task switch among ready task threads executing at the same priority level.</p>
<p>This function always causes a task switch; however, the original calling task may be the next to execute.</p>
<h2 id="semaphore-support">2.3 Semaphore Support</h2>
<p>The semaphore object provides a method of manipulating counting semaphores using a generic handle. Semaphores can be used for both task synchronization and mutual exclusion.</p>
<h3 id="function-overview-1">2.3.1 Function Overview</h3>
<p>The Semaphore Object access functions (in functional order) are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SemCreate()</td>
<td>Create new semaphore</td>
</tr>
<tr class="even">
<td>SemDelete()</td>
<td>Delete semaphore</td>
</tr>
<tr class="odd">
<td>SemPend()</td>
<td>Wait on semaphore, optionally for a period of time</td>
</tr>
<tr class="even">
<td>SemCount()</td>
<td>Get the current semaphore count</td>
</tr>
<tr class="odd">
<td>SemPost()</td>
<td>Release semaphore - increment count</td>
</tr>
<tr class="even">
<td>SemReset()</td>
<td>Reset semaphore and set new count</td>
</tr>
</tbody>
</table>
<h3 id="semaphore-api-functions">2.3.2 Semaphore API Functions</h3>
<h4 id="semcreate-create-new-semaphore">SemCreate  Create New Semaphore</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *SemCreate(<span class="dt">int</span> Count);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Count: Initial semaphore count</li>
</ul>
<p><strong>Return Value</strong> Handle to semaphore or NULL on error.</p>
<p><strong>Description</strong> Creates a new semaphore object with an initial count.</p>
<h4 id="semcount-get-current-semaphore-count">SemCount  Get Current Semaphore Count</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> SemCount(<span class="dt">void</span> *hSem);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSem: Handle to Semaphore</li>
</ul>
<p><strong>Return Value</strong> Current semaphore count</p>
<p><strong>Description</strong> Returns the current count of the semaphore object.</p>
<h4 id="semdelete-delete-semaphore">SemDelete  Delete Semaphore</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> SemDelete(<span class="dt">void</span> *hSem);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSem: Handle to Semaphore</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Deletes the semaphore object and frees related memory.</p>
<p>Any task currently waiting on this semaphore is blocked forever - even if it originally specified a timeout to <em>SemPend()</em>. With a little care in programming, this will not occur.</p>
<h4 id="sempend-wait-for-a-semaphore">SemPend  Wait for a Semaphore</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> SemPend(<span class="dt">void</span>     *hSem,
            <span class="dt">uint32_t</span> Timeout);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSem: Handle to Semaphore</li>
<li>Timeout: Maximum time to wait (in milliseconds)</li>
</ul>
<p><strong>Return Value</strong> The function returns 1 if the semaphore was obtained, and 0 if not.</p>
<p><strong>Description</strong> This function waits on a semaphore.</p>
<p>If the semaphore count is greater than 0, the semaphore count is decrement and this function immediately returns.</p>
<p>If the semaphore count is zero, the task is placed on a waiting list for the semaphore and blocked. If the semaphore becomes available in the time period specified in <em>Timeout</em>, the function returns. However, the function returns regardless once the timeout has expired. A timeout value of 0 always returns without blocking or yielding. A timeout value of SemaphoreP_WAIT_FOREVER causes the caller to wait on the semaphore without time out.</p>
<p>The waiting list is first in, first out, without regard to priority. Thus, semaphores can be used to round-robin task threads at different priority levels.</p>
<p>Calling this function may cause a task switch (unless called with <em>Timeout</em> set to 0).</p>
<h4 id="sempost-signal-a-semaphore">SemPost  Signal a Semaphore</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> SemPost(<span class="dt">void</span> *hSem);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSem: Handle to Semaphore</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> If the semaphore count is greater than 0 (or is equal to 0, but without any pending task threads), the semaphore count is incremented and this function immediately returns.</p>
<p>If the semaphore count is zero and there are tasks threads pending on it, the count remains at zero, and the first thread in the pending list is unblocked.</p>
<p>Calling this function may cause a task switch.</p>
<h4 id="semreset-reset-semaphore">SemReset  Reset Semaphore</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> SemReset(<span class="dt">void</span> *hSem,
              <span class="dt">int</span>  Count);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSem: Handle to Semaphore</li>
<li>Count: Initial semaphore count</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function resets the semaphore, first setting an initial semaphore count, and then unblocking all tasks that are pending on the semaphore.</p>
<p>This function should be used with care. Tasks that are pending on the semaphore may exhibit unexpected behavior because all tasks pending on the semaphore will return from their respective <em>SemPend()</em> calls regardless of requested timeout. The return value for the respective <em>SemPend()</em> calls will always be correct because one or more tasks may get the semaphore (depending on the value of <em>Count</em>), but tasks that called <em>SemPend()</em> without a timeout may assume they have obtained the semaphore without checking the <em>SemPend()</em> return value.</p>
<p>Calling this function may cause a task switch.</p>
<h2 id="memory-allocation-support">2.4 Memory Allocation Support</h2>
<p>As part of normal stack operation, memory will be allocated and freed on a regular basis. It is therefore recommended that a memory support system have the ability to allocate and free small memory blocks in a variety of sizes, without memory fragmentation. The functions described here work on a memory bucket system of predefined fixed sizes. Although it allocates more memory than requested, when the memory is released, it can be reused without fragmentation.</p>
<h3 id="function-overview-2">2.4.1 Function Overview</h3>
<p>The Memory Allocation access functions (in functional order) are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mmAlloc()</td>
<td>Allocate Small Memory Block</td>
</tr>
<tr class="even">
<td>mmFree()</td>
<td>Free <em>mmAlloc()</em> Memory Block</td>
</tr>
<tr class="odd">
<td>mmBulkAlloc()</td>
<td>Allocate Unrestricted Memory Block</td>
</tr>
<tr class="even">
<td>mmBulkFree()</td>
<td>Free <em>mmBulkAlloc()</em> Memory Block</td>
</tr>
<tr class="odd">
<td>mmCopy()</td>
<td>Copy a Memory Block</td>
</tr>
<tr class="even">
<td>mmZeroInit()</td>
<td>Initialize a Memory Block to Zero</td>
</tr>
</tbody>
</table>
<p><a name="memory-allocation-api-functions"></a></p>
<h3 id="memory-allocation-api-functions">2.4.2 Memory Allocation API Functions</h3>
<h4 id="mmalloc-allocate-memory-block">mmAlloc  Allocate Memory Block</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *mmAlloc(<span class="dt">uint32_t</span> size);</code></pre></div>
<p><strong>Return Value</strong> Pointer to allocated memory or NULL on error.</p>
<p><strong>Description</strong> Allocates a memory block of at least <em>size</em> bytes in length. The function should return a pointer to the new memory block, or NULL if memory is not available. <strong>The size of the allocation cannot be more than 3068 bytes.</strong></p>
<h4 id="mmfree-free-memory-block">mmFree  Free Memory Block</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> mmFree(<span class="dt">void</span> *pv);</code></pre></div>
<p><strong>Return Value</strong> If a memory tracking error occurs, this function returns 0; otherwise, it returns 1.</p>
<p><strong>Description</strong> Frees a previously allocated memory block by supplying the pointer that <em>mmAlloc()</em> originally returned.</p>
<h4 id="mmbulkalloc-allocate-bulk-memory-block">mmBulkAlloc  Allocate Bulk Memory Block</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *mmBulkAlloc(<span class="dt">int32_t</span> Size);</code></pre></div>
<p><strong>Return Value</strong> Pointer to allocated memory or NULL on error.</p>
<p><strong>Description</strong> Allocates a memory block of at least <em>size</em> bytes in length. The function returns a pointer to the new memory block, or NULL if memory is not available. The size of the allocation is not restricted.</p>
<h4 id="mmbulkfree-free-bulk-memory-block">mmBulkFree  Free Bulk Memory Block</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> mmBulkFree(<span class="dt">void</span> *pv);</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Frees a previously allocated memory block by supplying the pointer that <em>mmBulkAlloc()</em> originally returned.</p>
<h4 id="mmcopy-copy-memory">mmCopy  Copy Memory</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> mmCopy(<span class="dt">void</span>      *pDst,
            <span class="dt">void</span>      *pSrc,
            <span class="dt">uint32_t</span>  size);</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to copy <em>size</em> bytes of data memory from the data buffer <em>pSrc</em> to the data buffer <em>pDst</em>.</p>
<h4 id="mmzeroinit-zero-memory">mmZeroInit  Zero Memory</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> mmZeroInit(<span class="dt">void</span>      *pDst,
                <span class="dt">uint32_t</span>  size);</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to initialize <em>size</em> bytes of data memory in the data buffer <em>pDst</em> to NULL.</p>
<h2 id="print-and-debug-support">2.5 Print and Debug Support</h2>
<p>The stack provides an output function called <code>DbgPrintf()</code>. This function currently builds upon XDCs very configurable <code>System_printf()</code> to log messages. Where these messages go is controlled by the users configuration of XDCs <code>System</code> Module. For more information, including how to configure the <code>System</code> Module, refer to XDCs documentation.</p>
<p>Note that the severity threshold at which the debug message is recorded can be configured by the user (see <code>_oscfg.DbgPrintLevel</code>), as can the point at which the error causes a system shutdown (see <code>_oscfg.DbgAbortLevel</code>).</p>
<p>Also note that printf-style-formatting limitations (e.g.whether floating point formatting is supported) is a function of how the user configures XDCs <code>System</code> Module.</p>
<blockquote>
<p><strong>FreeRTOS Users Note:</strong> As <code>DbgPrint()</code> is built upon XDCs <code>System_printf()</code>, the logging features of <code>DbgPrintf()</code> are not provided on FreeRTOS. The severity threshold, which may cause the stack to shut down in the most extreme cases, <em>is</em> supported, but no logging is provided.</p>
</blockquote>
<h3 id="standard-api-functions">2.5.1 Standard API Functions</h3>
<p>A set of printf-like functions is supported:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_sprintf(<span class="dt">char</span> *s, <span class="dt">const</span> <span class="dt">char</span> *format, ...);
<span class="dt">int</span> NDK_vprintf(<span class="dt">const</span> <span class="dt">char</span> *format, va_list arg);
<span class="dt">int</span> NDK_vsprintf(<span class="dt">char</span> *s, <span class="dt">const</span> <span class="dt">char</span> *format, va_list arg);</code></pre></div>
<h3 id="debug-api-functions">2.5.2 Debug API Functions</h3>
<h4 id="dbgprintf-print-a-debug-message-to-the-debug-log">DbgPrintf  Print a Debug Message to the Debug Log</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> DbgPrintf(<span class="dt">int</span> ErrLevel,
               <span class="dt">char</span> *Format,
               ?);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>ErrLevel: Severity level of the error</li>
<li>Format: Standard printf format string</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function prints a debug message to the global debug log buffer. The log buffer is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define LL_DEBUG_LOG_MAX   1024</span>
<span class="kw">extern</span> <span class="dt">char</span> DebugLog[LL_DEBUG_LOG_MAX]; <span class="co">// DebugLog Buffer</span>
<span class="kw">extern</span> <span class="dt">int</span>  DebugLogSize;               <span class="co">// Bytes of data currently in DebugLog</span></code></pre></div>
<p>The buffer behaves like one large NULL terminated string. The contents are cleared by setting <em>DebugLogSize</em> to 0.</p>
<p>The value of ErrLevel determines if the message is printed and additionally, if the message results in a system shutdown. Both of these thresholds (printing and shutdown) are set through the OS configuration. The definition of the severity levels are as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define DBG_INFO  1</span>
<span class="pp">#define DBG_WARN  2</span>
<span class="pp">#define DBG_ERROR 3</span>
<span class="pp">#define DBG_None  4</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> The <em>DbgPrintf()</em> function is not supported for applications that use FreeRTOS.</p>
</blockquote>
<h1 id="sockets-and-stream-io-api">3 Sockets and Stream IO API</h1>
<p>This chapter describes the socket and file API functions.</p>
<h2 id="file-descriptor-environment">3.1 File Descriptor Environment</h2>
<p>In most embedded operating system environments, support for file descriptors varies greatly. In most cases, only the bare minimum functionality is provided, and trimmed down support functions are provided using the common reserved names (<em>read()</em>, <em>write()</em>, <em>close()</em>, etc.).</p>
<p>As this stack supports the standard sockets interface functions, and these functions require file descriptor support, the stack provides its own small file system. This section describes the basic mechanics of the file system.</p>
<h3 id="organization">3.1.1 Organization</h3>
<p>The basic building block of the stack code internally is an object handle. Internally to the stack, both sockets and pipes are addressed by object handles. However, at the application level, sockets and pipes are treated as file descriptors. The file descriptor contains additional state information allowing tasks to be blocked and unblocked based on socket activity.</p>
<p>The stack API supports the use of file descriptors by adding a file descriptor layer of abstraction to the native operating environment. This layer implements the standard sockets and file IO functions. The stack works by associating a file descriptor session with each callers thread (or in this terminology, task). In this system, each task has its own file descriptor session. The file descriptor session is used when the task needs to block pending network activity.</p>
<p>Note that although file descriptors can be used in classic functions like <em>select()</em>, in this implementation, they are still handles, not integers. For compatibility, network applications must use the NDK header files, and use INVALID_SOCKET for an error condition (not -1), and refrain from comparing sockets as &lt;0 when checking for validity.</p>
<h3 id="initializing-the-file-system-environment">3.1.2 Initializing the File System Environment</h3>
<p>To use the file system and socket functions provided by the stack, a task must first allocate a file descriptor table (called a file descriptor session). This is accomplished at the application layer by calling the file descriptor function <em>fdOpenSession()</em>.</p>
<p>When the task is finished using the file descriptor API, or when it is about to terminate, the function <em>fdCloseSession()</em> is called.</p>
<h3 id="when-to-initialize-the-file-descriptor-environment">3.1.2.1 When to Initialize the File Descriptor Environment</h3>
<p>For correct stack operation, a task thread must open a file descriptor session before calling any file descriptor related functions, and then close it when it is done.</p>
<p>The simplest way to handle the file descriptor session is to call <em>TaskCreate()</em>, which handles opening and closing the file descriptor session internally.</p>
<p>Another way to handle the file descriptor session is for the task to open a file session when it starts, and close the session when it completes. For example:</p>
<p><strong>Socket Task:</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> socket_task(<span class="dt">int</span> IPAddr, <span class="dt">int</span> TcpPort)
{
    SOCKET s;

    <span class="co">// Open the file session</span>
    fdOpenSession(TaskSelf());

    &lt; socket application code &gt;

    <span class="co">// Close the file session</span>
    fdCloseSession(TaskSelf());
}</code></pre></div>
<p>Another method is for the task that creates the socket task thread to open the file descriptor session for the child thread. Note that the parent task must guarantee that the child tasks file session is open before the child task executes. This is done via task priority or semaphore, but can complicate task creation. Therefore, it is not the ideal approach.</p>
<p>It is also possible to allow a child task to open its own file session, but allow the parent task to monitor its children and eventually destroy them. Here, the parent task must close the file session of the child task threads it destroys. The child task then blocks when finished instead of terminating its own thread. The following example illustrates this concept:</p>
<p><strong>Child Socket Task:</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> child_socket_task(<span class="dt">int</span> IPAddr, <span class="dt">int</span> TcpPort)
{
    SOCKET s;

    <span class="co">// Open the file session</span>
    fdOpenSession(TaskSelf());

    &lt; socket application code &gt;

    <span class="co">// We are done, but our parent thread will close</span>
    <span class="co">// our file session and destroy this task, so here</span>
    <span class="co">// we just yield.</span>
    TaskYield();
}</code></pre></div>
<p>The parent task functions would look as follows:</p>
<p><strong>Parent Task Functions:</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> create_child_task()
{
    <span class="co">// Create System Tasks</span>

    <span class="co">// Create a child task</span>
    hChildTask = TaskCreate(&amp;child_socket_task, ?);
}

<span class="dt">void</span> destroy_child_task()
{
    <span class="co">// First close the child's file session</span>
    <span class="co">// (This will close all open files)</span>
    fdSessionClose(hChildTask);

    <span class="co">// Then destroy the task</span>
    TaskDestroy(hChildTask);
}</code></pre></div>
<h3 id="auto-initializing-the-file-descriptor-environment">3.1.2.2 Auto-Initializing the File Descriptor Environment</h3>
<p>For TI-RTOS Kernel users who configure their application using XGCONF or a *.cfg configuration file, the calls to fdOpenSession and fdCloseSession can be configured to be called automatically. This is achieved by setting the following configuration parameter:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">var Global = xdc.useModule('ti.ndk.config.Global.xdc');
Global.autoOpenCloseFD = true;</code></pre></div>
<p>Setting this parameter to true causes calls to fdOpenSession and fdCloseSession to be made automatically in the TI-RTOS Kernel Task modules create hook function and exit hook function, respectively.</p>
<p>Note that the Global.autoOpenCloseFD parameter is only supported for dynamically-created Tasks created from within a Task context (that is, from within another running Task function). Tasks created statically in the configuration or dynamically in main() or a Hwi or Swi thread do not support this feature.</p>
<h2 id="file-descriptor-programming-interface">3.2 File Descriptor Programming Interface</h2>
<p>The purpose of supporting a file system is to support the sockets API. Unfortunately, the sockets API is not a complete IO API, as it was originally designed to integrate into the Unix file system. Thus, several file descriptor functions that are important for application programming are not really socket calls at all. The stack library supports a handful of what are normally considered file functions, so that sockets applications can be programmed in a more traditional sense. So that these functions will not conflict with any other file functions in the system, their names have been altered slightly from the standard definitions.</p>
<h3 id="function-overview-3">3.2.1 Function Overview</h3>
<p>The stream IO object can take two forms. In the vast majority of cases, it will be in the form of a local file descriptor. The following functions can operate on file descriptors:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fdOpenSession()</td>
<td>Open file descriptor support session</td>
</tr>
<tr class="even">
<td>fdCloseSession()</td>
<td>Close file descriptor support session</td>
</tr>
<tr class="odd">
<td>fdClose()</td>
<td>Flush stream and close file descriptor (same as standard <em>close()</em>)</td>
</tr>
<tr class="even">
<td>fdError()</td>
<td>Return last error value (same as standard <em>error</em>)</td>
</tr>
<tr class="odd">
<td>fdPoll()</td>
<td>Wait on a list of file descriptor events (same as standard <em>poll()</em>)</td>
</tr>
<tr class="even">
<td>fdSelect()</td>
<td>Wait on one or more file events (same as standard <em>select()</em>)</td>
</tr>
<tr class="odd">
<td>fdSelectAbort()</td>
<td>Aborts calls to <em>fdSelect()</em> and <em>fdPoll()</em> with forced timeout condition</td>
</tr>
<tr class="even">
<td>fdStatus()</td>
<td>Get the current status of a file descriptor (similar to <em>ioctl/FIONREAD</em>)</td>
</tr>
<tr class="odd">
<td>fdShare()</td>
<td>Add a reference count to a file descriptor</td>
</tr>
</tbody>
</table>
<p>The <em>fdSelect()</em> function uses file descriptor sets to specify which file descriptors are being checked for activity and which have activity detected. There is a small set of MACRO functions for manipulating file descriptor sets. These include the following:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FD_SET()</td>
<td>Add a file descriptor to a file descriptor set.</td>
</tr>
<tr class="even">
<td>FD_CLR()</td>
<td>Remove a file descriptor from a file descriptor set.</td>
</tr>
<tr class="odd">
<td>FD_ISSET()</td>
<td>Test to see if a file descriptor is included in a file descriptor set.</td>
</tr>
<tr class="even">
<td>FD_COPY()</td>
<td>Copy a file descriptor set.</td>
</tr>
<tr class="odd">
<td>FD_ZERO()</td>
<td>Clear (initialize) a file descriptor set.</td>
</tr>
</tbody>
</table>
<h3 id="file-descriptor-api-functions">3.2.2 File Descriptor API Functions</h3>
<h4 id="fdopensession-open-file-descriptor-session">fdOpenSession  Open File Descriptor Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdOpenSession(<span class="dt">void</span> *hTask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Task Thread Handle</li>
</ul>
<p><strong>Return Value</strong> 1 on success or 0 on error. An error return indicates that a session is already open for the specified task, or that a memory allocation error has occurred.</p>
<p><strong>Description</strong> This function opens a file descriptor session on a task thread so that the task can begin using file descriptor and other stream IO functions.</p>
<p>A task thread normally calls <em>fdOpenSession()</em> when it is first created, and <em>fdCloseSession()</em> before it exits. Use of these functions was described in more detail in the previous section.</p>
<h4 id="fdclosesession-close-file-descriptor-session">fdCloseSession  Close File Descriptor Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fdCloseSession(<span class="dt">void</span> *hTask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Task Thread Handle</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function closes a file descriptor session that was previously opened with <em>fdOpenSession()</em>. When called, any remaining open file descriptors are closed.</p>
<p>A task thread normally calls <em>fdOpenSession()</em> when it is first created, and <em>fdCloseSession()</em> before it exits. Use of these functions was described in more detail in the previous section.</p>
<h4 id="fdclose-close-file-descriptor">fdClose  Close File Descriptor</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdClose(<span class="dt">void</span> *fd);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File Descriptor to close (compatible with type SOCKET)</li>
</ul>
<p><strong>Return Value</strong> 0 on success or -1 on error. When an error occurs, the error type can be obtained by calling <em>fdError()</em> (<em>error</em> is also equal to this function).</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The descriptor does not reference a socket.</li>
<li>EINVAL: <em>NDK_listen()</em> has not been called on the socket or name arguments are invalid.</li>
</ul>
<p><strong>Description</strong> This function closes the indicated file descriptor.</p>
<h4 id="fderror-get-the-last-file-error">fdError  Get the Last File Error</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdError();</code></pre></div>
<p><strong>Description</strong> This function returns the last file error that occurred on the current task. In the <code>SERRNO.H</code> header file, <em>error</em> is equal to this function.</p>
<blockquote>
<p><strong>NOTE:</strong> The error code returned via <em>fdError()</em> is stored in the file descriptor session associated with a task. If a task calls a file or socket function before it opens a file descriptor session, an error condition results. However, no error code can be stored for retrieval by <em>fdError()</em> because the file descriptor session does not exist to hold it.</p>
</blockquote>
<h4 id="fdpoll-wait-on-a-list-of-file-descriptor-events">fdPoll  Wait on a List of File Descriptor Events</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdPoll(FDPOLLITEM items,
           <span class="dt">uint32_t</span>   itemcnt,
           <span class="dt">int32_t</span>    timeout);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>items: Pointer to a list of descriptor events of type FDPOLLITEM</li>
<li>itemcnt: Number of entries in <em>items</em> list</li>
<li>timeout: Function timeout in milliseconds</li>
</ul>
<p><strong>Return Value</strong></p>
<p>Returns the number of file descriptors in the items list for which the <em>eventsDetected</em> field is non-zero.</p>
<p>Returns SOCKET_ERROR if the caller has not opened a file descriptor session (with <em>fdOpenSession()</em>).</p>
<p>Returns zero (0) under any of the following conditions:</p>
<ul>
<li>No detected flags and time out has occurred</li>
<li>No detected flags and an <em>fdSelectAbort()</em> was issued</li>
<li>No detected flags and an internal resource allocation failed</li>
</ul>
<p><strong>Description</strong> The <em>fdPoll()</em> function is a more efficient alternative to the <em>fdSelect()</em> function. It polls the supplied list of sockets, with a timeout specified in milliseconds (or POLLINFTIM for infinite timeout). It has the advantage over <em>fdSelect()</em> because the original list of file descriptors (or sockets) to be examined is not overwritten by the results, and thus can be used multiple times without reconstruction.</p>
<p>The list of file descriptors to check is provided in the <em>items</em> array. The array is of type FDPOLLITEM, which is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _fdpollitem {
        <span class="dt">void</span> *fd;
        <span class="dt">uint16_t</span>   eventsRequested;
        <span class="dt">uint16_t</span>   eventsDetected;
} FDPOLLITEM;</code></pre></div>
<p>The FDPOLLITEM entry contains a file descriptor (or socket) to check, a set of flags for requested events that is initialized by the application, and a set of resulting flags for a detected event that is initialized by the <em>fdPoll()</em> function.</p>
<p>The entry <em>fd</em> is the file descriptor to check. If fd is set to INVALID_SOCKET, or the <em>eventsRequested</em> field is NULL, the item entry is ignored. However, the <em>eventsDetected</em> field is still reset to zero.</p>
<p>The same file descriptor should not appear twice in the list, instead the event flags should be combined on a single entry. (Duplicate descriptors will not cause an error, but will increase system load.)</p>
<p>Valid flags for <em>eventsRequested</em> are one or more of the following:</p>
<ul>
<li>POLLIN - Socket readable (or read error pending)</li>
<li>POLLOUT - Socket writable (or send error pending)</li>
<li>POLLPRI - Socket OOB readable (or error pending)</li>
<li>POLLNVAL - Socket or request type invalid</li>
</ul>
<p>Valid flags for <em>eventsDetected</em> are the same as above, where all detected conditions are indicated. (Note that POLLNVAL can be set whether or not it was requested in <em>eventsRequested</em>.)</p>
<h4 id="fdselect-wait-on-one-or-multiple-file-events">fdSelect  Wait on one or multiple File Events</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdSelect(<span class="dt">int</span>            maxfd,
             fd_set         *readset,
             fd_set         *writeset,
             fd_set         *exceptset,
             <span class="kw">struct</span> timeval *timeout);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>maxfd: Ignored</li>
<li>readset: Set of file descriptors to check for reading</li>
<li>writeset: Set of file descriptors to check for writing</li>
<li>exceptset: Set of file descriptors to check for exceptional conditions (OOB data)</li>
<li>timeout: Pointer to timeval structure of time to wait (or NULL)</li>
</ul>
<p><strong>Return Value</strong> Returns a positive count of ready descriptors (combined from all three possible sets), 0 on timeout, or -1 on error. When an error occurs, the error type can be obtained by calling <em>fdError()</em>.</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOMEM: Memory allocation error.</li>
<li>EINVAL: <em>NDK_listen()</em> has not been called on the socket or name arguments are invalid.</li>
</ul>
<p><strong>Description</strong> This function allows the task to instruct the stack to wait for any one of multiple events to occur and to wake up the process only when one of more of these events occurs or when a specified amount of time has passed.</p>
<p>The definition of the timeval structure is:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> timeval {
    <span class="dt">int32_t</span>   tv_sec;
    <span class="dt">int32_t</span>   tv_usec;
};</code></pre></div>
<p>Passing in a NULL pointer for timeout specifies an infinite wait period. Passing a valid pointer to a timeval structure with both <em>tv_sec</em> and <em>tv_usec</em> set to zero specifies that the function should not block.</p>
<blockquote>
<p><strong>NOTE:</strong> This function is less efficient than <em>fpPoll()</em>. In fact, the <em>fdSelect()</em> function calls <em>fdPoll()</em> after rearranging the descriptor sets into an <em>fdPoll()</em> descriptor list.</p>
</blockquote>
<h4 id="fdselectabort-terminate-a-previous-call-to-fdselect-or-fdpoll">fdSelectAbort  Terminate a Previous Call to fdSelect() or fdPoll()</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fdSelectAbort(<span class="dt">void</span> *hTask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hTask: Handle to the task thread that is blocked in <em>fdSelect()</em> or <em>fdPoll()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function aborts a call to <em>fdSelect()</em> or <em>fdPoll()</em> on the specified target thread by simulating a timeout condition (even when no timeout was originally specified). It can be used to wake a thread using a different method than socket or pipe activity. It is useful in callback functions where the handle to the target task thread is known, but where socket calls cannot be easily used.</p>
<p>The return value from the <em>fdSelect()</em> or <em>fdPoll()</em> function called on the target thread is still valid. In other words, if there is pending file descriptor activity, it will still be returned to the caller. However, if the target task thread is blocked in <em>fdSelect()</em> or <em>fdPoll()</em> at the time of the call, the most likely return value is zero for no activity.</p>
<p>If the target thread is not currently pending on a call to <em>fdSelect()</em> or <em>fdPoll()</em>, any subsequent call will be affected. Thus, the target thread is guaranteed to see the abort (although it may be accompanied by actual socket activity). So there is no race condition on calling <em>fdSelectAbort()</em> immediately prior to the target task thread calling <em>fdSelect()</em> or <em>fdPoll()</em>.</p>
<h4 id="fdstatus-get-the-current-status-of-a-file-descriptor">fdStatus  Get the Current Status of a File Descriptor</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdStatus(<span class="dt">void</span> *fd,
             <span class="dt">int</span>  request,
             <span class="dt">int</span>  *results);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File descriptor (socket or pipe) to check</li>
<li>request: Status request type.</li>
<li>hTask: Pointer to where status results are written</li>
</ul>
<p><strong>Return Value</strong> 0 on success or -1 on error. When an error occurs, the error type can be obtained by calling <em>fdError()</em> (<em>errno</em> is also equal to this function).</p>
<p><strong>Description</strong> This function reads current status information about the file descriptor. The descriptor can be either a socket or a pipe object. The following describes the value written to <em>results</em> for the various <em>request</em> types and descriptor types:</p>
<ul>
<li><p><code>request = FDSTATUS_TYPE;</code></p>
<p>The <em>results</em> pointer is written with the file descriptor type. It will be one of the following values:</p>
<ul>
<li>FDSTATUS_TYPE_SOCKET - The file descriptor is a socket.</li>
<li>FDSTATUS_TYPE_PIPE - The file descriptor is a pipe.</li>
</ul></li>
<li><p><code>request = FDSTATUS_RECV;</code></p>
<p>On listening sockets, the <em>results</em> pointer is written with:</p>
<ul>
<li>-1 - There is an error pending on the socket.</li>
<li>0 - There are no connections ready to be accepted.</li>
<li>1 - There is at least one connection ready to be accepted.</li>
</ul>
<p>On data sockets, the <em>results</em> pointer is written with:</p>
<ul>
<li>-1 - There is an error pending, or a call to <em>NDK_recv()</em> will result in an error. <strong>NOTE:</strong> On a TCP socket, this return value can also indicate that the peer connection has been closed and all available data has been read. In this case, a subsequent call to <em>NDK_recv()</em> will return NULL, not error.</li>
<li>&lt;0 to n&gt; - The number of bytes that can be read using <em>NDK_recv()</em> without blocking.</li>
</ul></li>
<li><p><code>request = FDSTATUS_SEND;</code></p>
<p>On listening sockets, the <em>results</em> pointer is written with:</p>
<ul>
<li>-1 - A listening socket can never be written.</li>
</ul>
<p>On TCP (non-ATOMIC) data sockets, the <em>results</em> pointer is written with:</p>
<ul>
<li>-1 - There is an error pending, or a call to <em>NDK_send()</em> will result in an error.</li>
<li>&lt;0 to n&gt; - The number of bytes that can be written using <em>NDK_send()</em> without blocking.</li>
</ul>
<p>On UDP/RAW (ATOMIC) data sockets, the <em>results</em> pointer is written with:</p>
<ul>
<li>-1 - There is an error pending, or a call to <em>NDK_send()</em> will result in an error.</li>
<li>&lt;0 to n&gt; - The maximum number of bytes that can be written using a single <em>NDK_send()</em> call.</li>
</ul></li>
</ul>
<h4 id="fdshare-add-a-reference-count-to-a-file-descriptor">fdShare  Add a Reference Count to a File Descriptor</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fdShare(<span class="dt">void</span> *fd);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File descriptor to share (compatible with type SOCKET)</li>
</ul>
<p><strong>Return Value</strong> Returns zero on success or -1 on error.</p>
<p><strong>Description</strong> This is an optional function for applications that use descriptor sharing. It increments a reference count on the target descriptor, which is then decremented when the application calls <em>fdClose()</em>. It allows the descriptor to be shared among multiple tasks, each calling <em>fdClose()</em> when they are done, and the file descriptor is only closed by the final call. (Note that file descriptors are created with a reference call of 1, meaning that the first call to <em>fdClose()</em> will close the descriptor.)</p>
<p>For example, <em>fdShare()</em> is useful in a case where Task A opens a session and calls <em>NDK_recv()</em> in a loop on a socket. Task B has a loop that calls <em>NDK_send()</em> on the same socket. The call to <em>NDK_send()</em> from Task B will fail and then <em>fdError()</em> will return -1 if you do not call <em>fdOpenSession()</em> and then <em>fdShare()</em> from the second Task after the first Task has opened the socket.</p>
<p>For an example that calls fdShare(), see the <code>contest.c</code> file in the <code>/ti/ndk/tools/console</code> directory.</p>
<h3 id="file-descriptor-set-fd_set-macros">3.2.3 File Descriptor Set (fd_set) Macros</h3>
<h4 id="fd_set-add-a-file-descriptor-to-a-file-descriptor-set">FD_SET  Add a File Descriptor to a File Descriptor Set</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FD_SET( <span class="dt">void</span>   *fd,
             fd_set *pFdSet);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File descriptor to add (compatible with type SOCKET)</li>
<li>pFdSet: Pointer to fd_set data type</li>
</ul>
<p><strong>Return Value</strong> Should be treated as a void function. The true return value is dependent on the implementation of the macro.</p>
<p><strong>Description</strong> This function adds a file descriptor to a file descriptor set, typically before using the set in a call to <em>fdSelect()</em>. Note that after declaring an fd_set data type, it should be initialized using <em>FD_ZERO()</em> before attempting to set individual file descriptors.</p>
<h4 id="fd_clr-remove-a-file-descriptor-from-a-file-descriptor-set">FD_CLR  Remove a File Descriptor From a File Descriptor Set</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FD_CLR(<span class="dt">void</span>   *fd,
            fd_set *pFdSet);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File descriptor to remove</li>
<li>pFdSet: Pointer to fd_set data type</li>
</ul>
<p><strong>Return Value</strong> Should be treated as a void function. The true return value is dependent on the implementation of the macro.</p>
<p><strong>Description</strong> This function removes a file descriptor from a file descriptor set, typically after the file descriptor has been processed in a loop that continuously checks a file descriptor set.</p>
<h4 id="fd_isset-test-to-see-if-a-file-descriptor-is-included-in-a-file-descriptor-set">FD_ISSET  Test to See if a File Descriptor is Included in a File Descriptor Set</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> FD_ISSET(<span class="dt">void</span>   *fd,
             fd_set *pFdSet);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>fd: File descriptor to check (compatible with type SOCKET)</li>
<li>pFdSet: Pointer to fd_set data type</li>
</ul>
<p><strong>Return Value</strong> Returns an int value that should be treated as a TRUE/FALSE condition.</p>
<p><strong>Description</strong> This function returns TRUE if the supplied file descriptor is contained in the indicated file descriptor set. This function is typically called after a call to <em>fdSelect()</em> to determine on what file descriptors select has detected activity.</p>
<h4 id="fd_copy-copy-a-file-descriptor-set">FD_COPY  Copy a File Descriptor Set</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FD_COPY(fd_set *pFdSetSRC,
             fd_set *pFdSetDST);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pFdSetSRC: Pointer to fd_set to copy</li>
<li>pFdSetDST: Pointer to fd_set to write copied data</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to make a copy of a file descriptor set. This is typically done if a set needs to be modified, but this original information needs to be maintained.</p>
<h4 id="fd_zero-clear-initialize-a-file-descriptor-set">FD_ZERO  Clear (Initialize) a File Descriptor Set</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FD_ZERO(fd_set *pFdSet);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pFdSet: Pointer to fd_set to initialize</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to clear all bits in a file descriptor set. This should be the first call made on a newly declared fd_set variable.</p>
<p><a name="sockets-programming-interface"></a></p>
<h2 id="sockets-programming-interface">3.3 Sockets Programming Interface</h2>
<p>The socket function API supported by the stack library is not consistent with the standard Berkeley sockets API. For the BSD-compliant socket interface, see <a href="#ApxF">Appendix F</a> and the SlNetSock documentation, which is provided with the SimpleLink SDK installation.</p>
<p>This section covers only the IPv4 (AF_INET) family Sockets. For details on IPv6 sockets, see <a href="#ApxG">Appendix G</a> of this document. Similarly, for details on Raw Ethernet Sockets, see <a href="#RawSockets">Section 3.4</a> of this document.</p>
<h3 id="enhanced-no-copy-socket-operation">3.3.1 Enhanced No-Copy Socket Operation</h3>
<p>Any performance of any data stream operation suffers when data copies are performed. Although the stack software is designed to use a minimum number of data copies, memory efficiency and API compatibility sometimes require the use of data copy operations.</p>
<p>By default, neither UDP nor RAW sockets use send or receive buffers. However, the sockets API functions <em>NDK_recv()</em> and <em>NDK_recvfrom()</em> require a data buffer copy because of how the calling parameters to the functions are defined. In the stack library, two alternative functions  <em>NDK_recvnc()</em> and <em>NDK_recvncfrom()</em>  are provided to allow an application to get received data buffers directly without a copy operation. When the application is finished with these buffers, it returns them to the system via a call to <em>NDK_recvncfree()</em>.</p>
<p>By default, TCP uses both a send and receive buffer. The send buffer is used because the TCP protocol can require reshaping or retransmission of data due to window sizes, lost packets, etc. On receive, the standard TCP socket also has a receive buffer. This coalesces TCP data received from packet buffers. Coalescing data is important for protocols that transmit data in very small bursts (like a telnet session).</p>
<p>For TCP applications that get data in large bursts (and tend not to use flags like MSG_WAITALL on receive), the receive buffer can be eliminated by specifying an alternate TCP stream type of SOCK_STREAMNC (see <em><a href="#ndk_socket">NDK_socket()</a></em> ). Without the receive buffer, there is at least one less data copy because TCP will queue up the actual network packets containing receive data instead of copying it into a receive buffer.</p>
<p>Care needs to be taken when eliminating the TCP receive buffer. Here large amounts of packet buffers can be tied up for a small amount of data. Also, because packet buffers come from the HAL, there may be a limited supply available. If the MSG_WAITALL flag is used on an <em>NDK_recv()</em> or <em>NDK_recvfrom()</em> call, it is possible for all packet buffers to be consumed before the specified amount of payload data is received. This would cause a deadlock situation if no socket timeout is specified.</p>
<p>Although TCP sockets that use the SOCK_STREAMNC stream type are 100% compatible with the standard TCP socket type, they can also be used with the <em>NDK_recvnc()</em> and <em>NDK_recvncfrom()</em> functions that UDP and RAW sockets use to eliminate the final data copy from the stack to the sockets application. Using the no copy functions with SOCK_STREAMNC eliminates two data copies from the standard TCP socket. Note that when <em>NDK_recvnc()</em> and <em>NDK_recvncfrom()</em> are used with TCP, out of band data is not supported. If the SO_OOBINLINE socket option is set, the out of band data is retained, but the out of band data mark is discarded. If not using the inline socket option, the out of band data is discarded.</p>
<h3 id="function-overview-4">3.3.2 Function Overview</h3>
<p>The standard socket access functions are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NDK_accept()</td>
<td>Accept a connection on a socket</td>
</tr>
<tr class="even">
<td>NDK_bind()</td>
<td>Bind a name to a socket</td>
</tr>
<tr class="odd">
<td>NDK_connect()</td>
<td>Initiate a connection on a socket</td>
</tr>
<tr class="even">
<td>NDK_getpeername()</td>
<td>Return name (address) of connected peer</td>
</tr>
<tr class="odd">
<td>NDK_getsockname()</td>
<td>Return the local name (address) of the socket</td>
</tr>
<tr class="even">
<td>NDK_getsockopt()</td>
<td>Get the value of a socket option</td>
</tr>
<tr class="odd">
<td>NDK_listen()</td>
<td>Listen for connection requests on a socket</td>
</tr>
<tr class="even">
<td>NDK_recv()</td>
<td>Receive data from a socket</td>
</tr>
<tr class="odd">
<td>NDK_recvfrom()</td>
<td>Receive data from a socket with the senders name (address)</td>
</tr>
<tr class="even">
<td>NDK_send()</td>
<td>Send data to a connected socket</td>
</tr>
<tr class="odd">
<td>NDK_sendto()</td>
<td>Send data to a specified destination on an unconnected socket</td>
</tr>
<tr class="even">
<td>NDK_setsockopt()</td>
<td>Set the value of a socket option</td>
</tr>
<tr class="odd">
<td>NDK_shutdown()</td>
<td>Close one half of a socket connection</td>
</tr>
<tr class="even">
<td>NDK_socket()</td>
<td>Create a socket</td>
</tr>
<tr class="odd">
<td>NDK_socketpair()</td>
<td>Create socket pair. Redundant; see <a href="#full-duplex-pipes">Section 3.5</a>, <em>Full Duplex Pipes Programming Interface</em>.</td>
</tr>
</tbody>
</table>
<p>The enhanced socket functions are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NDK_recvnc()</td>
<td>Receive no-copy data from a socket</td>
</tr>
<tr class="even">
<td>NDK_recvncfree()</td>
<td>Free buffer obtained from <em>NDK_recvnc()</em> or <em>NDK_recvncfrom()</em></td>
</tr>
<tr class="odd">
<td>NDK_recvncfrom()</td>
<td>Receive no-copy data from a socket with the senders name (address)</td>
</tr>
</tbody>
</table>
<p><a name="sockets-api-functions"></a></p>
<h3 id="sockets-api-functions">3.3.3 Sockets API Functions</h3>
<h4 id="ndk_accept-accept-a-connection-on-a-socket">NDK_accept  Accept a Connection on a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">SOCKET NDK_accept(SOCKET          s,
                  <span class="kw">struct</span> sockaddr *pName,
                  <span class="dt">int</span>             *plen);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pName: Name (address) of connected peer</li>
<li>plen: Pointer to size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a non-negative integer that is a descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ECONNABORTED: Listening socket has been shut down for read operations.</li>
<li>EMFILE: The file descriptor table is full.</li>
<li>ENOMEM: Memory allocation error.</li>
<li>ENOTSOCK: The descriptor does not reference a socket.</li>
<li>EINVAL: <em>NDK_listen()</em> has not been called on the socket or name arguments are invalid.</li>
<li>EWOULDBLOCK: Socket is marked non-blocking and no connections are ready</li>
</ul>
<p><strong>Description</strong> The argument <em>s</em> is a socket that has been created with the <em>NDK_socket()</em> function, bound to an address with <em>NDK_bind()</em>, and is listening for connections after <em>NDK_listen()</em>. The <em>NDK_accept()</em> function extracts the first connection request on the queue of pending connections, creates a new socket with the same properties of socket <em>s</em> and allocates a new file descriptor for the socket. If no pending connections are present on the queue, and the socket is not marked as non-blocking, <em>NDK_accept()</em> blocks the caller until a connection is present. If the socket is marked non-blocking and no pending connections are present on the queue, <em>NDK_accept()</em> returns an error as described above.</p>
<p>The accepted socket may not be used to accept more connections. The original socket <em>s</em> remains open.</p>
<p>The argument <em>pName</em> is a result parameter that is filled in with the address of the connecting entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>plen</em> is a value-result parameter; it should initially contain at least sizeof(struct sockaddr), the amount of space pointed to by <em>pName</em>; on return it will contain the actual length (in bytes) of the address returned.</p>
<p>This call is used with connection-based socket types, currently with SOCK_STREAM.</p>
<p>It is possible to select (<em>fdSelect()</em>) a socket for the purposes of doing an accept by selecting it for read.</p>
<h4 id="ndk_bind-bind-a-name-address-to-a-socket">NDK_bind  Bind a Name (Address) to a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_bind(SOCKET          s,
             <span class="kw">struct</span> sockaddr *pName,
             <span class="dt">int</span>             len);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pName: Name (address) of desired local address</li>
<li>len: Size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The descriptor does not reference a socket.</li>
<li>EINVAL: Name arguments are invalid.</li>
<li>EADDRNOTAVAIL: The specified address is not available from the local machine.</li>
<li>EADDRINUSE: The specified address is already in use.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_bind()</em> function assigns a name to an unnamed socket. When a socket is created with <em>NDK_socket()</em> it exists in a name space (address family) but has no name assigned. The <em>NDK_bind()</em> function requests that name be assigned to the socket.</p>
<p>The argument <em>s</em> is a socket that has been created with the <em>NDK_socket()</em> function. The argument <em>pName</em> is a structure of type sockaddr that contains the desired local address. The <em>len</em> parameter contains the size of <em>pName,</em> which is sizeof(struct sockaddr).</p>
<p><a name="ndk_connect"></a></p>
<h4 id="ndk_connect-initiate-a-connection-on-a-socket">NDK_connect  Initiate a Connection on a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_connect(SOCKET          s,
                <span class="kw">struct</span> sockaddr *pName,
                <span class="dt">int</span>             len);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pName: Name (address) of desired peer</li>
<li>len: Size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EADDRINUSE: The specified address is already in use.</li>
<li>EADDRNOTAVAIL: The specified address is not available from the local machine.</li>
<li>EALREADY: A connection request is already pending on this socket.</li>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ECONNREFUSED: The attempt to connect was forcefully rejected.</li>
<li>EHOSTUNREACH: The host is not reachable.</li>
<li>EINPROGRESS: The request was accepted and is pending (non-blocking sockets).</li>
<li>EINVAL: Name arguments are invalid.</li>
<li>EISCONN: The socket is already connected.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTSUPP: Socket is in the listening state and cannot be connected.</li>
<li>ETIMEDOUT: Connection establishment timed out without establishing a connection.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_connect()</em> function establishes a logical (and potentially physical) connection from the socket specified by <em>s</em> to the foreign name (address) specified by <em>pName</em>.</p>
<p>If sock is of type SOCK_DGRAM, this call specifies the peer address with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, the function attempts to make a connection to another socket.</p>
<p>The argument <em>s</em> is a socket that has been created with the <em>NDK_socket()</em> function. The argument <em>pName</em> is a structure of type sockaddr that contains the desired foreign address. The <em>len</em> parameter contains the size of <em>pName</em>, which is sizeof(struct sockaddr).</p>
<p>Stream sockets may connect only once; while datagram sockets may re-connect multiple times to change their association. The connection may be dissolved by attempting to connect to an illegal address (for example, NULL IP address and Port). Datagram sockets that require multiple connections may consider using the <em>NDK_recvfrom()</em> and <em>NDK_sendto()</em> functions instead of <em>NDK_connect()</em>.</p>
<p>It is possible to select (<em>fdSelect()</em>) a socket for the purposes of doing an <em>NDK_connect()</em> by selecting it for writing.</p>
<h4 id="ndk_getpeername-get-name-address-of-connected-peer">NDK_getpeername  Get Name (Address) of Connected Peer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_getpeername(SOCKET          s,
                    <span class="kw">struct</span> sockaddr *pName,
                    <span class="dt">int</span>             *plen);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pName: Name (address) of connected peer</li>
<li>plen: Pointer to size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: Name arguments are invalid.</li>
<li>ENOTCONN: The socket is not connected.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_getpeername()</em> function returns the name (address) of the connected peer.</p>
<p>The argument <em>pName</em> is a result parameter that is filled in with the address of the connecting entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>plen</em> is a value-result parameter; it should initially contain at least sizeof(struct sockaddr), the amount of space pointed to by <em>pName</em>; on return it will contain the actual length (in bytes) of the address returned.</p>
<h4 id="ndk_getsockname-get-the-local-name-address-of-the-socket">NDK_getsockname  Get the Local Name (Address) of the Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_getsockname(SOCKET          s,
                    <span class="kw">struct</span> sockaddr *pName,
                    <span class="dt">int</span>             *plen);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pName: Name (address) of connected peer</li>
<li>plen: Pointer to size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: Name arguments are invalid.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_getsockname()</em> function returns the local name (address) of the socket.</p>
<p>The argument <em>pName</em> is a result parameter that is filled in with the address of the connecting entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>plen</em> is a value-result parameter; it should initially contain at least sizeof(struct sockaddr), the amount of space pointed to by <em>pName</em>; on return it will contain the actual length (in bytes) of the address returned.</p>
<p><a name="ndk_getsockopt"></a></p>
<h4 id="ndk_getsockopt-get-the-value-of-a-socket-option-parameter">NDK_getsockopt  Get the Value of a Socket Option Parameter</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_getsockopt(SOCKET s,
                   <span class="dt">int</span>   level,
                   <span class="dt">int</span>   op,
                   <span class="dt">void</span>  *pbuf,
                   <span class="dt">int</span>   *pbufsize);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>level: Option level (SOL_SOCKET, IPPROTO_IP, IPPROTO_TCP)</li>
<li>op: Socket option to get</li>
<li>pbuf: Pointer to memory buffer</li>
<li>pbufsize: Pointer to size of memory buffer</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: Buffer arguments are invalid.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_getsockopt()</em> function returns the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.</p>
<p>When manipulating socket options, the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level, the protocol number of the appropriate protocol controlling the option is supplied. In this implementation, only SOL_SOCKET, IPPROTO_IP, and IPPROTO_TCP are supported.</p>
<p>The parameters <em>pbuf</em> and <em>pbufsize</em> identify a buffer in which the value for the requested option(s) are to be returned. <em>pbufsize</em> is a value-result parameter, initially containing the size of the buffer pointed to by <em>pbuf</em>, and modified on return to indicate the actual size of the value returned.</p>
<p>Most socket-level options utilize an int parameter for <em>pbuf</em>. SO_LINGER uses a struct linger parameter, which specifies the desired state of the option and the linger interval (see below). SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval parameter.</p>
<p>The following options are recognized at the socket level:</p>
<ul>
<li>SO_REUSEADDR: Specifies that the rules used in validating addresses supplied in an <em>NDK_bind()</em> call should allow reuse of local addresses.</li>
<li>SO_REUSEPORT: Allows completely duplicate bindings by multiple processes if they all set SO_REUSEPORT before binding the port. This option permits multiple instances of a program to each receive UDP/IP multicast or broadcast datagrams destined for the bound port.</li>
<li>SO_KEEPALIVE: Enables the periodic transmission of messages on a connected socket. Should the connected party fail to respond to these messages, the connection is considered broken and processes using the socket are notified when attempting to send data.</li>
<li>SO_DONTROUTE: Indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</li>
<li>SO_LINGER: Controls the action taken when unsent messages are queued on socket and a close is performed. If the socket promises reliable delivery of data and SO_LINGER is set, the system will block the process on the close attempt until it is able to transmit the data or until it decides it is unable to deliver the information (a timeout period, termed the linger interval, is specified in seconds in the <em>NDK_setsockopt()</em> call when SO_LINGER is requested). If SO_LINGER is disabled and a close is issued, the system will process the close in a manner that allows the process to continue as quickly as possible. SO_LINGER requires a struct linger parameter, which specifies the desired state of the option and the linger interval. The following example passes a linger struct to getsockopt() and setsockopt().</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> linger lingerConfig;

socklen_t optlen = <span class="kw">sizeof</span>(<span class="kw">struct</span> linger);
memset(&amp;lingerConfig, <span class="dv">0</span>, optlen);

getsockopt(lSocket, SOL_SOCKET, SO_LINGER , &amp;lingerConfig, &amp;optlen);

optlen = <span class="kw">sizeof</span>(<span class="kw">struct</span> linger);
memset(&amp;lingerConfig, <span class="dv">0</span>, optlen);
lingerConfig.l_onoff = <span class="dv">1</span>;
lingerConfig.l_linger = <span class="dv">100</span>;

setsockopt(lSocket, SOL_SOCKET, SO_LINGER , &amp;lingerConfig, optlen);</code></pre></div>
<ul>
<li>SO_BROADCAST: Requests permission to send broadcast datagrams on the socket. Broadcast was a privileged operation in earlier versions of the system.</li>
<li>SO_OOBINLINE: With protocols that support out-of-band data, this option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with NDK_recv or read calls without the MSG_OOB flag. Some protocols always behave as if this option is set.</li>
<li>SO_SNDBUF: Buffer size for output.</li>
<li>SO_RCVBUF: Buffer size for input.</li>
<li>SO_SNDLOWAT: Is an option to set the minimum count for output operations. Most output operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary for flow control. Non-blocking output operations will process as much data as permitted subject to flow control without blocking, but will process no data if flow control does not allow the smaller of the low water mark value or the entire request to be processed. A select operation testing the ability to write to a socket will return true only if the low water mark amount could be processed. The default value for SO_SNDLOWAT is set to a convenient size for network efficiency, often 1024.</li>
<li>SO_RCVLOWAT: Is an option to set the minimum count for input operations. In general, receive calls will block until any (non-zero) amount of data is received, then return with the smaller of the amount specified by SO_RCVLOWAT or the amount requested. The default value for SO_RCVLOWAT is 1. Receive calls may still return less than the amount specified by SO_RCVLOWAT or the amount requested if an error occurs, or the type of data next in the receive queue is different from that which was returned.</li>
<li>SO_SNDTIMEO: Is an option to set a timeout value for output operations. It accepts a struct timeval parameter with the number of seconds and microseconds used to limit waits for output operations to complete. If a send operation has blocked for this much time, it returns with a partial count or with the error EWOULDBLOCK if no data were sent. This timer is restarted each time additional data are delivered to the protocol, implying that the limit applies to output portions ranging in size from the low water mark to the high water mark for output.</li>
<li>SO_RCVTIMEO: Is an option to set a timeout value for input operations. It accepts a struct timeval parameter with the number of seconds and microseconds used to limit waits for input operations to complete. This timer is restarted each time additional data are received by the protocol, and thus, the limit is in effect an inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error EWOULDBLOCK if no data were received.</li>
<li>SO_TYPE: SO_TYPE returns the type of the socket, such as SOCK_STREAM.</li>
<li>SO_ERROR: Returns any pending error on the socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</li>
<li>SO_PRIORITY: Is an option to set the VLAN user priority bit mapping for a given socket. It accepts only unsigned integer values. The valid values that can be configured for this option are 0-7. When a value of 0xFFFF is set to this option, it resets the priority back to its default value.</li>
</ul>
<p>Options that are not Berkeley standard:</p>
<ul>
<li>SO_IFDEVICE: Specifies an uint32_t index (1 to <em>n</em>) of the designated interface for sending and receiving IP broadcast packets. When set, this interface is selected on an IP broadcast send operation if the sockets local (bound) IP address is NULL (INADDR_ANY). Also, when set, the socket will only accept incoming broadcast packets if they have been received on this interface.</li>
<li>SO_BLOCKING: Specifies an int flag (1 or 0) indicating if the socket is in blocking or non-blocking mode. Sockets default to blocking mode when created, but can be set to non-blocking by using <em>NDK_setsockopt()</em>. This option provides the same functionality as calling the Unix function <em>Fcntl()</em> with the O_NONBLOCK flag.</li>
<li>SO_TXTIMESTAMP: Specifies a call-out function to allow timestamping of transmitted UDP datagrams per socket basis. The NDK calls this function before adding the datagram into the drivers transmit queue. The function prototype of the call-out is typedef void (*TimestampFxn)(unsigned char *pIpHdr). This call-out function is responsible for updating the UDP checksum accordingly.</li>
</ul>
<p>The following options are recognized at the IPPROTO_IP level:</p>
<ul>
<li>IP_OPTIONS: Specifies the IP options to be included in any outgoing IP packet sent via this socket (maximum length is 20 bytes).</li>
<li>IP_HDRINCL: Indicates to IP that the socket application is supplying the IP header as well as the rest of the packet payload. This is for use with RAW sockets only.</li>
<li>IP_TOS: Specifies the TOS value to place in the IP header.</li>
<li>IP_TTL: Specifies the TTL value to place in the IP header.</li>
<li>IP_ADD_MEMBERSHIP: Specifies the multicast group to join. It accepts a struct ip_mreq parameter (as defined in RFC 3678) which specifies multicast group address that the application wants to join and the interface IP address to use for joining the multicast group.</li>
<li>IP_DROP_MEMBERSHIP: Is an option used to leave a multicast group for a specified interface. It accepts a struct ip_mreq parameter (as defined in RFC 3678) which specifies the IP address of the multicast group to leave and the interface IP address on our device to use to leave the group.</li>
</ul>
<p>The following options are recognized at the IPPROTO_TCP level:</p>
<ul>
<li>TCP_NODELAY: Disables TCP send delay/coalesce algorithm.</li>
</ul>
<p>Options that are not Berkeley standard:</p>
<ul>
<li>TCP_MAXSEG: Set the maximum TCP segment size.</li>
<li>TCP_NOPUSH: Do not send data just to finish a data block (attempt to coalesce).</li>
<li>TCP_NOOPT: Do not use TCP options.</li>
<li>TCP_SACKPERMITTED: Permit RFC-2018 Selective Acknowledgment(SACK) conformant connection. The SACK permitted option is exchanged at socket connection time. Hence, on the server side, the setting must be done before calling <em>NDK_listen()</em>, and on the client side before calling <em>NDK_connect()</em>. Note that for a server socket, if SACK is enabled in between the calls to <em>NDK_listen()</em> and <em>NDK_accept()</em>, it is possible for a new connection to be established (within the stack thread) after the socket is made to be listening but before SACK is enabled, potentially allowing a connection to be made that does not have SACK enbabled. To prevent this, SACK must be enabled prior to calling <em>NDK_listen()</em>. The retransmission characteristics of SACK can be modified by editing the following lines in <code>ti/ndk/stack/tcp/tcp.h</code> and rebuilding the NDK.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * The settings of TCP_SACK_REXMIT_TIMER_RATIO, TCP_SACK_REXMIT_SEGMENT,</span>
<span class="co"> * and TCP_SACK_TICKS_REXMT definitions allows tuning of retransmission</span>
<span class="co"> * characteristics of SACK.</span>
<span class="co"> */</span>
<span class="pp">#define TCP_SACK_REXMIT_TIMER_RATIO   4  </span><span class="co">/* SACK Retransmission Timer Ratio */</span>
                                         <span class="co">/* t_trtx / TCP_SACK_REXMIT_TIMER_RATIO */</span>
<span class="pp">#define TCP_SACK_REXMIT_SEGMENT       1  </span><span class="co">/* SACK Retransmission Congestion  */</span>
                                         <span class="co">/* Window Segment Count (in MSS unit) */</span>
<span class="pp">#define TCP_SACK_TICKS_REXMIT         2  </span><span class="co">/* If a SACK option is received,  */</span>
                                         <span class="co">/* the current traditional retransmit */</span>
                                         <span class="co">/* timeout tick value is incremented */</span>
                                         <span class="co">/* by TCP_SACK_TICKS_REXMIT. */</span></code></pre></div>
<ul>
<li>TCP_MAXRTT: The maximum TCP Round Trip Time value allowed in the determination of the estimated TCP RTT. TCP packets containing RTT values greater than the value specified will not be used in the TCP RTT calculation (however, the packets are still processed by the stack). Units are in milliseconds. Values are rounded up to the next internal clock tick (100 millisecond). The minimum value is 100 milliseconds. The default value is 1 hour.</li>
</ul>
<h4 id="ndk_listen-listen-for-connection-requests-on-socket">NDK_listen  Listen for Connection Requests on Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_listen(SOCKET s,
               <span class="dt">int</span>    maxcon);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>maxcon: Maximum number of connects to queue</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EOPNOTSUPP: The socket is not of a type that supports the operation listen.</li>
<li>EISCONN: The socket is already connected</li>
</ul>
<p><strong>Description</strong> The <em>NDK_listen()</em> function listens for connection requests on a socket.</p>
<p>To accept connections, a socket is first created with <em>NDK_socket()</em>. The <em>NDK_listen()</em> function is called to specify a willingness to accept incoming connections and a queue limit for incoming connections. New connections are accepted by calling the <em>NDK_accept()</em> function. The <em>NDK_listen()</em> function applies only to sockets of type SOCK_STREAM.</p>
<p>The <em>maxcon</em> parameter defines the maximum length to which the queue of pending connections may grow. If a connection request arrives with the queue full, the client receives an error with an indication of ECONNREFUSED.</p>
<h4 id="ndk_recv-receive-data-from-a-socket">NDK_recv  Receive Data from a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_recv(SOCKET s,
             <span class="dt">void</span>   *pbuf,
             <span class="dt">int</span>    size,
             <span class="dt">int</span>    flags);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Data buffer to place received data</li>
<li>size: Size of desired data</li>
<li>flags: Option flags</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes received. Returns 0 on connection oriented sockets where the connection has been closed by the peer (or socket shutdown for read). Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EINVAL: Attempt to read (or calling arguments) invalid for this socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_recv()</em> function attempts to receive data from a socket. It is normally used on a connected socket (see <em><a href="#ndk_connect">NDK_connect()</a></em> ). The data is placed into the buffer specified by <em>pbuf</em>, up to a maximum length specified by size. The options in flags can be used to change the default behavior of the operation.</p>
<p>The function returns the length of the message on successful completion.</p>
<p>For a datagram type socket, the receive operation always copies one packets worth of data. If the buffer is too short to hold the entire packet, the data is truncated and lost.</p>
<p>If no messages are available at the socket, it waits for a message to arrive, unless the socket is non-blocking. The function normally returns any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the options specified in flags as well as the socket-level options SO_RCVLOWAT and SO_RCVTIMEO described in <em><a href="#ndk_getsockopt">NDK_getsockopt()</a></em> .</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when more data arrives.</p>
<p>The <em>flags</em> argument to an <em>NDK_recv()</em> call is formed by combining one or more of the following flags:</p>
<ul>
<li>MSG_DONTWAIT: Requests that the operation not block when no data is available.</li>
<li>MSG_OOB: Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</li>
<li>MSG_PEEK: Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</li>
<li>MSG_WAITALL: Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</li>
</ul>
<h4 id="ndk_recvfrom-receive-data-from-a-socket-with-the-senders-name-address">NDK_recvfrom  Receive Data from a Socket with the Senders Name (Address)</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_recvfrom(SOCKET s,
                 <span class="dt">void</span>            *pbuf,
                 <span class="dt">int</span>             size,
                 <span class="dt">int</span>             flags,
                 <span class="kw">struct</span> sockaddr *pName,
                 <span class="dt">int</span>             *plen);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Data buffer to place received data</li>
<li>size: Size of desired data</li>
<li>flags: Option flags</li>
<li>pName: Pointer to place name (address) of sender</li>
<li>plen: Pointer to size of pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes received. Returns 0 on connection oriented sockets where the connection has been closed by the peer (or socket shutdown for read). Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EINVAL: Attempt to read (or calling arguments) invalid for this socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_recvfrom()</em> function attempts to receive data from a socket. It is normally called with unconnected, non-connection oriented sockets. The data is placed into the buffer specified by <em>pbuf</em>, up to a maximum length specified by size. The options in flags can be used to change the default behavior of the operation. The name (address) of the sender is written to <em>pName</em>.</p>
<p>The argument <em>pName</em> is a result parameter that is filled in with the address of the sending entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>plen</em> is a value-result parameter; it should initially contain at least sizeof(struct sockaddr), the amount of space pointed to by pName; on return it will contain the actual length (in bytes) of the address returned.</p>
<p>The function returns the length of the message on successful completion.</p>
<p>For a datagram type socket, the receive operation always copies one packets worth of data. If the buffer is too short to hold the entire packet, the data is truncated and lost.</p>
<p>If no messages are available at the socket, it waits for a message to arrive, unless the socket is non-blocking. The function normally returns any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the options specified in flags as well as the socket-level options SO_RCVLOWAT and SO_RCVTIMEO described in <em><a href="#ndk_getsockopt">NDK_getsockopt()</a></em> .</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when more data arrives.</p>
<p>The flags argument to an <em>NDK_recv()</em> call is formed by combining one or more of the following flags:</p>
<ul>
<li>MSG_DONTWAIT: Requests that the operation not block when no data is available.</li>
<li>MSG_OOB: Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</li>
<li>MSG_PEEK: Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</li>
<li>MSG_WAITALL: Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</li>
</ul>
<h4 id="ndk_recvnc-receive-data-from-a-socket-without-buffer-copy">NDK_recvnc  Receive Data from a Socket without Buffer Copy</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_recvnc(SOCKET s,
               <span class="dt">void</span>   **ppbuf,
               <span class="dt">int</span>    flags,
               <span class="dt">void</span>   **phBuffer);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>ppbuf: Pointer to receive data buffer pointer</li>
<li>flags: Option flags</li>
<li>phBuffer: Pointer to receive buffer handle</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes received. Returns 0 on connection oriented sockets where the connection has been closed by the peer (or socket shutdown for read). Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EINVAL: Attempt to read (or calling arguments) invalid for this socket.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_recvnc()</em> function attempts to receive a data buffer from a socket. It is normally used on a connected socket (see <em><a href="#ndk_connect">NDK_connect()</a></em> ). A pointer to the data buffer is returned in <em>ppbuf</em>. A system handle used to free the buffer is returned in <em>phBuffer</em>. Both of these pointers must be valid. The options in flags can be used to change the default behavior of the operation.</p>
<p>The function returns the length of the message on successful completion.</p>
<p>The receive operation always returns one packet buffer. The caller has no control over the size of the data returned in this buffer.</p>
<p>If no messages are available at the socket, this call waits for a message to arrive, unless the socket is non-blocking. The function returns the data buffer available.</p>
<p>When the caller no longer needs the data buffer, it is returned to the system by calling <em>NDK_recvncfree()</em>. Repeated failure to free buffers will eventually cause the stack to stop receiving data.</p>
<p>This function cannot be used with sockets of type SOCK_STREAM. When used with sockets of type SOCK_STREAMNC, out of band data marks are cleared.</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when more data arrives.</p>
<p>The flags argument to an <em>NDK_recv()</em> call can be one of the following flags:</p>
<ul>
<li>MSG_DONTWAIT: Requests that the operation not block when no data is available.</li>
<li>MSG_WAITALL: Requests that the operation block until data is available. Because blocking is the default behavior of a standard socket, this flag only alters the behavior of a non-blocking socket for this call.</li>
</ul>
<h4 id="ndk_recvncfree-return-a-data-buffer-obtained-from-a-no-copy-receive-operation">NDK_recvncfree  Return a Data Buffer Obtained from a No-Copy Receive Operation</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NDK_recvncfree(<span class="dt">void</span> *hBuffer);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hBuffer: Handle to receive buffer to free</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> The <em>NDK_recvncfree()</em> function frees a data buffer obtained from calling either <em>NDK_recvnc()</em> or <em>NDK_recvncfrom()</em>. The calling parameter <em>hBuffer</em> is the handle of the buffer to free (not the pointer to the buffer).</p>
<h4 id="ndk_recvncfrom-receive-data-and-the-senders-name-from-a-socket-without-buffer-copy">NDK_recvncfrom  Receive Data and the Senders Name From a Socket Without Buffer Copy</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_recvncfrom(SOCKET s,
                   <span class="dt">void</span>            **ppbuf,
                   <span class="dt">int</span>             flags,
                   <span class="kw">struct</span> sockaddr *pName,
                   <span class="dt">int</span>             *plen,
                   <span class="dt">void</span>            **phBuffer);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>ppbuf: Pointer to receive data buffer pointer</li>
<li>flags: Option flags</li>
<li>pName: Pointer to place name (address) of sender</li>
<li>plen: Pointer to size of pName</li>
<li>phBuffer: Pointer to receive buffer handle</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes received. Returns 0 on connection oriented sockets where the connection has been closed by the peer (or socket shutdown for read). Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EINVAL: Attempt to read (or calling arguments) invalid for this socket.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_recvncfrom()</em> function attempts to receive a data buffer from a socket. It is normally called with unconnected, non-connection oriented sockets. A pointer to the data buffer is returned in <em>ppbuf</em>. A system handle used to free the buffer is returned in <em>phBuffer</em>. Both of these pointers must be valid. The options in flags can be used to change the default behavior of the operation. The name (address) of the sender is written to <em>pName</em>.</p>
<p>The argument <em>pName</em> is a result parameter that is filled in with the address of the sending entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>plen</em> is a value-result parameter; it should initially contain at least sizeof(struct sockaddr), the amount of space pointed to by <em>pName</em>; on return it will contain the actual length (in bytes) of the address returned.</p>
<p>The function returns the length of the message on successful completion.</p>
<p>The receive operation always returns one packet buffer. The caller has no control over the size of the data returned in this buffer.</p>
<p>If no messages are available at the socket, this call waits for a message to arrive, unless the socket is non-blocking. The function returns the data buffer available.</p>
<p>When the caller no longer needs the data buffer, it is returned to the system by calling <em>NDK_recvncfree()</em>. Repeated failure to free buffers will eventually cause the stack to stop receiving data.</p>
<p>This function cannot be used with sockets of type SOCK_STREAM. When used with sockets of type SOCK_STREAMNC, out of band data marks are cleared.</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when more data arrives.</p>
<p>The <em>flags</em> argument to an <em>NDK_recv()</em> call can be one of the following flags:</p>
<ul>
<li>MSG_DONTWAIT: Requests that the operation not block when no data is available.</li>
<li>MSG_WAITALL: Requests that the operation block until data is available. Because blocking is the default behavior of a standard socket, this flag only alters the behavior of a non-blocking socket for this call.</li>
</ul>
<h4 id="ndk_send-transmit-data-to-a-socket">NDK_send  Transmit Data to a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_send(SOCKET s,
             <span class="dt">void</span>   *pbuf,
             <span class="dt">int</span>    size,
             <span class="dt">int</span>    flags);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Data buffer holding data to transmit</li>
<li>size: Size of data</li>
<li>flags: Option flags</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes sent. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EHOSTUNREACH: The remote host was unreachable.</li>
<li>EMSGSIZE: The specified size exceeds the limit of the underlying protocol.</li>
<li>ENOBUFS: Memory allocation failure while attempting to send data.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected.</li>
<li>ESHUTDOWN: The socket has been shut down for writes.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_send()</em> function attempts to send data on a socket. It is used on connected sockets only (see <em><a href="#ndk_connect">NDK_connect()</a></em> ). The data to send is contained in the buffer specified by <em>pbuf</em>, with a length specified by size. The options in flags can be used to change the default behavior of the operation.</p>
<p>The function returns the length of the data transmitted on successful completion.</p>
<p>If a thread does not contain calls to <em>fdOpenSession()</em> and <em>fdCloseSession()</em>, the <em>NDK_send()</em> function returns a value of -1.</p>
<p>For a datagram type socket, the send operation always copies one packets worth of data. If the buffer size is too large to be transmitted in a single packet, an error code of EMSGSIZE is returned.</p>
<p>If there is not transmit buffer space available on a stream type socket, the function waits for space to become available, unless the socket is non-blocking. The function normally transmits all the specified data.</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when the socket is able to write.</p>
<p>The flags argument to an <em>NDK_send()</em> call is formed by combining one or more of the following flags:</p>
<ul>
<li>MSG_OOB: sends out-of-band data on sockets that support this notion (e.g.SOCK_STREAM); the underlying protocol must also support out-of-band data.</li>
<li>MSG_EOR: indicates a record mark for protocols that support the concept.</li>
<li>MSG_EOF: Requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for SOCK_STREAM sockets in the AF_INET protocol family, and implements Transaction TCP.</li>
<li>MSG_DONTROUTE: Specifies that the packet should not be routed, but sent only using the Address Resolution Protocol (ARP) table entries.</li>
</ul>
<h4 id="ndk_sendto-transmit-data-on-a-socket-to-designated-destination">NDK_sendto  Transmit Data on a Socket to Designated Destination</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_sendto(SOCKET          s,
               <span class="dt">void</span>            *pbuf,
               <span class="dt">int</span>             size,
               <span class="dt">int</span>             flags,
               <span class="kw">struct</span> sockaddr *pName,
               <span class="dt">int</span>             len);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Data buffer holding data to transmit</li>
<li>size: Size of data</li>
<li>flags: Option flags</li>
<li>pName: Pointer to name (address) of destination</li>
<li>len: Size of data pointed to by pName</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes sent. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>EHOSTUNREACH: The remote host was unreachable.</li>
<li>EMSGSIZE: The specified size exceeds the limit of the underlying protocol.</li>
<li>ENOBUFS: Memory allocation failure while attempting to send data.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTCONN: The socket is connection oriented and not connected.</li>
<li>ESHUTDOWN: The socket has been shut down for writes.</li>
<li>ETIMEDOUT: The socket connection was dropped due to protocol layer timeout.</li>
<li>EWOULDBLOCK: The socket is specified as non-blocking, or the timeout has expired.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_sendto()</em> function attempts to send data on a socket to a specified destination. It is used on unconnected, non-connection oriented sockets only (see <em><a href="#ndk_connect">NDK_connect()</a></em> ). The data to send is contained in the buffer specified by pbuf, with a length specified by size. The options in flags can be used to change the default behavior of the operation.</p>
<p>The argument <em>pName</em> is a pointer to the address of the destination entity as known to the communications layer. The domain in which the communication is occurring determines the exact format of the <em>pName</em> parameter. The <em>len</em> parameter should contain the size of name, which is sizeof(struct sockaddr).</p>
<p>The function returns the length of the data transmitted on successful completion.</p>
<p>For a datagram type socket, the send operation always copies one packets worth of data. If the buffer size is too large to be transmitted in a single packet, an error code of EMSGSIZE is returned.</p>
<p>The select call (<em>fdSelect()</em>) may be used to determine when the socket is able to write.</p>
<p>The flags argument to an <em>NDK_sendto()</em> call is formed by combining one or more of the following flags:</p>
<ul>
<li>MSG_OOB: sends out-of-band data on sockets that support this notion (e.g., SOCK_STREAM); the underlying protocol must also support out-of-band data.</li>
<li>MSG_EOR: indicates a record mark for protocols that support the concept.</li>
<li>MSG_EOF: Requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for SOCK_STREAM sockets in the AF_INET protocol family, and implements Transaction TCP.</li>
<li>MSG_DONTROUTE: Specifies that the packet should not be routed, but sent only using the ARP table entries.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> The native operation of the socket <em>NDK_sendto</em> operation is to connect, sendto, and disconnect. Sockets that are not bound to a local IP or local port would have an ephemeral port selected every time in order to override this behavior and to ensure that the ephemeral port is not selected every time it is recommended that customers do an <em>NDK_bind()</em> to port 0. This selects the first free port not in use and all subsequent communication uses the same port.</p>
</blockquote>
<p><a name="ndk_setsockopt"></a></p>
<h4 id="ndk_setsockopt-set-the-value-of-a-socket-option-parameter">NDK_setsockopt  Set the Value of a Socket Option Parameter</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_setsockopt(SOCKET s,
                   <span class="dt">int</span>    level,
                   <span class="dt">int</span>    op,
                   <span class="dt">void</span>   *pbuf,
                   <span class="dt">int</span>    bufsize);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>level: Option level (SOL_SOCKET, IPPROTO_IP, IPPROTO_TCP)</li>
<li>op: Socket option to set</li>
<li>pbuf: Pointer to memory buffer</li>
<li>bufsize: Size of memory buffer pointed to by pbuf</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: bufsize argument is invalid.</li>
<li>EDOM: pbuf argument is invalid for the selected option.</li>
<li>ENOMEM: The selected option could not allocate the memory needed.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_setsockopt()</em> function sets option values associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.</p>
<p>When manipulating socket options, the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level, the protocol number of the appropriate protocol controlling the option is supplied. In this implementation, only SOL_SOCKET, IPPROTO_IP, and IPPROTO_TCP are supported.</p>
<p>The parameters <em>pbuf</em> and <em>bufsize</em> identify a buffer that holds the value for the specified option.</p>
<p>Most socket-level options utilize an int parameter for <em>pbuf</em>. SO_LINGER uses a struct linger parameter, which specifies the desired state of the option and the linger interval; see the example provided for <em>NDK_getsockopt()</em>. SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval parameter. The IP-level options IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP accept a struct ip_mreq parameter.</p>
<p>The socket options supported for <em>NDK_setsockopt()</em> are the same as defined for <em>NDK_getsockopt()</em>, with the exception of SO_TYPE and SO_ERROR, which cannot be set.</p>
<p>Please see the description of <em><a href="#ndk_getsockopt">NDK_getsockopt()</a></em> for a list of socket options.</p>
<blockquote>
<p><strong>NOTE:</strong> The SO_SNDBUF and SO_RCVBUF options can only be set if there is no transmit or receive data pending at the socket. In general, the buffer sizes should only be configured before the socket is bound or connected. Buffer sizes set on listen sockets will propagate to spawned accept sockets.</p>
</blockquote>
<h4 id="ndk_shutdown-close-one-half-of-a-connected-socket">NDK_shutdown  Close One Half of a Connected Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_shutdown(SOCKET s,
                 <span class="dt">int</span>    how);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>how: Manner of shut down</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>ENOTCONN: The specified socket is not connected.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_shutdown()</em> function causes all or part of a full-duplex connection on the socket associated with a socket to be shut down. If <em>how</em> is SHUT_RD (0), further receives will be disallowed. If <em>how</em> is SHUT_WR (1), further sends will be disallowed. If <em>how</em> is SHUT_RDWR (2), further sends and receives will be disallowed.</p>
<p><a name="ndk_socket"></a></p>
<h4 id="ndk_socket-create-a-socket">NDK_socket  Create a Socket</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">SOCKET NDK_socket(<span class="dt">int</span> domain,
                  <span class="dt">int</span> type,
                  <span class="dt">int</span> protocol);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>domain: Socket domain (AF_INET or AF_INET6)</li>
<li>type: Socket type (SOCK_DGRAM, SOCK_STREAM, SOCK_RAW)</li>
<li>protocol: Socket protocol (Normally IPPROTO_TCP or IPPROTO_UDP, but can be anything when type is set to SOCK_RAW)</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a file descriptor representing the socket. Otherwise, a value of INVALID_SOCKET is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EPFNOSUPPORT: The specified domain was not AF_INET or AF_INET6.</li>
<li>EPROTOTYPE: The <em>type</em> parameter does not support the <em>protocol</em> parameter.</li>
<li>ESOCKTNOSUPPORT: The specified socket type is not supported.</li>
<li>ENOMEM: Memory allocation error allocating socket buffers.</li>
<li>EMFILE: The descriptor table is full.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_socket()</em> function creates a socket, an endpoint for communication and returns the socket in the form of a file descriptor.</p>
<p>The <em>domain</em> parameter specifies a communications domain within which communication will take place; this selects the protocol/address family that should be used. This will always be AF_INET or AF_INET6 in this implementation.</p>
<p>The socket type parameter specifies the semantics of communication. The defined types are:</p>
<ul>
<li>SOCK_STREAM: Provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism is supported.</li>
<li>SOCK_STREAMNC: Identical to SOCK_STREAM except that received data is not coalesced into a receive holding buffer. This eliminates one or two receive data copies (depending on which <em>NDK_recv()</em> socket function is used), but has the potential of tying up multiple data packets. It should only be used when the socket is to receive data in large bursts. Out-of-band data is supported, but only when the traditional <em>NDK_recv()</em> socket calls are used.</li>
<li>SOCK_DGRAM: Supports datagrams - connectionless, unreliable messages of a fixed (typically small) maximum length.</li>
<li>SOCK_RAW: Similar to SOCK_DGRAM, only allows the use of any protocol that must be manually constructed in each datagram by the programmer.</li>
</ul>
<p>The <em>protocol</em> parameter specifies a particular protocol to be used with the socket. In this implementation of the stack, SOCK_STREAM must use IPPROTO_TCP, SOCK_DGRAM must use IPPROTO_UDP, and SOCK_RAW is unrestricted. To remain compatible with the industry, this parameter can be set to NULL on SOCK_STREAM or SOCK_DGRAM.</p>
<p><a name="RawSockets"></a></p>
<h2 id="raw-ethernet-sockets-programming-interface">3.4 Raw Ethernet Sockets Programming Interface</h2>
<p>Raw Ethernet sockets are a special type of sockets that allow an application to send and receive entire Ethernet packets without any intermediate processing by the stack, like stripping off headers, checksum calculations, etc., that are typically done for IPv4, IPv6 sockets. These sockets are expected to be used by applications that have very definite performance requirements and need ultimate control over packet processing. The Raw Ethernet sockets have both <em>no-copy</em> send and receive APIs. This facilitates the applications performance requirements even further by reducing any overhead on the send or receive data paths due to memory allocation and copying. A corresponding <em>Raw Ethernet Module</em> has also been added to the core NDK stack that interfaces with the NIMU layer to send/receive data. For more details on the Raw Ethernet module, see <a href="#raw-ethernet-module">Section A.15</a> of this document.</p>
<h3 id="function-overview-5">3.4.1 Function Overview</h3>
<p>The following is a complete list of socket APIs implemented for the Raw Ethernet socket family (AF_RAWETH).</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NDK_socket()</td>
<td>Creates a raw Ethernet socket</td>
</tr>
<tr class="even">
<td>NDK_shutdown()</td>
<td>Close one half of the socket</td>
</tr>
<tr class="odd">
<td>NDK_getsockopt()</td>
<td>Gets the value of a socket option</td>
</tr>
<tr class="even">
<td>NDK_setsockopt()</td>
<td>Sets the value of a socket option</td>
</tr>
<tr class="odd">
<td>NDK_send()</td>
<td>Sends raw Ethernet data using a previously opened raw Ethernet socket</td>
</tr>
<tr class="even">
<td>NDK_getsendncbuff()</td>
<td>Allocate space for a raw Ethernet packet and retrieve handle for the data buffer. This is used in conjunction with <em>NDK_sendnc</em> API for no-copy send.</td>
</tr>
<tr class="odd">
<td>NDK_sendnc()</td>
<td>Send out raw Ethernet data without making a copy of it during the Tx path</td>
</tr>
<tr class="even">
<td>NDK_sendncfree()</td>
<td>Free buffer obtained from <em>NDK_getsendncbuff()</em> API</td>
</tr>
<tr class="odd">
<td>NDK_recvnc()</td>
<td>Return a data buffer obtained from a no-copy receive operation</td>
</tr>
<tr class="even">
<td>NDK_recvncfree()</td>
<td>Free buffer obtained from <em>NDK_recvnc()</em> API</td>
</tr>
</tbody>
</table>
<h3 id="raw-ethernet-sockets-api-functions">3.4.2 Raw Ethernet Sockets API Functions</h3>
<p>This section describes the socket APIs listed before in detail and in particular when used with AF_RAWETH family sockets.</p>
<h4 id="ndk_socket-create-a-raw-ethernet-socket.">NDK_socket  Create a raw Ethernet socket.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">SOCKET NDK_socket( <span class="dt">int</span> domain,
                   <span class="dt">int</span> type,
                   <span class="dt">int</span> protocol );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>domain: Socket domain (AF_RAWETH)</li>
<li>type: Socket type (SOCK_RAWETH)</li>
<li>protocol: Socket protocol (can be set to any custom value other than the well-known types: IP (0x800), IPv6 (0x86DD), VLAN (0x8100), PPPoE Control (0x8863), PPPoE Data (0x8864) is acceptable)</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a file descriptor representing the socket. Otherwise, a value of INVALID_SOCKET is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EPFNOSUPPORT: The specified domain was none of the supported families, i.e., AF_INET, AF_INET6, AF_RAWETH.</li>
<li>EINVAL: The protocol parameter supplied is not valid. IP (0x800), IPv6 (0x86DD), VLAN (0x8100), PPPoE Control (0x8863), PPPoE Data (0x8864) are not valid values for the protocol argument.</li>
<li>ESOCKTNOSUPPORT: The specified socket type is not supported for this protocol.</li>
<li>ENOMEM: Memory allocation error allocating socket buffers.</li>
<li>EMFILE: The descriptor table is full.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_socket()</em> function creates a socket, an endpoint for communication and returns the socket in the form of a file descriptor. The <em>domain</em> parameter specifies a communications domain within which communication will take place; this selects the protocol/address family that should be used. To create a raw Ethernet socket, the domain must be specified as AF_RAWETH. The socket type parameter specifies the semantics of communication. For raw Ethernet sockets, this parameter must be set to SOCK_RAWETH. The protocol parameter specifies the protocol to be used for the socket. This can be set to any custom protocol type for a raw Ethernet socket. Standard protocol types like IP (0x800), IPv6 (0x86DD), VLAN (0x8100), PPPoE Control (0x8863), PPPoE Data (0x8864) must not be used here for protocol parameter.</p>
<h4 id="ndk_shutdown-close-one-half-of-a-connected-socket.">NDK_shutdown  Close one half of a connected socket.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_shutdown( SOCKET s,
                  <span class="dt">int</span>    how );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>how: Manner of shut down</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_shutdown()</em> function causes all or part of a full-duplex connection on the socket associated with a socket to be shut down. If <em>how</em> is SHUT_RD (0), further receives will be disallowed. If <em>how</em> is SHUT_WR (1), further sends will be disallowed. If <em>how</em> is SHUT_RDWR (2), further sends and receives will be disallowed.</p>
<h4 id="ndk_getsockopt-get-the-value-of-a-socket-option.">NDK_getsockopt  Get the value of a socket option.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_getsockopt(SOCKET s,
                   <span class="dt">int</span>    level,
                   <span class="dt">int</span>    op,
                   <span class="dt">void</span>   *pbuf,
                   <span class="dt">int</span>    *pbufsize);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>level: Option level (SOL_SOCKET only for AF_RAWETH sockets)</li>
<li>op: Socket option to get</li>
<li>pbuf: Pointer to memory buffer</li>
<li>pbufsize: Pointer to size of memory buffer</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: Buffer arguments are invalid.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_getsockopt()</em> function returns the options associated with a socket. Options are always present at the uppermost socket level (SOL_SOCKET) for raw Ethernet sockets. When manipulating socket options, the level at which the option resides and the name of the option must be specified. The parameters <em>pbuf</em> and <em>pbufsize</em> identify a buffer in which the value for the requested option(s) are to be returned. <em>pbufsize</em> is a value-result parameter, initially containing the size of the buffer pointed to by <em>pbuf</em>, and modified on return to indicate the actual size of the value returned.</p>
<p>The following socket (SOL_SOCKET) level options are recognized for raw Ethernet sockets:</p>
<ul>
<li>SO_IFDEVICE: Specifies a uint32_t index (1 to <em>n</em>) of the designated interface for sending and receiving raw Ethernet packets.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> The SO_IFDEVICE option must be configured to successfully use a raw Ethernet socket for communication.</p>
</blockquote>
<ul>
<li>SO_PRIORITY: Specifies a unit value (0 to 7) configured as the priority to be marked on all flowing packets using this socket. This priority can be used by the Ethernet driver in turn to differentiate between packets and apply any desired QoS scheme. It can be also used by a driver/application to map the priority to certain transmission properties like the EMAC channel number on which the packets are to be transmitted. Only unsigned integer values between 0 to 7 are acceptable values for this field. When a value of 0xFFF is set to this option, it resets the priority back to its default value.</li>
<li>SO_RCVTIMEO: Is an option to set a timeout value for input operations. It accepts a struct timeval parameter with the number of seconds and microseconds used to limit waits for input operations to complete. This timer is restarted each time additional data are received by the protocol, and therefore, the limit is in effect an inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error EWOULDBLOCK if no data were received.</li>
<li>SO_SNDBUF: Buffer size for output</li>
<li>SO_RCVBUF: Buffer size for input</li>
<li>SO_RCVLOWAT: Is an option to set the minimum size of data in bytes for input operations. The default value for SO_RCVLOWAT is 1. Receive calls may still return less than the amount specified by SO_RCVLOWAT or the amount requested if an error occurs.</li>
<li>SO_ERROR: Returns any pending error on the socket and clears the error status. It may be used to check for any asynchronous errors.</li>
<li>SO_TYPE: Returns the type of the socket. Always returns SOCK_RAWETH for raw Ethernet sockets.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Options like SO_SNDWAT, SO_SNDTIMEO, etc., are not supported for raw Ethernet sockets, since there is no buffering on the send path and the operation is synchronous; i.e., once <em>NDK_send()</em>/<em>NDK_sendnc()</em> APIs are invoked for raw Ethernet sockets, these calls actually return only after enqueuing the data in the driver queue. Hence, no buffering or timeouts are required.</p>
</blockquote>
<h4 id="ndk_setsockopt-set-the-value-of-a-socket-option.">NDK_setsockopt  Set the value of a socket option.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_setsockopt( SOCKET s,
                    <span class="dt">int</span>    level,
                    <span class="dt">int</span>    op,
                    <span class="dt">void</span>   *pbuf,
                    <span class="dt">int</span>    bufsize);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>level: Option level (SOL_SOCKET only for AF_RAWETH sockets)</li>
<li>op: Socket option to set</li>
<li>pbuf: Pointer to memory buffer</li>
<li>bufsize: Size of memory buffer pointed to by pbuf</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid.</li>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: bufsize argument is invalid.</li>
<li>EDOM: pbuf argument is invalid for the selected option.</li>
<li>ENOMEM: The selected option could not allocate the memory needed.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_setsockopt()</em> function sets option values associated with a socket. Options are always present at the uppermost socket level (SOL_SOCKET) for raw Ethernet sockets. When manipulating socket options, the level at which the option resides and the name of the option must be specified. The parameters <em>pbuf</em> and <em>bufsize</em> identify a buffer that holds the value for the specified option. Most socket-level options utilize an int parameter for <em>pbuf.</em></p>
<p>The socket options supported for <em>NDK_setsockopt()</em> are the same as the ones specified in the <em>NDK_getsockopt()</em> API.</p>
<h4 id="ndk_send-transmit-raw-ethernet-data-using-a-socket.">NDK_send  Transmit raw Ethernet data using a socket.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_send( SOCKET s,
              <span class="dt">void</span>   *pbuf,
              <span class="dt">int</span>    size,
              <span class="dt">int</span>    flags );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Data buffer holding data to transmit</li>
<li>size: Size of data</li>
<li>flags: Option flags</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes sent. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>ENOTSOCK: The file descriptor does not reference a socket.</li>
<li>EINVAL: The input is invalid.</li>
<li>ENOBUFS: Memory allocation failure while attempting to send data.</li>
<li>ESHUTDOWN: The socket has been shut down for writes.</li>
<li>EMSGSIZE: The size of the data being sent exceeds the MTU of the interface or the Maximum Transmit buffer size configured using SO_SNDBUF option, whichever is the smaller value of the two.</li>
<li>ENXIO: No egress interface specified for this socket to send out data. Use SO_IFDEVICE socket option and specify an interface before retrying to send out data using this socket.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_send()</em> function attempts to send data on a socket. The data to send is contained in the buffer specified by pbuf, with a length specified by size. The options in flags can be used to change the default behavior of the operation. No flag options are defined for raw Ethernet sockets. The function returns the length of the data transmitted on successful completion.</p>
<p>The data buffer specified here is allocated and freed up by the application itself. The packet buffer is copied over to the packet allocated on the transmit path by the Raw Ethernet module and hence the application buffer (pbuf) freeing is the responsibility of the application when this API returns. Based on the socket handle specified to this call, the raw Ethernet module retrieves the socket priority and device on which this packet needs to be transmitted and does the needful to transmit the data. All packets transmitted using the specified socket would inherit their priority from the socket.</p>
<p>The format of the data buffer sent as input to this function is shown as follows:</p>
<p><img src="data:image/gif;base64,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" alt="Figure 3-1 Raw Ethernet Buffer Format" /></p>
<h4 id="ndk_getsendncbuff-retrieve-handle-to-buffer-application-can-fill-with-raw-ethernet-data-to-send.">NDK_getsendncbuff  Retrieve handle to buffer application can fill with raw Ethernet data to send.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_getsendncbuff( SOCKET   s,
                       <span class="dt">uint32_t</span> bufSize,
                       <span class="dt">void</span>     **phBuf,
                       <span class="dt">void</span>     **phPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>bufSize: Size of data buffer to allocate</li>
<li>phbuf: Pointer to send data buffer pointer</li>
<li>phPkt: Pointer to packet buffer handle</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns 0. Also, the phbuf and phPkt pointers are filled in with valid pointers to the data and packet buffers just allocated. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>ENOBUFS: Out of memory. Couldnt allocate memory required for the packet and data buffer.</li>
<li>EMSGSIZE: The size of the data buffer requested exceeds the MTU of the interface or the Maximum Transmit buffer size configured using SO_SNDBUF option, whichever is the smaller value of the two on the specified socket.</li>
</ul>
<p><strong>Description</strong> This API needs to be called by the raw Ethernet application to obtain a buffer handle to use to transmit data without copy using the <em>NDK_sendnc()</em> API. This function ensures that bufSize byte memory is allocated for the raw Ethernet data buffer. It also allocates memory for the packet to hold this data buffer. The application can fill the required data in the buffer just obtained and needs to send both the data buffer and the packet pointers to <em>NDK_sendnc()</em> API to finally send out the packet. This packet and the data buffer are freed by the Ethernet driver once the transmit completes successfully. However, if the application would like to free up the buffer obtained because of some error it encountered during send process, it would have to use the <em>NDK_sendncfree</em> API and specify the packet buffer handle as a parameter and both the data buffer and packet buffer will be freed up.</p>
<h4 id="ndk_sendnc-send-data-out-on-the-socket-without-any-copy-on-transmit-path.">NDK_sendnc  Send data out on the socket without any copy on transmit path.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_sendnc( SOCKET s,
                <span class="dt">void</span>   *pbuf,
                <span class="dt">int</span>    size,
                <span class="dt">void</span>   *hPkt,
                <span class="dt">int</span>    flags );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>pbuf: Pointer to send data buffer</li>
<li>hPkt: Packet buffer handle obtained from the <em>NDK_getsendncbuff()</em> API</li>
<li>flags: Option flags</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns number of bytes transmitted. Otherwise, a value of -1 is returned, and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EINVAL: The input is invalid</li>
<li>ESHUTDOWN: The socket has been shut down for writes</li>
<li>ENOTSOCK: The file descriptor does not reference a socket</li>
<li>ENXIO: No egress interface specified for this socket to send out data. Use SO_IFDEVICE socket option and specify an interface before retrying to send out data using this socket.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_sendnc()</em> API function attempts to send the data buffer and packet specified using the raw Ethernet socket handle provided. It doesnt make any copies of the data on the transmit path and, therefore, provides a significant performance gain to the application using it. The buffer pointer and the packet handle must be obtained using the <em>NDK_getsendncbuff()</em> API before this function is called. The size of data buffer specified as input to this function must not exceed the size of buffer allocated using the <em>NDK_getsendncbuff()</em> API. No option flags are defined at this time for this API. This packet and the data buffer are freed by the Ethernet driver once the transmit completes successfully. However, If an error is returned from this API, the application is responsible for freeing up the packet and data buffers obtained earlier from the <em>NDK_getsendncbuff()</em> API by calling the <em>NDK_sendncfree()</em> API with the packet handle as input.</p>
<p>The format of the data buffer sent as input to this function is expected to be the following:</p>
<p><img src="data:image/gif;base64,R0lGODlhwwGXAPcAAB8bFyAcGCEdGiMeGyQfHCUgHSYhHiciHygjICkkISolIiomIysnJCwoJS0oJS4pJi8qJzArKDEsKTItKjMuLDQvLTUwLjYxLzcyMDgzMTk0Mjk1Mzo2NDs3NTw4Nj46OD87OTk8PUE9O0A8OkM/PUI+PENAPkRBP0VCQEdDQUZCQUdEQkhFQ0lGREpGRUpHRUtIRkxJR0dISUdJSkdJS0hKS0lKS0xJSE1KSU5LSk9MSktNTlBNS1FOTFFOTVJPTlNQT1RRT1VSUFZSUVZTUldUU1hVU1lVVFlWVVpXVltYVlxYV1ZXWFxZWF1aWV5bWV5cWllaW2BdXGFfXWJfXmNhX2RiYGViYWVjYmZkYmZlZWFiY2lnZWlnZmpoZ2tpaGxqaW1ram5sa29tbWpqa3BubXFvbnJwb3NxcHBwcXRzcnVzc3RycXZ0c3d2dXZ1dHh2dnl4d3p4eHt6eXl5en17en18e359fH99fX9+fX18fYB/foKBgIOCgYGAf4SDgoSCgoWEg4aFhIeGhYSEhoiHh4mIh4qJiIuKiomJioyLio2Mi4uLjI6NjY+OjZGQj5CPjpGQkJKRkJOSkZSTk5WUk5aVlJeWlpiXl5mYl5qZmZqZmJuampybm52cm56dnJ+enqCfn6Ggn6GhoKOioqKhoaSjo6Wko6alpKempaenpqinp6moqKuqqqqpqayrqq2sq62trK6tra+urrCvr7Gwr7GxsLKysbSzsrS0s7a1tLa2tbi3tri4t7m5uLq6ubu7ur29vL+/vr6+vby8u8C/v8HAwMLBwcPCwsTEw8XFxMbGxcfHxsjIx8nJyMrKycvLys3Nzc/OztDPz9HQ0NLR0dLR0tPT09TT1NXU1NbW1dXU1tjX19fX2NnY2Nra2djY2tvb293c3N7e3d/f3+Hg4OLh4ePj4uTk5Obl5efm5uLi5Ojo5+np6evq6uzs6+3t7e/u7urr7PDw7/Hx8fLy8vT08/X19fb29vj39/n5+fr6+vv7+/38/P7+/v///yH5BAkAABkALAAAAADDAZcAAAj+AN8FaUKwoMGDCBMqXMiwocOHCX1ogEixosWLF1mYwMhxoQkWHUOKHEmypMmTBIO8c/KvpcuXMGPKnEmzps2bOGWOSpGzp8+fQIG2uRK0KM0rbYwqXcq0qdOnUFs6WRm1qtWZO69q1Tp0a06kXsOKHUsW51SWZdP6zKq27c2ubl2CjUu3rl2bZ+/eZauXLly6c/sKHlw2L+G2fA+X/Rs3sOLHkJkajiw2MeWtjN06vsy588zJnq1aDg01c9vNpFNTBq3a6ejWS02rRQ27dl/Wto2+zi2UaF3avIOrxS18Lc/iRWWnBY68uVbizm3ujk5TeVnm1LNLpqod5/TuL63+k8UOvnxP6OZbfjcvfiz59PA/c48Pc3359mLf09//D316++DhF5Z+/MXnn3kAdiegVwQWmN6B5SWo3YJbNehgeRCCJ2F2FGpl4YXdZdjdhtR1eNWHIGYnonYkRmeiVSimGN2K2bXo3ItVxShjczRSZ2NzOEal447F9Rjdj8gFCdWQRAZnpHNIFqfkU0w2mduTzUUp3JROVWllbVgip2VwXDbl5ZethVncmLyVydSZaKampnBs5ubmUnDGGdqcwdVp251K5alnZ3zy5mdtgBol6KCXFZrbobAlWtSijEbmqG2QtiZpUJRW+tiltWWq2qZAderpYaDCJmpqpP5k6qn/g6Xa2qqkterTq7DeNl+BtIZma0+45nrXVEfcYeyxyCar7LLMNuvss9BGu2wWH0hr7bXYZputEDdo622zNwzx7bjklmvuueima+wR9+ji7rvwxivvvPTWa++9+OZL7yqX6OvvvwAHHPAonwhscL2fjHLwwgw37PDDEEf8rrAUV2zxxRhnrPHGHHfs8ccghyzyyCSXbPLJKBNWzzwpt+xyVZ+QMAAAHVTSWS8Q5KwzBOT8k08jLWUCwSFh8UJMbVrkLMEHLvzRj0/0QBCDUq1AIEd6ZejMgQ6Z+ANUO5e0BAcEswBlDC4tbcDBY7IEEEEWUyAAACmc5QJABEnknbc6/v+8YEBLlADwh1eNBABKbVIA4AIRLAAAQCE+zQOACEqlAoAa6XEBwApEtDBzUj6ZM4EPLfWxwi4/dSLAIy3poMNjagCwSUuDMFCGS/fwYgs7LjljDD//0GNMNf+cYww7wgjzNDy4rMLNS9Go4oxTdhcREzQOFGAMPIH/kc4ryLx0ziu+2NOSO8aU88wu+jyjjD/MuFLOS8usMk1L53QBgCDXwJa4Ky1phOJaQg9apMIZ+viHNoyBjpbAY3iSo1xL9BGMWZzjJeRoxSuI5xJtsKIalsOceTR3uH80gwEDaEZL7KELWTTQJccwxSzc0ZJVAKAFxtgHN4zxjn9Ewxg+/mRFOFyyD16Ywhj0+Ac72ACAOdwvGclwCT+QAYtxuCQbxshHNlZBjbQUAgAZyMMzYNKIBDiuAZ1oCQkAEI9/CAMAVPhHJAAABQAUIB24uIDjBgA5f6DBcXA031LsJoR5GHIe5osBIGcROCQ8wHFuaEkpFuA4EYzRFQBYQgEA0AwUPOALjmMAMP6BjyoA8gz+eAQgueA/AADwH7MY4DMqAEgdzOMSADBDSw4BgEFEsCWdaIDjEOCIlnxik44TYSU2KQAjXC5zACjhP84AAKBNY40AWMDh9FFHxy2gFv4AJADUYQYAtOIfQQDAG4ZZNnasAJAcsAYoAKmEfzCgAS1p/8UEHEcAP7TEC5cLAAAGoImy1MMHgFTBIrw2jABoQBWowAABlPGPNbbxjXGcowEUAYl6cOAApbhFBgSQjVEAoAnQ+CMimGI3cQIgCf/QBQMIoIpzBC4CtdjFAgZAj3I0wALC+IQAhvAPTAIAEIP4BwoAUIVmUFMM/+ClGJxhhbldYwoAiAMQW5O4MiBCDhkAABz+IYgKZMIZQgDAL+CxgAkkMAcC4MYvq1GACIQCFiAIwC3+MQUOAIMYEEBAP8aRAAbAohgjeOYIo+kSXmKOCADIhC9EwIBz4AIAYFCHLHIAuUoAwASqyEc5z5nOJCzDDgCYwj9I4QE7SEMMAJBEOP4AWoZR3vMf6WBAAi5hCxcwFqAuKAYkBlgWfqTCC3oEgB3+sQcAWKIlkmhiRdnoRjjKEQBZaAkwrPsPazRQf4YIxisC8AOWAgADYkivGIj2jwj87R+B0+U/WgAAb4QCAFIIRjCWqg5M9sAlS52e3aTwDyAAgBPBwAQAWBkHxrZSnE9I4j/8oQxENO5wYADALLQRAOv9UpWCaIkpMDvBXPiBAgAgByoAMIaWDFeE5SGhSxABgDK8AwAT0O8YAPAJZwRAADooRM/+cQ0AkO4fo0UnAFDHDCO75BqUQAIA6kBWALDOnvgsBQBA14tM/gOgabyxBsoyi054zR+iAMAG/v5hSlu0BBYLni7fbmHdOY71H6cAAFRfAlkFMODPJDCv9WLiXsABoA8tMbA1aGyAP/95GZisAoABcMFkAOAJ//hANh0N0wZLUzWJKwQvlCEOl/TCAwHAgSI/8Q+7jUERsvvHL6lZQmMA4Aj/gMQDEKAEDQBgHJYQq3oUG2MH/8MNj4PGQB3NAKJ5ogcCsONYi3zkJKczGv/wBgBel40bfLYI0hWElVty2z4AYBEtCQcAVPBlAMhiwgG4QFkaB4uWRCMAFOhHgw3RkkAc9R++zcY/5pnRQ7fkGADgwS7PAA390ULWyBCkUqonkwkMwNCDU7I17vuGg/MNk3tWKgBoqP+MSxcYAPdLBzPy8Q85AMATiHNlTFYgAGa0nLH+AIEEcKAAeMh6cv8wBACu9g/PsuEcARiBz2GQYlkAYNB8IDZ4ZPwPdVxAAMdwRwBE4LVpXMMf7QDGNcYRCWG+Qxvbbom1AWCNf3wj7aBktSem/I8vAg3L/9AEALpQQ6a2G23/EIC8yTIJAChADG7wQI3/4YwDKGAPeEBABHqWBQB8QROJLXiI/8GPF+TSDwpYwDlisTlTaEHqRbFbBbDAetaHT/F8cEb3WpJOa8AjAguoBCICAIJ9YPIMkya5yQM3BFQkAQBEM/cUWM1VmcNE05MIhQQAYLN/AMJxrPw55b6RPTn+/MEBCJBGNnAcC0EIdBr26EAA4nAIBqBeO5rTwRWWEIFctgSrbgiFBmqeZhagQhMLgAH9kA4AIAGB8A5r13Zv9zpUIFavoAIAgAb/oEpHEDa35Q4YIABoUAgWIABHA1CAJ3hpcQjTV4Be0EOwFAMDEAAvsFXQoHgWkAl1tj8uUQ1BIFAd8G7wVX8BYAUsM0gu5Tiv8A9+AACGM3sa9w/IgAICpQI293vB9w8lh2n+AAiURABnsA9K+EhL0Eqv9BKm4H4ZUAf2p0DRpoO/9A/A0AObZAK50BJ1EG05oD+HUwwgcF6qBGNTB0gLcAKIgA8t0Q5TQAAFWFBk5QCOQwL/vtASTwAABAANCeh2aYcMGwAADAAIA5AD/0ANtHQDeGdCRXAANKMK/wQAITh4ZeEP5TBkMAEP7RAT5OA1NgEP4vA0LuEP4kBDYaEOPmcT7TAOsugT/fANP9gS+QCMznEP4RCMLfEMAoABWjgT9JAOMPEOFwQT/hCLVnIP3JBALqEP30CNGHQPObEP3xCN3ygOzOgS+HCNL3Mx4tAFKBYI71iP9vgT7wACINAGLHeP/viPABmQAjmQI5MPEnYy+xAO3mgX/hAO5EiQLbEPvVgbPpAzZfMPopAzmOYSdQABJwA8L9EKLVAAAlACn5YWg7AzOnOSxdEIEYAPoAABGacV/7VAAHcAE+qwARDQEixwZy/RDzuDASjgByA5E+WQRkSSBTmTCS2BMxDQAi8BCRCAASjoEmuIAAHQAZFgi6rxTkPXErAFAELAjvvkfC1ReAgwBVAwM5TgFpqQNx0AACSQNw/nHPFQAcCnd3iwFb5AS1T2EqfHALuEAEP0EvzgOE6wBEWgADQ4E9PgAHFEJI0IAFjQEkUIAB/wEhAIAJPwEqswAAOwBFUginkAG+9kAVD5Dx1gAWLpEiZVAvjlEujwAASwVarkAnWBbMU0D8aAbS3BDDlEDb8zDa8gji1BDauwDOt4GOL2C3kHAHv5DxTUCoX5D8+QDP7gDKxgRT+xBv8BsEl/OWwBIJj/MA4DwAYwcZgC4BK2AABG8A/ACYj/IA7GIA56RwTHQEC6MAt80xL+UAwyNJHd0YgWMAFPAwQWl5ktQQwAAJu42RL3oGmvZEMZIJ+p8U5ZEADmMA3Y1ZotoQQAkAsVMADf0BLzZAVS9AzLmRa6+Q/xsAAMYD7mMABc14jlBAAP4GYtJ1AA4ARtBBktcAFeo5f/YA45wE+KwJMMEJYL0As/8QJgMEfhSQ4TsAQcQJ7/4AMMsJCcBwDr6TPXd5OaIwotsQQAYEOOs57OcIcA4ACoQEpHAEgN4KTg0YiVdwzxUABWQAAK+g9lAACh0DjD0BK+AAA48BL/zVCUF8qZ0VR4hTeWZggC/oBsiGZ9AHCTgtGi/xAGAHAK8PVvjRgDwTAJAeAB+dAKAEAE0dBggAAZ6hAA//Wce5lhgmAMOiAA09M4VeAMsQMGP0GNcxeeUvAA39ABWApQgypF/DQzRgaItQAAKMoOBUAC98BLOrAK/nCkoqALHhAB7YBJaMAOqpAD6FanjGoIr2BlfNoS8XBP9UBjLfYPmwAAXiAc76RsY3AFuOqhUccH/4BwHQA8d6Bcg6GpuoBd/4AEAdA/jRgLtAcAzPCngBAMtSAAD6oYy4CwsvoPEEAAuRAMzRVijUNRXYYW9qYKKJuyqqCLLxGsQRNZqoml/wNbCoZphFhgBUfga1/wD/3QAQkQD/MaYsFgXeOgZvqlP6nwRgPwA4vwQuaaDAaQBA3WDOv6D7gEVeRAAAvQQ4XHd8HxTvbgAR0wATBQtGPJD3G5ADnjOAA0r5U5QX4gDCtKFpqacwvADQQQBIwIAPn5D5V3C41YWH+2No/BC4qll/RghMzWcY1jRc0AAPXkEpfpUn3bsnT3DxZQAFeABQlAAFigDf+wCC9Xs18aPKwZRUUIClAQAKA7tHFUDMvmaJ15CTggUAYQnQOKckGQACZAAf5QtT0AAAmQM9HWmXT2Oi4hCLqgqKEBtpyaVWb7D6R3AUVQvY1DYNqAAAbgm//BlgJzOxaa+g/+ZqbP9Q+NiAkt4VvV8KekaA/CcJCH4QxxtrEQsACAyA3TADyNQ43yG7kOFA4AHMDh0I+W+5fu51LLIL4AMErKWrr5wJrC8A/V0GEGQFTVRWBF+6DR4A3+wA6+wA3fUEYDQMDZ0YjTcJlEsa7y+wDVWwQ4MEDwQEuoA0sAUAEPuaj2oHcAsJ2teQWc6RLpYAAkWmUPAAZXsIJvShfhyw3RhgC62IgU0AjU1AP+sAufRQoZFnKHYQ8HMGhE2gZ7RwopAABDuL+MB7lB4bIwYawu8afG2aUBwHpToGki4I1D4Djo+w/K1gF/wA9xWgefQAEEQA0KhgP//HIAIFAeJkxnsfUP6woHl+oS+UBLg8oJAIAAXPAFolhMrQG24zcA7mC252AABtCfLYEFBvcPmeBrAOABzKfEAMDJLXF82bW3deB+L8BBnbBPASAFVakYRNAAWkik9iAGorgAkPMPZty/aXy5L8HGLXEDHpCegBQAkmcF99MSepcAKMgPOgAABmAO6NAEM2MBZOoPfnDAK1AMioxy9SCKY8Sn+IBi0PASDRavrCACAhXFDnIO5fC9dfEDZtmIyqAP5hAT4/CKlLFiwSATOnTDZIEOAlCaPhFdWvASuEjA9nCOL5EP3MA7p9IO38CVA/kHLywC6EjQtdEPK+CTdyEJ/wlQojkxC1QgigwMkSezBhtwBDbnEniQBG1XG6UwAhBdF0FQqTlBCx2wAtWH00791FAtI+7wxnThkFF91TJxDhMAAUwpE/AAAcj7EnIAAUNYF/ogAqVZDl+AARVwBc/zEsKwMxpwA5xgE8yggz1xA3qI1ZSBDx8gkzTRAWMGE4sAAeXLGzRmqDNxYycQE39EinXhWdiWVjog0CxA0tsFAYn5AwIQALVAE6fARz/RCAbw1nxNGSYFABqAjjDhAAsQE190ZbyBAgNwh5X7D+0gC8PQDgDQ2C2BDK2QDo8Nn83wDrDQQP1wDKwgcC5hDavQCt5wi8JgCrTwo0CRDxtwqP9v9wFes0YcpF1O1hLidgf6YAwU1RLSUJ8utwa+iQ6w4Av1IMm6QAq94I3mQAC3c9qUAaKwCdkEZAu8oA+u7RLQwAriENs+dAz1EAuF2Qyr4Jvp1gqqkM2/iQqyYMpx8QuQK0DA1xLCwJoAIGWN7Q+aczfeRoobgAHepgbzAKJGOActwQfR5qX8Zg937DgPcNM+YTdJFTwX1A8cAAAgDd5H9g5VpQr+MAIBIHD7MAEMME+OQzqqgIgAAAI25w2a5jgjUGr/MAQJYKH6fRjaIAAmMGIbuYls+gMJ8Nr/MAeOkwAGxjrQ5gT4xQ/64zhfoIWUgEzqxLOVN0z+7Raw1Qn/990AP8p0hiANWNXYWuYCy3AKm4TiT7cIy4AH6sQMTQAAtUAPA+AC5BANQRAG/LBibcAOp8ADsu0TRTgKMPEHsfkS2xUABDDjEqjARPOsX1AOf/oFvJAOECABwVAKBPBfzVUJ7FAIRXBO/wBbixjmihF1goAPEhBXLdGAcCAN5fTaDOoBxFALEDBuwfsCjpALgZMFzwBQ6FsBGKAN3OAEWBAPtnYF6sALOOBPccFWC8AyifNc7lDlLfG4jf1HrP4PdSTp5z3GqBAMjgAAbMAP00cCc1DPajhQQdAIVN0TsKXjNLYBpg3eE4AFVTAED7A62SYAnkhNn73wkLNiTaBf/741DqqUAFDQCRJXhK/s7IKBtqz7D0xk7w6QACx3Y689CMjXEkwk5zssFZwZDGlGYI3jAWsQwQq0gjEgCNXpFsE2ADkjN4daDTfUEujQ2//gw/XmpwAg6QfNsZboaETxC1IgNyEe35VQuwBwAPb+E1XVRS2xCQGQARBuleFtQoanhccnDRawAcCj8hMIzsxWDPuQB4kFABAQCi2hSrOD84NBegGQM4y52vjgNi6BAK/dYNV3fUjPzsq8aX+mcM+ABQccAxdECkEQbQMQr27xzTzQwsJ0DPcgAAYAiFbc2C7X4wgl6fI5xgddDtCgD/aADMgAD6EAm7Lgwd/ADYtwAP4FwLw48afJ+goEoAF6DxPbdWT/IA2XDIjzZKZ/CWL/sGIdfgwNJA62EA/M0GCHWndLhvmD4cMv0MIoBhCq/mEAwO3fNQAL/jUCgObfvywAHv3rAaDaQycAjP1zxwyfPmfA7rHCAcASvGDTzlWSACDcQ5gxZc6kWdNmMwAa+MGEA+AMRABSKJUIcOLfMQEQGrEJAEDgBgD9HhYC4ATVD5PWCDzghArFAGmUAOhYZalACZtpGQrMNwFAhyBxo8UEBmAClitQIgDI8tDeAwAAnD3cBAAIJXoVEkRyJKADvjJ8Ze0BwOUhGgDk0m7m3NnzZ9ChRY8mXdr05nMGELyDuf4IwJN/cwxTwhFA4bcECAbdGSCRYsGHn8aekgLAz7sHBSa1wooLFgASpzpJeIDvdGk3AObExNkg3jkjABI0mmD0n6UFAHjEcfoPqtR/++QoAHBAjtRUHgJTyPSvHx76AGDhmNGUAQCPf54LbMFi6FpQAAQuOCMemM4AAAaYvskAABP+WSaFpkwgcB4uegNgiXIe6kGD61p08UUYY5RxRkX4igkdAwTgZh4sAjCgDhcU+keVllD4w7eKDPrHn0McAGAAMKzj5YTAGCjkoUb2AgAEW2Z8MZ18ZtLnHM748aaemPoZRxz4HsqHG3ZMG6KHFr8AoJGY9gmnzXbG8Semev+ymQemdgiow0tEE1V0UUZdbAdNmfpJcTN/vqEQJn/O8WafPL9Jp1FQQ5WpFgGsMW0SIwJwIE7TLDkgG1FjlXVWWmu19dZQjwjEtEM24OGW64zYA1diizX2WGSTVXZZZpt19lloo5V2WmqrtRbZeCa9lZxBr/X2W3A9q0ccYtFhjVYiuniolyAgwOEXmciBYF4IMGBBkc2yKSU0K6AI91+AAf5CiIeYUUICFVyZSQJ6LTAhD05tMkeT0OBwoU1RZwFAln+EKcACLBCQ4NyHxKnPiSWGMAAATGwiBoGfQFMFgGACtvlmaZ0RwJJ/vFmggSwcQOAamXprYgkj6OvDpmv+HoANtGMAIGVWHDLYqQoAclkIjYtgMpnF4Cr7Bxlj4NPGGHFqtIKZh96pxRaS+/mFlFvscVOCJHDWe+9kq0DAnX/eAKCTfz45Y6OYeot4F8P+ccaYex4aB23hfjDmz3p0meVTmIwxZRaSVVBhJ1ERirkCA6q5RGuZvvarDQAc+Sc8XR5qIYCZA2PxlwsCqwCXf96BYcEKmnnIzm/4Vn75Wek54OkbNMLEFdITB4BTfQYBQI5/wADAk4eKW2VBAPiJRoQq981niQUZYJ0yYGLFBABD/sEnAAQcaAqM1gMjQIDAQGEnnQCAGv4xDQAM4R14AEATZJGPERBgFrKIgAf+8GEJ47QjEz/YxEP6AIBPME+EI1RULQCwhof0rgJNQULEYNIbApgIB3bTRVCCdwAQ4MM1MVCFP3wAQl6AwAHpkAUAysCOVuTgEA+Z35VEBQgAhCJ4gQHEOZoAAGB5DQAIwIIVilAB7fyDHg64AD+0d4kh+eQoAGhBMIJxRWKwAgAFOMIkSDa/QZBQj3t0USbo9xDAnEEdduqg9axghSNARQtLAsEB3CEcPoztNf9ABwAu4EbvlSIZARDADw5hDpjQoiGxYk+X/sEAl/yDEwDIoxbBRskDBGAc/4gMLmKwmjT+xBVzZEAvGXCKfyBiBYFRwCIeIsdI8lGZywQNQ/r+8w8UAIAY/8DFKK0XsXpoAADC+MeROEGFAFBDkrAx0AB8yQDZaUIHTSnAdv5hIDHEShAA2Nc/cqCRf/ABAJKIiese4g4EAMAb//gFAJQAgEX+Q45lkGQTHtKMWZ6DF+aohiACUIGHhGJwzORoR2tCQEQ8xAoASMU/LgEAOxTteg/RhzbhxQ0BCAEBPnhIMhpISQCo4CHS8IY/2gEMbYTDEQsIAJoKKohYoSJ2YVMBHxRDNC1yMS/a5MFD/EGCwLziIdVUwSH6sQIBDGITCmAAOuZ5hFY0IgA0/QdVauZRuHq0GNt7COM48AcPCOCtLwSAFbAwBRBsyTr/QEJgJvH/EGoAYAN/yMcV5RCKCwwgGgSEgSowkQAO/Ek49QwVOgigLv/8IQEAqEBJ+7kg/E2gC7OcCgAsEDF6YHUB/ODGDwDIgVnEpw0HCIwO5vIPLSAAHnElLjP3EYEgwIQSDQBAAyoxExPhDwJV+G3h6sMqf2DFAOJQBxQIAAAKhNAffUAlAFDwVtl0TVRfyMCfWOoNjHnGDwCAQ5rC4UJ6fKN69tMG4B7Sjwr0pbgD5uMeDEAPmPBDGy78DAatEBN/iCNMD7kHN/QRE314g3MPeQGdZBUNAdSuNKXwLgHEaZpZBCB+BGbxCNPBAMKV5hZ+A4CISwONAHA2VmEwg2lAwYEX/uiYNF/gX4uNzLw8+Ks0uOAACvh5mjsgwb1HpnKVrXxlLGdZy1vmcpe9/GUwh1nMYyZzmc18ZjSnWc1rZnOb3fxmOMdZznOmc53tfGc851nPe+Zzn/18ZnmsYwd/JjSeCfGGhzAht4VmNJwZkYaYKLrRk17zJMgwEyaYktKbHjMnEoppTXNa1FwuxRTSkmlwpFrVq2Z1N1z9aljHWtazpjWtt3FrXOda17vmda99jQ1gB1vYwyZ2sY19bGQnW9nItkaznf1saEN7mjbpRrStbe1lZ1vb2+b2sn39bXCHG9e1Jne5ze1qVqd71a6IAme0IAN4x1ve855Bve19b3zn/1vf+943Dfz9b4AHXOADJ3jBa3BwhCdc4QtneMMd/nCIR/zhNqB4xS1+cYuHgBFpKUYIMP5xjEtc5CMnecklXnCUp1zl/+Z3y13+8nrPW+by/vSooQWJS9MkEZC2ec+1vPOZPNrnQ8+yH+gQE6ETXelWpgOC/sGIMSxd6lV+AyGgPnWsH1kPesh6173+dbCHXexjJ3vZzX52tKdd7WtnO7UiQILSoINe9VqBIaZME26Mou17h1EAMFAacwDAACgjAm+fWxNhJIChfGf8afwOE2usQhnwMYcx2oGOVyBjJoG3AExEYSOykY4baGMIFZbxEHjYAm4w6Qcw6AapxsceJv6PzycAAWCEdvzDNWJIDwAQHRPOU7gn+DqoKWMQgPEFpvPE2JBdugSP6O3n9LKX/eNryANoMHA7rqGALWRhAAJM+CGBB8D/AuMEToFCjQj5QTwok4RY6KMEA4jFLCbAgXsUJg/v4MQP0Ej92Hu8nqiDYNgFAxgB3aOvh0AfbfmHwDuALjoCC1BAe4AACtiHQwAASviHVjAiDwGAFHAjKACAXngOOpIE/wLAxnu8iEgAX5IAf3CNVooecoGJ4HsIdUiAABgozKAFHTiA3OtAhoqF8jsnvWuEFgiMBFgiFWS8x2OPENIHYRgU1wipfyiJGhw/14IJeKAPohkGgwqAK7l4iOeIJ2YAACR4CGeYJXTghXKwhkIQgAhoQif8O2MIgA8QBQsZwyp8CCwEvvrACyiAihuACRUIjFV4CF4AgBMoBH9wgQAQBE1YAAUwB0MAgCJ4hUcQgBygQ76jPVKYQIP6lD68QgDIQgdELQRQrZd4CEQArwmzBypJgHzwhiAAoA2AhfiAg4ACgByABk+kPnJglRaBIhRivfuCifzaL3zor2B8xtI4Be+SLGisRkYZBQ5wASmyxs0ICAA7" alt="Figure 3-2 Raw Ethernet Buffer Format" /></p>
<h4 id="ndk_sendncfree-free-the-packet-and-data-buffers-obtained-using-the-ndk_getsendncbuff-api.">NDK_sendncfree  Free the packet and data buffers obtained using the NDK_getsendncbuff() API.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NDK_sendncfree( <span class="dt">void</span> *hFrag );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hFrag: Handle to send buffer to free</li>
</ul>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> The <em>NDK_sendncfree()</em> function frees the packet and data buffer obtained from calling the <em>NDK_getsendncbuff()</em> API. The calling parameter, <em>hFrag</em>, is the handle of the packet buffer to free (not the pointer to the buffer handle).</p>
<h4 id="ndk_recvnc-receive-data-from-a-socket-without-buffer-copy-1">NDK_recvnc  Receive data from a socket without buffer copy</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_recvnc( SOCKET s,
                <span class="dt">void</span>   **ppbuf,
                <span class="dt">int</span>    flags,
                <span class="dt">void</span>   **phBuffer );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>s: Socket</li>
<li>ppbuf: Pointer to receive data buffer pointer</li>
<li>flags: Option flags</li>
<li>phBuffer: Pointer to receive buffer handle</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns the number of bytes received. Otherwise, a value of -1 is returned and the function <em>fdError()</em> can be called to determine the error:</p>
<ul>
<li>EBADF: The file descriptor (socket) is invalid</li>
<li>EINVAL: Attempt to read (or calling arguments) invalid for this socket</li>
<li>ENOTSOCK: The file descriptor does not reference a socket</li>
<li>EWOULDBLOCK: The receive timeout configured on the socket has expired and no data received so far.</li>
<li>ENXIO: No egress interface specified for this socket to receive from. Use SO_IFDEVICE socket option and specify an interface before retrying to receive data using this socket.</li>
</ul>
<p><strong>Description</strong> The <em>NDK_recvnc()</em> function attempts to receive a data buffer from a socket. A pointer to the data buffer is returned in <em>ppbuf</em>. A system handle used to free the buffer is returned in <em>phBuffer</em>. Both of these pointers must be valid. The options in flags can be used to change the default behavior of the operation. No flags are defined for raw Ethernet sockets. The function returns the length of the message on successful completion. The receive operation always returns one packet buffer. The caller has no control over the size of the data returned in this buffer. If no messages are available at the socket, this call waits for a message to arrive for the receive timeout specified on this socket. If no timeout is specified this call blocks forever waiting for data to arrive on the socket. The function returns the data buffer available. When the caller no longer needs the data buffer, it is returned to the system by calling <em>NDK_recvncfree()</em>. Repeated failure to free buffers eventually causes the stack to stop receiving data.</p>
<blockquote>
<p><strong>NOTE:</strong> Take care when using the <em>NDK_recvnc()</em> API, because packet buffers come from the driver; there may be a limited supply available. The packet buffers must be promptly freed up by the application once processing is complete.</p>
</blockquote>
<h4 id="ndk_recvncfree-return-a-data-buffer-obtained-from-a-no-copy-receive-operation-1">NDK_recvncfree  Return a data buffer obtained from a no-copy receive operation</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NDK_recvncfree(<span class="dt">void</span> *hBuffer);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hBuffer: Handle to receive buffer to free</li>
</ul>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> The <em>NDK_recvncfree()</em> function frees a data buffer obtained from calling <em>NDK_recvnc()</em>. The calling parameter <em>hBuffer</em> is the handle of the buffer to free (not the pointer to the buffer).</p>
<p><a name="full-duplex-pipes"></a></p>
<h2 id="full-duplex-pipes-programming-interface">3.5 Full Duplex Pipes Programming Interface</h2>
<p>Although sockets can be used for inter-task communications, it is not the most efficient method. The stack provides a second data communications model called pipes, which allow for local connection oriented communications.</p>
<p>A pipe is a full duplex connection oriented file descriptor. When a pipe is created, both ends of the pipe are returned to the caller as file descriptors.</p>
<p>Communication is performed using the standard file and sockets API functions. All the file descriptor functions are supported with pipes: <em>fdSelect()</em>, <em>fdClose()</em>, <em>fdError()</em>.</p>
<p>Also, socket functions <em>NDK_send()</em> and <em>NDK_recv()</em> write and read data through the pipe. Both functions also support the following standard sockets message flags when using pipes:</p>
<ul>
<li>MSG_PEEK: Examine data but do not consume it.</li>
<li>MSG_DONTWAIT: Do not block on send/recv operation (by default, pipe operations always block).</li>
</ul>
<p>Pipes are connection oriented, thus, when one end closes, the other end is altered by an error return from <em>NDK_send()</em> or <em>NDK_recv()</em>. It is therefore possible to make a blocking call on <em>NDK_recv()</em> without concern that the function will be deadlocked if the other end terminates the connection.</p>
<h3 id="pipe-api-functions">3.5.1 Pipe API Functions</h3>
<p>Because pipes share file descriptor and IO functions with sockets, the only pipe oriented function is the creation of the connected pair.</p>
<h4 id="ndk_pipe-create-a-full-duplex-pipe">NDK_pipe  Create a Full Duplex Pipe</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NDK_pipe( <span class="dt">void</span> **pfd1,
              <span class="dt">void</span> **pfd2);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pfd1: Pointer to file descriptor to first end of pipe.</li>
<li>pfd2: Pointer to file descriptor to second end of pipe.</li>
</ul>
<p><strong>Return Value</strong> Returns zero on success or -1 on error. A more detailed error code can be found by calling <em>fdError()</em>.</p>
<p><strong>Description</strong> Creates a pre-connected full duplex pipe. The returned file descriptors can be used with all the fd file descriptor functions, as well as the <em>NDK_send()</em> and <em>NDK_recv()</em> socket functions.</p>
<p>Pipes are connection oriented, so like TCP, a read or write call can return ENOTCONN when the connection is broken by one side or the other.</p>
<blockquote>
<p><strong>NOTE:</strong> Both file descriptors must be closed to correctly close down (and free) a pipe.</p>
</blockquote>
<h2 id="internet-group-management-protocol-igmp">3.6 Internet Group Management Protocol (IGMP)</h2>
<p>Internet Group Management Protocol (IGMP) is designed to help routers in routing IP multicast traffic. Each router can have multiple ports, and it is inefficient for the router to replicate every IP multicast packet out of each active port. Using the IGMP protocol, the multicast router is able to keep track of which IP multicast addresses need to be routed to each individual port. This allows the router to limit IP multicast transmission to only those ports that require the multicast traffic.</p>
<p>The IGMP protocol assumes a client/server relationship between endpoints. The IGMP server is run by the multicast router to get IP multicast information about all the client on each of its individual ports. The IGMP client is only concerned with communicating its own multicast requirements to the local IGMP server, so that it will get the IP multicast packets that it requires.</p>
<p>The NDK does not support IP multicast routing, so there is no need to use IGMP in server mode. However, the software does support IGMP client operation.</p>
<p>The IGMP client module indicates to the IGMP server which multicast IP addresses that the client needs to receive. The IGMP API will also maintain the Ethernet multicast MAC address list at the Ethernet driver level.</p>
<p>An application can join or leave a multicast group using the well-known <em>NDK_setsockopt()</em> API. To do this, use the <em>NDK_setsockopt()</em> and <em>NDK_getsockopt()</em> APIs with the IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP options. For more details on options for joining or leaving a multicast group, see getsockopt() and setsockopt().</p>
<p><a name="configuration-and-initialization"></a></p>
<h1 id="configuration-and-initialization">4 Configuration and Initialization</h1>
<p>This chapter discusses the Configuration Manager API, which is the recommended method for configuring your application. In addition, this chapter discusses the initialization sequence for the NDK.</p>
<h2 id="configuration-methods">4.1 Configuration Methods</h2>
<p>There are two ways to configure an applications use of NDK modules:</p>
<ul>
<li>The <strong>Configuration Manager API</strong> is a collection of functions to help you create and manipulate a configuration. This chapter describes the Configuration Manager API and its effects on the configuration database.</li>
<li><p>The <strong>XGCONF configuration tool</strong> within CCStudio can configure an applications use of NDK modules. Graphical displays let you enable and set properties as needed, and context-sensitive help provides information about individual fields. This configuration method cannot be used with FreeRTOS. XGCONF is a configuration tool used to configure the TI-RTOS Kernel (previously called SYS/BIOS). The same configuration in one project can configure both NDK and TI-RTOS modules and objects.</p>
<p>To open XGCONF in CCStudio, double-click the <em>.cfg file in your applications project. Alternatively, you can edit the </em>.cfg file in your TI-RTOS project with a text editor. See the steps in the <em>TI Network Developers Kit (NDK) Users Guide.</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) for using XGCONF with the NDK. For more about using XGCONF, see Chapter 2 of the <em>TI-RTOS Kernel Users Guide</em> (<a href="http://www.ti.com/lit/pdf/spruex3">SPRUEX3</a>).</p></li>
</ul>
<p>Internally, the XGCONF configuration tool generates C code that uses the Configuration Manager API to update the configuration database.</p>
<blockquote>
<p><strong>NOTE:</strong> You should not mix configuration methods. If you have NDK applications that use the API-based configuration method, you should either continue to use that method or convert the configuration entirely to an *.cfg file configuration using XGCONF. If a project uses both methods, there will be conflicts between the two configurations.</p>
</blockquote>
<p><a name="configuration-manager-api"></a></p>
<h2 id="configuration-manager-api">4.2 Configuration Manager API</h2>
<p>The Configuration Manager is a collection of API functions to help you create and manipulate a configuration. The manager API is independent of the configuration specification.</p>
<p>The configuration is arranged as a database with a master key (called <em>Tag</em>) that defines the class of configuration item. A second key (called <em>Item</em>) determines the sub-item type in the <em>tag</em> class. For each <em>tag</em> and <em>item</em>, there can be multiple instances. Items can be further distinguished by their <em>instance</em> value.</p>
<p>The configuration is based on an active database. That is, any change to the database can cause an immediate reaction in the system. For example, if a route is added to the configuration, it is added to the system route table. If the route is then removed from the configuration, it is removed from the system route table.</p>
<p>To facilitate the active procession of configuration changes in a generic fashion, the configuration API allows the installation of service provider callback functions that are called to handle specific <em>tag</em> values in the configuration.</p>
<p>Configurations can be set active or inactive. When a configuration is active, any change to the configuration results in a change in the system. When a configuration is inactive, it behaves like a standard database. Part of the main initialization sequence is to make the system configuration active, and then inactive when shutting down.</p>
<p>Both the configurations and configuration entries are referenced by a generic handle. Configuration functions (named as <em>CfgXxx()</em>) take a configuration handle parameter, while configuration entry functions (name as <em>CfgEntryXxx()</em>) take a configuration entry handle parameter. These handles are not interchangeable.</p>
<p>Configuration entry handles are <em>referenced</em>. This means that each handle contains an internal reference count so that the handle is not destroyed by one task while another task expects it to stay valid. Functions that return a configuration entry handle supply a referenced handle in that its reference count has already been incremented for the caller. The caller can hold this handle indefinitely, but should dereference it when it is through. There are three calls that dereference a configuration entry handle. These are: <em>CfgRemoveEntry()</em>, <em>CfgGetNextEntry()</em>, and most simply <em>CfgEntryDeRef()</em>. See individual function descriptions for more information.</p>
<p>The PPP module in the stack library and several modules in the NETTOOLS library make use of a <em>default</em> configuration to store and search for data. The default configuration is accessed by passing in a NULL configuration handle to any function that takes the <em>hCfg</em> parameter (except <em>CfgFree()</em>). The default configuration is specified by calling <em>CfgSetDefault()</em>.</p>
<h3 id="function-overview-6">4.2.1 Function Overview</h3>
<p>The configuration access functions (in functional order) are as follows:</p>
<p><strong>Configuration Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CfgNew()</td>
<td>Create a new configuration</td>
</tr>
<tr class="even">
<td>CfgFree()</td>
<td>Destroy a configuration</td>
</tr>
<tr class="odd">
<td>CfgSetDefault()</td>
<td>Set default configuration</td>
</tr>
<tr class="even">
<td>CfgGetDefault()</td>
<td>Get default configuration</td>
</tr>
<tr class="odd">
<td>CfgLoad()</td>
<td>Load configuration from a linear memory buffer</td>
</tr>
<tr class="even">
<td>CfgSave()</td>
<td>Save configuration to a linear memory buffer</td>
</tr>
<tr class="odd">
<td>CfgSetExecuteOrder()</td>
<td>Set the tag initialization and shutdown order on execute</td>
</tr>
<tr class="even">
<td>CfgExecute()</td>
<td>Make the configuration active or inactive</td>
</tr>
<tr class="odd">
<td>CfgSetService()</td>
<td>Sets service callback function for a particular tag</td>
</tr>
<tr class="even">
<td>CfgAddEntry()</td>
<td>Add a configuration entry to a configuration</td>
</tr>
<tr class="odd">
<td>CfgRemoveEntry()</td>
<td>Remove entry from configuration</td>
</tr>
<tr class="even">
<td>CfgGetEntryCnt()</td>
<td>Get the number of item instances for a tag/item pair</td>
</tr>
<tr class="odd">
<td>CfgGetEntry()</td>
<td>Get a referenced handle to a configuration entry</td>
</tr>
<tr class="even">
<td>CfgGetNextEntry()</td>
<td>Return supplied entry handle and get next entry handle</td>
</tr>
<tr class="odd">
<td>CfgGetImmediate()</td>
<td>Get configuration entry data without getting an entry handle</td>
</tr>
</tbody>
</table>
<p><strong>Configuration Entry Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CfgEntryRef()</td>
<td>Add a reference to a configuration entry handle</td>
</tr>
<tr class="even">
<td>CfgEntryDeRef()</td>
<td>Remove a reference to a configuration entry handle</td>
</tr>
<tr class="odd">
<td>CfgEntryGetData()</td>
<td>Get configuration entry data from entry handle</td>
</tr>
<tr class="even">
<td>CfgEntrySetData()</td>
<td>Replace data block of entry data using entry handle</td>
</tr>
<tr class="odd">
<td>CfgEntryInfo()</td>
<td>Get information on a configuration entry handle</td>
</tr>
</tbody>
</table>
<p>For API details, refer to the <a href="html/group__ti__ndk__inc__nettools__inc____Cfg.html">CFG Module in the NDK API Reference Guide</a>.</p>
<h2 id="configuration-specification">4.3 Configuration Specification</h2>
<p>Specifying all the available configuration options for the stack would require a separate document. This section details that part of the configuration that is relied upon by the Network Control (NC) initialization functions, or the services contained in the NETTOOLS library. The stack itself does not reference the configuration system. It has its own simpler method that is detailed in <a href="#ApxA">Appendix A</a>, but it is redundant when using the configuration API. In fact, they conflict, as the Network Control functions assume full control of it.</p>
<h3 id="organization-1">4.3.1 Organization</h3>
<p>As already mentioned, the configuration is arranged as a database with the value Tag as a major key, and the value Item as a minor key. Every major stack configuration component has a major key (Tag) value, including: network services (protocol servers), connected IP networks, gateway routes, connected client entities, global system information, and low-level stack configuration.</p>
<p>Most of these tags require service callback functions to implement the system functionality. For example, when an IP network is added using the CFGTAG_IPNET tag, there must be a function that makes the corresponding system calls that adds the network to the system route table. All these server callback functions are contained in the NETCTRL directory. Although source code to these functions is provided, many of the system calls they make can only be understood by reading the attached appendices.</p>
<p>The tag values defined are:</p>
<ul>
<li>CFGTAG_SERVICE: Network Service</li>
<li>CFGTAG_IPNET: IP Network (Address, subnet mask, etc.)</li>
<li>CFGTAG_ROUTE: IP Gateway Route</li>
<li>CFGTAG_CLIENT: IP Client (Client IP, Hostname, etc.)</li>
<li>CFGTAG_ACCT: Client user account (name, password, etc.)</li>
<li>CFGTAG_SYSINFO: Global System Information</li>
<li>CFGTAG_OS: Operating System Configuration entry</li>
<li>CFGTAG_IP: IP Stack Configuration entry</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Configuration support is not available for IPv6 stack management. IPv6 stack management can be done only using the APIs and data structure exported by it. IPv6 stack APIs and data structures are discussed in <a href="#ApxG">Appendix G</a> of this document.</p>
</blockquote>
<h3 id="network-service-specification-cfgtag_service">4.3.2 Network Service Specification (CFGTAG_SERVICE)</h3>
<p>The network services tag is perhaps the most time saving feature of the configuration. It allows you to instruct the system of what tasks to execute, and how they should be executed. It is also the most complicated configuration entry.</p>
<p>Network services are identified by a configuration <em>Tag</em> parameter value of CFGTAG_SERVICE.</p>
<p>Note that all these services are obtained directly from the NETTOOLS services API. The configuration system adds a level of abstraction so that a list of services can be added to a configuration, and then the service provider callback functions contained in the Network Control initialization routines can automatically load the services at runtime without having to call the NETTOOLS API directly.</p>
<h4 id="service-types">4.3.2.1 Service Types</h4>
<p>The type of service is indicated by the value of the <em>Item</em> parameter supplied to the <em>CfgAddEntry()</em> function. The defined service types include (by <em>Item</em>):</p>
<ul>
<li>CFGITEM_SERVICE_TELNET: Telnet Server</li>
<li>CFGITEM_SERVICE_NAT: Network Address Translation System</li>
<li>CFGITEM_SERVICE_DHCPSERVER: DHCP Server</li>
<li>CFGITEM_SERVICE_DHCPCLIENT: DHCP Client</li>
<li>CFGITEM_SERVICE_DNSSERVER: DNS Server</li>
</ul>
<h4 id="common-argument-structure">4.3.2.2 Common Argument Structure</h4>
<p>Each individual service has its own specific configuration instance structure, but they all share a generic argument structure. This is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Common Service Arguments</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_srvargs {
    <span class="dt">uint32_t</span> Item;        <span class="co">// Copy of Item value (init to NULL)</span>
    <span class="dt">void</span> *hService;       <span class="co">// Handle to service (init to NULL)</span>
    <span class="dt">uint32_t</span> Mode;        <span class="co">// Flags</span>
    <span class="dt">uint32_t</span> Status;      <span class="co">// Service Status (init to NULL)</span>
    <span class="dt">uint32_t</span> ReportCode;  <span class="co">// Standard NETTOOLS Report Code</span>
    <span class="dt">uint32_t</span> IfIdx;       <span class="co">// If physical Index</span>
    <span class="dt">uint32_t</span> IPAddr;      <span class="co">// Host IP Address</span>
    <span class="dt">void</span>(*pCbSrv)(uint, uint, uint, <span class="dt">void</span> *); <span class="co">// CbFun for status change</span>
} CISARGS;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>uint32_t Item;</code> This is a copy of the Item value used when the entry is added to the configuration. Its initial value should be NULL, but it is overwritten by the service provider callback. It is used so that the status callback function can be provided with the original Item value.</li>
<li><code>void *hService;</code> This is the handle to the service as returned by the NETTOOLS function corresponding to the type of service requested. Its initial value should be NULL, and it is initialized by the service callback function when the service is started. The value is needed to shut down the service when the configuration is unloaded.</li>
<li><code>uint32_t Mode;</code> The mode parameter is a collection of flags representing the desired execution behavior of the service. One or more of the following flags can be set:
<ul>
<li>CIS_FLG_IFIDXVALID: Specifies the <em>IfIdx</em> field is valid. This mode is required for DHCP Client, DHCP Server, and NAT Server. For Telnet Server and DNS Server, this flag will set the NT_MODE_IFIDX in the NTARGS struct described in <a href="#invoking-network-services-by-nettools-api">section 6.1.2</a></li>
<li>CIS_FLG_RESOLVEIP: Requests that <em>IfIdx</em> be resolved to an IP address before service execution is initiated. Warning: Calling this on the DHCP Client Service will prevent it from ever starting.</li>
<li>CIS_FLG_CALLBYIP: Specifies that the service should be invoked by IP address. (<em>This is the default behavior when IFIDXVALID is not set, but this flag can be set with IFIDXVALID when RESOLVEIP is also set. If IFIDXVALID is set and this bit is not set, the service is invoked by physical device .</em>)</li>
<li>CIS_FLG_RESTARTIPTERM: A service that is dependent on a valid IP address (as determined by the RESOLVEIP flag) is shut down if the IP address is removed from the system. When this flag is set, the service will be restarted when a new address becomes available. Otherwise; the service will not be restarted. Note: The DHCP Client service will only remove IP addresses in the event of a DHCP lease renewal, so you will have to manually remove an IP address for services to be restarted in any other event.</li>
</ul></li>
<li><code>uint32_t Status;</code> The status parameter contains the service status as detected by the Net Control service callback function that initiates the service with NETTOOLS. The value of status should be initialized to NULL. Its defined values are:
<ul>
<li>CIS_SRV_STATUS_DISABLED: Service not active (NULL state)</li>
<li>CIS_SRV_STATUS_WAIT: Net Control is waiting on IP resolution to start service</li>
<li>CIS_SRV_STATUS_IPTERM: Service was terminated because it lost its IP address</li>
<li>CIS_SRV_STATUS_FAILED: Service failed to initialize via its NETTOOLS open function</li>
<li>CIS_SRV_STATUS_ENABLED: Service enabled and initialized properly</li>
</ul></li>
<li><code>uint32_t ReportCode;</code> All the services available via the configuration can also be launched directly via a NETTOOLS API. The NETTOOLS service API has a standard service reporting callback function that is mirrored by the configuration system via the Net Control service provider callback. This variable holds the last report code reported by the NETTOOLS service invoked by this configuration entry.</li>
<li><code>uint32_t IfIdx;</code> This is the physical device Index (1 to n) on which the service is to be executed. For example, when launching a DHCP server service, the physical interface is that connected to the home network. For more generic services (like Telnet), the service can be launched by a pre-defined IP address (or INADDR_ANY as a wildcard). When launching by IP address only, this field is left NULL. If the field is valid, the CIS_FLG_IFIDXVALID flag should be set in <em>Mode</em>.</li>
<li><code>uint32_t IPAddr;</code> This is the IP address (in network format) on which to initiate the service. This IP address can specify the wildcard INADDR_ANY, in which case the service will accept connections to any valid IP address on any device. Note that some services (like DHCP server) do not support being launched by an IP address and require a device Index (supplied in <em>IfIdx</em>) on which to execute.</li>
<li><code>void(*pCbSrv)(uint, uint, uint, void *);</code> The pCbSrv parameter contains a callback function that is called when the status of the service changes. It can be set to NULL if a callback is not required. The specification of the callback function is as follows:</li>
<li><code>void StatusCallback( uint32_t Item, uint32_t Status, uint32_t Code, void *hCfgEntry );</code>
<ul>
<li>Item: Item value of entry changed</li>
<li>Status: New status</li>
<li>Code: Report code (if any)</li>
<li>hCfgEntry: Non-Referenced pointer to entry with status change</li>
</ul>
Note that the <em>Status</em> parameter is the same as the <em>Status</em> field described in the CISARGS structure. The Code parameter is that returned by the NETTOOLS service callback, which is a lower-level status callback function used by Net Control.</li>
</ul>
<h4 id="individual-configuration-entry-instance-structures">4.3.2.3 Individual Configuration Entry Instance Structures</h4>
<p>The following code defines the instance structures used for each of the defined configuration entries using the configuration service tag. Note that all structures contain the previously mentioned CISARGS structure. Some services require more information and their configuration entry structure contains an additional parameter structure as defined in the services NETTOOLS API. Others do not require a parameter structure.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Telnet Entry Data</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_service_telnet {
    CISARGS cisargs;      <span class="co">// Common arguments</span>
    NTPARAM_TELNET param; <span class="co">// Telnet parameters</span>
} CI_SERVICE_TELNET;

<span class="co">// NAT Service Entry Data</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_service_nat {
    CISARGS cisargs;     <span class="co">// Common arguments</span>
    NTPARAM_NAT param;   <span class="co">// NAT parameters</span>
} CI_SERVICE_NAT;

<span class="co">// DHCP Server Entry Data</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_service_dhcps {
    CISARGS cisargs;     <span class="co">// Common arguments</span>
    NTPARAM_DHCPS param; <span class="co">// DHCPS parameters</span>
} CI_SERVICE_DHCPS;

<span class="co">// DHCP Client Service</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_service_dhcpc {
    CISARGS cisargs;    <span class="co">// Common arguments</span>
    NTPARAM_DHCP param; <span class="co">// DHCP parameters</span>
} CI_SERVICE_DHCPC;

<span class="co">// DNS Server Service</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_service_dnss {
    CISARGS cisargs;    <span class="co">// Common arguments</span>
} CI_SERVICE_DNSSERVER;</code></pre></div>
<h4 id="specifying-network-services">4.3.2.4 Specifying Network Services</h4>
<h5 id="specifying-telnet-service-using-the-configuration">4.3.2.4.1 Specifying Telnet Service Using the Configuration</h5>
<p>The Telnet service can be specified as public because it can connect using any IP address, or an IP address of a specific interface. When accepting connections to any system IP address, the service is specified with the CALLBYIP flag and an IP address of INADDR_ANY. When a private connection is desired, the service is specified by the physical interface on which connections are allowed to occur. Because an IP address is required to initialize the service, the RESOLVEIP flag should also be set in the latter case. For example, the following code specifies that the telnet server should run using the IP address INADDR_ANY.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">telnet_example()
{
    CI_SERVICE_TELNET telnet;

    bzero( &amp;telnet, <span class="kw">sizeof</span>(telnet) );
    telnet.cisargs.IPAddr = INADDR_ANY;
    telnet.cisargs.pCbSrv = &amp;ServiceReport;
    telnet.param.MaxCon = <span class="dv">2</span>;
    telnet.param.Callback = &amp;ConsoleOpen;

    CfgAddEntry( hCfg, CFGTAG_SERVICE, CFGITEM_SERVICE_TELNET,
                 <span class="dv">0</span>, <span class="kw">sizeof</span>(telnet), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;telnet, <span class="dv">0</span> );
}</code></pre></div>
<p>The above code is all that is required when using the configuration system to invoke this service.</p>
<h5 id="specifying-dhcp-server-service-using-the-configuration">4.3.2.4.2 Specifying DHCP Server Service Using the Configuration</h5>
<p>Because the DHCP server service executes on a specific interface, it is never executed based on an IP address. Thus, it cannot be used with the CALLBYIP flag in the standard configuration service structure. However, because an IP host address is required to initialize the service on a specific interface, the RESOLVEIP flag should be set in cases where the IP address is not pre-assigned. For example, the following code specifies that the DHCP server should run on the interface specified by the physical index <em>dhcpsIdx</em>. Here, the home networks have already been written to the configuration, so the RESOLVEIP flag is not necessary. The address pool being used is already stored in <em>IPPoolBase</em> and <em>PoolSize</em>. The DHCPS is requested to report the local server address as a DNS server to DHCP clients.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">dhcp_server_example()
{
    CI_SERVICE_DHCPS dhcps;

    bzero( &amp;dhcps, <span class="kw">sizeof</span>(dhcps) );
    dhcps.cisargs.Mode = CIS_FLG_IFIDXVALID;
    dhcps.cisargs.IfIdx = dhcpsIdx;
    dhcps.cisargs.pCbSrv = &amp;ServiceReport;

    <span class="co">// Report our address as a DNS server to clients, and use the</span>
    <span class="co">// network's local domain name.</span>
    dhcps.param.Flags = DHCPS_FLG_LOCALDNS | DHCPS_FLG_LOCALDOMAIN;

    <span class="co">// Assign the IP address pool</span>
    dhcps.param.PoolBase = IPPoolBase;
    dhcps.param.PoolCount = PoolSize;

    CfgAddEntry( hCfg, CFGTAG_SERVICE, CFGITEM_SERVICE_DHCPSERVER, <span class="dv">0</span>,
                 <span class="kw">sizeof</span>(dhcps), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;dhcps, <span class="dv">0</span> );
}</code></pre></div>
<p>The above code is all that is required when using the configuration system to invoke this service.</p>
<h5 id="specifying-dhcp-client-service-using-the-configuration">4.3.2.4.3 Specifying DHCP Client Service Using the Configuration</h5>
<p>Because the DHCP client service executes on a specific interface, it is never executed based on an IP address. Thus, it cannot be used with the CALLBYIP flag in the standard configuration service structure. Also, because the service runs without an IP host address, the RESOLVEIP flag should never be set. For example, the following code specifies that the DHCP client should run on the interface specified by the physical Index <em>dhcpIdx</em>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">dhcp_client_example()
{
    CI_SERVICE_DHCPC dhcpc;

    bzero( &amp;dhcpc, <span class="kw">sizeof</span>(dhcpc) );
    dhcpc.cisargs.Mode = CIS_FLG_IFIDXVALID;
    dhcpc.cisargs.IfIdx = dhcpIdx;
    dhcpc.cisargs.pCbSrv = &amp;ServiceReport;
    CfgAddEntry( hCfg, CFGTAG_SERVICE, CFGITEM_SERVICE_DHCPCLIENT, <span class="dv">0</span>,
                 <span class="kw">sizeof</span>(dhcpc), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;dhcpc, <span class="dv">0</span> );
}</code></pre></div>
<p>The above code is all that is required when using the configuration system to invoke this service.</p>
<h5 id="specifying-dns-service-using-the-configuration">4.3.2.4.4 Specifying DNS Service Using the Configuration</h5>
<p>The service can be specified as public because it can connect using any IP address, or an IP address of a specific interface. When accepting connections to any system IP address, the service is specified with the CALLBYIP flag and an IP address of INADDR_ANY. When a private connection is desired, the service is specified by the physical interface on which connections are allowed to occur. Because an IP address is required to initialize the service, the RESOLVEIP flag should also be set in the latter case.</p>
<p>For example, the following code specifies that the server should run using the IP address INADDR_ANY.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">dns_server_example()
{
    CI_SERVICE_DNSSERVER dnss;

    bzero( &amp;dnss, <span class="kw">sizeof</span>(dnss) );
    dnss.cisargs.IPAddr = INADDR_ANY;
    dnss.cisargs.pCbSrv = &amp;ServiceReport;
    CfgAddEntry( hCfg, CFGTAG_SERVICE, CFGITEM_SERVICE_DNSSERVER, <span class="dv">0</span>,
                 <span class="kw">sizeof</span>(dnss), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;dnss, <span class="dv">0</span> );
}</code></pre></div>
<p>The above code is all that is required when using the configuration system to invoke this service.</p>
<h5 id="specifying-nat-service-using-the-configuration">4.3.2.4.5 Specifying NAT Service Using the Configuration</h5>
<p>Because the NAT service executes on a specified <em>public</em> interface, it is never executed based on an IP address. Thus, it cannot be used with the CALLBYIP flag in the standard configuration service structure. In addition, because the public IP host address is required to initialize the service, the RESOLVEIP flag should be set when the IP address is not pre-assigned.</p>
<p>For example, the following code specifies that the NAT service should run on the interface specified by the physical index <em>natIdx</em>. Here, the DHCP client service is used to obtain the public IP address (the address assigned to <em>natIdx</em>), so at this point the IP address is unknown. Thus, the RESOLVEIP flag is set in the execution mode parameter. This informs the configuration service manager not to invoke NAT until it has resolved an IP address for the target interface. The RESTART flag is also set to tell the service to restart NAT if a public IP address is lost and regained. In this example, it is assumed that all networks in the 192.168.x.x/255.255.0.0 subnet are part of the NAT group to be translated.</p>
<p>The MTU parameter to the NAT configuration allows the programmer to set a limit on the MTU negotiated during a TCP connection. This prevents TCP packet traffic from being unnecessarily fragmented. For example, when routing between Ethernet and PPPoE over NAT, the MTU should be set to the smaller MTU of the two, which is PPPoEs limit of 1492. In the example below, it is assumed that the system is Ethernet to Ethernet, and thus, it uses the full 1500.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">nat_service_example()
{
    CI_SERVICE_NAT nat;

    bzero( &amp;nat, <span class="kw">sizeof</span>(nat) );

    <span class="co">// Do not start NAT until we resolve an IP address on its IF</span>
    nat.cisargs.Mode = CIS_FLG_IFIDXVALID | CIS_FLG_RESOLVEIP |
                       CIS_FLG_RESTARTIPTERM;
    nat.cisargs.IfIdx = natIdx;
    nat.cisargs.pCbSrv = &amp;ServiceReport;

    <span class="co">// Include all 192.168.x.x addresses in NAT group</span>
    nat.param.IPVirt = htonl(<span class="bn">0xc0a80000</span>);
    nat.param.IPMask = htonl(<span class="bn">0xffff0000</span>);
    nat.param.MTU = <span class="dv">1500</span>;

CfgAddEntry( hCfg, CFGTAG_SERVICE, CFGITEM_SERVICE_NAT, <span class="dv">0</span>,
             <span class="kw">sizeof</span>(nat), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;nat, <span class="dv">0</span> ); }</code></pre></div>
<p>The above code is all that is required when using the configuration system to invoke this service.</p>
<p>To use NAT, it must be configured via the following function. Also, by default, the NAT code is not called by the stack. This increases stack efficiency when NAT is not in use. To enable the NAT module, the <em>IpNatEnable</em> element of the stack configuration structure must be set.</p>
<p>Note that when using the NAT service feature in NETTOOLS or when using the configuration system, this low-level configuration is not required.</p>
<h4 id="natsetconfig-configure-the-network-address-translation-module">NatSetConfig  Configure the Network Address Translation Module</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NatSetConfig( <span class="dt">uint32_t</span> IPAddr,
                   <span class="dt">uint32_t</span> IPMask,
                   <span class="dt">uint32_t</span> IPServer,
                   <span class="dt">uint32_t</span> MTU);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPAddr: IP address of the Virtual Network</li>
<li>IPMask: IP mask of the Virtual Network</li>
<li>IPServer: Physical IP address of the server that will host the NAT translation</li>
<li>MTU: IP Packet MTU (1500 for Ethernet, 1492 for PPPoE, etc.)</li>
</ul>
<p><strong>Description</strong> This function configures NAT with a virtual network and a physical server. Note that both the virtual and physical addresses must also be contained in the stacks route table. NAT should only be used when the stack is acting as a router, and when there are more than one Ethernet devices present.</p>
<p>The MTU parameter must be in the range of 64 to 1500. When set less than 1500, TCP connection negotiation will be altered so that TCP sessions through NAT will be limited to the MTU specified. This prevents unnecessary fragmentation when using NAT over dissimilar packet devices. (Note this MTU is the IP packet MTU, not the TCP MTU.)</p>
<p><a name="ip-network-specification"></a></p>
<h3 id="ip-network-specification-cfgtag_ipnet">4.3.3 IP Network Specification (CFGTAG_IPNET)</h3>
<p>The IPNET entry specifies what IP networks are to appear on which physical interfaces. When specifying an IPNET entry to the configuration, the Tag parameter is set to CFGTAG_IPNET, and the Item parameter is set to the Index (1 to n) of the physical interface on which the network is to appear.</p>
<p>The IPNET entry instance structure is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// IPNet Instance</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_ipnet {
    <span class="dt">uint32_t</span>    NetType;   <span class="co">// Network address type flags</span>
    <span class="dt">uint32_t</span>    IPAddr;    <span class="co">// IP Address</span>
    <span class="dt">uint32_t</span>    IPMask;    <span class="co">// Subnet Mask</span>
    <span class="dt">void</span>        *hBind;    <span class="co">// Binding handle (initially NULL)</span>
    <span class="dt">char</span>        Domain[CFG_DOMAIN_MAX]; <span class="co">// IPNet Domain Name</span>
} CI_IPNET;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>uint32_t NetType;</code> This is type of network that appears on the interface. The network type determines how the network is treated by some services like NAT, DHCP, and DNS. The value is a collection of one or more of the following flags.
<ul>
<li>CFG_NETTYPE_DYNAMIC: Address created by DHCP CLIENT</li>
<li>CFG_NETTYPE_VIRTUAL: Virtual Network used by DNS resolver</li>
<li>CFG_NETTYPE_DHCPS: Virtual Net Server reported by DHCP SERVER Most of the flags deal with the virtual network (or home network). If none of these flags are set, the network is a normal physical network. Note that virtual and non-virtual networks should not appear on the same interface. Also, only one network entry on each interface can have any of these flags set, although more than one of these flags can be set in that one entry.</li>
</ul></li>
<li><code>uint32_t IPAddr;</code> This is the IP address of the stack on the designated interface. When the NetType flag DHCPS is set, this address is also the gateway address reported to DHCP clients served by the DHCP server service.</li>
<li><code>uint32_t IPMask;</code> This is the IP network subnet mask.</li>
<li><code>void *hBind;</code> This is the stacks internal binding handle for the network. Each connected network is represented as a binding internally to the stack. This is discussed further in the appendices at the end of this document. The value should be initialized to NULL.</li>
<li><code>char Domain[CFG_DOMAIN_MAX];</code> This is the domain name of the network. It should be a full domain like home1.net, not just home1.</li>
</ul>
<p><a name="ip-gateway-route-specification"></a></p>
<h3 id="ip-gateway-route-specification-cfgtag_route">4.3.4 IP Gateway Route Specification (CFGTAG_ROUTE)</h3>
<p>The ROUTE entry specifies a route from one network to another via a specified IP gateway. When specifying a ROUTE entry to the configuration, the <em>Tag</em> parameter is set to CFGTAG_ROUTE, and the <em>Item</em> parameter is not used (set to zero).</p>
<p>The ROUTE entry instance structure is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Route Instance</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ci_route {
    <span class="dt">uint32_t</span>     IPDestAddr;  <span class="co">// Destination Network Address</span>
    <span class="dt">uint32_t</span>     IPDestMask;  <span class="co">// Subnet Mask of Destination</span>
    <span class="dt">uint32_t</span>     IPGateAddr;  <span class="co">// Gateway IP Address</span>
    <span class="dt">void</span>         *hRoute;     <span class="co">// Route handle (initially NULL)</span>
} CI_ROUTE;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><p><code>uint32_t IPDestAddr;</code> This is the IP base address of the IP network of the network that is made accessible via the IP gateway. This value should be pre-masked with the <em>IPDestMask</em> so that:</p>
<p><code>(IPDestAddr &amp; IPDestMask) = IPDestMask</code></p>
<p>This is used as a sanity check by the system. For a default route, the value is zero.</p></li>
<li><code>uint32_t IPDestMask;</code> This is the mask of the IP network accessible by the IP gateway. For a host route, the value is 0xFFFFFFFF, while for a default route, the value is zero.</li>
<li><code>uint32_t IPGateAddr;</code> This the IP address of the gateway through which the specified IP network is accessible. It must be an IP address that is available on a locally connected network, i.e., one gateway cannot point to another.</li>
<li><p><code>void *hRoute;</code> This is a handle to the route created by this configuration entry. All routes are represented as route handles internally to the stack. This is discussed further in the appendices at the end of this document. The value should be initialized to NULL.</p></li>
</ul>
<h3 id="client-record-specification-cfgtag_client">4.3.5 Client Record Specification (CFGTAG_CLIENT)</h3>
<p>The CLIENT entry specifies a record of a client that appears on the indicated physical interface. When specifying a CLIENT entry to the configuration, the <em>Tag</em> parameter is set to CFGTAG_CLIENT, and the <em>Item</em> parameter is set to the index (1 to n) of the physical interface on which the client appears.</p>
<p>Client records exist for two purposes:</p>
<ol>
<li>They are used to resolve DNS queries on virtual networks.</li>
<li>They are used by the DHCP server service to track DHCP clients on the serviced virtual network.</li>
</ol>
<p>Client records are created automatically in some DHCP server configurations (when using an address pool), but they can also be added manually. This allows an application to build a pre-defined fixed list of clients and their designated IP addresses on a virtual (home) network.</p>
<p>The CLIENT entry instance structure is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _ci_client {
    <span class="dt">uint32_t</span>  ClientType;          <span class="co">// Entry Status</span>
    <span class="dt">uint32_t</span>  Status;              <span class="co">// DHCPS Status (init to ZERO)</span>
    <span class="dt">uint32_t</span>  IPAddr;              <span class="co">// Client IP Address</span>
    <span class="dt">char</span>      MacAddr[<span class="dv">6</span>];          <span class="co">// Client Physical Address</span>
    <span class="dt">char</span>      Hostname[CFG_HOSTNAME_MAX]; <span class="co">// Client Hostname</span>
    <span class="dt">uint32_t</span>  TimeStatus;          <span class="co">// Time of last status change</span>
    <span class="dt">uint32_t</span>  TimeExpire;          <span class="co">// Expiration Time from TimeStatus</span>
} CI_CLIENT;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>uint32_t ClientType;</code> This is type of client record. There are only two types - those created by DHCP server from an address pool, and those created manually by an application.
<ul>
<li>CFG_CLIENTTYPE_DYNAMIC: Entry created via DHCPS</li>
<li>CFG_CLIENTTYPE_STATIC: Entry created manually</li>
</ul></li>
<li><code>uint32_t Status;</code> This is status of the client record. It is used by the DHCP server to track the state of the client and its lease to its IP address. The status can also be NULL for STATIC entries.
<ul>
<li>CFG_CLIENTSTATUS_PENDING: Supplied via DHCP OFFER</li>
<li>CFG_CLIENTSTATUS_VALID: Validated by DHCP REQUEST</li>
<li>CFG_CLIENTSTATUS_STATIC: Reported via DHCP INFORM or non-DHCP application</li>
<li>CFG_CLIENTSTATUS_INVALID: Invalidated by DHCP DECLINE</li>
</ul></li>
<li><code>uint32_t IPAddr;</code> This is IP address of the client.</li>
<li><code>char MacAddr[6];</code> This is physical Ethernet address of the client.</li>
<li><code>char Hostname[CFG_HOSTNAME_MAX];</code> This is the hostname of the client. It is recorded by the DHCP server service, even if the record is STATIC. Thus, when running DHCP server, even with a fixed client list, DHCP clients can specify their own host names, and these names will be available to the DNS resolver, i.e., DNS server and DNS client.</li>
<li><code>uint32_t TimeStatus;</code> This is the last time that the <em>Status</em> parameter was validated. It is thus the start time of a DHCP client lease.</li>
<li><code>uint32_t TimeExpire;</code> This is the total time in seconds of a DHCP client lease reported by the DHCP server to its clients. When using an address pool for the DHCP server, the server chooses this value.</li>
</ul>
<p><a name="client-user-account"></a></p>
<h3 id="client-user-account-cfgtag_acct">4.3.6 Client User Account (CFGTAG_ACCT)</h3>
<p>The ACCT entry specifies an account record of a client that has access to the system. When specifying an ACCT entry to the configuration, the Tag parameter is set to CFGTAG_ACCT, and the Item parameter is set to the account type. The NDK has only one generic account type. PPP authentication realms use this type. Valid types values are:</p>
<ul>
<li>CFGITEM_ACCT_SYSTEM: System user account (PPP)</li>
<li>CFGITEM_ACCT_PPP: PPP user account (SYSTEM)</li>
</ul>
<p>The ACCT entry instance structure is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _ci_acct {
    <span class="dt">uint32_t</span> Flags;                     <span class="co">// Account Flags</span>
    <span class="dt">char</span>     Username[CFG_ACCTSTR_MAX]; <span class="co">// Username</span>
    <span class="dt">char</span>     Password[CFG_ACCTSTR_MAX]; <span class="co">// Password</span>
} CI_ACCT;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>uint32_t Flags;</code> The flags determine the access granted by channel or group. The channels or groups that any given PPP server will allow is determined when the PPP server is invoked. A single client account can be a member of one or more groups, therefore, one or more of the following flags can be set:
<ul>
<li>CFG_ACCTFLG_CH1: Allow access to channel/group/realm 1</li>
<li>CFG_ACCTFLG_CH2: Allow access to channel/group/realm 2</li>
<li>CFG_ACCTFLG_CH3: Allow access to channel/group/realm 3</li>
<li>CFG_ACCTFLG_CH4: Allow access to channel/group/realm 4</li>
</ul></li>
<li><code>char Username[CFG_ACCTSTR_MAX];</code> This is the username of the client.</li>
<li><code>char Password[CFG_ACCTSTR_MAX];</code> This is the password corresponding to the supplied client username.</li>
</ul>
<p><a name="system-information-specification"></a></p>
<h3 id="system-information-specification-cfgtag_sysinfo">4.3.7 System Information Specification (CFGTAG_SYSINFO)</h3>
<p>The SYSINFO entry contains various types of global system information. There is no service callback function associated with these entries, as they are static information only. When specifying a SYSINFO entry to the configuration, the <em>Tag</em> parameter is set to CFGTAG_SYSINFO, and the <em>Item</em> parameter is set to the system information item in question.</p>
<p>Note that the first 256 values for <em>Item</em> are reserved for items that exactly match the corresponding DHCP protocol information tag value. For example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define CFGITEM_DHCP_DOMAINNAMESERVER 6 </span><span class="co">// Stack's DNS servers</span>
<span class="pp">#define CFGITEM_DHCP_HOSTNAME 12 </span><span class="co">// Stack's host name</span></code></pre></div>
<p>These values are read by various network services, and are written in one of two ways.</p>
<p>First, when the standard DHCP client is executing, it will take full control over the first 256 <em>Item</em> values. It fills in the entries when it obtains its address lease, and purges them when the lease expires. There is a set of default entries that the DHCP client will always request. Additional information requests can be made by configuring the DHCP client, and the resulting replies will be added to the configuration.</p>
<p>Second, when there is no DHCP client service, the network application must manually write values to the configuration for the <em>Item</em> values it views as important. A minimum configuration would include hostname, domain name, and a list of domain name servers. Note that multiple IP addresses should be stored as multiple instances of the same Item, not concatenated together with a longer byte length.</p>
<h3 id="extended-system-information-tags">4.3.8 Extended System Information Tags</h3>
<p>The following tag values are reserved for NDK and services configuration (see <a href="#ApxC">Appendix C</a> for more information on PPP realms):</p>
<ul>
<li>CFGITEM_SYSINFO_REALM1: Realm Name 1 (maximum 31 chars)</li>
<li>CFGITEM_SYSINFO_REALM2: Realm Name 2 (maximum 31 chars)</li>
<li>CFGITEM_SYSINFO_REALM3: Realm Name 3 (maximum 31 chars)</li>
<li>CFGITEM_SYSINFO_REALM4: Realm Name 4 (maximum 31 chars)</li>
<li>CFGITEM_SYSINFO_REALMPPP: Server Name for PPP (maximum 31 chars)</li>
<li>CFGITEM_SYSINFO_EVALCALLBACK: Callback function registered by application. It is used by the Evaluation version of the NDK to notify the application five minutes before the expiration of the 24-hour evaluation period.</li>
</ul>
<h3 id="os-ip-stack-configuration-item-specification-cfgtag_os-cfgtag_ip">4.3.9 OS / IP Stack Configuration Item Specification (CFGTAG_OS, CFGTAG_IP)</h3>
<p>The OS and IP tags specify entries that alter various configuration options that can be adjusted in the operating system and low-level stack operation. When specifying an entry to the configuration, the <em>Tag</em> parameter is set to CFGTAG_OS or CFGTAG_IP, and the <em>Item</em> parameter is set to the configuration item to set (these are listed below).</p>
<p>Creating a configuration entry results in an alteration of the systems internal configuration structures, but because these entries are also part of the configuration object (hCfg), they can be stored off and recorded as part of the <a href="#configuration-manager-api">CfgLoad()/CfgSave()</a> functionality. Thus, using the configuration API has a significant advantage over modifying the internal structures manually.</p>
<p>Removing an entry restores the default value to the internal stack configuration. Entries that are not present cannot be read, and an error return on read implies the entry is in its default state.</p>
<p>The following is the list of configuration items. All items are of type int or uint. They correspond exactly to the internal system configuration structures. For more information on these fields, see the internal configuration discussion in both the <a href="#configuration-structure">Section 2.1.1</a> section earlier in this document, and the Configuring the Stack section in the attached appendix <a href="#configuring-the-stack">Section A.11</a>.</p>
<p>When creating a configuration entry for one of these tags, the entry should be specified as unique. For example, to enable routing in the IP stack that code would be as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Enable IP routing</span>
<span class="dt">uint32_t</span> tmp = <span class="dv">1</span>;
CfgAddEntry(hCfg, CFGTAG_IP, CFGITEM_IP_IPFORWARDING,
            CFG_ADDMODE_UNIQUE, <span class="kw">sizeof</span>(uint), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;tmp, <span class="dv">0</span>);</code></pre></div>
<p>As another example, to set the size of the boot tasks stack, the code would be as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> rc = <span class="dv">4096</span>;
CfgAddEntry(hCfg, CFGTAG_OS, CFGITEM_OS_TASKSTKBOOT,
    CFG_ADDMODE_UNIQUE, <span class="kw">sizeof</span>(uint), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;rc, <span class="dv">0</span>);</code></pre></div>
<p>The following item values correspond directly to the OS and IP Stack configuration structures <code>_oscfg</code> and <code>_ipcfg</code>.</p>
<p>For more information on these structures, see <a href="#configuration-structure">Section 2.1.1</a> and <a href="#configuration-structure2">Section A.11.1</a>.</p>
<p>When <em>Tag</em> is CFGTAG_OS, the value of <em>Item</em> can be one of the following:</p>
<ul>
<li>CFGITEM_OS_DBGPRINTLEVEL: Debug message print threshold</li>
<li>CFGITEM_OS_DBGABORTLEVEL: Debug message abort threshold</li>
<li>CFGITEM_OS_TASKPRILOW: Lowest priority for stack task</li>
<li>CFGITEM_OS_TASKPRINORM: Normal priority for stack task</li>
<li>CFGITEM_OS_TASKPRIHIGH: Highest priority for stack task</li>
<li>CFGITEM_OS_TASKPRIKERN: Kernel-level priority (highest)</li>
<li>CFGITEM_OS_TASKSTKBOOT: Boot tasks stack size</li>
<li>CFGITEM_OS_TASKSTKLOW: Minimum stack size</li>
<li>CFGITEM_OS_TASKSTKNORM: Normal stack size</li>
<li>CFGITEM_OS_TASKSTKHIGH: Stack size for high volume tasks</li>
</ul>
<p>When <em>Tag</em> is CFGTAG_IP, the value of <em>Item</em> can be one of the following:</p>
<ul>
<li>CFGITEM_IP_ICMPDOREDIRECT: Add route on ICMP redirect (1 = Yes)</li>
<li>CFGITEM_IP_ICMPTTL: TTL for ICMP messages (RFC1700 says 64)</li>
<li>CFGITEM_IP_ICMPTTLECHO: TTL for ICMP echo (RFC1700 says 64)</li>
<li>CFGITEM_IP_IPINDEXSTART: IP Protocol Start Index</li>
<li>CFGITEM_IP_IPFORWARDING: IP Forwarding Enable (1 = Yes)</li>
<li>CFGITEM_IP_IPNATENABLE: IP NAT Translation Enable (1 = Yes)</li>
<li>CFGITEM_IP_IPREASMMAXTIME: Maximum IP reassembly time in seconds</li>
<li>CFGITEM_IP_IPREASMMAXSIZE: Maximum IP reassembly packet size</li>
<li>CFGITEM_IP_DIRECTEDBCAST: Support directed BCast IP addresses (1 = Yes)</li>
<li>CFGITEM_IP_TCPREASMMAXPKT: Maximum out of order packets held by TCP socket</li>
<li>CFGITEM_IP_RTCENABLEDEBUG: Enable route control dbg messages (1 = Yes)</li>
<li>CFGITEM_IP_RTCADVTIME: Time in sec to send Router Adv. (0 = dont)</li>
<li>CFGITEM_IP_RTCADVLIFE: Lifetime of route in RtAdv if active</li>
<li>CFGITEM_IP_RTCADVPREF: Preference of route in RtAdv if active</li>
<li>CFGITEM_IP_RTARPDOWNTIME: Time 5 failed ARPs keeps route down</li>
<li>CFGITEM_IP_RTKEEPALIVETIME: Timeout of validated route in seconds</li>
<li>CFGITEM_IP_RTARPINACTIVITY: Time in seconds beyond which an unused route is considered <em>inactive</em> and is cleaned up.</li>
<li>CFGITEM_IP_RTCLONETIMEOUT: Timeout of newly cloned route in seconds</li>
<li>CFGITEM_IP_RTDEFAULTMTU: MTU for internal routes</li>
<li>CFGITEM_IP_RTGARP: Set processing policy of received gratuitous ARP packets</li>
<li>CFGITEM_IP_SOCKTTLDEFAULT: Default IP TTL for Sockets</li>
<li>CFGITEM_IP_SOCKTOSDEFAULT: Default IP TOS for Sockets</li>
<li>CFGITEM_IP_SOCKMAXCONNECT: Maximum connections on listening socket</li>
<li>CFGITEM_IP_SOCKTIMECONNECT: Maximum time for connect socket</li>
<li>CFGITEM_IP_SOCKTIMEIO: Default Maximum time for socket send/rcv</li>
<li>CFGITEM_IP_SOCKTCPTXBUF: TCP Transmit allocated buffer size</li>
<li>CFGITEM_IP_SOCKTCPRXBUF: TCP Receive allocated buffer size (copy mode)</li>
<li>CFGITEM_IP_SOCKTCPRXLIMIT: TCP Receive limit (non-copy mode)</li>
<li>CFGITEM_IP_SOCKUDPRXLIMIT: UDP/RAW Receive limit</li>
<li>CFGITEM_IP_SOCKMINTX: Default min Tx space for able to write</li>
<li>CFGITEM_IP_SOCKMINRX: Default min Rx data for able to read</li>
<li>CFGITEM_IP_PIPETIMEIO: Maximum time for pipe send/rcv call</li>
<li>CFGITEM_IP_PIPEBUFMAX: Pipe internal buffer size</li>
<li>CFGITEM_IP_PIPEMINTX: Pipe min Tx space for able to write</li>
<li>CFGITEM_IP_PIPEMINRX: Pipe min Rx data for able to read</li>
<li>CFGITEM_IP_TCPKEEPIDLE: Idle time before 1st TCP keep probe</li>
<li>CFGITEM_IP_TCPKEEPINTVL: TCP keep probe interval</li>
<li>CFGITEM_IP_TCPKEEPMAXIDLE: Maximum TCP keep probing time before drop</li>
<li>CFGITEM_IP_ICMPDONTREPLYBC: Do not reply to ICMP Echo Request packets sent to broadcast/directed broadcast IP addresses (1 = Yes)</li>
<li>CFGITEM_IP_ICMPDONTREPLYMC: Do not reply to ICMP Echo Request packets sent to multicast IP addresses (1 = Yes)</li>
<li>CFGITEM_IP_ICMPDONTREPLYEC: Do not reply to any ICMP Echo Request packet (0=Reply)</li>
<li>CFGITEM_IP_UDPSENDICMPUNREACH: Reply with ICMP Unreachable packet to connection attempts to a not listened UDP port (1=Reply)</li>
<li>CFGITEM_IP_TCPSENDRST: Reply with RST packet to connection attempts to a not listened TCP port (1=Reply)</li>
<li>CFGITEM_IP_SOCKRAWETHRXLIMIT: Raw Ethernet socket receive limit</li>
<li>CFGITEM_IP_MAX: Maximum CFGTAG_STACK item</li>
</ul>
<p><a name="initialization-procedures"></a></p>
<h2 id="initialization-procedure">4.4 Initialization Procedure</h2>
<p>For applications that do not use XGCONF configuration, the basic process of stack initialization is as follows:</p>
<ol>
<li>Initialize the operating system environment with the initialization function <em>NC_SystemOpen( Priority, OpMode )</em>. This function must always be called first - before any other NDK related function. The calling parameters determine the priority and operating mode of the network event scheduler.</li>
<li>Create a new configuration via <em>CfgNew()</em>.</li>
<li>Build the new configuration via configuration API calls, or load a previous configuration from non-volatile memory using <em>CfgLoad()</em>.</li>
<li>Boot the stack with the configuration by calling <em>NC_NetStart( hCfg, pfnStart, pfnStop, pfnNetIP )</em> with a handle to the configuration, plus pointers to three user supplied callback functions for start, stop, and IP address change operations. The <em>NC_NetStart()</em> function does not return until the stack session has terminated. The configuration handle <em>hCfg</em> becomes the default configuration for the system.</li>
<li>After some preliminary initialization, the <em>NC_NetStart()</em> function creates a new thread that calls the user supplied callback function for the start operation. At this point, the callback function creates task threads for its networking requirements. This start function does not need to return immediately, but should return at some point - i.e., the callback function should not take permanent control of the calling thread. If system shutdown is initiated before the start function returns, some resources may not be freed.</li>
<li>Under normal operation, the network does not shut down until the <em>NC_NetStop()</em> function is called. At some point after a call to <em>NC_NetStop()</em>, the original <em>NC_NetStart()</em> thread calls the user supplied callback function for the stop operation. In this callback function, the application shuts down any operation it initiated in the start callback function and frees any allocated resources. After the stop callback function returns, NDK functionality is no longer available.</li>
<li>The original call to <em>NC_NetStart()</em> returns with the return value as set by the return parameter passed in the call to <em>NC_NetStop()</em>. The application can immediately reboot the NDK by calling <em>NC_NetStart()</em> again, with or without reloading a new configuration. This is useful for a reboot command.</li>
</ol>
<p>When the system is ready for a final shutdown, the following actions are performed:</p>
<ol>
<li>When <em>NC_NetStart()</em> returns and the session is over, call the <em>CfgFree()</em> function to free the configuration handle created with <em>CfgNew()</em>.</li>
<li>After all resources have been freed, call the <em>NC_SystemClose()</em> function to complete the system shutdown.</li>
</ol>
<h2 id="network-control-initialization-procedure-netctrl">4.5 Network Control Initialization Procedure (NETCTRL)</h2>
<p>The stack library includes code to perform system initialization based on the configuration. Initialization of the scheduling routines is performed by a network control layer called NETCTRL.</p>
<p>If you use the XGCONF configuration tool to configure the NDK, the following custom C functions are generated for you to manage NDK startup and thread scheduling. See the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) for details. You should take care not to create functions in your own application with these names.</p>
<ul>
<li><em>ti_ndk_config_Global_stackThread()</em>: The NDK stack thread function.</li>
<li><em>networkOpen()</em>: function that is called automatically by <em>NC_NetStart()</em>.</li>
<li><em>networkClose()</em>: function that is called automatically by <em>NC_NetStart()</em>.</li>
<li><em>networkIPAddr()</em>: function that is called automatically by <em>NC_NetStart()</em>.</li>
<li><em>ti_ndk_config_Global_serviceReport()</em>: Service report callback function.</li>
</ul>
<h3 id="initialization-procedure-1">4.5.1 Initialization Procedure</h3>
<p>If you use the Configuration Manager API to configure your application, see <a href="#initialization-procedure">Section 4.4</a> for the stack initialization process.</p>
<p>If you use the XGCONF configuration tool to configure the NDK, the <em>ti_ndk_config_Global_stackThread()</em> function is automatically generated to handle the initialization process and to act as the NDK scheduler thread. You can use XGCONF to configure Hook functions to be called at various point during the initialization and thread scheduling. See the section on Global Hook Configuration in the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>).</p>
<p>If you use the XGCONF configuration tool to configure the NDK, the basic process of stack initialization occurs as follows:</p>
<ol>
<li>Run the <strong>Stack Thread Begin</strong> (Global.stackBeginHook) hook function if one is configured. Note that no NDK-related code can run in this hook function because the <em>NC_SystemOpen()</em> function has not yet run.</li>
<li>Initialize the operating system environment with the initialization function <em>NC_SystemOpen( Priority, OpMode )</em>. This function must always be called first - before any other NDK related function. The calling parameters determine the priority and operating mode of the network event scheduler.</li>
<li>Create a new configuration via <em>CfgNew()</em> (which is called from generated code).</li>
<li>Run the <strong>Stack Thread Initialization</strong> (Global.stackInitHook) hook function if one is configured.</li>
<li>The generated <em>ti_ndk_config_Global_stackThread()</em> function builds the new configuration via code generated from the XGCONF configuration.</li>
<li>Boot the stack with the configuration by calling <em>NC_NetStart( hCfg, pfnStart, pfnStop, pfnNetIP )</em> with a handle to the configuration, plus pointers to the three generated functions for start, stop, and IP address change operations. The <em>NC_NetStart()</em> function does not return until the stack session has terminated.</li>
<li>After some preliminary initialization, the <em>NC_NetStart()</em> function creates a new thread that calls the generated <em>networkOpen()</em> function.</li>
<li>Run the <strong>Network Open</strong> (Global.networkOpenHook) hook function if one is configured.</li>
<li>The <em>networkOpen()</em> function creates task threads for its networking requirements.</li>
<li>Under normal operation, the network does not shut down until the <em>NC_NetStop()</em> function is called. <em>NC_NetStop()</em> is called by the generated <em>networkClose()</em> function.</li>
<li>Run the <strong>Network Close</strong> (Global.networkCloseHook) hook function if one is configured. In this hook function, the application should shut down any operation it initiated in the Network Open hook function and free any allocated resources.</li>
<li>After the <em>networkClose()</em> function returns, NDK functionality is no longer available.</li>
<li>The original call to <em>NC_NetStart()</em> returns with the return value as set by the return parameter passed in the call to <em>NC_NetStop()</em>.</li>
<li>The application can immediately reboot the NDK by calling <em>NC_NetStart()</em> again, with or without reloading a new configuration. This is useful for a reboot command.</li>
</ol>
<p>When the system is ready for a final shutdown, the following actions are performed:</p>
<ol>
<li>When <em>NC_NetStart()</em> returns and the session is over, run the <strong>Stack Thread Delete</strong> (Global.stackDeleteHook) hook function if one is configured.</li>
<li>Call the <em>CfgFree()</em> function to free the configuration handle created with <em>CfgNew()</em>.</li>
<li>After all resources have been freed, call the <em>NC_SystemClose()</em> function to complete the system shutdown.</li>
</ol>
<h3 id="function-overview-7">4.5.2 Function Overview</h3>
<p>The system initialization access functions (in functional order) are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NC_SystemOpen()</td>
<td>Initiate a system session</td>
</tr>
<tr class="even">
<td>NC_SystemClose()</td>
<td>Full system shutdown</td>
</tr>
<tr class="odd">
<td>NC_NetStart()</td>
<td>Start the network with a supplied configuration</td>
</tr>
<tr class="even">
<td>NC_NetStop()</td>
<td>Halt the network, and pass a return code the caller of the <em>NC_NetStart()</em> function</td>
</tr>
</tbody>
</table>
<p>For API details, refer to the <a href="html/group__ti__ndk__inc__netctrl__NC.html">NETCTRL Module in the NDK API Reference Guide</a>.</p>
<h1 id="network-tools-library---support-functions">5 Network Tools Library - Support Functions</h1>
<p>Included with the stack package is a library of network tools. It provides auxiliary functionality to the stack library and contains source written to the socket layer that would normally be considered application level code. The library file is called NETTOOLS.LIB, and can be accessed by an application that includes the file NETTOOLS.H.</p>
<p>The support supplied by NETTOOLS can be categorized into two classes: support functions and services. The support functions consist of a programming API that can aid the development of network applications, while services are servers that execute on the stack platform.</p>
<p>This section describes the NETTOOLS support functions. Please note that these services are all IPv4 based. Based on the IPv6 documentation, these applications can be easily re-written to use IPv6 sockets instead for communication.</p>
<h2 id="generic-support-calls">5.1 Generic Support Calls</h2>
<p>This section contains a selection of functions that can be very useful when programming network applications. Some are standard Berkeley Software Distribution (BSD) Socket APIs, while others are custom to the stackdesigned to save you the time and trouble of programming directly to the stack API.</p>
<h3 id="function-overview-8">5.1.1 Function Overview</h3>
<p>The following is a summary of the support functions described in this section:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>inet_addr()</td>
<td>Convert a string to a 32 bit IP address in network format</td>
</tr>
<tr class="even">
<td>inet_aton()</td>
<td>Convert a string to an <em>in_addr</em> structure record</td>
</tr>
<tr class="odd">
<td>NtAddNetwork()</td>
<td>Add a host network to a logical interface handle</td>
</tr>
<tr class="even">
<td>NtRemoveNetwork()</td>
<td>Remove a network added with <em>NtAddNetwork()</em></td>
</tr>
<tr class="odd">
<td>NtAddStaticGateway()</td>
<td>Add a static gateway route to the route table</td>
</tr>
<tr class="even">
<td>NtRemoveStaticGateway()</td>
<td>Remove a static gateway route</td>
</tr>
<tr class="odd">
<td>NtIfIdx2Ip()</td>
<td>Get the IP host address assigned to a physical interface Index</td>
</tr>
<tr class="even">
<td>NtGetPublicHost()</td>
<td>Get the system public IP address and domain name</td>
</tr>
<tr class="odd">
<td>NtIPN2Str()</td>
<td>Convert 32 bit IP address in network format to string</td>
</tr>
</tbody>
</table>
<h3 id="network-tools-support-api-functions">5.1.2 Network Tools Support API Functions</h3>
<h4 id="inet_addr-return-32-bit-binary-network-ordered-ipv4-address">inet_addr  Return 32-bit Binary Network Ordered IPv4 Address</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> inet_addr(<span class="dt">char</span> *strptr);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>strptr: Pointer to character string</li>
</ul>
<p><strong>Return Value</strong> IP address or NULL.</p>
<p><strong>Description</strong> This function converts an IP address printed in a character string to a 32-bit network ordered IP address value. Note that leading 0s in the address string are interpreted as octal. The function returns NULL on failure.</p>
<p>This function actually calls <em>inet_aton()</em>, which is the better form of the function.</p>
<h4 id="inet_aton-convert-ip-address-from-string-and-return-in-in_addr-structure">inet_aton  Convert IP Address from String and Return in in_addr Structure</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> inet_aton( <span class="dt">char</span>           *strptr,
               <span class="kw">struct</span> in_addr *pa );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>strptr: Pointer to character string</li>
<li>pa: Pointer to address structure</li>
</ul>
<p><strong>Return Value</strong> 1 upon success; 0 upon failure.</p>
<p><strong>Description</strong> This function converts an IP address printed in a character string to a 32-bit network ordered IP address value. Note that leading 0s in the address string are interpreted as octal. The function return writes the IP address into the <em>in_addr</em> structure pointed to by the <em>pa</em> parameter. The function returns 1 on success and 0 on failure.</p>
<h4 id="ntaddnetwork-add-host-network-to-interface-by-if-handle">NtAddNetwork  Add Host Network to Interface by IF Handle</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *NtAddNetwork( <span class="dt">void</span>     *hIF,
                    <span class="dt">uint32_t</span> IPHost,
                    <span class="dt">uint32_t</span> IPMask);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hIF: Handle to target interface</li>
<li>IPHost: IP Host Address (in network format)</li>
<li>IPMask: IP Host Subnet Mask (in network format)</li>
</ul>
<p><strong>Return Value</strong> Handle to network binding on success or NULL on failure.</p>
<p><strong>Description</strong> This function attempts to add the specified IP host address (and mask) to the specified logical interface handle. The function returns a handle to the binding that binds the IP address to the interface. On an error, the function returns NULL. The most common error would be that adding the host address caused a duplicate IP indication from another host.</p>
<blockquote>
<p><strong>NOTE:</strong> In place of this function, consider using the configuration system with the CFGTAG_IPNET configuration entry (see <a href="#ip-network-specification">Section 4.3.3</a>).</p>
</blockquote>
<h4 id="ntremovenetwork-remove-host-network-from-interface">NtRemoveNetwork  Remove Host Network from Interface</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NtRemoveNetwork( <span class="dt">void</span> *hBind );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hBind: Handle to network binding returned by <em>NtAddNetwork()</em>.</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function removes a network that was previously added with <em>NtAddNetwork()</em>.</p>
<h4 id="ntaddstaticgateway-add-static-gateway-route-to-the-route-table">NtAddStaticGateway  Add Static Gateway Route to the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *NtAddStaticGateway( <span class="dt">uint32_t</span> IPDestAddr,
                          <span class="dt">uint32_t</span> IPDestMask,
                          <span class="dt">uint32_t</span> IPGateAddr);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPDestAddr: IP address of destination (in network format)</li>
<li>IPDestMask: IP subnet mask of destination (in network format)</li>
<li>IPGateAddr: IP address of next hop gateway (in network format)</li>
</ul>
<p><strong>Return Value</strong> Handle to newly created route or NULL on error.</p>
<p><strong>Description</strong> This function adds a static gateway route to the system route table.</p>
<p><em>IPDestAddr</em> is the IP base address of the IP network of the network that is made accessible via the IP gateway. This value should be pre-masked with the IPDestMask so that:</p>
<p><code>(IPDestAddr &amp; IPDestMask) = IPDestMask</code></p>
<p>This is used as a sanity check by the system. For a default route, the value is zero.</p>
<p><em>IPDestMask</em> is the mask of the IP network accessible by the IP gateway. For a host route, the value is 0xFFFFFFFF, while for a default route, the value is zero.</p>
<p><em>IPGateAddr</em> is the IP address of the gateway through which the specified IP network is accessible. It must be an IP address that is available on a locally connected network, i.e., one gateway cannot point to another.</p>
<p>The function returns a handle to the route created by this configuration entry. All routes are represented as route handles internally to the stack. This is discussed further in the appendices at the end of this document. Note that the handle returned here is <em>not</em> referenced (see the appendix for more details). All it means for the purposes of this function is that the handle can be discarded by the caller. It will remain valid until the route is removed via <em>NtRemoveStaticGateway()</em>.</p>
<blockquote>
<p><strong>NOTE:</strong> In place of this function, consider using the configuration system with the CFGTAG_ROUTE configuration entry (see <a href="#ip-gateway-route-specification">Section 4.3.4</a>).</p>
</blockquote>
<h4 id="ntremovestaticgateway-remove-static-gateway-route-from-the-route-table">NtRemoveStaticGateway  Remove Static Gateway Route from the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NtRemoveStaticGateway( <span class="dt">uint32_t</span> IPTarget );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPTarget: IP address of destination to remove (in network format)</li>
</ul>
<p><strong>Return Value</strong> Returns 1 if the route was removed, or 0 if it was not found.</p>
<p><strong>Description</strong> This function removes a static gateway route from the system route table. It searches for the route by destination IP address and will remove the first matching static route it finds. Note that only routes with both the GATEWAY and STATIC flags set are considered for removal.</p>
<h4 id="ntifidx2ip-get-the-32-bit-representation-of-the-ip-address-of-an-interface-index">NtIfIdx2Ip  Get the 32-bit Representation of the IP Address of an Interface Index</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NtIfIdx2Ip( <span class="dt">uint32_t</span> IfIdx,
                <span class="dt">uint32_t</span> *pIPAddr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IfIdx: Index of physical interface</li>
<li>pIPAddr: Pointer to receive IP address</li>
</ul>
<p><strong>Return Value</strong> Returns 1 if an address was found, or 0 if it was not found.</p>
<p><strong>Description</strong> This function obtains the first IP host address found that is assigned to the supplied interface Index. The host address (in network format) is written to the pointer <em>pIPAddr</em>.</p>
<h4 id="ntgetpublichost-get-the-system-public-ip-address-and-domain-name">NtGetPublicHost  Get the System Public IP Address and Domain Name</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NtGetPublicHost( <span class="dt">uint32_t</span>      *pIPAddr,
                     <span class="dt">uint32_t</span>      MaxSize,
                     <span class="dt">unsigned</span> <span class="dt">char</span> *pDomain);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pIPAddr: Pointer to receive IP address</li>
<li>MaxSize: Size of string buffer pointed to by <em>pDomain</em></li>
<li>pDomain: Pointer to string buffer to receive domain name</li>
</ul>
<p><strong>Return Value</strong> Returns 1 if information was found, or 0 if it was not found.</p>
<p><strong>Description</strong> This function gets the best IP address and domain name to use for access to the external network. For determining the best address and domain name, public addresses and domain names are preferred over IP addresses and domain names of virtual networks. The IP address (in network format) is written to <em>pIPAddr</em>, and the domain name is copied to <em>pDomain</em>.</p>
<h4 id="ntipn2str-convert-32-bit-ip-address-in-network-format-to-string">NtIPN2Str  Convert 32-bit IP Address in Network Format to String</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NtIPN2Str( <span class="dt">uint32_t</span> IPAddr,
                <span class="dt">char</span>     *pStrBuffer );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPAddr: IP address in network format</li>
<li>pStrBuffer: Pointer to receive IP address string</li>
</ul>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This function performs a <em>sprintf()</em> of the IP address supplied in IPAddr to the buffer supplied in <em>pStrBuffer</em>. Note that no buffer size is provided. This is because the size is deterministic, and will not exceed 16 characters (including the NULL terminator).</p>
<h2 id="dns-support-calls">5.2 DNS Support Calls</h2>
<p>The concepts and code behind the Unix <em>gethostbyname()</em> and <em>gethostbyaddr()</em> functions is extensive, and there are public domain versions available, which can be easily run on the IP stack library.</p>
<p>Although the code to support the whole name, address and server database is quite large, the basic name resolution functions are quite useful. For this reason, the stack provides a basic form of these function calls, without incurring the overhead associated with a full implementation. The DNS resolver used by these client functions is the same as accessed by the DNS server. When the configuration contains client machine records (i.e., controls local domain names), these entries are checked when the matching domain is encountered. Otherwise (and for all other queries), the query is resolved via external DNS servers.</p>
<p>In addition to providing a more compact implementation, the calls provided here are reentrant, which is not true of the standard Unix counterparts.</p>
<h3 id="function-overview-9">5.2.1 Function Overview</h3>
<p>The following is a summary of the support functions described in this section:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DNSGetHostname()</td>
<td>Return the hostname of the current host</td>
</tr>
<tr class="even">
<td>DNSGetHostByAddr()</td>
<td>Resolve a hostname from an IP address</td>
</tr>
<tr class="odd">
<td>DNSGetHostByName()</td>
<td>Resolve a hostname and IP address from a hostname</td>
</tr>
</tbody>
</table>
<h3 id="standard-types-and-definitions">5.2.2 Standard Types and Definitions</h3>
<h3 id="host-entry-structure">5.2.2.1 Host Entry Structure</h3>
<p>The DNS client functions all take a pointer to a buffer. They treat this buffer as a pointer to a host entry structure. If the function takes a pointer to a scrap buffer, a host entry structure is allocated from the start of this scrap buffer. Thus, on successful return from one of these calls, the pointer to the scrap buffer may be treated as a pointer to a host entry structure.</p>
<p>The structure differs slightly from the conventional definition. It is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// Host Entry Structure</span>
<span class="co">//</span>
<span class="kw">struct</span> _hostent {
    <span class="dt">char</span>        *h_name;     <span class="co">// Official name of host</span>
    <span class="dt">int</span>         h_addrtype; <span class="co">// Address Type (AF_INET)</span>
    <span class="dt">int</span>         h_length;   <span class="co">// Address Length (4)</span>
    <span class="dt">int</span>         h_addrcnt;  <span class="co">// Number of IP addresses found</span>
    <span class="dt">uint32_t</span>    h_addr[<span class="dv">8</span>];  <span class="co">// List of up to 8 IP addresses (network format)</span>
};

<span class="kw">typedef</span> <span class="kw">struct</span> _hostent HOSTENT;</code></pre></div>
<h3 id="function-return-codes">5.2.2.2 Function Return Codes</h3>
<p>DNS functions that return an error code use the following definitions. Those that are obtained directly from a DNS response packet are so noted:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NDK_DNS_NOERROR</td>
<td>0</td>
<td>(DNS Reply Code) No error</td>
</tr>
<tr class="even">
<td>NDK_DNS_EFORMERR</td>
<td>1</td>
<td>(DNS Reply Code) Format error</td>
</tr>
<tr class="odd">
<td>NDK_DNS_ESERVFAIL</td>
<td>2</td>
<td>(DNS Reply Code) Server failure</td>
</tr>
<tr class="even">
<td>NDK_DNS_ENXDOMAIN</td>
<td>3</td>
<td>(DNS Reply Code) Non-existent domain</td>
</tr>
<tr class="odd">
<td>NDK_DNS_ENOTIMP</td>
<td>4</td>
<td>(DNS Reply Code) Not implemented</td>
</tr>
<tr class="even">
<td>NDK_DNS_EREFUSED</td>
<td>5</td>
<td>(DNS Reply Code) Query refused</td>
</tr>
<tr class="odd">
<td>NDK_DNS_EOVERFLOW</td>
<td>16</td>
<td>Scrap Buffer Overflow</td>
</tr>
<tr class="even">
<td>NDK_DNS_EMEMERROR</td>
<td>17</td>
<td>Memory Allocation Error (used for packets and temp storage)</td>
</tr>
<tr class="odd">
<td>NDK_DNS_ESOCKETERROR</td>
<td>18</td>
<td>Socket Error (call <em>fdError()</em> for socket error number)</td>
</tr>
<tr class="even">
<td>NDK_DNS_ENODNSREPLY</td>
<td>19</td>
<td>No DNS server response</td>
</tr>
</tbody>
</table>
<h3 id="dns-support-api-functions">5.2.3 DNS Support API Functions</h3>
<h4 id="dnsgethostname-return-the-hostname-of-the-current-host">DNSGetHostname  Return the Hostname of the Current Host</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> DNSGetHostname( <span class="dt">char</span> *pNameBuf,
                    <span class="dt">int</span>  size );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNameBuf: Pointer to a buffer to accept the hostname</li>
<li>size: Size of the supplied buffer in bytes</li>
</ul>
<p><strong>Return Value</strong> Error code as defined above.</p>
<p><strong>Description</strong> This function is quite similar to BSDs <em>gethostname()</em>. It requests the hostname of the systems public IP address (as obtained from <em>NtGetPublicHost()</em>). The hostname is copied into the buffer pointed to by <em>pNameBuf</em> with a maximum size of <em>size</em>. The name is NULL terminated when space allows.</p>
<h4 id="dnsgethostbyaddr-resolve-a-hostname-from-an-ip-address">DNSGetHostByAddr  Resolve a Hostname from an IP Address</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> DNSGetHostByAddr( <span class="dt">uint32_t</span> IPAddr,
                      <span class="dt">void</span>     *pScrapBuf,
                      <span class="dt">int</span>      size );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPAddr: IP address to resolve, in network format</li>
<li>pScrapBuf: Pointer to a scrap buffer from which a HOSTENT structure will be allocated</li>
<li>size: Size of the supplied scrap buffer in bytes</li>
</ul>
<p><strong>Return Value</strong> Error code as defined above.</p>
<p><strong>Description</strong> This function is quite similar to BSDs <em>gethostbyaddr()</em>. It uses DNS to resolve a hostname from the supplied IP address. On a successful return, <em>pScrapBuf</em> can be treated as a HOSTENT structure. The size of the scrap buffer (<em>size</em>) must be greater than the size of the structure as the structure will contain pointers into the scrap buffer, and the scrap buffer is also used for temporary name storage. 512 bytes should be sufficient for most requests.</p>
<h4 id="dnsgethostbyname-resolve-a-hostnameaddress-from-a-hostname">DNSGetHostByName  Resolve a Hostname/Address from a Hostname</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> DNSGetHostByName( <span class="dt">char</span> *Name,
                      <span class="dt">void</span> *pScrapBuf,
                      <span class="dt">int</span>  size);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Name: Null terminated Hostname to resolve (with or without trailing .)</li>
<li>pScrapBuf: Pointer to a scrap buffer from which a HOSTENT structure will be allocated</li>
<li>size: Size of the supplied scrap buffer in bytes</li>
</ul>
<p><strong>Return Value</strong> Error code as defined above.</p>
<p><strong>Description</strong> This function is quite similar to BSDs <em>gethostbyname()</em>. It uses DNS to resolve an official hostname and address from the supplied hostname. On a successful return, pScrapBuf can be treated as a HOSTENT structure. The size of the scrap buffer (size) must be greater than the size of the structure as the structure will contain pointers into the scrap buffer, and the scrap buffer is also used for temporary name storage. 512 bytes should be sufficient for most requests.</p>
<p>If the hostname <em>Name</em> is terminated with a dot (.), the dot is removed prior to lookup. If a dot appears anywhere in <em>Name</em>, an initial lookup on the unaltered name is attempted. If <em>Name</em> does not contain a dot, or if the initial lookup fails, the default domain name (from <em>NtGetPublicHost()</em>) is appended to the end of the supplied name. For example, if the domain name obtained from <em>NtGetPublicHost()</em> was ti.com, then a request for host.sc would attempt to resolve host.sc first, and then host.sc.ti.com, while a request for host would attempt to resolve host.sc.ti.com on the initial attempt.</p>
<h2 id="tftp-support">5.3 TFTP Support</h2>
<p>TFTP is supported via the received function. More information on TFTP can be found in RFC783, released by the Internet Engineering Task Force (IETF) organization.</p>
<h3 id="tftp-support-api-functions">5.3.1 TFTP Support API Functions</h3>
<p>TFTP is accessed through this API. The network tools include the file <code>NETTOOLS.H</code>, which is required.</p>
<h4 id="nttftprecv-retrieve-data-from-a-tftp-server">NtTftpRecv  Retrieve Data from a TFTP Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> NtTftpRecv( <span class="dt">uint32_t</span> TftpIp,
                <span class="dt">char</span>     *szFileName,
                <span class="dt">char</span>     *pFileBuffer,
                <span class="dt">uint32_t</span> *pFileSize,
                <span class="dt">uint16_t</span> *pErrorCode);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>TftpIp: IP Address in network format</li>
<li>szFileName: Pointer to null terminated filename string</li>
<li>pFileBuffer: Pointer to buffer to receive file data</li>
<li>pFileSize: Pointer to size of buffer on input, returns as size needed or used</li>
<li>pErrorCode: Pointer to where to write TFTP server error code (if any)</li>
</ul>
<p><strong>Return Value</strong> This function returns an error code indicating the results of the operation. Negative codes are error conditions.</p>
<p>In the following cases, <em>pFileSize</em> is set to the actual file size:</p>
<ul>
<li>0: Successful transfer and copy</li>
<li>1: Successful transfer, with partial copy (file size too large)</li>
</ul>
<p>In the following cases, <em>pFileSize</em> is set to the actual number of bytes copied:</p>
<ul>
<li>TFTPERROR_ERRORREPLY: Error returned by TFTP server (see below)</li>
<li>TFTPERROR_BADPARAM: Invalid calling parameters</li>
<li>TFTPERROR_RESOURCES: Memory allocation error during transfer</li>
<li>TFTPERROR_SOCKET: Internal socket error during transfer</li>
<li>TFTPERROR_FAILED: TFTP failed (e.g., server did not reply)</li>
</ul>
<p>In the case of TFTPERROR_ERRORREPLY, the server error code written to <em><em>pErrorCode</em> should be one of the following standard TFTP codes, and the error message is copied to pFileBuffer</em>:</p>
<ul>
<li>0: Not defined, see error message (if any).</li>
<li>1: File not found.</li>
<li>2: Access violation.</li>
<li>3: Disk full or allocation exceeded.</li>
<li>4: Illegal TFTP operation.</li>
<li>5: Unknown transfer ID.</li>
<li>6: File already exists.</li>
<li>7: No such user.</li>
</ul>
<p><strong>Description</strong> TFTP (Trivial File Transfer Protocol), allows files to be transferred from a remote machine.</p>
<p>This function attempts to receive the file with the filename designated by <em>szFileName</em> from the TFTP server with the IP address in <em>TftpIp</em>, and copy the data into the memory buffer pointed to by <em>pFileBuffer</em>. Note that when specifying the name of the file in <em>szFileName</em>, certain operating systems have case sensitive naming conventions.</p>
<p>On entry, the parameter <em>pFileSize</em> must point to the size of the buffer pointed to by <em>pFileBuffer</em>. If the value at *<em>pFileSize</em> is null, the <em>pFileBuffer</em> parameter can be NULL.</p>
<p>This function attempts to receive the entire file, even if the buffer space is insufficient. The return value indicates if the file was received.</p>
<p>A return value of 1 indicates that the file was received and copied into the buffer. A return value of 0 indicates that the file was received, but was too large for the specified buffer. In both these cases, the actual size of the file in bytes is written back to *<em>pFileSize</em>.</p>
<p>A negative return value indicates that an error has occurred during transfer. In this case, the number of bytes actually consumed in the buffer is written back to <em><em>pFileSize</em>. An error return of TFTPERROR_ERRORREPLY is a special return value that indicates that an error code was returned from the TFTP server. In this case, the servers TFTP error code is written to pErrorCode</em>, and the servers TFTP error message string is copied to the data buffer pointer to by <em>pFileBuffer</em>.</p>
<h2 id="tcpudp-server-daemon-support">5.4 TCP/UDP Server Daemon Support</h2>
<p>A server daemon is a single network task that monitors the socket status of multiple network servers. When activity is detected, the daemon creates a task thread specifically to handle the new activity. This is more efficient than having multiple servers, each with their own listening thread.</p>
<h3 id="server-daemon-support-api-functions">5.4.1 Server Daemon Support API Functions</h3>
<p>Entries in the server daemon are created and destroyed through the following APIs. The network tools include the file <code>NETTOOLS.H</code>, which is required.</p>
<h4 id="daemonnew-create-a-new-tcpudp-server-entry">DaemonNew  Create a New TCP/UDP Server Entry</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *DaemonNew( <span class="dt">uint32_t</span> Type,
                 <span class="dt">uint32_t</span> LocalAddress,
                 <span class="dt">uint32_t</span> LocalPort,
                 <span class="dt">int</span>      (*pCb)(SOCKET,<span class="dt">uint32_t</span>),
                 <span class="dt">uint32_t</span> Priority,
                 <span class="dt">uint32_t</span> StackSize,
                 <span class="dt">uint32_t</span> Argument,
                 <span class="dt">uint32_t</span> MaxSpawn );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Type: Socket type (SOCK_STREAM, SOCK_STREAMNC, or SOCK_DGRAM)</li>
<li>LocalAddress: Local IP address (set to NULL for wildcard)</li>
<li>LocalPort: Local Port to serve (cannot be NULL)</li>
<li>pCb: Pointer to callback to handle server event (connection or activity)</li>
<li>Priority: Priority of new task to create for callback function</li>
<li>StackSize: Stack size of new task to create for callback function</li>
<li>Argument: Argument (besides socket) to pass to callback function</li>
<li>MaxSpawn: Maximum number of callback function instances (must be 1 for UDP)</li>
</ul>
<p><strong>Return Value</strong> This function returns a handle to a daemon , or NULL on error.</p>
<p><strong>Description</strong> Once a new entry is created, the daemon will create the desired TCP or UDP socket, and start listening for activity.</p>
<p>In the case of TCP, when a new connection is established, a new task thread is created, and a socket session is opened. Then the users callback function is called on the new task thread, being supplied with both the socket to the new connection and the caller specified argument (as supplied to <em>DaemonNew()</em>). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback once it is done with the connection. The function can choose to close the socket if desired. The return code informs the daemon whether the socket has been closed (0) or is still open (1).</p>
<p>In the case of UDP, when any data is available on the UDP socket, a new task thread is created, and a socket session is opened. Then the users callback function is called on the new task thread, being supplied with both the UDP socket and the caller specified argument (as supplied to <em>DaemonNew()</em>). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback only when it is done with the data. (While the callback function holds the UDP socket, the daemon will ignore further activity on it.) The callback should return 1, as it should not close the UDP socket.</p>
<h4 id="daemonfree-destroy-a-tcpudp-server-entry">DaemonFree  Destroy a TCP/UDP Server Entry</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> DaemonFree( <span class="dt">void</span> *hEntry );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hEntry: Handle to server entry returned from <em>DaemonNew()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Destroys a daemon entry, and closes the socket session of all child tasks spawned from the entry. Closing the socket sessions will result in all socket functions returning SOCKET_ERROR in all spawned child tasks. Thus, all spawned tasks should error out and return to the daemon, allowing them to be freed.</p>
<h3 id="server-daemon-example">5.4.2 Server Daemon Example</h3>
<p>The following is an example TCP echo server using the server daemon. The TCP server will use SOCK_STREAMNC for non-copy TCP. Its only job is to read from the socket, and write back what it reads.</p>
<p>To install the server on port 7, use the following code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">hEcho = DaemonNew( SOCK_STREAMNC, <span class="dv">0</span>, <span class="dv">7</span>, dtask_tcp_echo,
                   OS_TASKPRINORM, OS_TASKSTKNORM, <span class="dv">0</span>, <span class="dv">3</span> );</code></pre></div>
<p>This code allows up to three echo sessions to be running simultaneously on different threads. Note the IP specified is NULL, allowing echo connection on any local IP address assigned to the system.</p>
<p>To destroy the server and all its instances, the hEcho handle returned from <em>DaemonNew()</em> is used:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">DaemonFree( hEcho );</code></pre></div>
<p>The code for the callback function dtask_tcp_echo() is as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> dtask_tcp_echo( SOCKET s, <span class="dt">uint32_t</span> unused )
{
    <span class="kw">struct</span> timeval to;
    <span class="dt">int</span> I;
    <span class="dt">char</span> *pBuf;
    <span class="dt">void</span> *hBuffer;

    (<span class="dt">void</span>)unused;

    <span class="co">// Configure our socket timeout to be 5 seconds</span>
    to.tv_sec = <span class="dv">5</span>;
    to.tv_usec = <span class="dv">0</span>;
    NDK_setsockopt( s, SOL_SOCKET, SO_SNDTIMEO, &amp;to, <span class="kw">sizeof</span>(to) );
    NDK_setsockopt( s, SOL_SOCKET, SO_RCVTIMEO, &amp;to, <span class="kw">sizeof</span>(to) );

    I = <span class="dv">1</span>;
    NDK_setsockopt( s, IPPROTO_TCP, TCP_NOPUSH, &amp;I, <span class="dv">4</span> );
    <span class="cf">for</span>(;;)
    {
        I = (<span class="dt">int</span>)NDK_recvnc( s, (<span class="dt">void</span> **)&amp;pBuf, <span class="dv">0</span>, &amp;hBuffer );

        <span class="co">// If we read data, echo it back</span>
        <span class="cf">if</span>(I &gt; <span class="dv">0</span>)
        {
            <span class="cf">if</span>(send( s, pBuf, I, <span class="dv">0</span>) &lt; <span class="dv">0</span> )
                <span class="cf">break</span>;
            NDK_recvncfree( hBuffer );
        }
        <span class="co">// If the connection got an error or disconnect, close</span>
        <span class="cf">else</span>
            <span class="cf">break</span>;
    }
    fdClose( s );

    <span class="co">// Return &quot;0&quot; since we closed the socket</span>
    <span class="cf">return</span>(<span class="dv">0</span>);
}</code></pre></div>
<h1 id="network-tools-library---services">6 Network Tools Library - Services</h1>
<p>Included with the stack package is a library of network tools. It provides auxiliary functionality to the stack library and contains source written to the socket layer that would normally be considered application level code. The library file is called NETTOOLS.LIB, and can be accessed by an application that includes the file NETTOOLS.H.</p>
<p>The support supplied by NETTOOLS can be categorized into two classes: support functions and services. The support functions consist of a programming API that can help develop network applications, while services are servers that execute on the stack platform.</p>
<p>This section describes the NETTOOLS services. Note that these services are all IPv4 based. Based on the IPv6 documentation, these applications can be easily re-written to use IPv6 sockets instead for communication.</p>
<h2 id="service-calling-conventions">6.1 Service Calling Conventions</h2>
<h3 id="specifying-network-services-using-the-configuration">6.1.1 Specifying Network Services Using the Configuration</h3>
<p>If you are using XGCONF to configure your application, you can configure network services to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details. If you are using XGCONF for configuration, you can ignore the APIs described in the subsections that follow.</p>
<p>If you are using the Configuration Manager API to configure your application, the subsections that follow describe the direct and configuration APIs used to add services to an application.</p>
<p>Although each service has its own specific API, it is usually more convenient to add services by specifying the service in the system configuration as opposed to calling each individual Open and Close API function. Included in the description of each network service is a description of its direct API, as well as an example of specifying the service in the system configuration.</p>
<h3 id="service-report-function">6.1.1.1 Service Report Function</h3>
<p>All the configuration examples in this section use a common service report callback function. The following is a very simple implementation of a service report function that calls printf() to print service status.</p>
<p>Note that this function relies on the physical value of items in the configuration specification found in the file: <code>/ti/ndk/inc/nettools/netcfg.h</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">char</span> *TaskName[] = { <span class="st">&quot;Telnet&quot;</span>,<span class="st">&quot;&quot;</span>,<span class="st">&quot;NAT&quot;</span>,<span class="st">&quot;DHCPS&quot;</span>,<span class="st">&quot;DHCPC&quot;</span>,<span class="st">&quot;DNS&quot;</span> };
<span class="dt">static</span> <span class="dt">char</span> *ReportStr[] = { <span class="st">&quot;&quot;</span>,<span class="st">&quot;Running&quot;</span>,<span class="st">&quot;Updated&quot;</span>,<span class="st">&quot;Complete&quot;</span>,<span class="st">&quot;Fault&quot;</span> };
<span class="dt">static</span> <span class="dt">char</span> *StatusStr[] = { <span class="st">&quot;Disabled&quot;</span>,<span class="st">&quot;Waiting&quot;</span>,<span class="st">&quot;IPTerm&quot;</span>,<span class="st">&quot;Failed&quot;</span>,<span class="st">&quot;Enabled&quot;</span> };

<span class="dt">static</span> <span class="dt">void</span> ServiceReport( <span class="dt">uint32_t</span> Item, <span class="dt">uint32_t</span> Status, <span class="dt">uint32_t</span> Report, <span class="dt">void</span> *h )
{
    printf( <span class="st">&quot;Service Status: %-9s: %-9s: %-9s: %03d</span><span class="sc">\n</span><span class="st">&quot;</span>,
            TaskName[Item-<span class="dv">1</span>], StatusStr[Status],
            ReportStr[Report/<span class="dv">256</span>], Report&amp;<span class="bn">0xFF</span> );
}</code></pre></div>
<h3 id="invoking-network-services-by-nettools-api">6.1.2 Invoking Network Services by NETTOOLS API</h3>
<p>If you are using XGCONF to configure your application, you can configure network services to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details. You can ignore the APIs described in this section.</p>
<p>If you are using the Configuration Manager API to configure your application, this section describes the APIs used to add services to an application. (Calls to these APIs are generated automatically by the XGCONF configuration.)</p>
<p>Each service API uses a common calling format. This allows the services to be invoked by the configuration system using callback functions provided in the Network Control software (which also performs system initialization). It is preferable to launch services via the configuration system, instead of manually calling each Open and Close function described in the following sections. However, because the source to the Network Control software uses these calls, they are documented here.</p>
<p>The common calling interface consists of a simple Open and Close concept. The Open function initiates the service and returns a service handle, while the Close function shuts down the service using the service handle returned from the Open call.</p>
<p>Each service Open call takes at least one parameter. This parameter is a pointer to a common argument structure called NTARGS. The specification of this structure is as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _ntargs {
    <span class="dt">int</span>       CallMode;       <span class="co">// Determines desired calling mode</span>
<span class="pp">#define NT_MODE_IFIDX1        </span><span class="co">// Call by specifying IfIdx</span>
<span class="pp">#define NT_MODE_IPADDR2       </span><span class="co">// Call by specifying IPAddr</span>
    <span class="dt">int</span>       IfIdx;          <span class="co">// Physical interface Index (0-n)</span>
    <span class="dt">uint32_t</span>  IPAddr;         <span class="co">// IP Address</span>
    <span class="dt">void</span>      *hCallback;     <span class="co">// Handle to pass to callback function</span>
    <span class="dt">void</span>(*pCb)(<span class="dt">void</span> *, uint); <span class="co">// Callback for status change</span>
} NTARGS;</code></pre></div>
<p>Note that this entry structure is a simplified version of that provided by the configuration system. This structure also contains a callback function. The callback function is a subset of that in the configuration system, and codes returned by this callback are passed through the configuration callback to the application.</p>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>int CallMode;</code> This parameter determines how the service is launched, either by IP address or by interface index (1 to n). Some services can be launched either on a specific interface (1 to n) or on a specific IP address, which can also be the wildcard INADDR_ANY. Generally, any service that accepts an IP address can also accept an interface. The service will look up the IP address for the specified interface. Other services can only be executed by interface and are independent of IP address. These are said to be compatible with NT_MODE_IFIDX only. The value of <em>CallMode</em> can be one of the following:
<ul>
<li>NT_MODE_IFIDX: Call by specifying the interface Index (1 to n)</li>
<li>NT_MODE_IPADDR: Call by specifying IP address in network format</li>
</ul></li>
<li><code>int IfIdx;</code> This is the physical interface index (1 to n) on which the service is to be executed. For example, when launching a DHCP server service, the physical interface is that connected to the home network. For more generic services (like Telnet), the service can be launched by a pre-defined IP address (or INADDR_ANY as a wildcard). When launching by IP address only, this field is left NULL. When this field is used, <em>CallMode</em> should be set to NT_MODE_IFIDX.</li>
<li><code>uint32_t IPAddr;</code> This is the IP address (in network format) on which to initiate the service. This IP address can specify the wildcard INADDR_ANY, in which case the service will accept connections to any valid IP address on any device. Note that some services (like DHCP server) do not support being launched by IP address. When this field is used, <em>CallMode</em> should be set to NT_MODE_IPADDR.</li>
<li><code>void *hCallback;</code> This is the caller supplied handle that is passed back to the caller when the status callback function is invoked (see below).</li>
<li><code>void (*pCb)(void *, uint);</code> This is a pointer to a caller supplied callback function by which the service reports status. The specification of this callback is: <code>void cbFun(void *hCallback, uint32_t NtStatus);</code>
<ul>
<li>hCallback: Handle supplied to the service by the caller</li>
<li>NtStatus: NetTools Service Status code The <em>NtStatus</em> parameter consists of an upper byte that is predefined, and a lower byte that is specific to the service. When masked with ~0xFF (NOT 0xFF), the value will be one of the following:
<ul>
<li>NETTOOLS_STAT_NONE.: Nothing reported</li>
<li>NETTOOLS_STAT_RUNNING: Service is initialized (running)</li>
<li>NETTOOLS_STAT_PARAMUPDATE: The service parameter structure has changed (the configuration containing this structure should be saved)</li>
<li>NETTOOLS_STAT_COMPLETED: The service has run to completion</li>
<li>NETTOOLS_STAT_FAULT: The service has halted due to a fault</li>
</ul></li>
</ul>
Note that this callback function does not go directly to the application when using the configuration system. These codes are supplied to the configuration service callback in the <em>Code</em> parameter. An optional second parameter to each service Open function is a pointer to a private service parameter structure. In the configuration section of this document, the individual service parameter structures were included in the specification of the configuration entry instance structure for each service.</li>
</ul>
<h2 id="telnet-server-service">6.2 Telnet Server Service</h2>
<p>If you are using XGCONF to configure your application, you can configure Telnet to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<p>The Telnet Server service provides a mechanism for exposing a stream IO connection to any remote telnet client console.</p>
<p>A telnet connection is basically just a TCP connection to the well-known port designated for telnet. However, there is some data translation that occurs on the stream. Telnet has a set of commands that can change the behavior of the terminal, and can perform some character translation. The telnet server supplied here is designed to convert a normal TTY stream to a telnet stream and back. This allows any application to treat a telnet session as any other TTY session (like a serial port).</p>
<p>Connection to an application is achieved by use of an application supplied callback function that telnet calls when a new connection is established. This callback function returns the file descriptor of one end of a full duplex communications pipe. By allowing multiple calls to the callback function, console applications can be written to work with multiple IO streams.</p>
<h3 id="telnet-parameter-structure">6.2.1 Telnet Parameter Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here.</p>
<p>The following structure defines the unique parameters of the Telnet service. It is located in the file: <code>/ti/ndk/inc/nettools/inc/telnetif.h</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// Telnet Parameter Structure</span>
<span class="co">//</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ntparam_telnet {
   <span class="dt">int</span>     MaxCon;         <span class="co">// Max number of telnet connections</span>
   <span class="dt">int</span>     Port;           <span class="co">// Port (set to NULL for telnet default)</span>
   SOCKET  (*Callback)(<span class="kw">struct</span> sockaddr *);
                           <span class="co">// Connect function returns local pipe</span>
} NTPARAM_TELNET;</code></pre></div>
<ul>
<li>MaxCon: Maximum number of simultaneous telnet sessions (1 to 24)</li>
<li>Port: TCP port to use for Telnet (set to zero for Telnet default)</li>
<li>Callback: Pointer to a callback function that takes a pointer to a sockaddr structure, and returns a local file descriptor to one end of a full duplex communications pipe</li>
</ul>
<p>This structure is used both when specifying the service to the configuration system or when bypassing the configuration and invoking the service API directly.</p>
<h3 id="invoking-the-service-via-nettools-api">6.2.2 Invoking the Service via NETTOOLS API</h3>
<p>In addition to the configuration option, this service can also be created and destroyed directly through this NETTOOLS API. If an application wishes to bypass the configuration system and launch the service directly, these calls can be used.</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TelnetOpen()</td>
<td>Create an instance of the Telnet Server</td>
</tr>
<tr class="even">
<td>TelnetClose()</td>
<td>Destroy an instance of the Telnet Server</td>
</tr>
</tbody>
</table>
<p>For API details, refer to the <a href="html/group__ti__ndk__inc__nettools__inc____Telnet.html">Telnet Module in the NDK API Reference Guide</a>.</p>
<h2 id="dhcp-server-service">6.3 DHCP Server Service</h2>
<p>When acting as a router, the NDK may also need to maintain the network configuration on one of its network devices. A DHCP server allows the stack to maintain the IP address of multiple Ethernet client devices. When combined with Network Address Translation (NAT), the DHCP server can be used to establish client membership in a private virtual network.</p>
<p>If you are using XGCONF to configure your application, you can configure the DHCP server to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="operation">6.3.1 Operation</h3>
<p>The DHCP server can be optionally configured to allocate IP addresses out of a pool that is specified by an IP base address and the number of addresses in the pool. If no pool is specified, the server will use static client entries in the configuration system to resolve client address requests.</p>
<p>The server will respond to DHCP requests from a single Ethernet device. This allows for isolation of clients for a given interface, and allows multiple instances of the DHCP server to manage different IP address pools for different interfaces.</p>
<h3 id="dhcp-server-parameter-structure">6.3.2 DHCP Server Parameter Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here.</p>
<p>The following structure defines the unique parameters of the DHCP server service. It is located in the file: <code>/ti/ndk/inc/nettools/inc/dhcpsif.h</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// DHCPS Parameter Structure</span>
<span class="co">//</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ntparam_dhcps {
        <span class="dt">uint32_t</span>   Flags;      <span class="co">// DHCPS Execution Control Flags</span>
        <span class="dt">uint32_t</span>   PoolBase;   <span class="co">// First IP address in optional pool</span>
        <span class="dt">uint32_t</span>   PoolCount;  <span class="co">// Number of addresses in optional pool</span>
} NTPARAM_DHCPS;</code></pre></div>
<ul>
<li>Flags - Execution control flags. Can be any combination of the following:
<ul>
<li>DHCPS_FLG_LOCALDNS: Causes DHCPS to report its own IP address as the local DNS server to clients. If this flag is not set, DHCPS reports the DNS servers as contained in the SYSINFO portion of the configuration.</li>
<li>DHCPS_FLG_LOCALDOMAIN: Causes DHCPS to report the local domain name assigned to the virtual network to clients. If this flag is not set, DHCPS reports the public domain name to clients.</li>
</ul></li>
<li>PoolBase - The first IP address (in network format) of the address pool.</li>
<li>PoolCount - The number of addresses in the address pool.</li>
</ul>
<p>This structure is used both when specifying the service to the configuration system or when bypassing the configuration and invoking the service API directly.</p>
<h3 id="invoking-the-service-via-nettools-api-1">6.3.3 Invoking the Service via NETTOOLS API</h3>
<p>In addition to the configuration option, this service can also be created and destroyed directly through this NETTOOLS API. If an application wishes to bypass the configuration system and launch the service directly, these calls can be used.</p>
<h4 id="dhcpsopen-open-a-dhcp-server">DHCPSOpen  Open a DHCP Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *DHCPSOpen( NTARGS        *pNTA,
                 NTPARAM_DHCPS *pNTP );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNTA: Pointer to common argument structure used by all services.</li>
<li>pNTP: Pointer to DHCP parameter structure</li>
</ul>
<p><strong>Return Value</strong> Returns a pointer to a DHCPS instance structure that is used in calls to other DHCPS functions like <em>DHCPSClose()</em>.</p>
<p><strong>Description</strong> This function is called to initiate DHCPS control of an IP address pool on a given interface. The base address of the address pool does not have to be the first IP address in the subnet.</p>
<p>The DHCP Server executes on a specific interface. Thus, it is compatible with NT_MODE_IFIDX only.</p>
<h4 id="dhcpsclose-close-an-instance-of-the-dhcp-server">DHCPSClose  Close an Instance of the DHCP Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> DHCPSClose( <span class="dt">void</span> *hDHCPS );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hDHCPS: Handle to a DHCP server instance obtained from <em>DHCPSOpen()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to terminate DHCPS control of the previously supplied interface. This call also destroys the supplied DHCP server instance handle <em>hDHCPS</em>.</p>
<h2 id="dhcp-client-support">6.4 DHCP Client Support</h2>
<p>At system start up, the DHCP client will try and acquire an IP address from the DHCP servers available on the network.</p>
<p>Note that the client will accept the first IP address offered. The INIT-REBOOT State (which requests a previously assigned IP address) is not supported.</p>
<p>More information on DHCP can be found in RFC2131 and RFC2132, released by the Internet Engineering Task Force (IETF) organization.</p>
<p>If you are using XGCONF to configure your application, you can configure the DHCP client to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="operation-1">6.4.1 Operation</h3>
<p>The DHCP client is a special service that always executes immediately in a system. It is usually after the DHCP client obtains a public IP address that most of the other services in the system can initialize.</p>
<p>The DHCP client code makes more use of the service status report callback function than most of the other services. Recall from the beginning of this section that the least significant byte of the report code is reserved for service specific information.</p>
<p>The following report codes are returned in the LSB of the report code sent by the DHCP service:</p>
<ul>
<li>DHCPCODE_IPADD: An IP client address had been added to the system</li>
<li>DHCPCODE_IPREMOVE: An IP client address has been removed from the system</li>
<li>DHCPCODE_IPRENEW: An IP client address has been renewed</li>
</ul>
<p>Note that in each of the above cases, the DHCP portion of the system information configuration (the first 256 entries of CFGTAG_SYSINFO) has been erased and potentially reprogrammed. If an application needs to share the DHCP portion of the system information configuration, these DHCP report codes can be used to signal when to add additional application specific tags. For more information on DHCP and the CFGTAG_SYSINFO tag, see <a href="#system-information-specification">Section 4.3.7</a>.</p>
<h3 id="dhcp-client-parameter-structure">6.4.2 DHCP Client Parameter Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here.</p>
<p>The following structure defines the unique parameters of the DHCP client service. It is located in the file: <code>/ti/ndk/inc/nettools/inc/dhcpif.h</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// DCHP Parameter Structure</span>
<span class="co">//</span>
<span class="pp">#define DHCP_MAX_OPTIONS 64 </span><span class="co">// Max number of allowed options</span>

<span class="kw">typedef</span> <span class="kw">struct</span> _ntparam_dhcp {
     <span class="dt">unsigned</span> <span class="dt">char</span>  *pOptions;   <span class="co">// Options to request</span>
     <span class="dt">int</span>            len;         <span class="co">// Length of options list</span>
} NTPARAM_DHCP;</code></pre></div>
<ul>
<li>pOptions: Pointer to additional DHCP option tags to request. The list is used when additional information must be obtained from the DHCP server. Up to DHCP_MAX_OPTIONS tags can be specified. This pointer can be NULL when <em>len</em> is set to 0.</li>
<li>len: Specifies the length in bytes of the list pointed to by pOptions.</li>
</ul>
<p>This structure is used both when specifying the service to the configuration system or when bypassing the configuration and invoking the service API directly.</p>
<h3 id="invoking-the-service-via-nettools-api-2">6.4.3 Invoking the Service via NETTOOLS API</h3>
<p>In addition to the configuration option, this service can also be created and destroyed directly through this NETTOOLS API. If an application wishes to bypass the configuration system and launch the service directly, these calls can be used.</p>
<h4 id="dhcpopen-open-a-dhcp-server">DHCPOpen  Open a DHCP Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *DHCPOpen( NTARGS       *pNTA ,
                NTPARAM_DHCP *pNTP);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNTA: Pointer to common argument structure used by all services</li>
<li>pNTP: Pointer to DHCP parameter structure</li>
</ul>
<p><strong>Return Value</strong> Returns a pointer to a DHCP instance structure, which is used in calls to other DHCP functions like <em>DHCPClose()</em>.</p>
<p><strong>Description</strong> This function is called to initiate DHCP control of a given device.</p>
<p><em>DHCPOpen()</em> starts the DHCP process. This process will discover if there are any DHCP servers on the network and request an IP address. The result of the search for an IP address will be passed to the application via the standard network tools status callback.</p>
<p>The Client will remain running so it can renew the IP address when necessary.</p>
<p>For any additional option tags entered into the DHCP client parameter structure, the resulting information from the DHCP server is written to the system configuration under the CFGTAG_SYSINFO entry. See <a href="#system-information-specification">Section 4.3.7</a> for more information.</p>
<p>The DHCP Client executes on a specific interface. Thus, it is compatible with NT_MODE_IFIDX only.</p>
<h4 id="dhcpclose-close-an-instance-of-the-dhcp-client">DHCPClose  Close an Instance of the DHCP Client</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> DHCPClose( <span class="dt">void</span> *hDHCP );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hDHCP: Handle to a DHCP server instance obtained from <em>DHCPSOpen()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to terminate DHCP control of the previously supplied interface and frees the supplied DHCP server instance handle <em>hDHCP</em>.</p>
<p>Note this function will also remove any IP address it has added to the system. In the case of a service shutdown, there will be no status callback indicating the address removal.</p>
<h2 id="dns-server-service">6.5 DNS Server Service</h2>
<p>The DNS server service allows clients on a home network to resolve host names and addresses for clients on both the home and public networks.</p>
<p>If you are using XGCONF to configure your application, you can configure the DNS server to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="operation-2">6.5.1 Operation</h3>
<p>The NDK contains a small DNS resolver that can resolve hostnames and addresses that are local to the system via the configuration, or those outside the system by using an external DNS server.</p>
<p>The DNS server service described here allows the same internal DNS resolver to be accessed by clients on a virtual (home) network. This allows clients on a home network to look up peers on the home network using the same DNS server that is used for external lookups. Thus, DNS service for the home network is transparent to these clients.</p>
<p>Because the DNS server service uses the same internal DNS resolver as the client services discussed earlier, the server adds very little overhead to the system.</p>
<h3 id="dns-server-parameter-structure">6.5.2 DNS Server Parameter Structure</h3>
<p>The DNS server service does not require a parameter structure.</p>
<h3 id="invoking-the-service-via-nettools-api-3">6.5.3 Invoking the Service via NETTOOLS API</h3>
<p>In addition to the configuration option, this service can also be created and destroyed directly through this NETTOOLS API. If an application wishes to bypass the configuration system and launch the service directly, these calls can be used.</p>
<h4 id="dnsserveropen-create-an-instance-of-the-dns-server">DNSServerOpen  Create an Instance of the DNS Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *DNSServerOpen( NTARGS *pNTA );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNTA: Pointer to common argument structure used by all services.</li>
</ul>
<p><strong>Return Value</strong> Returns a handle to the new server instance, or NULL if the service could not be created. This handle is used with <em>DNSServerClose()</em> to shut down the server when it is no longer needed.</p>
<p><strong>Description</strong> Creates a DNS server task that can service external DNS requests using UDP.</p>
<h4 id="dnsserverclose-destroy-an-instance-of-the-dns-server">DNSServerClose  Destroy an Instance of the DNS Server</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> DNSServerClose( <span class="dt">void</span> *hDNSS );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hDNSS: Handle to DNS server instance obtained from <em>DNSServerOpen()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Destroys the instance of the DNS server indicated by the supplied handle. Once called, the server is shut down. It waits for all spawned sessions to complete.</p>
<h2 id="network-address-translation-nat-service">6.6 Network Address Translation (NAT) Service</h2>
<p>The NAT service allows for the establishment of a home virtual network that is isolated and protected from the external public network. It provides a port based address translation function that allows all the clients on the home network to share a single public IP address. Thus, multiple clients can share the same ISP account.</p>
<p>If you are using XGCONF to configure your application, you can configure the NAT service to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="operation-3">6.6.1 Operation</h3>
<p>The NDK contains both a network address translation module and an IP filtering model. When the translation service is enabled, any packet received from a client on a virtual network that is destined for the external public network is adjusted to use the stacks public IP client address.</p>
<p>The translation is performed by allocating a translation record and holding it for a period of time. The translation records are timed out based on their protocol. In TCP, records are timed out based on the state of their TCP connection. UDP and ICMP translations time out based on when they were last used.</p>
<p>In addition to translation, the stack contains an IP filter option (always enabled by this service) that filters packets from the public network from being seen by the private network. For example, if someone on a public network knew the IP address and the subnet mask of the routers (stack in route mode) private network, it could set a gateway route to the routers public IP host address and the router would route packets from the public to the private network and back (internally it does not distinguish between public and private while routing). The IP filter prevents this. It also prevents an entity on a public network from accessing protocol servers (like Telnet) that are running on the private network. This allows the router to present different Telnet interfaces to the public than it does to clients in the home.</p>
<p>The NAT service is executed on the public interface - i.e., the interface that is assigned a valid public IP host address (used to carry traffic for the virtual client addresses). There can only be one instance and thus only one public IP address, but the service can serve multiple virtual (home) networks in the system so long as they can be combined and still exclude the public IP. If the combination of these networks results in an overlap with the public network, the service fails.</p>
<p>For example, assume interface If-1 is connected to the physical network 128.32.12.x/255.255.255.0, and there are two home networks (192.168.0.x/255.255.255.0) on If-2 and (192.168.1 .x/255.255.255.0) on If-3. To run NAT on both home networks, the NAT interface would be If-1 (the public interface), and the NAT group (virtual) network would be 192.168.0.0/255.255.254.0, which covers both home networks.</p>
<p>For more information on NAT operation, including how to program proxy filters, see <a href="#ApxB">Appendix B</a>, <em>Network Address Translation</em>.</p>
<h3 id="nat-server-parameter-structure">6.6.2 NAT Server Parameter Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here.</p>
<p>The following structure defines the unique parameters of the NAT server service. It is located in the file: <code>/ti/ndk/inc/nettools/inc/natif.h</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// NAT Parameter Structure</span>
<span class="co">//</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _ntparam_nat {
     <span class="dt">uint32_t</span>    IPVirt;   <span class="co">// Virtual IP address</span>
     <span class="dt">uint32_t</span>    IPMask;   <span class="co">// Mask of virtual subnet</span>
     <span class="dt">uint32_t</span>    MTU;      <span class="co">// NAT packet MTU (normally 1500 or 1492)</span>
} NTPARAM_NAT;</code></pre></div>
<ul>
<li>IPVirt: NAT Group virtual network address</li>
<li>IPMask: Subnet mask of NAT Group virtual network</li>
<li>MTU: IP MTU Limit (1500 for Ethernet, 1492 for PPPoE, etc.)</li>
</ul>
<p>This structure is used both when specifying the service to the configuration system or when bypassing the configuration and invoking the service API directly.</p>
<h3 id="invoking-the-service-via-nettools-api-4">6.6.3 Invoking the Service via NETTOOLS API</h3>
<p>In addition to the configuration option, this service can also be created and destroyed directly through this NETTOOLS API. If an application wishes to bypass the configuration system and launch the service directly, these calls can be used.</p>
<h4 id="natopen-enable-the-nat-service">NATOpen  Enable the NAT Service</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *NATOpen( NTARGS *pNTA,
               NTPARAM_NAT *pNTP );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNTA: Pointer to common argument structure used by all services.</li>
<li>pNTP: Pointer to NAT parameter structure.</li>
</ul>
<p><strong>Return Value</strong> Returns a handle to the NAT instance (1), or NULL if the service could not be created. This handle is used with <em>NATClose()</em> to disable the service when it is no longer needed.</p>
<p><strong>Description</strong> Enables the Network Address Translation Service. Although the function returns a handle for compatibility with the standard NETTOOLS API, only one instance of the NAT service is allowed.</p>
<p>This service utilizes the virtual and external network information using the configuration system. If the configuration system was not used to create the network records, this function will fail.</p>
<p>The NAT service executes on a specific public interface. Thus, it is compatible with NT_MODE_IFIDX only.</p>
<h4 id="natclose-disable-the-nat-service">NATClose  Disable the NAT Service</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NATClose( <span class="dt">void</span> *hNAT );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hNAT: Handle to NAT service obtained from <em>NATOpen()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Disables the NAT service.</p>
<h1 id="registering-ndk-hook-functions">7 Registering NDK Hook Functions</h1>
<p>The NDK provides a function, <code>NDK_registerHook</code>, that allows the user to register their own functions to hook into predetermined internal portions of the NDK. Some NDK modules already provide their own methods of hooking into their code, but we have started to consolidate the hooks into the <code>NDK_registerHook</code> method.</p>
<h2 id="operation-4">7.1 Operation</h2>
<h3 id="hook-function-structure">7.1.1 Hook Function Structure</h3>
<p>All user hook functions must be of the type <code>NDK_HookFxn</code> defined in <code>ti/ndk/inc/socketndk.h</code> as:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> (*NDK_HookFxn) (<span class="dt">uintptr_t</span>);</code></pre></div>
<h4 id="ndk_registerhook---register-a-hook-function">NDK_registerHook - Register a hook function</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NDK_registerHook( <span class="dt">int</span>         type,
                       NDK_HookFxn fxn  );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>type: The type of hook function to register. This determines where in the NDK the function will be run.</li>
<li>fxn: The function to be registered</li>
</ul>
<p><strong>Description</strong> Registers a NDK_HookFxn of a given type. For instance a <code>CREATE_SKT_CTX_HOOK</code> type will register the function inside socket creation calls</p>
<h2 id="hook-function-types">7.2 Hook Function Types</h2>
<p>The NDK currently supports three hook function types. The symbols for the types are displayed below, and can be found in <code>/ti/ndk/inc/socketndk.h</code></p>
<ul>
<li><code>CREATE_SKT_CTX_HOOK</code> - Create socket context</li>
<li><code>CLOSE_SKT_CTX_HOOK</code> - Close socket context</li>
<li><code>NETSTART_ERROR_HOOK</code> - NetStart Error</li>
</ul>
<h3 id="createclose-socket-context">7.2.1 Create/Close Socket Context</h3>
<p>These two types allow you to hook into the process of creating or closing a socket. Both the create and close hooks will send a <code>SOCKET</code> as an argument.</p>
<p>The caller of the create socket context hook expects an integer return value indicating the sockets context. This context can be whatever you want it to be, but it will ultimately be stored on the <code>SOCK</code> structs <code>int32_t</code> <code>Ctx</code> field.</p>
<p>The close socket context hook is meant to remove any context that was created in the create socket context hook call. The caller does not expect any return value.</p>
<p>The NDKs own <code>slnetif</code> module implements these hooks in <code>ti/ndk/slnetif/slnetifndk.c</code> by registering the <code>addSktToTable</code> and <code>removeSktFromTable</code> functions as open and close context hooks respectively.</p>
<h3 id="netstart-error">7.2.2 NetStart Error</h3>
<p>This type will hook into the various error states of the <code>NC_NetStart</code> function found in <code>ti/ndk/netctrl/netctrl.c</code>. This allows you to configure what action should be taken, and what information should be displayed at these error states. If this hook function is not present, default actions will be taken at error states.</p>
<p>The caller of this hook function will pass a <code>NetStartError_Obj</code> (definition found in <code>ti/ndk/inc/socketndk.h</code>) as an argument. The <code>NetStartError_Obj</code>s <code>error</code> field will be filled in with the type of the error. The two currently supported error types (found in <code>ti/ndk/inc/stack/inc/nimuif.h</code>) are:</p>
<ul>
<li><code>NIMU_ERR_SOME_FAILED</code> - Some NIMU devices failed to initialize during stack startup</li>
<li><code>NIMU_ERR_ALL_FAILED</code> - All NIMU devices failed to initialize during stack startup</li>
</ul>
<p>Below is an example of how this hook function type can be used:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;ti/ndk/inc/stkmain.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ti/ndk/inc/netmain.h&gt;</span>

<span class="dt">static</span> <span class="dt">int</span> netCtrlErrorHook(<span class="dt">uintptr_t</span> errorStruct)
{
    NetStartError_Obj *ncError = (NetStartError_Obj *)errorStruct;

    <span class="cf">if</span>(ncError-&gt;error == NIMU_ERR_ALL_FAILED)
    {
        DbgPrintf(<span class="st">&quot;All NIMU devices failed to initialize. Shutting down stack</span><span class="sc">\n</span><span class="st">&quot;</span>);
        NC_NetStop(ncError-&gt;error);
    }
    <span class="cf">else</span> <span class="cf">if</span>(ncError-&gt;error == NIMU_ERR_SOME_FAILED)
    {
        DbgPrintf(<span class="st">&quot;Some NIMU devices failed to initialize. Continuing stack startup</span><span class="sc">\n</span><span class="st">&quot;</span>);
    }
    <span class="cf">else</span>
    {
        DbgPrintf(<span class="st">&quot;Unrecognized NC_NetStart error.</span><span class="sc">\n</span><span class="st">&quot;</span>);
    }

    <span class="co">/*</span>
<span class="co">     * This hook type does not need a return value, but returning 0 to satisfy</span>
<span class="co">     * the NDK_HookFxn type</span>
<span class="co">     */</span>
    <span class="cf">return</span>(<span class="dv">0</span>);
}

<span class="dt">static</span> <span class="dt">void</span> ndkStackThread(<span class="dt">void</span> *argUnused)
{
    NDK_registerHook(NETSTART_ERROR_HOOK, (NDK_HookFxn)(&amp;netCtrlErrorHook));

    <span class="cf">do</span>
    {
        rc = NC_NetStart(hCfg, networkOpen, networkClose, networkIPAddr);
    } <span class="cf">while</span>(rc &gt; <span class="dv">0</span>);
}</code></pre></div>
<p><a name="ApxA"></a></p>
<h1 id="a-internal-stack-functions">A Internal Stack Functions</h1>
<p>In the source code to the network control functions, there are several calls to internal stack functions. This is similar to calling the kernel in other operating environments. This section contains a partial list of internal stack functions provided to aid in the comprehension of kernel oriented calls.</p>
<p>Note the following points for this section:</p>
<ol>
<li>This section is required only for system programming that needs low level access to the stack for configuration and monitoring. <strong>This API does not apply to general sockets application programming.</strong></li>
<li>In addition to the internal functions described here, there are scheduling and configurations tools available that make any direct coding to these functions unnecessary.</li>
</ol>
<p><a name="internal-stack-functions-overview"></a></p>
<h2 id="a.1-overview">A.1 Overview</h2>
<p>The control API is the collection of functions supplied in the stack library. The entire API is exposed, although the vast majority of functions and objects will only be used internally to the stack.</p>
<h3 id="a.1.1-interrupts-and-preemption">A.1.1 Interrupts and Preemption</h3>
<p>It should be noted that no part of the stack is interrupt driven. Neither can any stack function be called at interrupt time. All interrupt processing is performed in the HAL or OS libraries, and is thus externally-defined code, which allows the development of a HAL/OS architecture that is best suited for a given operating environment, without affecting the operation of the stack.</p>
<p>The stack may or may not be preempted, depending on the operating environment in use. A non-preemptive architecture is possible because the stack code does not use polling loops nor make any internal blocking type calls, but preemption is also supported.</p>
<p><a name="proper-use-of"></a></p>
<h3 id="a.1.2-proper-use-of-the-llenter-and-llexit-functions">A.1.2 Proper Use of the <em>llEnter()</em> and <em>llExit()</em> Functions</h3>
<p>The internal stack functions are not designed to be reentrant. This allows the stack to operate freely without the concept of a critical section, which is implementation dependent and potentially detrimental to real-time operation. Thus, access to stack functions must be strictly controlled. The form of this control is dependent on the system environment, and is embodied as two low level OS library functions, <em>llEnter()</em> and <em>llExit()</em>. These functions are called before and after a section of code where any stack functions are called. For example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">llEnter();
StackFunction1();
StackFunction2();
llExit();</code></pre></div>
<p>These functions can be thought of as entering and exiting kernel mode.</p>
<p>To make normal user functions appear to be re-entrant, some user functions (like the sockets API) make internal calls to <em>llEnter()</em> and <em>llExit()</em> when calling into the stack. If an application needs to call both user functions and internal stack functions, care must be taken so that standard user functions are not called between an <em>llEnter()</em> / <em>llExit()</em> pair (this would cause an error if they in turn called <em>llEnter()</em>).</p>
<p>The following are good general guidelines:</p>
<ul>
<li>Always call <em>llEnter()</em> before calling a stack function, and <em>llExit()</em> when done calling stack functions.</li>
<li>Try and keep all code that requires <em>llEnter()</em> and <em>llExit()</em> in a single module. They are only required for system maintenance.</li>
<li>Do not call a normal user function (like a socket function) between an <em>llEnter()</em>/<em>llExit()</em> pair.</li>
<li>Never call <em>llEnter()</em> or <em>llExit()</em> from an ISR.</li>
</ul>
<h3 id="a.1.3-objects">A.1.3 Objects</h3>
<p>Many of the control API functions deal with object handles. These handles are created by a variety of class functions contained in the stack. When using an object handle, it is important to realize how the object handle will be treated by the function being called.</p>
<p>Associated with every object is the concept of who owns it, who is using it, and who will eventually free it. In general, when an application creates an object, the application owns it, the application is the only one using it, and the application must eventually free it. Unfortunately, the matter becomes somewhat confused when object handles are shared between applications - especially when the scope of the handle creator may be shorter than the handle itself.</p>
<p>In this system, there are two basic object types:</p>
<ul>
<li>Static Objects - The static object is one that is created by a designated task, and destroyed by that task or a task where the object has been passed. In most cases, the task that created the object also destroys it.</li>
<li><p>Referenced Objects - A referenced object is one that may be used by other tasks after the original creator is through with it. This type of handle is useful when an object is needed for a task of indeterminate length, where the creator of the handle does not need or may not be able to track it.</p>
<p>Under the referenced handle scheme, all tasks that access the object handle make a specific Ref_Xxx_() call so that references may be tracked. Whenever a task is finished with the handle, it calls the objects de-reference function. The object is not freed until the reference count reaches zero.</p></li>
</ul>
<h2 id="a.2-stack-executive-exec">A.2 Stack Executive (Exec)</h2>
<p>At the heart of the stack is the Executive API (Exec). The Executive acts as a message dispatcher for the internal stack components. This action is mostly hidden from the application, but there are some public functions.</p>
<h3 id="a.2.1-api-functions">A.2.1 API Functions</h3>
<h4 id="execopen-prepare-the-system-for-execution">ExecOpen  Prepare the System for Execution</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ExecOpen();</code></pre></div>
<p><strong>Description</strong> Prepares the stack for execution by initializing the individual components. Until <em>ExecOpen()</em> is called, the system cannot do any work, but after calling this function, objects like routes and bindings can be created.</p>
<h4 id="execclose-shutdown-stack-and-cleanup">ExecClose  Shutdown Stack and Cleanup</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ExecClose();</code></pre></div>
<p><strong>Description</strong> Completes stack execution. This function is called to perform final clean up on the system after all user objects (like devices and bindings) have been destroyed.</p>
<h4 id="execlowresource-signal-low-resource-condition">ExecLowResource  Signal Low Resource Condition</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ExecLowResource();</code></pre></div>
<p><strong>Description</strong> Informs the stack that memory resources are getting dangerously low. As a result of this call, the stack will abandon certain operations that hold excessive resources. (Pending ARP packets are thrown away, IP packet fragments pending reassembly are abandoned, etc.)</p>
<h4 id="exectimer-signal-110th-second-timer-tick">ExecTimer  Signal 1/10th Second Timer Tick</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ExecTimer();</code></pre></div>
<p><strong>Description</strong> This function is called ten times a second to inform the stack that one tenth of a second has elapsed. This function is called from a normal task thread, never an ISR. In theory, the function can be called from anywhere, but in practice, it is always called from a scheduler thread that also handles network packets. For more information, see the description of the NETCTRL functions in the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>).</p>
<p><a name="packet-buffer-manager-pbm-object"></a></p>
<h2 id="a.3-packet-buffer-manager-pbm-object">A.3 Packet Buffer Manager (PBM) Object</h2>
<p>The NDK uses a common packet buffer object that is managed by a module called the Packet Buffer Manager (PBM). The implementation of this manager determines the buffer strategy for the entire system.</p>
<p>Internally, the packet buffer objects are pointers to a structure of type PBM_Pkt; however, the buffers are abstracted into a handle of type PBM_Handle for use by code outside of the NDK. This helps protect the reserved members of the packet buffer structure from being misused.</p>
<p>If you are using XGCONF to configure your application, you can configure the size and location of the buffers managed by the PBM in the <strong>Buffers</strong> page of the NDK Global module configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="a.3.1-object-type">A.3.1 Object Type</h3>
<p><em>Static</em> - PBM objects are owned by a single entity and destroyed by their owner. Ownership of a packet buffer changes as it is passed via function calls.</p>
<h3 id="a.3.2-api-function-overview">A.3.2 API Function Overview</h3>
<p>The PBM API functions are as follows:</p>
<p><strong>Initialization/Shutdown Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PBM_open()</td>
<td>Open the Packet Buffer Manager</td>
</tr>
<tr class="even">
<td>PBM_close()</td>
<td>Close the Packet Buffer Manager</td>
</tr>
</tbody>
</table>
<p><strong>Create/Destroy Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PBM_alloc()</td>
<td>Create New Packet Buffer</td>
</tr>
<tr class="even">
<td>PBM_free()</td>
<td>Destroy (Free) Packet Buffer</td>
</tr>
<tr class="odd">
<td>PBM_copy()</td>
<td>Create an exact copy of the Packet Buffer</td>
</tr>
</tbody>
</table>
<p><strong>Property Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PBM_getBufferLen()</td>
<td>Get the length of the physical data buffer</td>
</tr>
<tr class="even">
<td>PBM_getDataBuffer()</td>
<td>Get a pointer to the physical data buffer</td>
</tr>
<tr class="odd">
<td>PBM_getValidLen()</td>
<td>Get the length of the valid data in the buffer</td>
</tr>
<tr class="even">
<td>PBM_getDataOffset()</td>
<td>Get the buffer offset to the start of the valid data</td>
</tr>
<tr class="odd">
<td>PBM_getIFRx()</td>
<td>Get the device handle of the ingress Ethernet device</td>
</tr>
<tr class="even">
<td>PBM_setValidLen()</td>
<td>Set the length of the valid data in the buffer</td>
</tr>
<tr class="odd">
<td>PBM_setDataOffset()</td>
<td>Set the buffer offset to the start of the valid data</td>
</tr>
<tr class="even">
<td>PBM_setIFRx()</td>
<td>Set the device handle of the ingress Ethernet device</td>
</tr>
</tbody>
</table>
<h3 id="a.3.3-api-function-description">A.3.3 API Function Description</h3>
<h4 id="pbm_open-open-the-packet-buffer-manager">PBM_open  Open the Packet Buffer Manager</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> PBM_open();</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>None.</li>
</ul>
<p><strong>Return Value</strong> Function returns 1 on success, and 0 on failure.</p>
<p><strong>Description</strong> This function is called once to open the PBM module and allow it to initialize its internal queues.</p>
<h4 id="pbm_close-close-the-packet-buffer-manager">PBM_close  Close the Packet Buffer Manager</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBM_close();</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>None.</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called at system shutdown to allow the PBM module to shut down and free any memory it has allocated.</p>
<h4 id="pbm_alloc-create-new-packet-buffer">PBM_alloc  Create New Packet Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">PBM_Handle PBM_alloc( <span class="dt">uint32_t</span> MaxSize );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>MaxSize: Maximum size of the physical data buffer required</li>
</ul>
<p><strong>Return Value</strong> Handle to the packet buffer or NULL on memory allocation error.</p>
<p><strong>Description</strong> This function is called to create a new packet buffer handle. When first created, the packet is entirely uninitialized, except for the physical characteristics of the data buffer (the buffer pointer and its physical length). The length of the buffer will be the same or greater than that specified by the caller in <em>MaxSize</em>.</p>
<h4 id="pbm_free-destroy-free-packet-buffer">PBM_free  Destroy (Free) Packet Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBM_free( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer to free</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to destroy a packet buffer. When called, all objects associated with the packet buffer are dereferenced or destroyed.</p>
<h4 id="pbm_copy-create-an-exact-copy-of-the-packet-buffer">PBM_copy  Create an exact copy of the Packet Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">PBM_Handle PBM_copy( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer to copy</li>
</ul>
<p><strong>Return Value</strong> Handle to the new copy of the packet buffer or NULL on memory allocation error.</p>
<p><strong>Description</strong> This function makes a duplicate copy of a packet buffer. It is usually called to copy a packet to be distributed to multiple destinations, or to be sent to multiple egress devices.</p>
<h4 id="pbm_getbufferlen-get-the-length-of-the-physical-data-buffer">PBM_getBufferLen  Get the Length of the Physical Data Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> PBM_getBufferLen( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
</ul>
<p><strong>Return Value</strong> Length of the physical data buffer in bytes.</p>
<p><strong>Description</strong> This function is called to get the length of the physical data buffer associated with the packet buffer handle. Note that the buffer length is fixed for the life of the buffer and cannot be changed.</p>
<h4 id="pbm_getdatabuffer-get-a-pointer-to-the-physical-data-buffer">PBM_getDataBuffer  Get a Pointer to the Physical Data Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">unsigned</span> <span class="dt">char</span> *PBM_getDataBuffer( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
</ul>
<p><strong>Return Value</strong> Pointer to the physical data buffer.</p>
<p><strong>Description</strong> This function is called to get a pointer to the physical data buffer associated with the packet buffer handle. Note that the physical buffer is fixed and cannot be changed.</p>
<h4 id="pbm_getvalidlen-get-the-length-of-the-valid-data-in-the-buffer">PBM_getValidLen  Get the Length of the Valid Data in the Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> PBM_getValidLen( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
</ul>
<p><strong>Return Value</strong> Byte length of the valid data stored in the packet buffer.</p>
<p><strong>Description</strong> This function is called to get the length of the valid data currently held in the packet buffer. When a packet buffer is created, it has no valid data, so this value is initially zero.</p>
<h4 id="pbm_getdataoffset-get-the-buffer-offset-to-the-start-of-the-valid-data">PBM_getDataOffset  Get the Buffer Offset to the start of the Valid Data</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> PBM_getDataOffset( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
</ul>
<p><strong>Return Value</strong> Byte offset from the start of the physical data buffer to the first byte of valid data.</p>
<p><strong>Description</strong> This function is called to get the offset in bytes from the start of the physical data buffer to the first byte of valid data. When a packet buffer is created, it has no valid data, so this value is initially zero.</p>
<h4 id="pbm_getifrx-get-the-device-handle-of-the-ingress-ethernet-device">PBM_getIFRx  Get the Device Handle of the Ingress Ethernet Device</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *PBM_getIFRx( PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
</ul>
<p><strong>Return Value</strong> NULL for locally created packets, or a handle to the device on which the packet was received.</p>
<p><strong>Description</strong> This function is called to get the handle to the ingress device where the packet contained in the packet buffer originated. Packet drivers in the HAL (both serial and Ethernet based) record the logical handle associated with all incoming packets. This identifies the packet type as well as the interface on which the packet was received.</p>
<h4 id="pbm_setvalidlen-set-the-length-of-the-valid-data-in-the-buffer">PBM_setValidLen  Set the Length of the Valid Data in the Buffer</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBM_setValidLen( PBM_Handle hPkt,
                      <span class="dt">uint32_t</span>   length );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
<li>length: Length of the valid data held in the packet buffer</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to set the length of the valid data in the packet buffer. It informs the system of the number of bytes of valid data that are stored in the physical data buffer. When a packet buffer is created, it has no valid data, so this value is initially zero.</p>
<h4 id="pbm_setdataoffset-set-the-buffer-offset-to-the-start-of-the-valid-data">PBM_setDataOffset  Set the Buffer Offset to the Start of the Valid Data</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBM_setDataOffset( PBM_Handle hPkt,
                        <span class="dt">uint32_t</span>   offset );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
<li>offset: Offset from start of data buffer to valid data</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to set the offset in bytes from the start of the physical data buffer to the first byte of valid data. It informs the system of where valid data is stored in the physical data buffer. When a packet buffer is created, it has no valid data, so this value is initially zero.</p>
<h4 id="pbm_setifrx-set-the-device-handle-of-the-ingress-ethernet-device">PBM_setIFRx  Set the Device Handle of the Ingress Ethernet Device</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBM_getIFRx( PBM_Handle hPkt,
                  <span class="dt">void</span>       *hDevice );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to packet buffer</li>
<li>hDevice: Handle to packet ingress device</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to set the handle to the ingress device where the packet contained in the packet buffer originated. Packet drivers in the HAL (both serial and Ethernet based) record the logical handle associated with all incoming packets. This identifies the packet type, as well as the interface on which the packet was received.</p>
<h2 id="a.4-packet-buffer-manager-queue-pbmq-object">A.4 Packet Buffer Manager Queue (PBMQ) Object</h2>
<p>The PBM module also includes a queue object that can be used to queue packet buffers for later use. The queue is a first in first out system, so it can be used to queue in-order packets as well as free buffers.</p>
<p>The PBMQ object is just a structure of type PBMQ. Once this structure is declared and initialized, it is ready for use.</p>
<h3 id="a.4.1-object-type">A.4.1 Object Type</h3>
<p><em>Static</em> - PBMQ objects are owned by a single entity and destroyed by their creator.</p>
<h3 id="a.4.2-api-function-overview">A.4.2 API Function Overview</h3>
<p>The PBM API functions are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PBMQ_init()</td>
<td>Initialize a PBMQ object for use</td>
</tr>
<tr class="even">
<td>PBMQ_count()</td>
<td>Return the number of PBM packet buffers on the queue</td>
</tr>
<tr class="odd">
<td>PBMQ_enq()</td>
<td>Enqueue a PBM packet buffer onto the queue</td>
</tr>
<tr class="even">
<td>PBMQ_deq()</td>
<td>Dequeue a PBM packet buffer off the queue</td>
</tr>
</tbody>
</table>
<h3 id="a.4.3-api-function-description">A.4.3 API Function Description</h3>
<h4 id="pbmq_init-initialize-a-pbmq-object-for-use">PBMQ_init  Initialize a PBMQ Object for Use</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBMQ_init( PBMQ *pQ );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pQ: Pointer to a structure of type PBMQ</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called once to initialize a PBMQ structure for use.</p>
<h4 id="pbmq_count-return-the-number-of-pbm-packet-buffers-on-the-queue">PBMQ_count  Return the Number of PBM Packet Buffers on the Queue</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> PBMQ_count( PBMQ *pQ );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pQ: Pointer to a structure of type PBMQ</li>
</ul>
<p><strong>Return Value</strong> Number of queued buffers.</p>
<p><strong>Description</strong> This function is called once to return the number of PBM packet buffers currently on the indicated queue.</p>
<h4 id="pbmq_enq-enqueue-a-pbm-packet-buffer-onto-the-queue">PBMQ_enq  Enqueue a PBM Packet Buffer onto the Queue</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> PBMQ_enq( PBMQ       *pQ,
               PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pQ: Pointer to a structure of type PBMQ</li>
<li>hPkt: Handle to PBM packet buffer to add to queue</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to add the supplied PBM packet buffer to the indicated queue.</p>
<h4 id="pbmq_deq-dequeue-a-pbm-packet-buffer-off-the-queue">PBMQ_deq  Dequeue a PBM Packet Buffer Off the Queue</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">PBM_Handle PBMQ_deq( PBMQ *pQ );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pQ: Pointer to a structure of type PBMQ</li>
</ul>
<p><strong>Return Value</strong> Handle to PBM packet buffer, or NULL on empty queue.</p>
<p><strong>Description</strong> This function is called to remove a PBM packet buffer from the indicated queue. The function returns a handle to the PBM packet buffer removed from the queue, or NULL if the queue was empty.</p>
<h2 id="a.5-jumbo-packet-buffer-manager-jumbo-pbm-object">A.5 Jumbo Packet Buffer Manager (Jumbo PBM) Object</h2>
<p>The PBM object is capable of handling memory allocations only up to buffer sizes of maximum MMALLOC_MAXSIZE (3068 bytes). For handling memory allocation for jumbo frames, i.e., packets typically larger than 1500 bytes in size, and that could be as large as 10K bytes, the PBM object invokes the Jumbo PBM APIs internally. The Jumbo PBM is responsible for handling memory allocation and de-allocation for Jumbo frames.</p>
<p>The following are some of the main features of Jumbo PBM:</p>
<ul>
<li>The Jumbo PBM implementation is similar to the PBM implementation, except that it can handle larger block sizes than the ones in PBM and ranges between 3K and 10K bytes by default.</li>
<li>Jumbo PBM does not use any TI-RTOS Kernel APIs or dynamic memory allocation method for its memory allocation and, therefore, can be used safely in interrupt context. It uses a static memory allocation method, i.e., it reserves a chunk of memory in the <em>far</em> section of the device memory and uses it to allocate for the packet buffers required.</li>
<li>The Jumbo PBM allocates memory off a separate section in the memory than the PBM. The PBM uses the memory sections <em>NDK_PACKETMEM</em>, <em>NDK_MMBUFFER</em> for its memory allocation. On the other hand, Jumbo PBM defines and uses a section called <em>NDK_JMMBUFFER</em> for its memory allocation. The size of this section and its placement are all customizable by an application user.</li>
<li>A sample implementation of the Jumbo PBM is provided in the NDK OS abstraction layer (OS AL). The customer is expected to customize this implementation according to their application needs and systems memory constraints. The memory section sizes, block sizes, and the allocation method is all up for customization.</li>
<li>Jumbo PBM APIs are not expected to be invoked directly. The application and driver must call the <em>PBM_alloc()</em>/<em>PBM_free()</em> APIs only. These APIs in turn invoke the Jumbo PBM APIs to allocate/clean-up memory if the memory requested is larger than what PBM can handle, i.e., 3K bytes.</li>
</ul>
<p>For a sample implementation of the Jumbo PBM, refer to the source file <code>/ti/ndk/stack/jumbo_pbm.c</code>.</p>
<h3 id="a.5.1-api-function-overview">A.5.1 API Function Overview</h3>
<p>The Jumbo PBM API are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>_jumbo_mmInit()</td>
<td>API to initialize the Jumbo PBM object</td>
</tr>
<tr class="even">
<td>jumbo_mmAlloc()</td>
<td>Allocates memory requested for the new packet buffer</td>
</tr>
<tr class="odd">
<td>jumbo_mmFree()</td>
<td>Frees up the memory held in the packet buffer</td>
</tr>
<tr class="even">
<td>_jumbo_mmCheck()</td>
<td>Dump the current memory usage in Jumbo PBM object</td>
</tr>
</tbody>
</table>
<h3 id="a.5.2-api-function-description">A.5.2 API Function Description</h3>
<h4 id="jumbo_mminit-initialize-the-jumbo-pbm-object-for-use.">_jumbo_mmInit  Initialize the Jumbo PBM object for use.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> _jumbo_mmInit();</code></pre></div>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Return Value</strong> Always returns 1 to indicate success.</p>
<p><strong>Description</strong> This function is called during the system initialization to initialize the Jumbo PBM memory and any relevant data structures.</p>
<h4 id="jumbo_mmalloc-allocate-a-new-jumbo-packet-buffer.">jumbo_mmAlloc  Allocate a new Jumbo packet buffer.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *jumbo_mmAlloc( <span class="dt">uint32_t</span> Size );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Size: Size of the packet buffer to allocate.</li>
</ul>
<p><strong>Return Value</strong> Pointer to the newly allocated packet buffer.</p>
<p><strong>Description</strong> This function is called by the PBM object when an application/driver requests for a packet buffer larger than what it can handle, i.e., MMALLOC_MAXSIZE (3068 bytes). This API allocates memory out of jumbo memory pool and returns a pointer to the packet buffer just allocated.</p>
<h4 id="jumbo_mmfree-frees-up-memory-held-by-the-packet-buffer.">jumbo_mmFree  Frees up memory held by the packet buffer.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> jumbo_mmFree( <span class="dt">void</span> *p );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>p: Handle to the packet buffer that was obtained earlier using jumbo_mmAlloc API and that needs to be freed up.</li>
</ul>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This API returns the packet buffer to the jumbo memory pool for use again by the application. The packet buffer handle passed as an argument to this function must be a valid handle obtained using <em>jumbo_mmAlloc()</em> API earlier.</p>
<h4 id="jumbo_mmcheck-dumps-the-memory-usage-stats-for-jumbo-pbm-object.">_jumbo_mmCheck  Dumps the memory usage stats for jumbo PBM object.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _jumbo_mmCheck( <span class="dt">uint32_t</span> CallMode,
                     <span class="dt">int</span> (*pPrn)(<span class="dt">const</span> <span class="dt">char</span> *,...) );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>CallMode: Specifies the type of stats that need to be printed out. The 3 supported call modes are:
<ul>
<li>MMCHECK_MAP: Map out allocated memory, but dont dump IDs</li>
<li>MMCHECK_DUMP: Dump allocated block IDs</li>
<li>MMCHECK_SHUTDOWN: Dump all allocated blocks and free</li>
</ul></li>
<li>pPrn: Callback function pointer to be notified</li>
</ul>
<p><strong>Description</strong> This function iterates through the Jumbo PBM objects memory allocation table and dumps the current memory usage stats according to the arguments specified.</p>
<p><a name="stack-event-object"></a></p>
<h2 id="a.6-stack-event-stkevent-object">A.6 Stack Event (STKEVENT) Object</h2>
<p>Although technically not part of the NDK, the STKEVENT event object is a central component to the low level architecture. It ties the HAL layer to the network scheduler thread. The network scheduler thread waits on events from various device drivers in the system including the Ethernet, serial, and timer drivers. The device drivers use the STKEVENT object to inform the scheduler that an event has occurred.</p>
<h3 id="a.6.1-object-type">A.6.1 Object Type</h3>
<p><em>Static</em> - The STKEVENT object is created and owned by the network scheduler.</p>
<h3 id="a.6.2-api-function-overview">A.6.2 API Function Overview</h3>
<p>The STKEVENT object is implemented entirely via #define MACROs and therefore, does not have a true API. This allows the network scheduler to present an abstracted API to the HAL layer for network events. The STKEVENT object is a simple structure and manipulated directly by the network control module (NETCTRL). This is discussed further in the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>).</p>
<p>The two MACRO functions are as follows:</p>
<p><strong>Property Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STKEVENT_init()</td>
<td>Initialize a new STKEVENT object to NULL</td>
</tr>
<tr class="even">
<td>STKEVENT_signal()</td>
<td>Signal a new STKEVENT event code</td>
</tr>
</tbody>
</table>
<h3 id="a.6.3-api-function-description">A.6.3 API Function Description</h3>
<h4 id="stkevent_init-initialize-a-new-stkevent-object-to-null">STKEVENT_init  Initialize a new STKEVENT object to NULL</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> STKEVENT_init( STKEVENT_Handle  hEvent,
                    Semaphore_Handle hSem )</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hEvent: Handle to STKEVENT object</li>
<li>hSem: Handle to Semaphore object to use in STKEVENT (if any)</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called once to initialize the STKEVENT object so it is ready for use.</p>
<blockquote>
<p><strong>NOTE:</strong> This function is implemented as a multi-line macro, so care should be taken when using it in the body of an if/else statement.</p>
</blockquote>
<h4 id="stkevent_signal-signal-a-new-stkevent-event-code">STKEVENT_signal  Signal a New STKEVENT Event Code</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> STKEVENT_signal( STKEVENT_Handle hEvent,
                      <span class="dt">uint32_t</span>        EventCode,
                      <span class="dt">uint32_t</span>        fHwAsynch )</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hEvent: Handle to STKEVENT object</li>
<li>EventCode: Type of event being signaled</li>
<li>fHwAsynch: Flag indicating event triggered by an asynchronous hardware event (e.g., ISR, PRD).</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called from a device driver to signal an event to the network scheduler for further processing. The STKEVENT handle <em>hEvent</em> is an event handle supplied to the device driver when the driver is first initialized. The <em>EventCode</em> parameter specifies the type of event. The defined events include the following:</p>
<ul>
<li>STKEVENT_TIMER: 100 ms Timer Tick Event</li>
<li>STKEVENT_ETHERNET: One or more Ethernet packets received</li>
<li>STKEVENT_SERIAL: One or more serial packets received</li>
<li>STKEVENT_LINKUP: Link has come up</li>
<li>STKEVENT_LINKDOWN: Link has gone down</li>
</ul>
<p>The <em>fHwAsynch</em> flag specifies whether the event was triggered by an external asynchronous hardware source. Examples of asynchronous events include hardware interrupts or timer PRDs. An example of a non-asynchronous event would be detecting an event from within a driver service check function. Service check functions are called periodically (or polled) by the scheduler.</p>
<blockquote>
<p><strong>NOTE:</strong> This function is implemented as a multi-line macro, so care should be taken when using it in the body of an if/else statement.</p>
</blockquote>
<h2 id="a.7-link-layer-information-lli-object">A.7 Link Layer Information (LLI) Object</h2>
<p>To make full use of the stack objects described in this section, it is necessary to understand some of the stacks basic building block components. One such component is the Link Layer Information Object, or LLI for short.</p>
<p>An LLI object is an ARP table entry. This implementation of the IP stack combines the traditional route table and ARP table into a single table with a single API. Routes that need to use the ARP function include an ARP status object, called LLI. Normally, you only use an LLI object to inspect the ARP status of the route table.</p>
<p>The ARP entries can be of two types:</p>
<ul>
<li><strong>Dynamic:</strong> These ARP entries are managed using the Address Resolution Protocol (ARP), i.e., through exchange of ARP Request and ARP Reply messages between the NDK stack and the networking device engaged in communication with it. These entries are dynamic and have a keep-alive timeout associated with them. An ARP/LLI entrys lifetime is extended using <em>ARP revalidation logic</em> if it has been active, i.e., if it has been used by an application in the system in the last ARP inactivity timeout seconds. These keep-alive and ARP inactivity timeouts are configurable in NDK and can be tuned as per the application and system needs. However, if the ARP entry was inactive or idle, or if the ARP revalidation process failed, the ARP entry is deleted and the communication between the NDK stack and the networking device in question is broken unless it is re-established using ARP protocol again. To configure a dynamic ARP entry, the NDK stack internally uses the <em>LLIValidateRoute()</em> API. This API is documented in the following section.</li>
<li><strong>Static:</strong> On the other hand, static entries are ARP entries that are manually configured by an application in the stack and they have no timeout associated with them. They remain valid until the application or user deletes them. No ARP request-reply transactions are performed here.</li>
</ul>
<p>Both the dynamic and static ARP entries are supported in NDK stack. The next section discusses the APIs exported by NDK stack to configure dynamic and static ARP entries.</p>
<h3 id="a.7.1-arp-revalidation-logic">A.7.1 ARP Revalidation Logic</h3>
<p>Each dynamic LLI/ARP entry in NDK is associated with a non-zero <em>Keep-alive timeout</em> (controlled using CFGITEM_IP_RTKEEPALIVETIME). This timeout determines the length of time in seconds that an LLI entry and its associated route entry is valid. The routing module in the stack internally runs a timer and periodically checks to see if any routes or associated LLI entries are about to expire. If it finds a route/LLI entry that is about to expire, it checks to see if that LLI entry is <em>active</em>, i.e., if it has been used in the last <em>Route Inactivity timeout</em> seconds (configured using CFGITEM_IP_RTARPINACTIVITY). If so, the LLI module initiates an <em>ARP Request/Reply</em> exchange to revalidate the LLI entry even before it expires and disrupts any ongoing communication. If an ARP reply is received successfully for the request sent out earlier, the LLI entry is marked <em>valid</em> again for another <em>Keep-alive timeout</em> seconds and any packets using the route/LLI entry are sent out of the device. However, if no ARP reply is received, the ARP request is retransmitted and this process is repeated 3 times before the revalidation process is aborted and the associated LLI/Route entries are deleted. Also, if the LLI/Route entry was inactive or never used in the last <em>Route Inactivity Timeout</em> seconds ARP revalidation process is not done for such an entry and is deleted immediately from the system. Once the LLI/Route entries are deleted they have to be re-established using a successful <em>ARP Request-Reply</em> exchange triggered by an applications attempt to transmit packets to the intended destination.</p>
<h3 id="a.7.2-object-type">A.7.2 Object Type</h3>
<p><em>Static</em> - LLI objects are owned and destroyed by their creator.</p>
<h3 id="a.7.3-information-structure">A.7.3 Information Structure</h3>
<p>The following data structure is used to hold information regarding an ARP/LLI entry in the NDK stack. This structure is especially useful in presenting the LLI entry info in a simple, compact way to an application requesting information about the LLI entries configured in the stack.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co"> * </span><span class="an">@brief</span>
<span class="co"> *  This structure describes the LLI/ARP Information Object.</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@details</span>
<span class="co"> *  This data structure is used by the LLI module to populate</span>
<span class="co"> *  LLI/ARP Entry information contained in the NDK Kernel</span>
<span class="co"> *  in a simple, user-friendly way to the application.</span>
<span class="co"> *</span>
<span class="co"> */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> _lli_info
{
    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co"> Links to other LLI_INFO Objects</span>
<span class="co">     */</span>
    LIST_NODE Links;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co"> Boolean Flag to indicate whether this LLI</span>
<span class="co">     * entry is a static / dynamic entry.</span>
<span class="co">     */</span>
    <span class="dt">unsigned</span> <span class="dt">char</span>     IsStatic;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co"> The 4 byte IPv4 address associated with this</span>
<span class="co">     * LLI/ARP Entry.</span>
<span class="co">     */</span>
    <span class="dt">uint32_t</span>       IPAddr;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co"> The 6 byte Ethernet MAC address associated with this</span>
<span class="co">     * LLI/ARP Entry.</span>
<span class="co">     */</span>
    <span class="dt">unsigned</span> <span class="dt">char</span>     MacAddr[<span class="dv">6</span>];
} LLI_INFO;</code></pre></div>
<h3 id="a.7.4-api-function-overview">A.7.4 API Function Overview</h3>
<p>The LLI API functions are as follows:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LLIGetMacAddr()</td>
<td>Get the Mac Address Associated with this LLI.</td>
</tr>
<tr class="even">
<td>LLIValidateRoute()</td>
<td>Validate an IP address/MAC address pairing in the route table.</td>
</tr>
<tr class="odd">
<td>LLIAddStaticEntry</td>
<td>Add a new static ARP entry/update an existing static ARP entry/modify a dynamic entry to a static ARP entry in the stack.</td>
</tr>
<tr class="even">
<td>LLIRemoveStaticEntry</td>
<td>Remove a previously configured static ARP entry from the stack.</td>
</tr>
<tr class="odd">
<td>LLIGetStaticARPTable</td>
<td>Retrieve a copy of the static ARP table from the stack.</td>
</tr>
<tr class="even">
<td>LLIFreeStaticARPTable</td>
<td>Cleans the memory allocated by a previous call to LLIGetStaticARPTable API.</td>
</tr>
</tbody>
</table>
<h3 id="a.7.5-api-functions">A.7.5 API Functions</h3>
<h4 id="lligetmacaddr-get-the-mac-address-associated-with-this-lli">LLIGetMacAddr  Get the Mac Address Associated with this LLI</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> LLIGetMacAddr( <span class="dt">void</span>          *hLLI,
                        <span class="dt">unsigned</span> <span class="dt">char</span> *pMacAddr,
                        <span class="dt">uint32_t</span>      MaxLen );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hLLI: Handle to LLI object</li>
<li>pMacAddr: Pointer to buffer to write Mac address data</li>
<li>MaxLen: Maximum byte length of buffer (must be at least 6)</li>
</ul>
<p><strong>Return Value</strong> Returns 1 if the Mac address for the LLI is valid and it was successfully written to the supplied buffer.</p>
<p>Returns 0 if the LLI does not contain a valid Mac address, or one of the calling parameters is invalid.</p>
<p><strong>Description</strong> This function is called to return the six byte Mac address associated with the LLI. It is used in system programming to obtain the hardware address from an LLI contained in a route entry.</p>
<h4 id="llivalidateroute-validate-an-ip-addressmac-address-pairing-in-the-route-table">LLIValidateRoute  Validate an IP Address/MAC Address Pairing in the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *LLIValidateRoute(<span class="dt">void</span>          *hIF,
                       <span class="dt">uint32_t</span>      IPAddr,
                       <span class="dt">unsigned</span> <span class="dt">char</span> *MacAddr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hIF: Handle to the interface on which the target IP address/MAC address appears</li>
<li>IPAddr: IP address to validate</li>
<li>MacAddr: Six byte MAC address corresponding to the supplied IP address</li>
</ul>
<p><strong>Return Value</strong> Referenced handle to route or NULL if there was no room to create the entry.</p>
<p><strong>Description</strong> This function is called to create or update an entry in the stack route table for the supplied IP address. The entry for the given IP address is marked as valid, and assigned the supplied MAC address. Packets sent to the IP address will be assigned the given MAC address, and no ARP request will be sent.</p>
<p>This function also updates the route in the LLI (ARP) expiration list. It allows an application to change the state of the ARP entry even if the stack has already created the route. It should be used when it is unclear if the route (really ARP table entry) already exists or not.</p>
<p>Note that this function returns a referenced route handle. This handle must be dereferenced using the <em>RtDeRef()</em> function when it is no longer required. Because the route is treated as a standard ARP entry (with a standard expiration time as supplied in the configuration structure), the route can be dereferenced immediately.</p>
<h4 id="lliaddstaticentry-addupdate-a-static-arp-entry-or-change-a-dynamic-entry-to-a-static-arp-entry">LLIAddStaticEntry  Add/update a static ARP entry or change a dynamic entry to a static ARP entry</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> LLIAddStaticEntry( <span class="dt">uint32_t</span>      IPAddr,
                       <span class="dt">unsigned</span> <span class="dt">char</span> *pMacAddr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IP Address: IPv4 address of the device</li>
<li>pMacAddr: 6 byte EMAC address of the device corresponding to the supplied IPv4 address.</li>
</ul>
<p><strong>Return Value</strong> Returns 0 on success or -1 on invalid input/error in LLI entry creation.</p>
<p><strong>Description</strong> This API validates the input and returns an error (-1) if any of the following conditions are met:</p>
<ul>
<li>No MAC Address specified</li>
<li>IPv4 address specified is either a broadcast/multicast address</li>
<li>IPv4 address specified is a local IP address, i.e., the IP address specified is in use by a local interface attached to the NDK stack.</li>
<li>IPv4 address is not reachable using the routes configured. That is, there is no Network / Cloning route (no local interface is on the same subnet as specified IPv4 address) that can be used to reach the IPv4 address specified.</li>
<li>Memory allocation issue.</li>
</ul>
<p>If no error encountered, this API does the following:</p>
<ul>
<li>Tries to find a duplicate static entry matching the IP Address Specified. If a duplicate static entry found, updates the entry with the new MAC address specified. Returns Success (0).</li>
<li>Checks for any dynamic LLI/route entries matching the IPv4 address. If found, deletes this entry and creates a new static LLI entry and host route with the IPv4 address and new MAC address specified. Returns Success (0). This ensures that Static LLI entries always override the dynamic ones automatically configured by the stack.</li>
<li>If no duplicate static/dynamic entry already exists, adds a new static LLI entry and an associated Host route to the stack using the IPv4 address and MAC address specified. Returns Success (0). The static LLI entries have to be removed by an application manually if not in use or will be deleted when the NDK stack is shutdown.</li>
</ul>
<p>This API is an <em>application level</em> API and can be called from outside the kernel mode.</p>
<h4 id="lliremovestaticentry-remove-a-previously-configured-static-arp-entry-from-the-stack.">LLIRemoveStaticEntry  Remove a previously configured static ARP entry from the stack.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> LLIRemoveStaticEntry( <span class="dt">uint32_t</span> IPAddr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPAddr: IPv4 address of the device</li>
</ul>
<p><strong>Return Value</strong> Returns 0 on success or -1 on invalid input/error in LLI entry removal.</p>
<p><strong>Description</strong> This API searches for a static route and associated LLI entry in the NDK stack using the IPv4 address specified and if no entry found returns an error, i.e., -1. If a valid entry is found, it removes the route and corresponding LLI entries and cleans up any memory associated with them. On successful clean up, returns 0. If this API is not explicitly called to remove a previously configured static ARP entry, it is cleaned up only during the NDK stack shutdown.</p>
<p>This API is an <em>application level</em> API and can be called from outside the kernel mode.</p>
<h4 id="lligetstaticarptable-retrieve-a-copy-of-the-static-arp-table-from-the-stack.">LLIGetStaticARPTable  Retrieve a copy of the static ARP table from the stack.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> LLIGetStaticARPTable( <span class="dt">uint32_t</span>*  pNumEntries,
                           LLI_INFO** pStaticArpTable );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNumEntries: Pointer to hold the number of static ARP entries in the stack.</li>
<li>pStaticArpTable: Pointer to hold the replicated static ARP table returned by this API</li>
</ul>
<p><strong>Return Value</strong> Updates <em>pNumEntries</em> with the number of static ARP Entries and <em>pStaticArpTable</em> with a list of LLI_INFO structures containing the information of all static ARP entries configured in the stack.</p>
<p><strong>Description</strong> This API can be used to retrieve the number of static ARP entries and a replicated list of such entries configured in the system. This API traverses through the route and LLI (ARP) table configured in NDK, finds any static routes/LLI entries configured, and creates a copy of them and returns them as a linked list of LLI_INFO structures for the requesting application to use. In case of a memory allocation error or if no static ARP entries found, this API returns the number of entries (pNumEntries) as zero to indicate the same.</p>
<p>This API is an <em>application level</em> API and can be called from outside the kernel mode.</p>
<h4 id="llifreestaticarptable-cleans-the-memory-allocated-by-a-previous-call-to-lligetstaticarptable-api.">LLIFreeStaticARPTable  Cleans the memory allocated by a previous call to LLIGetStaticARPTable API.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> LLIFreeStaticARPTable( LLI_INFO* pStaticArpTable );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pStaticArpTable: This is the head of the duplicated static ARP table list which has to be cleaned up</li>
</ul>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This function is called to clean the memory allocated by a previous call to LLIGetStaticARPTable API. This function cleans the replicated copy of the static ARP table.</p>
<p>This API is an <em>application level</em> API and can be called from outside the kernel mode.</p>
<h2 id="a.8-binding-object">A.8 Binding Object</h2>
<p>For a device object to live on the network, it must have an IP address and knowledge of its IP subnet. The process of assigning an IP address and subnet to a device binds the device with the desired IP addressing.</p>
<h3 id="a.8.1-object-type">A.8.1 Object Type</h3>
<p><em>Static</em> - Binding objects are generally created and destroyed by the same entity.</p>
<h3 id="a.8.2-bind-api-functions">A.8.2 BIND API Functions</h3>
<p>Although the Bind object API is larger than that discussed here, this section covers the portion of the API that is encountered by a system application.</p>
<h4 id="bindnew-create-new-ip-binding">BindNew  Create New IP Binding</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *BindNew( <span class="dt">void</span>     *hIF,
               <span class="dt">uint32_t</span> IPAddr,
               <span class="dt">uint32_t</span> IPMask );</code></pre></div>
<p><strong>Return Value</strong> Returns a handle to the Bind object, or NULL on error.</p>
<p><strong>Description</strong> Binds the indicated IP address and mask to the supplied Ether device. The handle to the Ether device object is specified as hIF - or an handle to an <em>interface</em>, because the interface may or may not be an Ethernet device (but always is in this version).</p>
<p>The IP address and mask arguments are given the type uint32_t. The IP data must be supplied in network format. If unsure of the network format for your hardware, use the htonl() macro function on the native format (where 1.2.3.4 = = 0x01020304).</p>
<h4 id="bindfree-destroy-ip-binding-object">BindFree  Destroy IP Binding Object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> BindFree( <span class="dt">void</span> *hBind );</code></pre></div>
<p><strong>Description</strong> Destroys the indicated Bind object, and frees its associated memory. This function removes the IP address and subnet association in the system route table. It has no effect on the Ether object involved in the binding.</p>
<h4 id="bindgetfirst-start-enumeration-of-binding-objects">BindGetFirst  Start Enumeration of Binding Objects</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *BindGetFirst();</code></pre></div>
<p><strong>Description</strong> Returns a handle to the first binding installed in the system (or NULL if no bindings exist).</p>
<h4 id="bindgetnext-continue-enumeration-of-binding-objects">BindGetNext  Continue Enumeration of Binding Objects</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *BindGetNext( <span class="dt">void</span> *hBind );</code></pre></div>
<p><strong>Description</strong> Returns a handle to the binding in the installed binding list that follows the indicated binding (or NULL if no more bindings exist). Note that bindings are not internally kept in chronological order in which they were installed.</p>
<h4 id="bindgetif-get-the-ether-object-that-is-bound-by-this-binding-object">BindGetIF  Get the Ether Object that is Bound by this Binding Object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *BindGetIF( <span class="dt">void</span> *hBind );</code></pre></div>
<p><strong>Description</strong> Returns a handle to the Ether object that is bound by this binding object. Note that a binding is nothing more than an assignment of an Ether object to an IP address/network.</p>
<h4 id="bindgetip-get-the-ip-addressnetwork-that-is-bound-by-this-binding-object">BindGetIP  Get the IP Address/Network that is Bound by this Binding Object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> BindGetIP( <span class="dt">void</span>     *hBind,
                <span class="dt">uint32_t</span> *pIPHost,
                <span class="dt">uint32_t</span> *pIPNet,
                <span class="dt">uint32_t</span> *pIPMask );</code></pre></div>
<p><strong>Description</strong> Returns the IP address and mask as requested by the calling arguments. Any of the pointer arguments can be NULL if the information is not required.</p>
<p>The arguments are defined as follows:</p>
<ul>
<li>pIPHost: Pointer to the local IP address assigned by this binding</li>
<li>pIPNet: Pointer to the network assigned by this binding (IP address AND IP Mask)</li>
<li>pIPMask: Pointer to the subnet mask of the network assigned by this binding</li>
</ul>
<h2 id="a.9-route-object">A.9 Route Object</h2>
<p>The route manager maintains IP routing information. It is called by various routines to get and set route information. A route object is a destination on the network. Locally, it consists of an egress interface and a next hop IP address.</p>
<p>This section describes a subset of the route object. Flags, features, and API calls have been omitted for simplicity. Also, documenting the entire API would require the documentation of other stack objects that are not covered in this document.</p>
<h3 id="a.9.1-object-type">A.9.1 Object Type</h3>
<p>Referenced - Route objects are referenced and dereferenced as needed. The object is removed when the reference count reaches ZERO.</p>
<h3 id="a.9.2-route-entry-flags-definition">A.9.2 Route Entry Flags Definition</h3>
<p>Associated with each route is a collection of entry/status flags. These flags indicate the type of route and its status. Most system programming is not concerned with the route entry flags. They are listed here for completeness. The definition of the various flags is as follows:</p>
<ul>
<li><p>FLG_RTE_UP - Entry is up</p>
<p>When set, indicates that the route is valid. The only time this flag is cleared is when the route is being initialized, or when an error condition is signaled via RtSetFailure(). The flag is reset to TRUE by calling <em>RtSetFailure()</em> with NULL failure code, or if the route is modified.</p></li>
<li><p>FLG_RTE_EXPIRED - Entry is expired</p>
<p>When set, indicates that the route is expired. The flag cannot be cleared. A new route must be created. Expired routes are never found, but a route cached by another entity may expire while it is being held.</p></li>
<li><p>FLG_RTE_STATIC - Entry is static</p>
<p>This flag is set when a route should remain in the routing table even if it has no references. Various routes can be static. Static routes are manually referenced by the system during create, and manually de-referenced by the system during system shutdown.</p></li>
<li><p>FLG_RTE_BLACKHOLE - Entry is a blackhole</p>
<p>When set, indicates that the route is a black hole. All packets destined for this address are silently discarded.</p></li>
<li><p>FLG_RTE_REJECT - Entry is rejected When set, indicates that the route is to an invalid address. All packets destined for this address are discarded with an error indication.</p></li>
<li><p>FLG_RTE_MODIFIED - Route has been auto modified</p>
<p>When set, indicates that the route has been modified as a result of an ICMP redirect message. This can occur only to GATEWAY routes, and only if ICMP modifications are enabled in the stack configuration.</p></li>
<li><p>FLG_RTE_DYNAMIC - Route has been auto created</p>
<p>When set, indicates that the route has been created as a result of an ICMP redirect message. ICMP can only create GATEWAY routes, and may do so only if ICMP modifications are enabled in the stack configuration.</p></li>
<li><p>FLG_RTE_PROXYPUB - Reply to ARP with clients MAC address</p>
<p>This flag indicates that the router is a proxy publisher of another entitys MAC address. When set, the ARP protocol will respond to ARP requests for the routes IP address with the supplied static MAC address when the host is on the same IF device as the incoming ARP request. This allows support of hosts that do not implement ARP but are on the same physical Ethernet network. PROXYPUB entries are always created with a MAC address and contain a static LLI (link-layer info, i.e., ARP entry).</p></li>
<li><p>FLG_RTE_PROXY - Reply to ARP with routers MAC address</p>
<p>This flag indicates that the router is acting as a proxy for this host or network route. When set, the ARP protocol will respond to ARP requests with its own MAC address for the associated IP host or network when the network appears on a different IF device from the incoming ARP request. The MAC address supplied in the reply is the local MAC of the ingress IF device. This technique tricks clients into sending packets to the router when subnets are split across physical devices on a router.</p>
<p>One potential use applies when the stack is acting as a PPP server and Ethernet router. If a PPP client is made part of the same IP subnet as an Ethernet based interface, the stack acts as the PPP clients proxy so that Ethernet peers can communicate via ARP.</p></li>
<li><p>FLG_RTE_CLONING - Cloning route to a local IP subnet</p>
<p>When set, indicates that the network route is a cloning route. Cloning routes clone (spawn to) host routes when a route search is performed on a host address that is a member of the cloning routes network (via the address and subnet mask). Cloned host routes take on most of the properties of their parent network route, with the following alterations:</p>
<ul>
<li>Any MODIFIED or DYNAMIC flags are cleared.</li>
<li>The STATIC flag is never set.</li>
<li>The HOST flag is set and the netmask is set to 1s.</li>
<li>The CLONING flag is cleared.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Cloning routes are routes to a network (IP and subnet). These routes are added automatically when an IP network is added to a device via a Bind object. Take care when adding this type of route manually.</p>
</blockquote></li>
<li><p>FLG_RTE_HOST - Host route (no subnet mask)</p>
<p>When set, indicates that the route entry is a host route. A host route has no subnet mask (or rather a subnet mask of all 1s). When searching for a route, host routes always match before network routes (but this behavior can be overridden).</p></li>
<li><p>FLG_RTE_GATEWAY - Destination is available via a Gateway</p>
<p>When set, indicates that the host or network route is indirectly accessible via an IP gateway. For a route with this flag set, the GateIP address is always valid. Most GATEWAY routes will also be network routes; however, a host redirect from ICMP can create a host route with a different gateway than its parent route. When searching for a route, gateway routes always match before host routes (but this behavior can be overridden).</p></li>
<li><p>FLG_RTE_IFLOCAL - IP address is Local to the stack</p>
<p>When set, indicates that the host route does not have a valid LLI (ARP) entry because the host is local to the stack. The MAC address of this local IP host address can be obtained from the interface handle associated with the route.</p>
<blockquote>
<p><strong>NOTE:</strong> Local routes are in the routing table to route packets that originate in the stacks upper layers. When handling ARP requests and routing of incoming packets from outside the stack, the IP address list published via the Bind object is used. The ARP will not respond to, nor will the IP accept, packets addressed to an IP address that is not in the Bind list, even if an IFLOCAL address entry exists in the route table. As with a cloning route, the Bind object is the best way to create a local route.</p>
</blockquote></li>
</ul>
<h3 id="a.9.3-route-entry-flags-guidelines">A.9.3 Route Entry Flags Guidelines</h3>
<p>See the following for some general guidelines to use when creating new routes. Use the definitions listed above with the following legal flag combinations:</p>
<ul>
<li>Setting FLG_RTE_BLACKHOLE
<ul>
<li>FLG_RTE_REJECT - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_REJECT
<ul>
<li>FLG_RTE_BLACKHOLE - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_CLONING
<ul>
<li>FLG_RTE_HOST - must be OFF</li>
<li>FLG_RTE_GATEWAY - must be OFF</li>
<li>FLG_RTE_IFLOCAL - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_HOST
<ul>
<li>FLG_RTE_CLONING - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_GATEWAY
<ul>
<li>FLG_RTE_CLONING - must be OFF</li>
<li>FLG_RTE_IFLOCAL - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_IFLOCAL
<ul>
<li>FLG_RTE_HOST - must be ON</li>
<li>FLG_RTE_CLONING - must be OFF</li>
<li>FLG_RTE_GATEWAY - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_PROXYPUB
<ul>
<li>FLG_RTE_HOST - must be ON</li>
<li>FLG_RTE_CLONING - must be OFF</li>
<li>FLG_RTE_GATEWAY - must be OFF</li>
</ul></li>
<li>Setting FLG_RTE_PROXY
<ul>
<li>FLG_RTE_CLONING - must be OFF</li>
<li>FLG_RTE_GATEWAY - must be OFF</li>
</ul></li>
</ul>
<h3 id="a.9.4-api-functions">A.9.4 API Functions</h3>
<p>The Route API is the most extensive API that a system task uses outside of the stack routines themselves. As with the other stack APIs, this guide does not document the entire API.</p>
<p>Calls that accept a CallFlags argument can be supplied with the FLG_RTF_REPORT flag to indicate that the call should result in a route report to the route control object. The route control object is described later in this section.</p>
<h4 id="rtref-reference-a-route">RtRef  Reference a Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtRef( <span class="dt">void</span> *hRt );</code></pre></div>
<p><strong>Description</strong> Called to add one to the reference count of a route. An application that keeps a route it did not create itself should reference the route before it uses it, and dereference it when it is through.</p>
<h4 id="rtderef-dereference-a-route">RtDeRef  Dereference a Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtDeRef(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Description</strong> Called to remove one from the reference count of a route. An application dereferences a route when it is through with it. This is the same (to the application) as destroying the route. The route is actually destroyed when its reference count reaches zero.</p>
<h4 id="rtcreate-create-new-route">RtCreate  Create New Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *RtCreate( <span class="dt">uint32_t</span>      CallFlags,
                <span class="dt">uint32_t</span>      RtFlags,
                <span class="dt">uint32_t</span>      IPAddr,
                <span class="dt">uint32_t</span>      IPMask,
                <span class="dt">void</span>          *hIF,
                <span class="dt">uint32_t</span>      IPGateway,
                <span class="dt">unsigned</span> <span class="dt">char</span> *pMacAddr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>CallFlags: Call Type Flags</li>
<li>RtFlags: Route Type Flags</li>
<li>IPAddr: Destination IP address of route</li>
<li>IPMask: Destination IP Mask of route (or NULL)</li>
<li>hIF: Interface (or NULL)</li>
<li>IPGateway: Gate IP address (or NULL)</li>
<li>pMacAddr: Pointer to six byte MAC address (or NULL)</li>
</ul>
<p><strong>Call Flags</strong></p>
<ul>
<li>FLG_RTF_REPORT: Reports new route (NEW)</li>
</ul>
<p><strong>Return Value</strong> Referenced handle to newly created route.</p>
<p><strong>Description</strong> Called to create a new host or network route and add it to the route table. Existing routes cannot be modified via this call.</p>
<p>Some flag combinations are incorrect, and the following rules are strictly enforced.</p>
<ul>
<li>FLG_RTE_UP flag is always SET.</li>
<li>FLG_RTE_EXPIRED and FLG_RTE_MODIFIED flags are always CLEARED.</li>
<li>If FLG_RTE_HOST is set, then the route is a host route and <em>IPMask</em> is ignored, and FLG_RTE_CLONING cannot be set.</li>
<li>If FLG_RTE_GATEWAY is set, then <em>IPGateway</em> must specify a valid (reachable) IP address.</li>
<li>If FLG_RTE_GATEWAY is not set, then <em>hIF</em> must be valid.</li>
<li>If FLG_RTE_IFLOCAL is set, then the specified host address is local to this machine, and FLG_RTE_HOST must also be set, FLG_RTE_GATEWAY cannot be set, and <em>hIF</em> must be valid.</li>
<li>If FLG_RTE_CLONING is specified in Flags, the route is a cloning network route. The <em>IPMask</em> argument must be valid, and neither FLG_RTE_HOST nor FLG_RTE_GATEWAY may be set.</li>
<li>If FLG_RTE_STATIC is specified in Flags, the route is referenced once by the route code, and later dereferenced during shut down.</li>
</ul>
<h4 id="rtfind-find-a-route">RtFind  Find a Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtFind( <span class="dt">uint32_t</span> CallFlags,
             <span class="dt">uint32_t</span> IPAddr );</code></pre></div>
<p><strong>Call Flags</strong></p>
<ul>
<li>FLG_RTF_REPORT: Reports any new (cloned) or unfound route (NEW or MISS)</li>
</ul>
<p><strong>Return Value</strong> Referenced handle to best match route (or NULL)</p>
<p><strong>Description</strong> This call searches the route table for a route that matches the supplied IP address. The search always returns the best match for a route. The best match is a match with the most bits in the subnet mask. Thus, a host match takes priority over a network match.</p>
<p>When there is more than one route with the same subnet mask, the following matching guidelines are used (listed from best to worst):</p>
<ul>
<li>Route has a local destination (occurs with host addresses only).</li>
<li>Route has a gateway destination.</li>
<li>Route has a subnet destination on a connected interface.</li>
</ul>
<p>Sometimes a search is desired where particular matches are desired. The following flags can be combined with the value of <em>CallFlags</em> to change the behavior of the search:</p>
<ul>
<li>FLG_RTF_CLONE: Clone a network route to a host route if host not found</li>
<li>FLG_RTF_HOST: Find only non-gateway host routes</li>
</ul>
<h4 id="rtsettimeout-set-the-timeout-for-a-non-static-route">RtSetTimeout  Set the Timeout for a Non-static Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtSetTimeout(<span class="dt">void</span> *hRt, <span class="dt">uint32_t</span> dwTimeOut);</code></pre></div>
<p><strong>Description</strong> This call allows an application to specify that the stack should time out a referenced route. When the route is added to the timeout list, the system will add a reference. Thus, once the application sets the timeout value, it should call <em>RtDeRef()</em> to dereference the route. The route will stay valid until the timeout value is exceeded, after which it is dereferenced by the system. Note that if this function is called and the route is not dereferenced by the caller, it will still be removed from the system route table when the expiration time elapses, but the object will not be freed.</p>
<h4 id="rtsetfailure-set-the-timeout-for-a-non-static-route">RtSetFailure  Set the Timeout for a Non-Static Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtSetFailure( <span class="dt">void</span>     *hRt,
                   <span class="dt">uint32_t</span> CallFlags,
                   <span class="dt">uint32_t</span> FailCode );</code></pre></div>
<p><strong>Call Flags</strong></p>
<ul>
<li>FLG_RTF_REPORT: Reports the status change of the route (UP or DOWN)</li>
</ul>
<p><strong>Description</strong> This call allows an application to specify a particular error with a route, or clear a previously indicated error. Setting an error clears the FLG_RTE_UP bit in the flags. When use of the route is attempted, the specified error is returned. Defined error codes for the <em>FailCode</em> argument are:</p>
<ul>
<li>NULL: Route is operating normally (sets FLG_RTE_UP flag)</li>
<li>RTC_HOSTDOWN: Host is down</li>
<li>RTC_HOSTUNREACH: Host unreachable</li>
<li>RTC_NETUNREACH: Network unreachable</li>
</ul>
<h4 id="rtremove-remove-route-from-system-route-table">RtRemove  Remove Route from System Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtRemove( <span class="dt">void</span>     *hRt,
               <span class="dt">uint32_t</span> CallFlags,
               <span class="dt">uint32_t</span> FailCode);</code></pre></div>
<p><strong>Call Flags</strong></p>
<ul>
<li>FLG_RTF_REPORT: Reports the removal of the route (REMOVED)</li>
</ul>
<p><strong>Description</strong> This call allows an application to remove a route from the system route table independently of any held references to the route. It is similar to the <em>RtSetFailure()</em> call, but differs in two ways:</p>
<ol>
<li>It removes the route from the system route table so that it can no longer be returned by <em>RtFind()</em>.</li>
<li>It calls the IP and Sockets layers to flush the route from any local cache.</li>
</ol>
<p>Calling this function clears the FLG_RTE_UP bit in the flags. When use of the route is attempted, the error specified in <em>FailCode</em> is returned. Defined error codes for the <em>FailCode</em> argument are:</p>
<ul>
<li>RTC_HOSTDOWN: Host is down</li>
<li>RTC_HOSTUNREACH: Host unreachable</li>
<li>RTC_NETUNREACH: Network unreachable</li>
</ul>
<h4 id="rtgetfailure-get-the-error-code-of-a-downed-route">RtGetFailure  Get the Error Code of a Downed Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetFailure(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> Failure code or NULL for normal operation.</p>
<p><strong>Description</strong> This call allows an application to retrieve the error code of a route where the FLG_RTE_UP bit is not set in the route flags. Defined error codes are:</p>
<ul>
<li>RTC_HOSTDOWN: Host is down</li>
<li>RTC_HOSTUNREACH: Host unreachable</li>
<li>RTC_NETUNREACH: Network unreachable</li>
</ul>
<h4 id="rtgetflags-get-the-route-flags">RtGetFlags  Get the Route Flags</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetFlags(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Description</strong> This function returns the state of the route flags for the indicated route. The flag values and definitions were discussed earlier in this section.</p>
<h4 id="rtgetipaddr-get-the-route-ip-address">RtGetIPAddr  Get the Route IP Address</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetIPAddr(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> IP host/network address.</p>
<p><strong>Description</strong> This function returns the specified routes IP address in network format.</p>
<h4 id="rtgetipmask-get-the-route-ip-subnet-mask">RtGetIPMask  Get the Route IP Subnet Mask</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetIPMask(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> IP subnet mask.</p>
<p><strong>Description</strong> This function returns the specified routes IP subnet mask in network format.</p>
<h4 id="rtgetgateip-get-the-route-gateway-ip-address">RtGetGateIP  Get the Route Gateway IP Address</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetGateIP(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> IP address of the Gateway or NULL.</p>
<p><strong>Description</strong> This function returns the Gateway IP address for the specified route (assuming the FLG_RTF_GATEWAY bit is set in the route flags).</p>
<h4 id="rtgetif-get-the-routes-destination-hardware-interface">RtGetIF  Get the Routes Destination Hardware Interface</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *RtGetIF( <span class="dt">void</span> *hRt );</code></pre></div>
<p><strong>Return Value</strong> Pointer to Ether Object representing target interface.</p>
<p><strong>Description</strong> This function returns an Ether device handle to the egress (target) device of the route. Even local IP addresses have target devices (the device they are bound to).</p>
<h4 id="rtgetmtu-get-the-mtu-of-a-packet-sent-via-this-route">RtGetMTU  Get the MTU of a Packet Sent via this Route</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RtGetMTU(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> Packet payload MTU in bytes.</p>
<p><strong>Description</strong> This function returns the MTU (not including layer 2 header) of a packet sent via the supplied route.</p>
<h4 id="rtwalkbegin-start-walking-the-route-table">RtWalkBegin  Start Walking the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *RtWalkBegin();</code></pre></div>
<p><strong>Return Value</strong> Pointer to first route in system route table or NULL if no routes.</p>
<p><strong>Description</strong> This function initiates a walk of the route table. It returns the first route in the table. The walk must be terminated with <em>RtWalkEnd()</em> for the system to behave properly.</p>
<h4 id="rtwalknext-get-next-route-while-walking-the-route-table">RtWalkNext  Get Next Route While Walking the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *RtWalkNext(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Return Value</strong> Pointer to next route in system route table or NULL if no routes.</p>
<p><strong>Description</strong> This function gets the next route (based off the previous route supplied) in a walk of the route table. The walk must be terminated with <em>RtWalkEnd()</em> for the system to behave properly.</p>
<h4 id="rtwalkend-stop-walking-the-route-table">RtWalkEnd  Stop Walking the Route Table</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RtWalkEnd(<span class="dt">void</span> *hRt);</code></pre></div>
<p><strong>Description</strong> This function completes the walk of the route table. The last route (if any) obtained from <em>RtWalkBegin()</em> or <em>RtWalkNext()</em> is specified in the calling argument. Otherwise, NULL is used.</p>
<h2 id="a.10-route-control-object">A.10 Route Control Object</h2>
<p>The route control object is more of a function than an object. It serves as a collection point for route related information in the system. A routing daemon may use this information, or it could simply be logged as debugging information.</p>
<p>When so configured, route control messages are transformed into debug messages by the stack and logged via <em>DbgPrintf()</em>. By default, the route control debug messages are disabled. Also, the message function can be hooked by an application.</p>
<p>Note, control messages can also be suppressed individually by not supplying the FLG_RTF_REPORT flag to the Route object API function when the call is made (as mentioned in the previous section).</p>
<h3 id="a.10.1-route-control-messages">A.10.1 Route Control Messages</h3>
<p>The basic form of the route control message is an unsigned int message value, with two unsigned 32 bit values for additional data. In most cases these are immediate data. In one instance, the value is actually a 32 bit memory pointer.</p>
<p>Messages are passed internally to the stack via the function:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RTCReport( <span class="dt">uint32_t</span> Msg,
                <span class="dt">uint32_t</span> Param1,
                <span class="dt">uint32_t</span> Param2 );</code></pre></div>
<p>Applications should not call this function directly.</p>
<p>The possible values for <em>Msg</em> are as follows:</p>
<h4 id="msg_rtc_up-route-is-validpending">MSG_RTC_UP  Route is Valid/Pending</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called after a down message indicating that a route that had previously been in the down state is now up again. This does not mean that the route has been validated, but only that it will attempt to validate itself if used.</p>
<h4 id="msg_rtc_down-route-is-down">MSG_RTC_DOWN  Route is Down</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when a route goes down due to an error. Packets sent via a route in this state will generate an error. The most common reason for a route to go down is for a non-response to 5 successive ARP requests. In this case, the route will come back up after the down time has expired.</p>
<h4 id="msg_rtc_miss-route-find-missed-on-route">MSG_RTC_MISS  Route Find Missed on Route</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when the route table was searched for a route and no matching route was found. This message will never be sent when there is a default route in the table because all searches will have a match (unless a special restricted search is performed).</p>
<h4 id="msg_rtc_new-new-route-has-been-entered-into-the-route-table">MSG_RTC_NEW  New Route has been Entered into the Route Table</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when a new route is created and entered into the route table. Routes can be created by applications, when new bindings are created, by ICMP redirects, or when local host routes are cloned from local subnet routes.</p>
<h4 id="msg_rtc_expired-route-has-expired">MSG_RTC_EXPIRED  Route has Expired</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when a route with an expiration timeout has expired and been removed from the table.</p>
<h4 id="msg_rtc_removed-route-has-been-manually-removed">MSG_RTC_REMOVED  Route has been Manually Removed</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when a route has been manually removed from the table. This message is not generated when static routes are removed at system shutdown. Generally, a route can only be removed when its reference count reaches zero. This cannot happen to a static route or a route with an expiration timeout. For the former, no message is ever generated. For the latter, the MSG_RTC_EXPIRED message is used.</p>
<h4 id="msg_rtc_modified-route-has-been-manually-modified">MSG_RTC_MODIFIED  Route has been Manually Modified</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: Route IP Mask (all ones for host route)</li>
</ul>
<p><strong>Description</strong> Called when a route has been manually modified via the <em>RtModify()</em> call. The stack does not use this function, so if it is not called by an application, this message will never occur.</p>
<h4 id="msg_rtc_redirect-route-has-been-redirected">MSG_RTC_REDIRECT  Route has been Redirected</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Route IP</li>
<li>Param2: New Destination Gateway IP</li>
</ul>
<p><strong>Description</strong> Called when an ICMP redirect message is received for a given IP host address. Because the invention of classless subnets, all redirects are treated as HOST redirects. If the stack is configured to generate redirect routes automatically (will do so by default), this message will occur after the new static host redirect route has been created (which will also generate a MSG_RTC_NEW message). If the stack does not create the redirect route, this message occurs <em>before</em> the socket layer is notified so that if a new route is created as a result of this message, the sockets layer will find it.</p>
<h4 id="msg_rtc_dupip-a-duplicate-ip-address-has-been-detected-in-the-system">MSG_RTC_DUPIP  A Duplicate IP Address has been Detected in the System</h4>
<p><strong>Parameters</strong></p>
<ul>
<li>Param1: Duplicated IP</li>
<li>Param2: Pointer to 6 byte MAC address of offending device</li>
</ul>
<p><strong>Description</strong> Called when an ARP packet is received from a device that has an IP address that is the same as the IP address of the stack on that physical interface. Depending on the age of the address, the application may wish to destroy the binding.</p>
<h3 id="a.10.2-route-control-api-functions">A.10.2 Route Control API Functions</h3>
<h4 id="rtcaddhook-hook-rtc-messages">RTCAddHook  Hook RTC Messages</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> RTCAddHook (<span class="dt">void</span> (*pfn)(uint, <span class="dt">uint32_t</span>, <span class="dt">uint32_t</span>));</code></pre></div>
<p><strong>Return Value</strong> 1 if the hook was installed, or NULL on an error (too many hooks).</p>
<p><strong>Description</strong> Called to hook a message function to receive route control messages. The argument is a pointer to a message function of the type:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> MyMsgFun( <span class="dt">uint32_t</span> Msg,
               <span class="dt">uint32_t</span> Param1,
               <span class="dt">uint32_t</span> Param2 );</code></pre></div>
<p>Note that the supplied callback function is called from within an <em>llExit()</em>/<em>llEnter()</em> pair, and thus may call the stack API directly, but may not call any applications API functions, like sockets functions. If such action is required, the callback function may call <em>llExit()</em> when called and then <em>llEnter()</em> before returning.</p>
<p>When the hook is no longer required, the function may be unhooked by calling <em>RTCRemoveHook()</em>.</p>
<h4 id="rtcremovehook-unhook-rtc-messages">RTCRemoveHook  Unhook RTC Messages</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> RTCRemoveHook (<span class="dt">void</span> (*pfn)(uint, <span class="dt">uint32_t</span>, <span class="dt">uint32_t</span>));</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to remove a previously hooked callback function.</p>
<p><a name="configuring-the-stack"></a></p>
<h2 id="a.11-configuring-the-stack">A.11 Configuring the Stack</h2>
<p>The stack has multiple configuration options that can be changed by the system programmer. This is possible by altering the default values in a stack configuration structure before the stack is initialized.</p>
<p><a name="configuration-structure2"></a></p>
<h3 id="a.11.1-configuration-structure">A.11.1 Configuration Structure</h3>
<p>This section describes a data structure that is generated automatically by the XGCONF configuration. If you are using XGCONF for configuration, you can ignore the structure described here.</p>
<p>The stack internal configuration structure is _ipcfg. Any element in this structure may be modified before the initial system call to ExecOpen(). This structure should not be modified after this initial call.</p>
<p>The _ipcfg structure is of type IPCONFIG, which is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _ipconfig {
      <span class="dt">uint32_t</span> IcmpDoRedirect;         <span class="co">// Update RtTable on ICMP redirect (1=Yes)</span>
      <span class="dt">uint32_t</span> IcmpTtl;                <span class="co">// TTL for ICMP messages RFC1700 says 64</span>
      <span class="dt">uint32_t</span> IcmpTtlEcho;            <span class="co">// TTL for ICMP echo RFC1700 says 64</span>
      <span class="dt">uint32_t</span> IpIndex;                <span class="co">// IP Start Index</span>
      <span class="dt">uint32_t</span> IpForwarding;           <span class="co">// IP Forwarding (1 = Enabled)</span>
      <span class="dt">uint32_t</span> IpNatEnable;            <span class="co">// IP NAT Enable (1 = Yes)</span>
      <span class="dt">uint32_t</span> IpFilterEnable;         <span class="co">// IP Filtering Enable (1 = Yes)</span>
      <span class="dt">uint32_t</span> IpReasmMaxTime;         <span class="co">// Max reassembly time in seconds</span>
      <span class="dt">uint32_t</span> IpReasmMaxSize;         <span class="co">// Max reassembly packet size</span>
      <span class="dt">uint32_t</span> IpDirectedBCast;        <span class="co">// Look for directed BCast IP addresses</span>
      <span class="dt">uint32_t</span> TcpReasmMaxPkt;         <span class="co">// Max reasm pkts held by TCP socket</span>
      <span class="dt">uint32_t</span> RtcEnableDebug;         <span class="co">// Enable Route Control Messages (1=On)</span>
      <span class="dt">uint32_t</span> RtcAdvTime;             <span class="co">// Time in sec to send RtAdv (0=don't)</span>
      <span class="dt">uint32_t</span> RtcAdvLife;             <span class="co">// Lifetime of route in RtAdv</span>
      <span class="dt">int</span>      RtcAdvPref;             <span class="co">// Preference Level (signed) in RtAdv</span>
      <span class="dt">uint32_t</span> RtArpDownTime;          <span class="co">// Time 5 failed ARPs keep Rt down (sec)</span>
      <span class="dt">uint32_t</span> RtKeepaliveTime;        <span class="co">// VALIDATED route timeout (sec)</span>
      <span class="dt">uint32_t</span> RtArpInactvity;         <span class="co">// ARP Inactivity Timeout (sec)</span>
      <span class="dt">uint32_t</span> RtCloneTimeout;         <span class="co">// INITIAL route timeout (sec)</span>
      <span class="dt">uint32_t</span> RtDefaultMTU;           <span class="co">// Default MTU for internal routes</span>
      <span class="dt">uint32_t</span> SockTtlDefault;         <span class="co">// Default Packet TTL</span>
      <span class="dt">uint32_t</span> SockTosDefault;         <span class="co">// Default Packet TOS</span>
      <span class="dt">int</span>      SockMaxConnect;         <span class="co">// Max Socket Connections</span>
      <span class="dt">uint32_t</span> SockTimeConnect;        <span class="co">// Max time to connect (sec)</span>
      <span class="dt">uint32_t</span> SockTimeIo;             <span class="co">// Default Socket IO timeout (sec)</span>
      <span class="dt">int</span>      SockTcpTxBufSize;       <span class="co">// TCP Transmit buffer size</span>
      <span class="dt">int</span>      SockTcpRxBufSize;       <span class="co">// TCP Receive buffer size (copy mode)</span>
      <span class="dt">int</span>      SockTcpRxLimit;         <span class="co">// TCP Receive limit (non-copy mode)</span>
      <span class="dt">int</span>      SockUdpRxLimit;         <span class="co">// UDP Receive limit</span>
      <span class="dt">int</span>      SockBufMinTx;           <span class="co">// Min Tx space for &quot;able to write&quot;</span>
      <span class="dt">int</span>      SockBufMinRx;           <span class="co">// Min Rx data for &quot;able to read&quot;</span>
      <span class="dt">uint32_t</span> PipeTimeIo;             <span class="co">// Default Pipe IO timeout (sec)</span>
      <span class="dt">int</span>      PipeBufSize;            <span class="co">// Pipe internal buffer size</span>
      <span class="dt">int</span>      PipeBufMinTx;           <span class="co">// Min Tx space for &quot;able to write&quot;</span>
      <span class="dt">int</span>      PipeBufMinRx;           <span class="co">// Min Rx data for &quot;able to read&quot;</span>
      <span class="dt">uint32_t</span> TcpKeepIdle;            <span class="co">// Time (in 0.1 sec) connection muse be idle</span>
                                       <span class="co">// for TCP to send first keepalive probe.</span>
      <span class="dt">uint32_t</span> TcpKeepIntvl;           <span class="co">// Time (in 0.1 sec) between consecutive TCP</span>
                                       <span class="co">// keep alive probes</span>
      <span class="dt">uint32_t</span> TcpKeepMaxIdle;         <span class="co">// Time (in 0.1 sec) that a TCP connection can</span>
                                       <span class="co">// go without responding to a probe before</span>
                                       <span class="co">// being dropped</span>
      <span class="dt">uint32_t</span> IcmpDontReplyBCast;     <span class="co">// Don't Reply To ICMP ECHO REQ packets</span>
                                       <span class="co">// sent to BCast or Directed BCast</span>
      <span class="dt">uint32_t</span> IcmpDontReplyMCast;     <span class="co">// Don't Reply To ICMP ECHO REQ packets</span>
                                       <span class="co">// sent to Multi-Cast</span>
      <span class="dt">uint32_t</span> RtGarp;                 <span class="co">// How to handle received gratuitous ARP</span>
      <span class="dt">uint32_t</span> IcmpDontReplyEcho;      <span class="co">// Don't Reply to ICMP ECHO packets</span>
      <span class="dt">uint32_t</span> UdpSendIcmpPortUnreach; <span class="co">// Send ICMP Port Unreach if UDP port</span>
                                       <span class="co">// is opened or not.</span>
      <span class="dt">uint32_t</span> TcpSendRst;             <span class="co">// Send RST if TCP port is opened or not.</span>
      <span class="dt">int</span>      SockRawEthRxLimit;      <span class="co">// Raw Ethernet Receive limit</span>
} IPCONFIG;</code></pre></div>
<p>The structure entries are defined as follows:</p>
<h4 id="ipcfg.icmpdoredirect-update-route-table-on-icmp-redirect">_ipcfg.IcmpDoRedirect  Update Route Table on ICMP Redirect</h4>
<p><strong>Default Value</strong> 1 (Yes)</p>
<p><strong>Description</strong> When set to true (1), causes ICMP to automatically create a route to perform redirects on an IP host to the gateway supplied in the redirect message. If set to false (0), you can take whatever action you feel necessary as the ICMP redirect will also generate a route control message.</p>
<h4 id="ipcfg.icmpttl-ttl-for-icmp-messages">_ipcfg.IcmpTtl  TTL for ICMP Messages</h4>
<p><strong>Default Value</strong> 64</p>
<p><strong>Description</strong> This is the TTL value ICMP will use in messages it generates as a result of routing IP packets. Legal values are in the range of 1-255.</p>
<h4 id="ipcfg.icmpttlecho-ttl-for-icmp-echo-reply-messages">_ipcfg.IcmpTtlEcho  TTL for ICMP ECHO Reply Messages</h4>
<p><strong>Default Value</strong> 255</p>
<p><strong>Description</strong> This is the TTL value ICMP will use in echo reply messages it generates in response to receiving echo requests. Legal values are in the range of 1-255.</p>
<h4 id="ipcfg.ipindex-ip-start-index">_ipcfg.IpIndex  IP Start Index</h4>
<p><strong>Default Value</strong> 1</p>
<p><strong>Description</strong> This is the initial value that is placed in the IP Id field for IP packets generated by the system. Legal values are in the range of 1-65535.</p>
<h4 id="ipcfg.ipforwarding-ip-forwarding-enable">_ipcfg.IpForwarding  IP Forwarding Enable</h4>
<p><strong>Default Value</strong> 0 (No)</p>
<p><strong>Description</strong> When set to true (1), this allows the stack to forward packets it receives for other IP address to their next hop destination (i.e., it allows the stack to act as a router).</p>
<h4 id="ipcfg.ipnatenable-ip-network-address-translation-enable">_ipcfg.IpNatEnable  IP Network Address Translation Enable</h4>
<p><strong>Default Value</strong> 0 (No)</p>
<p><strong>Description</strong> When set to true (1), this allows the stack to make use of the network address translation (NAT) module. Note that in addition to setting this structure element, NAT must also be configured. This is described in the following section.</p>
<h4 id="ipcfg.ipfilterenable-p-filtering-enable">_ipcfg.IpFilterEnable  P Filtering Enable</h4>
<p><strong>Default Value</strong> 0 (No)</p>
<p><strong>Description</strong> When set to true (1), this allows the stack to make use of the IP filtering module. Note that this is automatically turned on when NAT is enabled in the stack. This module is described in more detail in the NAT Service section of this document.</p>
<h4 id="ipcfg.ipreasmmaxtime-maximum-ip-packet-reassembly-time-in-seconds">_ipcfg.IpReasmMaxTime  Maximum IP Packet Reassembly Time in Seconds</h4>
<p><strong>Default Value</strong> 10</p>
<p><strong>Description</strong> This is the maximum time that the stack will hold IP packet fragments while attempting to assemble a complete packet. If the time expires before all the fragments arrive, the packet is discarded.</p>
<h4 id="ipcfg.ipreasmmaxsize-maximum-ip-packet-reassembly-packet-size-in-bytes">_ipcfg.IpReasmMaxSize  Maximum IP Packet Reassembly Packet Size in Bytes</h4>
<p><strong>Default Value</strong> 3020</p>
<p><strong>Description</strong> This is the maximum packet size that the stack will attempt to reassemble. As soon as the stack determines that the total packet size exceeds this value, the packet is discarded. The default size of 3020 is the maximum size given the default implementation of the packet buffer manager (PBM). If a larger size is desired, then large buffer support must be added to the PBM module. This value is not otherwise restricted. Note the MAC and IP headers are not included in this size limit.</p>
<h4 id="ipcfg.ipdirectedbcast-look-for-directed-broadcast-ip-packets">_ipcfg.IpDirectedBCast  Look for Directed Broadcast IP Packets</h4>
<p><strong>Default Value</strong> 1 (Yes)</p>
<p><strong>Description</strong> A directed broadcast address is one where all the bits in the subnet portion of the address are set to 1. For example, on the network 192.168.1.0:255.2555.255.0, the IP address 192.168.1.255 would be a directed broadcast IP. This address is treated as a broadcast for both IP send and receive. The IP layer can be told to disable directed broadcast by setting this value to zero. When disabled, the directed broadcast address is treated like any other host address.</p>
<h4 id="ipcfg.tcpreasmmaxpkt-maximum-reassembly-packets-held-by-tcp-socket">_ipcfg.TcpReasmMaxPkt  Maximum Reassembly Packets Held by TCP Socket</h4>
<p><strong>Default Value</strong> 2</p>
<p><strong>Description</strong> The TCP layer has its own packet reassembly module, allowing TCP packets to arrive out of order, and yet be properly reassembled without the need to retransmit data. One potential issue with embedded environments where the socket receive buffers are large is that a significant number of packets can be tied up in TCP if the first packet of a large burst is lost. This value allows you to specify the maximum number of packets the TCP layer will hold per socket pending reassembly, or in other words, the maximum number of out of order packets allowed.</p>
<h4 id="ipcfg.rtcenabledebug-enable-route-control-messages">_ipcfg.RtcEnableDebug  Enable Route Control Messages</h4>
<p><strong>Default Value</strong> 0 (No)</p>
<p><strong>Description</strong> Route control messages keep the system informed of route updates. When set to Yes (1), this variable causes RTC to process the route control message and convert the message into a debug call to <em>llDebugMessage()</em>. Note that an application may also hook into the RTC message loop using the <em>RTCAddHook ()</em> function.</p>
<h4 id="ipcfg.rtcadvtime-time-in-seconds-to-send-router-advertisments">_ipcfg.RtcAdvTime  Time in Seconds to Send Router Advertisments</h4>
<p><strong>Default Value</strong> 0 (Do not Send Router Advertisements)</p>
<p><strong>Description</strong> The stack has the ability to automatically send ICMP router advertisements at a predetermined interval. Setting this variable to a non-zero value determines the interval.</p>
<h4 id="ipcfg.rtcadvlife-lifetime-of-route-in-router-advertisments">_ipcfg.RtcAdvLife  Lifetime of Route in Router Advertisments</h4>
<p><strong>Default Value</strong> 120</p>
<p><strong>Description</strong> If sending router advertisements (see above), this is the route lifetime that will be sent in the ICMP message.</p>
<h4 id="ipcfg.rtcadvpref-preference-level-of-route-in-router-advertisments">_ipcfg.RtcAdvPref  Preference Level of Route in Router Advertisments</h4>
<p><strong>Default Value</strong> 0</p>
<p><strong>Description</strong> If sending router advertisements (see above), this is the route preference level that will be sent in the ICMP message. This value is signed.</p>
<h4 id="ipcfg.rtdowntime-time-in-seconds-a-route-is-down-due-to-failed-arp">_ipcfg.RtDownTime  Time in Seconds a Route is Down Due to Failed ARP</h4>
<p><strong>Default Value</strong> 20</p>
<p><strong>Description</strong> To stop an application from sending endless packets to a route that is not responding to ARP, the route is brought down for a period of time so that the application will receive an error when IP attempts to send. After the designated time, the route is brought back up and will attempt more ARP requests if used again.</p>
<h4 id="ipcfg.rtkeepalivetime-time-in-seconds-a-validated-route-is-held">_ipcfg.RtKeepAliveTime  Time in Seconds a Validated Route is Held</h4>
<p><strong>Default Value</strong> 1200</p>
<p><strong>Description</strong> Routes should not be held indefinitely. Use of a route is also not sufficient to keep the route alive. This value represents the time an ARP validated route is held before it expires. If the route is revalidated via ARP during this period, the period is extended for this interval from that point in time.</p>
<h4 id="ipcfg.rtarpinactivity-arp-inactivity-timeout-in-seconds">_ipcfg.RtArpInactivity  ARP Inactivity timeout in seconds</h4>
<p><strong>Default Value</strong> 3</p>
<p><strong>Description</strong> Time in seconds beyond which a route and an associated LLI/ARP entry if unused is considered <em>inactive</em> or <em>idle</em>. Inactive ARP entries lifetime is not extended using ARP revalidation process and are instead deleted. The associated route entry is also removed.</p>
<h4 id="ipcfg.rtclonetimeout-default-timeout-in-seconds-of-a-cloned-route">_ipcfg.RtCloneTimeout  Default Timeout in Seconds of a Cloned Route</h4>
<p><strong>Default Value</strong> 120</p>
<p><strong>Description</strong> When a host route is first cloned from a network route, it is assigned this default timeout. Once the route is validated via ARP, the timeout is extended (see above).</p>
<h4 id="ipcfg.rtdefaultmtu-default-mtu-for-local-routes">_ipcfg.RtDefaultMTU  Default MTU for Local Routes</h4>
<p><strong>Default Value</strong> 1500</p>
<p><strong>Description</strong> When a route is created, it gets its MTU from the egress device. However, if the route is local to the system, there is no egress device. In this case, a default MTU is used.</p>
<h4 id="ipcfg.sockttldefault-default-ttl-for-packets-sent-via-a-socket">_ipcfg.SockTtlDefault  Default TTL for Packets Sent via a Socket</h4>
<p><strong>Default Value</strong> 64</p>
<p><strong>Description</strong> This is the default IP packet TTL value of packets sent via a socket. Note that the application can override this value with the sockets API.</p>
<h4 id="ipcfg.socktosdefault-default-tos-for-packets-sent-via-a-socket">_ipcfg.SockTosDefault  Default TOS for Packets Sent via a Socket</h4>
<p><strong>Default Value</strong> 0</p>
<p><strong>Description</strong> This is the default IP packet TOS value of packets sent via a socket. Note that the application can override this value with the sockets API.</p>
<h4 id="ipcfg.sockmaxconnect-maximum-connections-on-a-listening-socket">_ipcfg.SockMaxConnect  Maximum Connections on a Listening Socket</h4>
<p><strong>Default Value</strong> 8</p>
<p><strong>Description</strong> This is the maximum number of connections a socket will pend waiting for a sockets <em>NDK_accept()</em> call from the application. Note: This value is also the upper bounds of the maximum connection argument supplied by an application via the sockets <em>listen()</em> function (calls with higher values are silently rounded down).</p>
<h4 id="ipcfg.socktimeconnect-maximum-time-in-seconds-to-wait-on-a-connect">_ipcfg.SockTimeConnect  Maximum Time in Seconds to Wait on a Connect</h4>
<p><strong>Default Value</strong> 80</p>
<p><strong>Description</strong> This is the maximum amount to time the sockets layer will wait on an actively connecting socket. The default value of 80 is a few seconds longer than the TCP keep time, so TCP will generate the official (more accurate) timeout error.</p>
<h4 id="ipcfg.socktimeio-maximum-time-in-seconds-to-wait-on-socket-readwrite">_ipcfg.SockTimeIo  Maximum Time in Seconds to Wait on Socket Read/Write</h4>
<p><strong>Default Value</strong> 0</p>
<p><strong>Description</strong> This is the maximum amount of time the sockets layer will wait on a read or write operation without any progress. For example, if the user calls <em>send()</em> with a very large buffer, the function will not time out so long as some fraction of the data is sent during the timeout period. After every successful transfer of data, the timeout period is reset. A timeout value of ZERO means never time out.</p>
<h4 id="ipcfg.socktcptxbufsize-tcp-transmit-buffer-size">_ipcfg.SockTcpTxBufSize  TCP Transmit Buffer Size</h4>
<p><strong>Default Value</strong> 8192</p>
<p><strong>Description</strong> This is the size of the TCP send buffer. A TCP send buffer is allocated for every TCP socket. This value cannot be overridden by the sockets option function.</p>
<h4 id="ipcfg.socktcprxbufsize-tcp-receive-buffer-size-copy-mode">_ipcfg.SockTcpRxBufSize  TCP Receive Buffer Size (Copy Mode)</h4>
<p><strong>Default Value</strong> 8192</p>
<p><strong>Description</strong> This is the size of the TCP receive buffer allocated for a standard TCP socket. Note that only SOCK_STREAM sockets use receive buffers. This value cannot be overridden by the sockets option function.</p>
<h4 id="ipcfg.socktcprxlimit-tcp-receive-limit-non-copy-mode">_ipcfg.SockTcpRxLimit  TCP Receive Limit (Non-Copy Mode)</h4>
<p><strong>Default Value</strong> 8192</p>
<p><strong>Description</strong> This is the maximum number of cumulative bytes contained in packet buffers than can be queued up at any given TCP based socket. Note that only TCP sockets using SOCK_STREAMNC queue packet buffers directly to a socket. This value cannot be overridden by the sockets option function.</p>
<h4 id="ipcfg.sockudprxlimit-udp-receive-limit">_ipcfg.SockUdpRxLimit  UDP Receive Limit</h4>
<p><strong>Default Value</strong> 8192</p>
<p><strong>Description</strong> This is the maximum number of cumulative bytes contained in packet buffers than can be queued up at any given UDP or RAW based socket. This value cannot be overridden by the sockets option function.</p>
<h4 id="ipcfg.sockbufmintx-min-size-in-bytes-for-socket-able-to-write">_ipcfg.SockBufMinTx  Min Size in Bytes for Socket Able to Write</h4>
<p><strong>Default Value</strong> 2048</p>
<p><strong>Description</strong> This is the size in bytes required to be free in the TCP buffer before it is regarded as able to write by the system. (Affects how the write fd set behaves in a <em>select()</em> call.) This value is usually about 25% to 50% of the send buffer size. UDP and RAW IP sockets are always able to write.</p>
<h4 id="ipcfg.sockbufminrx-min-size-in-bytes-for-socket-able-to-read">_ipcfg.SockBufMinRx  Min Size in Bytes for Socket Able to Read</h4>
<p><strong>Default Value</strong> 1</p>
<p><strong>Description</strong> This is the size in bytes required to be present in a socket buffer for it to be regarded as able to be read by the system. (Affects how the read fd set behaves in a <em>select()</em> call.) Alter at your own risk.</p>
<h4 id="ipcfg.pipetimeio-maximum-time-in-seconds-to-wait-on-pipe-readwrite">_ipcfg.PipeTimeIo  Maximum Time in Seconds to Wait on Pipe Read/Write</h4>
<p><strong>Default Value</strong> 0</p>
<p><strong>Description</strong> This is maximum amount to time the file layer will wait on a read or write operation on a pipe without any progress. For example, if the user calls <em>send()</em> with a very large buffer, the function will not time out as long as some fraction of the data is sent during the timeout period. After every successful transfer of data, the timeout period is reset. A timeout value of ZERO means never time out.</p>
<h4 id="ipcfg.pipebufsize-size-in-bytes-of-each-end-of-a-pipe-buffer">_ipcfg.PipeBufSize  Size in Bytes of Each End of a Pipe Buffer</h4>
<p><strong>Default Value</strong> 1024</p>
<p><strong>Description</strong> This is the size of a Pipe send and receive buffer. This value is only examined when pipes are created, so changing this value will not affect the buffering of existing pipes.</p>
<h4 id="ipcfg.pipebufmintx-min-size-in-bytes-for-pipe-able-to-write">_ipcfg.PipeBufMinTx  Min Size in Bytes for Pipe Able to Write</h4>
<p><strong>Default Value</strong> 256</p>
<p><strong>Description</strong> This is the size in bytes required to be free in the Pipe buffer before it is regarded as able to write by the system. (Affects how the write fd set behaves in a <em>select()</em> call.) It is usually about 25% to 50% of the send buffer size. This value is only examined when pipes are created, so changing this value will not affect the buffering of existing pipes.</p>
<h4 id="ipcfg.pipebufminrx-min-size-in-bytes-for-pipe-able-to-read">_ipcfg.PipeBufMinRx  Min Size in Bytes for Pipe Able to Read</h4>
<p><strong>Default Value</strong> 1</p>
<p><strong>Description</strong> This is the size in bytes required to be present in the Pipe receive buffer for it to be regarded as able to be read by the system. (Affects how the read fd set behaves in a <em>select()</em> call.) Alter at your own risk. This value is only examined when pipes are created, so changing this value will not affect the buffering of existing pipes.</p>
<h4 id="ipcfg.tcpkeepidle-keep-idle-time-0.1-sec-units">_ipcfg.TcpKeepIdle  Keep Idle Time (0.1 Sec Units)</h4>
<p><strong>Default Value</strong> 72000 (2 hours)</p>
<p><strong>Description</strong> This parameter only affects sockets that have specified the SO_KEEPALIVE socket option. It is the time a TCP connection can be idle before KEEP probes are sent.</p>
<h4 id="ipcfg.tcpkeepintvl-keep-probe-interval-0.1-sec-units">_ipcfg.TcpKeepIntvl  Keep Probe Interval (0.1 Sec Units)</h4>
<p><strong>Default Value</strong> 750 (75 seconds)</p>
<p><strong>Description</strong> This parameter only affects sockets that have specified the SO_KEEPALIVE socket option. It specifies the time between probe intervals once TCP begins sending KEEP probes.</p>
<h4 id="ipcfg.tcpkeepmaxidle-keep-probe-timeout-0.1-sec-units">_ipcfg.TcpKeepMaxIdle  Keep Probe Timeout (0.1 Sec Units)</h4>
<p><strong>Default Value</strong> 6000 (10 minutes)</p>
<p><strong>Description</strong> This parameter only affects sockets that have specified the SO_KEEPALIVE socket option. It is the time the TCP will continue to send unanswered KEEP probes before timing out the connection.</p>
<h4 id="ipcfg.icmpdontreplybcast-do-not-reply-to-icmp-echo-request-packets-sent-to-broadcastdirected-addresses">_ipcfg.IcmpDontReplyBCast  Do NOT Reply to ICMP Echo Request Packets Sent to Broadcast/Directed Addresses</h4>
<p><strong>Default Value</strong> 0 (Reply to ICMP Echo Request packets sent to broadcast/directed broadcast addresses)</p>
<p><strong>Description</strong> When set, causes ICMP to not reply to ICMP Echo Request packets sent to broadcast or directed broadcast addresses.</p>
<h4 id="ipcfg.icmpdontreplymcast-do-not-reply-to-icmp-echo-request-packets-sent-to-multicast-addresses">_ipcfg.IcmpDontReplyMCast  Do NOT Reply to ICMP Echo Request Packets Sent to Multicast Addresses</h4>
<p><strong>Default Value</strong> 0 (Reply to ICMP Echo Request packets sent to multicast addresses)</p>
<p><strong>Description</strong> When set, causes ICMP to not reply to ICMP Echo Request packets sent to multicast addresses.</p>
<h4 id="ipcfg.rtgarp-how-to-handle-received-gratuitous-arp-packets">_ipcfg.RtGarp  How to Handle Received Gratuitous ARP Packets</h4>
<p><strong>Default Value</strong> 0 (Discard received gratuitous ARP packets)</p>
<p><strong>Description</strong> The hosts may send gratuitous ARP packets to broadcast their [IP number, MAC address] information to inform other hosts in the network. This parameter determines the handling policy of received gratuitous ARP packets based on the following configuration values:</p>
<ul>
<li>0 - Discard the received gratuitous ARP packets. (default)</li>
<li>1 - If host is already in the routing table, update MAC address only.</li>
<li>2 - If host is already in the routing table, update MAC address. If host is not the routing table, add to the table. This option can cause growing of the table by adding entries for not communicated hosts information, and consumes more memory.</li>
</ul>
<h4 id="ipcfg.icmpdontreplyecho-reply-to-icmp-echo-request-packet">_ipcfg.IcmpDontReplyEcho  Reply to ICMP Echo Request Packet</h4>
<p><strong>Default Value</strong> 0 (Reply to ICMP Echo Request packets with ICMP Echo Reply)</p>
<p><strong>Description</strong> The ICMP Echo Request can be used to determine if a host on the Internet is responding. The host receiving ICMP Echo Request replies with ICMP Echo Reply packet. The <em>ping</em> program uses ICMP Echo Request/Reply packets. It is a valuable tool diagnosing host and network problem. However, it can also be used to discover the IP numbers of hosts connected on the Internet. This option allows configuring to reply ICMP Echo Request packets or not.</p>
<ul>
<li>0 - Reply to ICMP Echo Request packets</li>
<li>1 - Do NOT reply to ICMP Echo Request packets</li>
</ul>
<h4 id="ipcfg.udpsendicmpportunreach-reply-with-icmp-port-unreachable-if-udp-port-is-not-listened">_ipcfg.UdpSendIcmpPortUnreach  Reply with ICMP Port Unreachable if UDP Port is Not Listened</h4>
<p><strong>Default Value</strong> 1 (Reply with ICMP Port Unreachable message)</p>
<p><strong>Description</strong> The port scanning is used to discover which services is used on a host. If a UDP port is not listened, the NDK replies with an ICMP Port Unreachable message to any received UDP datagram. So, you can find that if a UDP port is not open, and by exclusively determine which ports are open. This option allows configuring to reply or not to not listened UDP ports.</p>
<ul>
<li>0 - Do NOT reply with ICMP Port Unreachable message</li>
<li>1 - Reply with ICMP Port Unreachable message</li>
</ul>
<h4 id="ipcfg.tcpsendrst-reply-with-rst-message-if-tcp-port-is-not-listened">_ipcfg.TcpSendRst  Reply with RST message if TCP Port is Not Listened</h4>
<p><strong>Default Value</strong> 1 (Reply with RST message)</p>
<p><strong>Description</strong> The port scanning is used to discover which services is used on a host. If a TCP port is not listened, the NDK replies with an RST message to a connection attempt (received SYN message). So, you can find that if a TCP port is not open, and by exclusively determine which ports are open. This option allows configuring to reply or not to not listened TCP ports.</p>
<ul>
<li>0 - Do NOT reply with RST message</li>
<li>1 - Reply with RST message</li>
</ul>
<h4 id="ipcfg.sockrawethrxlimit-raw-ethernet-socket-receive-limit">_ipcfg.SockRawEthRxLimit  Raw Ethernet socket receive limit</h4>
<p><strong>Default Value</strong> 8192</p>
<p><strong>Description</strong> This is the maximum number of cumulative bytes contained in packet buffers than can be queued up at any given Raw Ethernet socket. This value cannot be overridden by the sockets option function.</p>
<h2 id="a.12-network-address-translation">A.12 Network Address Translation</h2>
<p>The stack includes a small network address translation (NAT) function that can be used to setup virtual networks when the stack is acting as a router. When enabled, NAT will translate routed packets sent from or to a targeted virtual network.</p>
<p>If you are using XGCONF to configure your application, you can configure the NAT service to be enabled in the application by checking the box in the property sheet to add the module to your configuration. See the <a href="NDK_Users_Guide.html">SPRU523</a> (<em>TI Network Developers Kit (NDK) Users Guide.</em>) and the context-sensitive help for details.</p>
<h3 id="a.12.1-operation">A.12.1 Operation</h3>
<p>NAT works by altering the TCP/UDP port numbers of a packet sent from a virtual network, and then using an alternate IP on the physical network to transfer the packet. For ICMP packets, the Id field of ICMP requests is used.</p>
<p>When configured, NAT will have a target virtual network that consists of an IP base address and a subnet mask. It also has a physical IP address that is used as a type of proxy for the translated packets.</p>
<p>The types of packets translated include:</p>
<ul>
<li>Any TCP or UDP packet</li>
<li>ICMP ECHO and TSTAMP packets sent from the virtual network</li>
<li>ICMP ECHOREPLY and TSTAMPREPLY packets sent to the virtual network</li>
<li>ICMP error packets sent to the virtual network in response to a translated packet sent from the virtual network</li>
</ul>
<p>The translation entries are created dynamically, and have a lifetime based on their protocol. ICMP and UDP translation entries have a fixed time limit based on the last time they were accessed. TCP expiration is based on the state of the TCP connection.</p>
<p>Note that some protocols (like FTP) communicate TCP/UDP port information in the packet payload. These types of protocols will not function under NAT without a custom proxy program to alter the packet payload. Individual proxies are not provided.</p>
<h2 id="a.13-network-interface-management-unit-nimu">A.13 Network Interface Management Unit (NIMU)</h2>
<h3 id="a.13.1-synopsis">A.13.1 Synopsis</h3>
<p>NIMU architecture replaces the existing LL packet layer architecture, originally designed to communicate with only one instance of the device driver. It adds flexibility to the NDK core stack by adding the capability to communicate and control multiple device drivers simultaneously. In comparison to single-port serial device applications, the new NIMU architecture is best suited for Ethernet type devices where it is common to have multiple instances running concurrently.</p>
<p>NIMU implementation has two parts:</p>
<ul>
<li>NIMU NDK core layer that defines the APIs for the network applications to communicate with device drivers in an abstract manner. It also provides an interface between the NDK core stack and the device drivers.</li>
<li>NIMU device driver interface counterpart that implements the NIMU APIs for the specific device driver.</li>
</ul>
<p>Figure A-1 showcases NIMU architecture.</p>
<p><img src="data:image/gif;base64,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1phJ/9bYSdsFqU+EFzKmp9gyqXYKY5CKpU60S6AkXKvaF1XZTDA2Zz76qDylVWU2ZrfqREZDkcvlqXyaqzdKDeqGgVOzDMvQDNh6rdmardp6rdrardyKrc/grddKruX6rduaruGKruIKrur6re7qruaarvDareuKr/GKr82QreTKrv+ar+rKrvoKsPp6rWTQADx3qQurIe7DBQYrsBFrsPPart4qr8vgrxR7rxVbrwObrucqsRobshXrseiaryCrrc8grgVrrxbrrcdgBQDABSOABWOABzY7Bjh7s3iwszbbszersznbs0HLszgbtEf7sz/rszo7tEJrtEMLtU8rtTubtMZIO7U567RFS7VWq7VYS7RVO7Q/oAAKy7AMiw90gAAmkLVLu7VNy7RX27Vdi7VRC7Rgy7ZXy7Vre7RZa7dti7d0q7R5+7VvS7djIAYjUADKwAVO4ARR0LiM67iRG7mNO7mO+7iWO7mXC7mPq7lRULmf27mgK7maS7qZa7qXK7qUW7qoy7qj67qtq7qv67mwi7lckAz4ULa5myHhsAWYS7upO7uyG7vDG7zEu7myC7zHq7yri7y0S7zJy7zLe7rNO72MewVlEBAAOw==" title="NIMU Architecture" alt="Figure A-1 NIMU Architecture" /></p>
<h3 id="a.13.2-data-structure-definition">A.13.2 Data Structure Definition</h3>
<p>The NIMU network interface object is equivalent to the device independent packet layer. Each NIMU network interface object is described with the following data structure:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> NETIF_DEVICE
{
    LIST_NODE links;

    <span class="co">/* Device Identification */</span>
    <span class="dt">uint32_t</span> index;
    <span class="dt">char</span> name[MAX_INTERFACE_NAME_LEN];

    <span class="co">/* Device Specific Information */</span>
    <span class="dt">uint32_t</span> flags;
    <span class="dt">uint32_t</span> mtu;
    <span class="dt">unsigned</span> <span class="dt">char</span> mac_address[<span class="dv">6</span>];

    <span class="co">/* Internal Use: Number of references held. */</span>
    <span class="dt">uint32_t</span> RefCount;
    <span class="dt">uint32_t</span> type;

    <span class="co">/* Pointer to 'driver specific private data' */</span>
    <span class="dt">void</span>* pvt_data;

    <span class="co">/*****************************************************************</span>
<span class="co">     ***************** Driver Interface Functions ********************</span>
<span class="co">     *****************************************************************/</span>

    <span class="dt">int</span> (*start)(<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device);
    <span class="dt">int</span> (*stop)(<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device);
    <span class="dt">void</span> (*poll)(<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device, <span class="dt">uint32_t</span> timer_tick);
    <span class="dt">int</span> (*send)(<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device, PBM_Handle hPkt);
    <span class="dt">void</span> (*pkt_service) (<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device);
    <span class="dt">int</span> (*ioctl)(<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device, <span class="dt">uint32_t</span> cmd,
         <span class="dt">void</span>* pbuf, <span class="dt">uint32_t</span> size);
    <span class="dt">int</span> (*add_header) (<span class="kw">struct</span> NETIF_DEVICE* ptr_net_device, PBM_Handle hPkt,
         <span class="dt">unsigned</span> <span class="dt">char</span>* dst_mac, <span class="dt">unsigned</span> <span class="dt">char</span>* src_mac, <span class="dt">uint16_t</span> ether_type);

} NETIF_DEVICE;</code></pre></div>
<p>The structure entries are described below:</p>
<h4 id="links-pointers-to-the-next-and-previous-devices">links  Pointers to the next and previous devices</h4>
<p><strong>Description</strong> Holds pointers to the previous and next devices in the chain of NIMU registered devices in the system.</p>
<h4 id="index-unique-number-to-identity-the-device-in-the-system">index  Unique number to identity the device in the system</h4>
<p><strong>Description</strong> Numerically identifies devices uniquely in the system. Driver authors should <strong>not</strong> alter this value. It will be assigned in <code>NIMURegister()</code>. The value will be the devices .init functions index in the <a href="ug/ug_ndk/stack.html#nimu-device-table">NIMU Device Table</a> + 1.</p>
<h4 id="name-device-name">name  Device name</h4>
<p><strong>Description</strong> Name of the device to identify it uniquely in the system. Driver authors can specify a name for the device; but in the case of conflicts its value will be modified to be unique in the system. Therefore, if driver authors are using this in their code it is best to re-read the value after the registration process.</p>
<h4 id="flags-device-specific-flags">flags  Device specific flags</h4>
<p><strong>Description</strong> Contains additional information which further describes the network device and its properties. The following flags may be set by a driver author when the NETIF_DEVICE structure is initialized. Flags should not be set at runtime, because the driver modifies flags to maintain information about driver status.</p>
<ul>
<li>NIMU_DEVICE_NO_ARP. Device does not support ARP.</li>
<li>NIMU_DEVICE_NO_FREE. Device is responsible for allocating and freeing the device instance. Setting this flag causes internal calls to <em>mmFree()</em> to be omitted. Drivers that set this flag should call <em>mmFree()</em> or otherwise free the device instance in the registered stop function. See <a href="#memory-allocation-api-functions">Section 2.4.2</a> for details on mmFree(). For example:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="co">/* Initialization function in driver */</span>
    ptr_device = mmAlloc(<span class="kw">sizeof</span>(NETIF_DEVICE));
    mmZeroInit (ptr_device, <span class="kw">sizeof</span>(NETIF_DEVICE));
    ...
    ptr_device-&gt;flags = NIMU_DEVICE_NO_FREE;</code></pre></div>
<ul>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_TX_ALL. Device configured to compute and insert checksums into outgoing IP, ICMP, TCP and UDP packets in hardware. If this flag is set, software checksum calculations and insertions will be omitted in the respective stack layers, as the hardware is assumed to handle this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_TX_ICMP. Device configured to compute and insert checksums into outgoing ICMP packets in hardware. If this flag is set, ICMP software checksum calculations and insertions will be omitted in the respective stack layers, as the hardware is assumed to handle this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_TX_IP. Device configured to compute and insert checksums into outgoing IP packets in hardware. If this flag is set, IP software checksum calculations and insertions will be omitted in the respective stack layers, as the hardware is assumed to handle this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_TX_UDP. Device configured to compute and insert checksums into outgoing UDP packets in hardware. If this flag is set, UDP software checksum calculations and insertions will be omitted in the respective stack layers, as the hardware is assumed to handle this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_TX_TCP. Device configured to compute and insert checksums into outgoing TCP packets in hardware. If this flag is set, TCP software checksum calculations and insertions will be omitted in the respective stack layers, as the hardware is assumed to handle this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_RX_ALL. Device configured to compute and verify checksums for incoming IP, ICMP, TCP and UDP packets in hardware. If this flag is set, software checksum verifications will be omitted in the respective stack layers, as the hardware is assumed to have handled this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_RX_ICMP. Device configured to compute and verify checksums for incoming ICMP packets in hardware. If this flag is set, ICMP software checksum verifications will be omitted in the respective stack layers, as the hardware is assumed to have handled this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_RX_IP. Device configured to compute and verify checksums for incoming IP packets in hardware. If this flag is set, IP software checksum verifications will be omitted in the respective stack layers, as the hardware is assumed to have handled this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_RX_UDP. Device configured to compute and verify checksums for incoming UDP packets in hardware. If this flag is set, UDP software checksum verifications will be omitted in the respective stack layers, as the hardware is assumed to have handled this.</p></li>
<li><p>NIMU_DEVICE_ENABLE_HW_CHKSM_RX_TCP. Device configured to compute and verify checksums for incoming TCP packets in hardware. If this flag is set, TCP software checksum verifications will be omitted in the respective stack layers, as the hardware is assumed to have handled this.</p></li>
</ul>
<h4 id="mtu-maximum-transmission-unit-for-the-device">mtu  Maximum transmission unit for the device</h4>
<p><strong>Description</strong> This defines the maximum size of a packet that can be transmitted over the device without any fragmentation. Driver authors should configure this value to the maximum data payload that can be carried without the corresponding Layer2 header. For example, in Ethernet this will be 1514 (maximum data payload) - 14 (L2 Ethernet header) = 1500. By default, the value for mtu is 1500.</p>
<h4 id="mac_address-hardware-address-of-this-device">mac_address  Hardware address of this device</h4>
<p><strong>Description</strong> This is the hardware address of the device that uniquely identifies the device.</p>
<h4 id="refcount-reference-count-of-the-device">RefCount  Reference count of the device</h4>
<p><strong>Description</strong> This indicates the number of references of network interface objects held by components. Network Interface objects can only be removed from the system if there are no references of them held in the system. This is used internally by the NIMU control module and should never be modified by the driver.</p>
<h4 id="type-defines-the-interface-type">type  Defines the interface type</h4>
<p><strong>Description</strong> For compatibility with the old network interface object, this is set to HTYPE_ETH or HTYPE_PPP depending on the type of network interface object. Moving forward, this field will be obsolete and application authors should use the field instead.</p>
<h4 id="pvt_data-pointer-to-device-specific-private-data">pvt_data  Pointer to device-specific private data</h4>
<p><strong>Description</strong> This can be used by the driver authors to store any additional driver-specific data. Memory allocation, Initialization and cleanup is the responsibility of the driver author the NDK NIMU module does not use this field in any way and is opaque to the NDK core stack.</p>
<p>The driver interface functions can be described as follows:</p>
<h4 id="start-callback-function-registered-by-driver-to-open-the-controller">start  Callback function registered by driver to open the controller</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> (*start) (NETIF_DEVICE* ptr_netif_device);</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on success and a negative value on error.</p>
<p><strong>Description</strong> The device start function is a registered call back function which is populated by the device driver author in the network interface object control block. Once the network interface object is registered with the NIMU NDK core stack during the registration process, the NDK core stack will call out this function. Device driver authors are recommended to place hardware initialization and start-up code in this callback function. After the successful completion of the API, the driver should be able to receive and transmit packets from the hardware. Driver authors must specify this callback function or else the NIMU registration will fail.</p>
<h4 id="stop-callback-function-registered-by-driver-to-close-the-controller">stop  Callback function registered by driver to close the controller</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> (*stop) (NETIF_DEVICE* ptr_netif_device);</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on Success and a negative value on error.</p>
<p><strong>Description</strong> The device stop function is a registered call back function which is populated by the device driver author in the network interface object control block. The function is invoked by the NDK core stack when the NIMU network interface object is being unregistered from the NIMU system. Driver authors are recommended to place the hardware controller shutdown code in this API. After the successful completion of this API, the driver should not be able to receive or transmit packets. Driver authors must specify this callback function or else the NIMU registration will fail.</p>
<h4 id="poll-callback-function-registered-by-driver-to-be-called-periodically-by-the-ndk.">poll  Callback function registered by driver to be called periodically by the NDK.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> (*poll) (NETIF_DEVICE* ptr_netif_device, <span class="dt">uint32_t</span> timer_tick);</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> The call back function is used by the NDK core stack to periodically call the driver. Driver authors can use this function to monitor link activity or do any work outside the kernel mode context. The callback function registered here is not called from kernel mode.</p>
<p>The following table summarizes the significance of timer_tick.</p>
<table>
<thead>
<tr class="header">
<th>timer_tick</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>The polling function is called because of a timer event. It is recommended that device authors use this for doing periodic activities such as link management, watchdog timers, etc.</td>
</tr>
<tr class="even">
<td>0</td>
<td>This indicates that the polling function has been called because the driver has indicated a <code>STKEVENT_signal</code>. This is useful for device authors to signify some activity outside kernel mode.</td>
</tr>
</tbody>
</table>
<h4 id="send-callback-function-registered-by-driver-to-send-packets.">send  Callback function registered by driver to send packets.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> (*send) (NETIF_DEVICE* ptr_netif_device,
             PBM_Handle    hPkt );</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on success and a negative value on error. On success, the packet memory cleanup needs to be handled by the driver; but if an error is returned, the NDK core stack will clean up the packet.</p>
<p><strong>Description</strong> The device send function is an API which is used by the core NDK stack to pass packets to the driver for transmission. Driver authors must specify this callback function or else the NIMU registration will fail.</p>
<h4 id="pkt_service-callback-function-registered-by-driver-for-the-ndk-stack-to-receive-packets">pkt_service  Callback function registered by driver for the NDK stack to receive packets</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> (*pkt_service) (NETIF_DEVICE* ptr_netif_device);</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> The API is used by the NDK core stack to receive packets from the driver. This is indicated through the STKEVENT_signal API once the packets have been received. The NDK core scheduler detects this signal and ensures that the appropriate packet service API is called. This function is called from kernel mode. The drivers should handle conditions where even though this API is called there are no packets in the receive queue.</p>
<h4 id="ioctl-callback-function-registered-by-driver-for-the-ndk-stack-to-getset-configuration">ioctl  Callback function registered by driver for the NDK stack to get/set configuration</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> (*ioctl) (NETIF_DEVICE  *ptr_device,
               <span class="dt">uint32_t</span>      cmd,
               <span class="dt">void</span>          *pBuf,
               <span class="dt">uint32_t</span> size );</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on Success and a negative value on error.</p>
<p><strong>Description</strong> This API is used by the NDK core stack to be able to get/set configuration in the drivers. The interface can be used to configure the multicast address list, change device MAC address, etc. Each NIMU network interface object can also identify its own custom IOCTL commands to do any device-specific configuration. This function is called from kernel mode.</p>
<h4 id="add_header-callback-function-registered-by-driver-for-the-ndk-stack-to-add-custom-l2-header">add_header  Callback function registered by driver for the NDK stack to add custom L2 header</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> (*add_header)(NETIF_DEVICE*  ptr_netif_device,
                   PBM_Handle     hPkt,
                   <span class="dt">unsigned</span> <span class="dt">char</span>* dst_mac,
                   <span class="dt">unsigned</span> <span class="dt">char</span>* src_mac,
                   <span class="dt">uint16_t</span>       ether_type);</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This is a registered call back function added by the driver to add custom layer2 headers on packets. This is called by the NDK core stack after layer3 has done its work. Ethernet driver authors can set this API to be NIMUAddEthernetHeader. However, if the driver is not a standard Ethernet driver, this can be used to add an appropriate layer2 header. For example, If the driver is USB-RNDIS, then this function can be defined to add not only the standard Ethernet header, but also the RNDIS header. If there are custom headers, then ensure there is sufficient head room in the packet buffers which are being allocated. Configuration of header and trailer sizes are provided by the NIMU exported API NIMUSetRsvdSizeInfo. This function is called from kernel mode.</p>
<h3 id="a.13.3-nimu-configuration">A.13.3 NIMU Configuration</h3>
<p>For sample NIMU API usage, please refer to the DSK6455 and DM642 Ethernet driver code in the latest platform specific packages.</p>
<h3 id="a.13.4-api-function-overview">A.13.4 API Function Overview</h3>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NIMURegister</td>
<td>Registers a NIMU compliant network interface object</td>
</tr>
<tr class="even">
<td>NIMUUnregister</td>
<td>Un-registers a NIMU compliant network interface object</td>
</tr>
<tr class="odd">
<td>NIMUGetRsvdSizeInfo</td>
<td>Get current header and trailer size</td>
</tr>
<tr class="even">
<td>NIMUSetRsvdSizeInfo</td>
<td>Set current header and trailer size</td>
</tr>
<tr class="odd">
<td>NIMUReceivePacket</td>
<td>Interface API to pass packets to the NDK core stack</td>
</tr>
<tr class="even">
<td>NIMUIoctl</td>
<td>Get/set configuration from the NIMU module and drivers</td>
</tr>
</tbody>
</table>
<h3 id="a.13.5-api-function-description">A.13.5 API Function Description</h3>
<h4 id="nimuregister-callback-registers-a-nimu-compliant-network-interface-object">NIMURegister  Callback Registers a NIMU compliant network interface object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> NIMURegister (NETIF_DEVICE* ptr_netif_device);</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on success and a negative value on error.</p>
<p><strong>Description</strong> The API is used to register a NIMU compliant network interface object with the core NDK NIMU module. As part of the registration process, the API will also invoke the <em>start</em> API to open and begin the corresponding the network device.</p>
<h4 id="nimuunregister-un-registers-a-nimu-compliant-network-interface-object">NIMUUnregister  Un-registers a NIMU compliant network interface object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> NIMUUnregister (NETIF_DEVICE* ptr_netif_device);</code></pre></div>
<p><strong>Return Value</strong> The function returns a value of 0 on success and a negative value on error.</p>
<p><strong>Description</strong> The API is used to un-register a previously registered NIMU compliant network interface object from the core NDK NIMU module. As part of the un-registration process, the API will also invoke the <em>stop</em> API to close the corresponding network device. This API can only be called from within kernel mode.</p>
<h4 id="nimugetrsvdsizeinfo-get-current-header-and-trailer-size">NIMUGetRsvdSizeInfo  Get current header and trailer size</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">_include &lt;stkmain.h&gt;_

_void NIMUGetRsvdSizeInfo ( <span class="dt">int</span> *hdr_size,
                            Int *trail_size );_</code></pre></div>
<p><strong>Return Value</strong> The function returns the current header and trailer reserved space.</p>
<p><strong>Description</strong> All packets set aside by the network interface management unit are allocated reserving some space for headers and trailers. The API is used to get the current header and trailer size that NIMU will use from this point on. This API can only be called from within kernel mode.</p>
<h4 id="nimusetrsvdsizeinfo-set-current-header-and-trailer-size">NIMUSetRsvdSizeInfo  Set current header and trailer size</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> NIMUSetRsvdSizeInfo (<span class="dt">int</span> hdr_size,
                          <span class="dt">int</span> trail_size);</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> All packets set aside by the network interface management unit are allocated reserving some space for headers and trailers. The API is used to set the current header and trailer size that NIMU will use from this point on. There are no validations done on the header and trailer size values passed to the function. It is assumed that the system authors have configured this value correctly. This API can only be called from within kernel mode.</p>
<h4 id="nimureceivepacket-interface-api-to-pass-packets-to-the-ndk-core-stack">NIMUReceivePacket  Interface API to pass packets to the NDK Core stack</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> NIMUReceivePacket (PBM_Handle hPkt);</code></pre></div>
<p><strong>Return Value</strong> The function returns the 0 on success and &lt;0 on error. Note that in case of error, the function will clean the packet memory.</p>
<p><strong>Description</strong> This is the interface function which has been exported by the NIMU module to pass received packets to the networking stack. This API is available only for NIMU network interface objects and replaces the EtherRxPacket API, which handles the LL packet architecture. This API can only be called from within kernel mode.</p>
<h4 id="nimuioctl-getset-configuration-from-the-nimu-module-and-drivers">NIMUIoctl  Get/Set configuration from the NIMU Module and Drivers</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> NIMUIoctl( <span class="dt">uint32_t</span> cmd,
               NIMU_IF_REQ *ptr_nimu_ifreq,
               Void *pBuf,
               <span class="dt">uint32_t</span> size );</code></pre></div>
<p><strong>Return Value</strong> The function returns the 0 on success and a negative value on error.</p>
<p><strong>Description</strong> This function is used to get and set configuration parameters from either the NIMU module or to the NIMU network interface objects driver attached to the NIMU module. The NIMU_IF_REQ structure is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> NIMU_IF_REQ
{
    <span class="dt">uint32_t</span> index;                        <span class="co">/* Device Index */</span>
    <span class="dt">char</span>     name[MAX_INTERFACE_NAME_LEN]; <span class="co">/* Device Name */</span>
} NIMU_IF_REQ;</code></pre></div>
<p>The structure is used to identify the NIMU network interface object which is being referred to. The introduction of NIMU network interface objects can be referred by a <em>name</em> or by a <em>unique index</em>. The NIMU IOCTL Interface searches for a matching device using the <em>name</em>; if no device is found then the device index is used to find a matching device. If none is found then an error is returned. The cmd parameter is used to specify the command, and <em>pBuf</em> and <em>size</em> are defined on a per command basis. The following table summarizes the set of supported IOCTL commands and the values expected in the pBuf and size.</p>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>pBuf</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NIMU_GET_DEVICE_HANDLE</td>
<td>&amp;(void *)</td>
<td>4</td>
<td>Use this to get the NIMU device handle associated with the device.</td>
</tr>
<tr class="even">
<td>NIMU_GET_DEVICE_MTU</td>
<td>&amp;uint16_t</td>
<td>2</td>
<td>Use this to get the MTU associated with the device.</td>
</tr>
<tr class="odd">
<td>NIMU_SET_DEVICE_MTU</td>
<td>&amp;uint16_t</td>
<td>2</td>
<td>Use this to set the MTU associated with the device. No validations are done on this.</td>
</tr>
<tr class="even">
<td>NIMU_GET_DEVICE_MAC</td>
<td>&amp;(unsigned char[6])</td>
<td>6</td>
<td>Get the device MAC address.</td>
</tr>
<tr class="odd">
<td>NIMU_SET_DEVICE_MAC</td>
<td>&amp;(unsigned char[6])</td>
<td>6</td>
<td>Set the device MAC address. In this case the MAC address is also passed down to the NIMU Network interface object so that the MINI-driver can also be reconfigured. If this is not supported by the driver the IOCTL fails.</td>
</tr>
<tr class="even">
<td>NIMU_GET_DEVICE_NAME</td>
<td>&amp;(unsigned char[20])</td>
<td>20</td>
<td>Use this API to translate the device index to device name. The device name is returned in pBuf</td>
</tr>
<tr class="odd">
<td>NIMU_GET_DEVICE_INDEX</td>
<td>&amp;uint16_t</td>
<td>2</td>
<td>Use this API to translate the device name to device index. The device index is returned in pBuf</td>
</tr>
<tr class="even">
<td>NIMU_ADD_MULTICAST_ADDRESS</td>
<td>&amp;(unsigned char[6])</td>
<td>6</td>
<td>This API is used to add a multicast MAC address to the device multicast list. This IOCTL needs to be handled in the NIMU Network Interface Object Driver.</td>
</tr>
<tr class="odd">
<td>NIMU_DEL_MULTICAST_ADDRESS</td>
<td>&amp;(unsigned char[6])</td>
<td>6</td>
<td>This API is used to delete a multicast MAC address to the device multicast list. This IOCTL needs to be handled in the NIMU Network Interface Object Driver.</td>
</tr>
<tr class="even">
<td>NIMU_ENABLE_RX_CSO_ERROR_HW_DROPS</td>
<td>&amp;(uint32_t)</td>
<td>4</td>
<td>This API is used to control the behavior of the MAC hardware, regarding devices with hardware checksum offload (CSO) support. This IOCTL is used to configure the MAC hardware, on the RX channel specified in pBuf, to drop packets received with bad checksum values. When this setting is in effect, such bad packets will be dropped by the hardware; as such, they will never reach the NIMU driver code. Only supported for devices with hardware checksum offload enabled. Affects RX packets only. If this is not supported by the driver, the IOCTL fails.</td>
</tr>
<tr class="odd">
<td>NIMU_DISABLE_RX_CSO_ERROR_HW_DROPS</td>
<td>&amp;(uint32_t)</td>
<td>4</td>
<td>This API is used to control the behavior of the MAC hardware, regarding devices with hardware checksum offload (CSO) support. This IOCTL is used to configure the MAC hardware, on the RX channel specified in pBuf, to <em>not</em> drop packets received with bad checksum values. When this setting is in effect, such bad packets will be ignored by the hardware; as such, they will be passed up to the NIMU driver code where they must be dropped in software. Only supported for devices with hardware checksum offload enabled. Affects RX packets only. If this is not supported by the driver, the IOCTL fails.</td>
</tr>
</tbody>
</table>
<p>Typically, most of the requests are done for a specific network interface object; but in some cases, configuration might be required for all NIMU network interface objects. In the case of these special cmd, the value of the interface request is NULL. These special case cmd are shown in the following table.</p>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>pBuf</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NIMU_GET_NUM_NIMU_OBJ</td>
<td>&amp;uint16_t</td>
<td>2</td>
<td>Use this to get the number of NIMU network interface objects active in the system.</td>
</tr>
<tr class="even">
<td>NIMU_GET_ALL_INDEX</td>
<td>&amp;uint16_t</td>
<td>(Number of NIMU Objects) * sizeof(uint16_t)</td>
<td>The API is used to populate an array of all device indexs present in the system. Memory allocated should be sufficient to store all this information. Use the above API to get an active count and allocate memory appropriately for pBuf.</td>
</tr>
</tbody>
</table>
<p>This API cannot be called from kernel mode. It is recommended that system application authors use this API instead of directly trying to access low layer information.</p>
<h2 id="a.14-virtual-lan-vlan-support">A.14 Virtual LAN (VLAN) Support</h2>
<h3 id="a.14.1-synopsis">A.14.1 Synopsis</h3>
<p>Virtual LAN (VLAN) support in NDK adds the capability of receiving and transmitting VLAN tagged packets through the stack. VLAN support in NDK is available only in conjunction with NIMU architecture.</p>
<p>Figure A-2 highlights the VLAN module components in reference to the NIMU enabled NDK stack.</p>
<p><img src="data:image/gif;base64,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" title="VLAN Module Placement in NIMU Enabled NDK Stack" alt="Figure A-2 VLAN Module Placement in NIMU Enabled NDK Stack" /></p>
<p>The NIMU core and VLAN modules in the NDK stack are closely tied together. The VLAN module is brought down by the NIMU as a part of its de-initializing routine during the system shutdown. Similarly, the NIMU modules packet receive routine is responsible for handing over all VLAN tagged packets to the VLAN module for processing. It does so by checking all incoming packets for their L2 type and if it is VLAN, forwards the packets onto the VLAN module of the stack for further processing.</p>
<p>VLAN implementation has 2 parts:</p>
<ul>
<li>VLAN Layer2 stack that is responsible for the addition and deletion of VLAN headers in the transmit and receive paths.</li>
<li>VLAN network interface objects which are instances of NIMU devices with VLAN specific attributes like a VLAN Identifier, user priority, etc.</li>
</ul>
<p>A VLAN network interface object is a NIMU device characterized additionally by these VLAN specific attributes:</p>
<ul>
<li>VLAN Identifier - Each VLAN node is identified by a unique VLAN identifier per source interface.</li>
<li>Source Interface - The VLAN source interface is the actual physical interface on which the VLAN nodes are executing. This is the actual physical Ethernet interface on which packets are received and transmitted.</li>
<li>Default Priority - VLAN tagged packets carry a 16-bit tag also known as the tag control information (TCI) header. This field internally carries a 3-bit user priority. The value here is the <em>default priority</em> which is filled in these fields if the packet to be transmitted has no <em>priority specified</em>.</li>
<li>User Priority Mapping - The user priority mappings are specified to remap the packet priority to a 3-bit user priority.</li>
</ul>
<h3 id="a.14.2-user-priority-mapping-configuration">A.14.2 User Priority Mapping Configuration</h3>
<p>A user application can configure the user priority for a VLAN device using the <em>NDK_setsockopt()</em> API, which is discussed in great detail in <a href="#sockets-api-functions">Section 3.3.3</a>. The following sections provide an example on how the VLAN user priority can be communicated by an application to the VLAN module in the core stack and how they are translated to bits in VLAN header of the packets.</p>
<h3 id="a.14.2.1-user-priority-configuration">A.14.2.1 User Priority Configuration</h3>
<p>Figure A-3 shows two applications that use the NDK stack to communicate with other devices on the network through an Ethernet interface. The applications use the socket APIs described in <a href="#sockets-api-functions">Section 3.3.3</a> to send/receive packets through the device. With VLAN support, there should be a mechanism which the application authors will use to communicate the VLAN user priority value to associate their socket to the stack. This enables the stack to mark the user priority bits appropriately in the VLAN headers of the packets.</p>
<p>In Figure A-3, lets assume that Application1 is a high priority application and Application2 is a lower priority application. The network administrators on which the Ethernet is physically connected should have defined a <em>Traffic Conditioning Agreement</em>. All devices connected on that network should comply to this agreement that defines the user priority values for high and low priority application.</p>
<p><img src="data:image/gif;base64,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" title="VLAN Example" alt="Figure A-3 VLAN Example" /></p>
<p>Assuming that the traffic condition agreement mentioned in <a href="#a.14.2.1-user-priority-configuration">Section A.14.2.1</a> is as follows:</p>
<table>
<thead>
<tr class="header">
<th>Application Priority</th>
<th>VLAN User Priority Bits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>High</td>
<td>7</td>
</tr>
<tr class="even">
<td>Low</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Undefined</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>This implies that all packets generated by Application1 should be marked with the user priority value of 7. Similarly, all packets generated by Application2 should be marked with the user priority value of 5.</p>
<p>Each application is capable of sending and receiving packets only through the socket interface; therefore, you need to ensure that all sockets that send packets in Application1 are mapped to the correct priority level to ensure that they are marked to the user priority value of 7.</p>
<p>The other advantage of working out priority at the socket level instead of the application level is that <em>granularity</em> exists which allows prioritization even inside the applications. For example, one data flow in Application1 could be low priority while the other could be high priority.</p>
<p>As mentioned before, the user priority can be communicated by the application using <em>NDK_setsockopt</em> API with the socket option parameter set to <em>SO_PRIORITY</em> and the value set to the appropriate user priority. Note that the valid range for the user priority is 0 - 7; although a value of 0xFFFF can be used to reset the priority back to default. For more details on how to get/set the user priority using getsockopt() and setsockopt() socket APIs, see <a href="#sockets-api-functions">Section 3.3.3</a>.</p>
<p>Example</p>
<p>The following example configures the socket priority to be 0:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint16_t</span> priority = <span class="dv">0</span>;
<span class="cf">if</span> (NDK_setsockopt(s, SOL_SOCKET, SO_PRIORITY, &amp;priority, <span class="kw">sizeof</span>(priority) &lt; <span class="dv">0</span>)
    printf (<span class="st">&quot;TEST Case Failed: 0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>, fdError());</code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> Configuration of the socket priority is equivalent of indicating what the priority of the application is. The socket priority has no meaning outside the stack and is only used internally.</p>
</blockquote>
<h3 id="a.14.2.2-marking-packet-priority">A.14.2.2 Marking Packet Priority</h3>
<p>This section documents how the translation needs to be done to mark the <em>user priority bits</em>. Once an application has marked the socket priority, the VLAN module translates the socket priority to user priority bits using the following formula:</p>
<p><code>prio_mapping[socket_priority] = VLAN User Priority</code></p>
<p>The table in the previous section shows the traffic conditioning agreement for the VLAN user priority bits. It indicates that Application1 has HIGH priority so the VLAN module should mark its VLAN user priority bits set to 7 and that Application2 has LOW priority so the VLAN module should mark its VLAN user priority bits set to 5.</p>
<p>To satisfy this requirement, Application1 should have the following code snippet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint16_t</span> priority = <span class="dv">0</span>;
<span class="cf">if</span> (NDK_setsockopt(s, SOL_SOCKET, SO_PRIORITY, &amp;priority, <span class="kw">sizeof</span>(priority) &lt; <span class="dv">0</span>)
    printf (<span class="st">&quot;TEST Case Failed: 0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>, fdError());</code></pre></div>
<p>The idea is that all packets generated by Application1 will have a socket priority of 0 (HIGH).</p>
<p>Similarly, Application2 should have the following code snippet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint16_t</span> priority = <span class="dv">1</span>;
<span class="cf">if</span> (NDK_setsockopt(s, SOL_SOCKET, SO_PRIORITY, &amp;priority, <span class="kw">sizeof</span>(priority) &lt; <span class="dv">0</span>)
    printf (<span class="st">&quot;TEST Case Failed: 0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>, fdError());</code></pre></div>
<p>The idea is that all packets generated by Application2 will have a socket priority of 1 (LOW).</p>
<p>The VLAN device should be created with the following code snippet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* By default: We configure the priority mapping to be as follows:-</span>
<span class="co"> * Priority | VLAN User Priority</span>
<span class="co"> * -----------------------------------</span>
<span class="co"> *    0     |     7</span>
<span class="co"> *    1     |     5</span>
<span class="co"> *    2     |     0</span>
<span class="co"> *    3     |     0</span>
<span class="co"> *    4     |     0</span>
<span class="co"> *    5     |     0</span>
<span class="co"> *    6     |     0</span>
<span class="co"> *    7     |     0</span>
<span class="co"> */</span>
prio_mapping[<span class="dv">0</span>] = <span class="dv">7</span>;
prio_mapping[<span class="dv">1</span>] = <span class="dv">5</span>;
prio_mapping[<span class="dv">2</span>] = <span class="dv">0</span>;
prio_mapping[<span class="dv">3</span>] = <span class="dv">0</span>;
prio_mapping[<span class="dv">4</span>] = <span class="dv">0</span>;
prio_mapping[<span class="dv">5</span>] = <span class="dv">0</span>;
prio_mapping[<span class="dv">6</span>] = <span class="dv">0</span>;
prio_mapping[<span class="dv">7</span>] = <span class="dv">0</span>;

<span class="co">/* Use the VLAN API to create a new VLAN device. */</span>
<span class="cf">if</span> (VLANAddDevice (src_index, <span class="dv">10</span>, <span class="dv">0</span>, prio_mapping) &lt; <span class="dv">0</span>)
    printf (<span class="st">&quot;Error VLAN Failed errcode=%d</span><span class="sc">\n</span><span class="st">&quot;</span>);</code></pre></div>
<p>The important point to note in this example is the configuration of the user priority table. This is basically the translation of the traffic conditioning agreement to an array.</p>
<p>With the VLAN device created as follows, if a packet is transmitted from Application1 it is marked with a socket priority of 0, and then it is translated by the VLAN module to user priority 7.</p>
<h3 id="a.14.3-configuring-vlan-to-send-data-to-a-linux-pc">A.14.3 Configuring VLAN To Send Data To A Linux PC</h3>
<p>This section provides an overview of how to set up a VLAN device using the available commands in the NDK Telnet console. The commands are used to create and configure a VLAN device, and then send data over that device to a Linux PC. Note that the steps in this section assume Ubuntu Linux; however, similar commands should be available on other versions of Linux.</p>
<h3 id="a.14.3.1-configuring-vlan-on-the-linux-pc">A.14.3.1 Configuring VLAN On the Linux PC</h3>
<ol>
<li><p>Ensure your Linux box has the <code>vlan</code> application. If not, it can be installed by running the following command:</p>
<pre><code>sudo apt-get install vlan</code></pre></li>
<li><p>The <code>ncat</code> or a similar application is also needed. It can be installed by running the following command:</p>
<pre><code>sudo apt-get install ncat</code></pre></li>
<li><p>The Wireshark application is recommended, but not required. It can be installed by running the following command:</p>
<pre><code>sudo apt-get install wireshark</code></pre></li>
<li><p>Load the 8021q module into the kernel:</p>
<pre><code>sudo modprobe 8021q</code></pre></li>
<li><p>Assuming youre connected on interface <code>eth0</code> (with IP address 192.168.0.31):</p>
<pre><code>ifconfig
eth0  Link encap:Ethernet  HWaddr --:--:--:--:--:--
      inet addr:192.168.0.31  Bcast:192.168.0.255  Mask:255.255.255.0
      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
      RX packets:446 errors:0 dropped:0 overruns:0 frame:0
      TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
      collisions:0 txqueuelen:1000
      RX bytes:38520 (38.5 KB)  TX bytes:33324 (33.3 KB)</code></pre></li>
<li><p>Use the vconfig command to add a new VLAN interface with VLAN ID 10. This will create a new interface, but it will not have any IP address assigned to it:</p>
<pre><code>sudo vconfig add eth0 10</code></pre></li>
<li><p>Assign an IP address to the VLAN interface, choosing a different network:</p>
<pre><code>sudo ip addr add 10.90.90.15/24 broadcast 10.90.90.255 dev eth0.10</code></pre></li>
<li><p>Ensure that the interface is up:</p>
<pre><code>sudo ip link set up eth0.10</code></pre></li>
<li><p>You should now see the following detailed in the ifconfig command for the VLAN interface:</p>
<pre><code>eth0.10   Link encap:Ethernet  HWaddr --:--:--:--:--:--
      inet addr:10.90.90.15  Bcast:10.90.90.255  Mask:255.255.255.0
      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
      RX packets:21 errors:0 dropped:0 overruns:0 frame:0
      TX packets:26 errors:0 dropped:0 overruns:0 carrier:0
      collisions:0 txqueuelen:0
      RX bytes:5951 (5.9 KB)  TX bytes:6643 (6.6 KB)</code></pre></li>
<li><p>Use <code>ncat</code> to run a UDP echo server on port 10000, in order to receive incoming VLAN packets sent from the NDK:</p>
<pre><code>ncat -e /bin/cat -k -u -l 10000</code></pre></li>
<li>Run Wireshark on the VLAN interface <code>eth0.10</code> to capture packets sent to the VLAN interface</li>
<li><p>The Linux side is now ready to receive VLAN UDP packets</p></li>
</ol>
<h3 id="a.14.3.2-configuring-vlan-in-the-ndk">A.14.3.2 Configuring VLAN In The NDK</h3>
<p>The following steps provide an overview of how to add and configure a VLAN device, using the commands available in the Telnet console.</p>
<ol>
<li>Build an NDK application that enables the Telnet console. The app should be DHCP enabled to get an IP automatically.</li>
<li>Load and run the application.</li>
<li>From a terminal, telnet into the NDK application using the IP address obtained from DHCP.</li>
<li><p>Run the <code>ipaddr</code> command to display the list of interfaces and associated IP addresses configured for the NDK:</p>
<pre><code>&gt;ipaddr all
Interface Name: eth0
Interface Id  : 1
IP Address    : 192.168.0.9
IP Mask       : 255.255.255.0
MTU           : 1500 bytes
MAC Address   : --:--:--:--:--:--</code></pre></li>
<li><p>Use the <code>vlan</code> command to add a new VLAN interface on top of the existing Ethernet interface (IF number 1). Use VLAN ID 10 and priority of 4:</p>
<pre><code>&gt;vlan add 1 10 4
Successfully created new VLAN Device 2</code></pre></li>
<li><p>Repeat the <code>ipaddr</code> command. You should now see the new VLAN interface, in addition to the previously seen Ethernet interface:</p>
<pre><code>&gt;ipaddr all
Interface Name: eth0:10
Interface Id  : 2
MTU           : 1496 bytes
MAC Address   : --:--:--:--:--:--
Interface Name: eth0
Interface Id  : 1
IP Address    : 192.168.0.9
IP Mask       : 255.255.255.0
MTU           : 1500 bytes
MAC Address   : --:--:--:--:--:--</code></pre></li>
<li><p>Use the <code>ipaddr</code> command to assign an IP address to the VLAN interface:</p>
<pre><code>&gt;ipaddr 2 10.90.90.21 255.255.255.0</code></pre></li>
<li><p>Again, repeat the <code>ipaddr</code> command. You will see the VLAN interface now has the IP associated with it:</p>
<pre><code>&gt;ipaddr all
Interface Name: eth0:10
Interface Id  : 2
IP Address    : 10.90.90.21
IP Mask       : 255.255.255.0
MTU           : 1496 bytes
MAC Address   : --:--:--:--:--:--</code></pre>
<h3 id="a.14.3.3-sending-data-over-the-vlan-device">A.14.3.3 Sending Data Over The VLAN Device</h3></li>
<li><p>Run the <code>vlan send</code> command to send UDP packets to the Linux laptop on port 10000:</p>
<pre><code>&gt;vlan send 10.90.90.15
TEST Case Passed: Priority 0x8 is incorrect and was detected
Packet with priority 0 has been sent
Packet with priority 1 has been sent
Packet with priority 2 has been sent
Packet with priority 3 has been sent
Packet with priority 4 has been sent
Packet with priority 5 has been sent
Packet with priority 6 has been sent
Packet with priority 7 has been sent
Packet with default priority has been sent</code></pre></li>
<li><p>On the Linux PC, you should see the packets being sent in Wireshark. If you inspect the Ethernet frame, you will see the VLAN header and ID of 10</p></li>
</ol>
<h3 id="a.14.4-vlan-api-functions">A.14.4 VLAN API Functions</h3>
<p>This section details the VLAN APIs. Note, some functions are for internal stack usage only.</p>
<h3 id="a.14.4.1-function-overview">A.14.4.1 Function Overview</h3>
<p>The following are the APIs exported by the VLAN module in the core stack.</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VLANInit</td>
<td>Initializes the VLAN module in the core NDK stack.</td>
</tr>
<tr class="even">
<td>VLANDeinit</td>
<td>Deinitalizes the VLAN module and shuts down all the VLAN enabled NIMU network interface objects in the system.</td>
</tr>
<tr class="odd">
<td>VLANReceivePacket</td>
<td>Handles all VLAN tagged packets on the receive path.</td>
</tr>
<tr class="even">
<td>VLANAddDevice</td>
<td>Creates a VLAN device on a specified NIMU interface.</td>
</tr>
<tr class="odd">
<td>VLANDelDevice</td>
<td>Deletes a previously created VLAN device.</td>
</tr>
</tbody>
</table>
<h3 id="a.14.4.2-api-functions">A.14.4.2 API Functions</h3>
<h4 id="vlaninit-initializes-the-vlan-module-in-the-core-ndk-stack.">VLANInit  Initializes the VLAN module in the core NDK stack.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> VLANInit (<span class="dt">void</span>)</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This function is used to initialize the VLAN module in the NDK core stack. It is for internal stack usage only and should not be called by any application directly. This function is called as a part of the stack bring up, i.e., NC_NetStart invocation by the user application. It initializes the header and trailer sizes for VLAN NIMU objects that would be created in the system later by a user application.</p>
<h4 id="vlandeinit-deinitalizes-vlan-module-and-shuts-down-vlan-enabled-nimu-network-interface-objects">VLANDeinit  Deinitalizes VLAN module and shuts down VLAN enabled NIMU network interface objects</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">void</span> VLANDeinit (<span class="dt">void</span>);</code></pre></div>
<p><strong>Return Value</strong> None</p>
<p><strong>Description</strong> This function is used to shut down the VLAN module in the core stack. It closes and shuts down any VLAN enabled NIMU network interface objects existent in the system. This function is for internal stack usage only and should not be called by any application directly. It is called as a part of stack teardown, i.e., when the user application invokes NC_NetStop function.</p>
<h4 id="vlanreceivepacket-handles-all-vlan-tagged-packets-on-the-receive-path">VLANReceivePacket  Handles all VLAN tagged packets on the receive path</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">uint32_t</span> VLANReceivePacket (PBM_Handle hPkt);</code></pre></div>
<p><strong>Return Value</strong> Returns 0xFFFF on error and on success returns the values of the encapsulated protocol.</p>
<p><strong>Description</strong> This function is called by the NIMU receive function when a VLAN tagged packet is received. It validates the packet and ensures that there is a valid VLAN node on the system that can process the packet. This function is for internal stack usage only and should not be called by any application directly.</p>
<h4 id="vlanadddevice-create-a-vlan-network-interface-object">VLANAddDevice  Create a VLAN Network Interface object</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> VLANAddDevice (<span class="dt">uint32_t</span>      src_index,
                   <span class="dt">uint16_t</span>      vlan_id,
                   <span class="dt">unsigned</span> <span class="dt">char</span> default_priority,
                   <span class="dt">unsigned</span> <span class="dt">char</span> prio_mapping[]);</code></pre></div>
<p><strong>Return Value</strong> This function returns the device index of the new VLAN network interface object created on a success or a negative value on error.</p>
<p><strong>Description</strong> This API enables system developers to create a VLAN Network Interface object on a specified NIMU source interface based on the arguments supplied. Note that this function must be called from user mode only.</p>
<h4 id="vlandeldevice-deletes-a-previously-created-vlan-device">VLANDelDevice  Deletes a previously created VLAN device</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stkmain.h&gt;</span>

<span class="dt">int</span> VLANDelDevice (<span class="dt">uint16_t</span> dev_index);</code></pre></div>
<p><strong>Return Value</strong> This function returns 0 on a success or a negative value on error.</p>
<p><strong>Description</strong> This API deletes a previously created VLAN network interface object. The device index passed is the index returned from the prior invocation of the VLANAddDevice API. Note that this function must be called from user mode only.</p>
<p><a name="raw-ethernet-module"></a></p>
<h2 id="a.15-raw-ethernet-module">A.15 Raw Ethernet Module</h2>
<h3 id="a.15.1-synopsis">A.15.1 Synopsis</h3>
<p>A new module called the <em>Raw Ethernet Module</em> has been added to the NIMU enabled NDK stack to handle the Raw Ethernet packet traffic through NDK. A Raw Ethernet packet can be defined as an Ethernet packet whose Protocol type (Offset 12 in the Ethernet header) doesnt match any of the well-known standard protocol types like IP (0x800), IPv6 (0x86DD), VLAN (0x8100), PPPoE Control (0x8863), PPPoE Data (0x8864). The Raw Ethernet Module interfaces with the application and the stack to provide the APIs required in configuring a raw Ethernet socket, and in sending and receiving packets using it.</p>
<p>Figure A-4 shows the placement of the Raw Ethernet module in the NDK stack.</p>
<p><img src="data:image/gif;base64,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" title="Raw Ethernet Channel Manager Module in NDK" alt="Figure A-4 Raw Ethernet Channel Manager Module in NDK" /></p>
<p>As Figure A-4 illustrates, traditional data path for the IP packets is different from the data path followed by the Raw Ethernet packets. The complete Layer 4, Layer 3 and Layer 2 processing in the NDK IP stack is bypassed for the Raw Ethernet packets. The Raw Ethernet packets alternatively travel through the Raw Ethernet Module which maintains a mapping between the custom Ethernet type configured and the interface on which the packets should be transmitted. This mapping is maintained in the Raw Ethernet Socket object structure. Also, shown in the above figure is the implementation of Raw Ethernet prioritization implementation in the driver using separate queues for IP and raw Ethernet traffic. This implementation is just an illustration of how this feature can be extended further to suit any application demands and is not really tied in with the design of Raw Ethernet Socket and Modules.</p>
<blockquote>
<p><strong>NOTE:</strong> The Raw Ethernet Module is supported only with NIMU enabled NDK stacks and drivers.</p>
</blockquote>
<p>For more details on the Raw Ethernet Socket APIs, see <a href="#RawSockets">Section 3.4</a> of this document.</p>
<h3 id="a.15.2-raw-ethernet-data-prioritization---socket-priority-use-case">A.15.2 Raw Ethernet Data Prioritization - Socket Priority Use Case</h3>
<p>A user application can use the Socket Priority to add any sort of special differentiation that the raw Ethernet application would require for all packets travelling using the specified socket. For example, if there exists two raw Ethernet sockets, they could be both configured with different priorities using <em>NDK_setsockopt()</em> API discussed in <a href="#sockets-api-functions">Section 3.3.3</a>. Further, a desired QoS scheme can be implemented in the Ethernet driver using this priority that is carried onto the packets. It can be also used by an application to map the priority to certain transmission properties like EMAC channel number on which the packets are to be transmitted etc. This section describes one such implementation of Socket Priority to implement Raw Ethernet Packet Prioritization over traditional IP traffic.</p>
<h3 id="a.15.2.1-socket-priority-configuration">A.15.2.1 Socket Priority Configuration</h3>
<p>In this specific use case, the application requires that:</p>
<ul>
<li>Raw Ethernet traffic and traditional IP traffic to be sent out on two separate EMAC channels.</li>
<li>Further, it also requires that both on Transmit (Tx) and Receive (Rx) paths, the Raw Ethernet data is always serviced before the IP data.</li>
</ul>
<p>For the implementation to achieve this also has two requirements:</p>
<ul>
<li>For requirement 1, the application would have to create a Raw Ethernet socket and configure the socket priority to carry the EMAC channel number. The Raw Ethernet module in turn will ensure that all packets travelling using this socket are tagged with the EMAC channel number in their PktPriority field. The socket priority configuration is shown in the following example:</li>
</ul>
<p>The following example creates a Raw Ethernet socket and configures the EMAC channel number to 3 using socket priority:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">SOCKET sraw = INVALID_SOCKET;
<span class="dt">uint16_t</span> priority = <span class="dv">0</span>;
<span class="dt">int</span> retVal, val;

<span class="co">/* Allocate the file environment for this task */</span>
fdOpenSession( TaskSelf() );

<span class="co">/* Create the raw Ethernet socket */</span>
sraw = NDK_socket(AF_RAWETH, SOCK_RAWETH, <span class="bn">0x300</span>);
<span class="cf">if</span>( sraw == INVALID_SOCKET )
{
    printf(<span class="st">&quot;Fail socket, %d</span><span class="sc">\n</span><span class="st">&quot;</span>, fdError());
    fdCloseSession (TaskSelf());
    <span class="cf">return</span>;
}

<span class="co">/* Configure the transmit device */</span>
val = <span class="dv">1</span>;
retVal = NDK_setsockopt(sraw, SOL_SOCKET, SO_IFDEVICE, &amp;val, <span class="kw">sizeof</span>(val));
<span class="cf">if</span>(retVal)
    printf(<span class="st">&quot;error in setsockopt </span><span class="sc">\n</span><span class="st">&quot;</span>);

<span class="co">/* Configure the EMAC channel number */</span>
val = <span class="dv">3</span>;
retVal = NDK_setsockopt(sraw, SOL_SOCKET, SO_PRIORITY, &amp;val, <span class="kw">sizeof</span>(val));
<span class="cf">if</span>(retVal)
    printf(<span class="st">&quot;error in setsockopt </span><span class="sc">\n</span><span class="st">&quot;</span>);</code></pre></div>
<ul>
<li><p>Secondly, to implement the prioritization and also obtain the EMAC channel number on which the packet needs to be transmitted, the EMAC driver can inspect the PktPriority field of the packet and use it to enqueue the packet to the hardware accordingly. A code snippet from the Ethernet driver is shown below for illustration purposes:</p>
<p>This is a code snippet from the Send routine of the Ethernet driver.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Peek into the packet to check out if any prioritization is needed.</span>
<span class="co"> *</span>
<span class="co"> * All raw Ethernet packets are tagged with the EMAC channel number onto</span>
<span class="co"> * which they need to be sent out in the PktPriority field.</span>
<span class="co"> */</span>
<span class="cf">if</span> (((PBM_Pkt *)hPkt)-&gt;PktPriority != PRIORITY_UNDEFINED)
{
    <span class="co">/* Enqueue the packet in the Raw Tx Queue and send it for transmission.</span>
<span class="co">     * Use the PktPriority field now as the EMAC channel number on which</span>
<span class="co">     * packet needs to be Txed</span>
<span class="co">     */</span>
}
<span class="cf">else</span>
{
    <span class="co">/* This is just a normal IP packet. Enqueue the packet in the</span>
<span class="co">     * Tx queue and send it for transmission.</span>
<span class="co">     */</span>
}</code></pre></div>
<p>For more details on this use case implementation, please refer to the Ethernet driver code packaged in the NSP for TCI6488.</p>
<h3 id="a.15.3-api-function-overview">A.15.3 API Function Overview</h3>
<p>The following APIs are exported by the Raw Ethernet module of the core NDK stack:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RawEthTxPacket</td>
<td>API to send out Raw Ethernet data using Raw Ethernet sockets</td>
</tr>
<tr class="even">
<td>RawEthTxPacketNC</td>
<td>API to send out Raw Ethernet data using Raw Ethernet sockets without any copy</td>
</tr>
<tr class="odd">
<td>RawEthRxPacket</td>
<td>API to handle raw Ethernet packets received by the stack</td>
</tr>
</tbody>
</table>
<h3 id="a.15.4-api-functions">A.15.4 API Functions</h3>
<h4 id="rawethtxpacket-sends-out-raw-ethernet-data-creates-a-copy-of-the-data.">RawEthTxPacket  Sends out Raw Ethernet data, creates a copy of the data.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> RawEthTxPacket (<span class="dt">void</span>* hRawEthSock,
                    <span class="dt">char</span>* pBuffer,
                    <span class="dt">int</span>   len);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hRawEthSock: Handle to the raw Ethernet socket</li>
<li>pBuffer: Handle to the data buffer that needs to be sent</li>
<li>len: Length of data contained in the data buffer pBuffer.</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li>0: Successfully sent out the packet</li>
<li>ENOBUFS: Error allocating memory for the packet. Packet not sent out.</li>
</ul>
<p><strong>Description</strong> This is the API called by the Raw Ethernet sockets module to transmit data sent by the application. This API allocates memory for the packet and the buffer according to the length specified, copies over the contents of the application buffer to the packet, and finally populates any socket priority configured on the socket to the <em>PktPriority</em> field of the packet for further use by the stack or the driver. It also increments the Raw Ethernet success stats if the transmit succeeded. This API invokes the NIMUSendPacket API to send out the packet eventually.</p>
<h4 id="rawethtxpacketnc-sends-out-raw-ethernet-data-without-any-copy-of-the-data.">RawEthTxPacketNC  Sends out Raw Ethernet data, without any copy of the data.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> RawEthTxPacketNC (<span class="dt">void</span> *hRawEthSock,
                      <span class="dt">char</span>* pBuffer,
                      <span class="dt">int</span> len,
                      <span class="dt">void</span> *hPkt);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hRawEthSock: Handle to the raw Ethernet socket</li>
<li>pBuffer: Handle to the data buffer that needs to be sent</li>
<li>len: Length of data contained in the data buffer pBuffer</li>
<li>hPkt: Handle to the packet that needs to be sent. The pBuffer is the data buffer</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li>0: Successfully sent out the packet</li>
<li>EINVAL: Bad Packet / Buffer Handles. Packet not sent out</li>
</ul>
<p><strong>Description</strong> This is the API called by the Raw Ethernet sockets module to transmit data sent by the application without making any copy of it on the Tx path. This API is very useful for applications which have very definite performance requirements for their application. The buffers and packet handles passed here can be obtained in advance using the socket API <em>getsendncbuff()</em> by the application , then can be used to fill data and finally invoke the <em>sendnc()</em> API to transmit this data. The send no-copy API of the raw Ethernet socket module in turn invokes this API for finally transmitting the data. The raw Ethernet socket APIs are all discussed in detail in <a href="#RawSockets">Section 3.4</a> of this document. This API validates the packet and buffer handles, and populates any socket priority configured on the socket to the <em>PktPriority</em> field of the packet for further use by the stack or the driver. It finally invokes the <em>NIMUSendPacket</em> API to send out the packet eventually. It also increments the Raw Ethernet success stats if the transmit succeeded. No memory allocations or copies are made by this API and hence is less intensive in terms of performance.</p>
<h4 id="rawethrxpacket-receive-handler-for-raw-ethernet-traffic-in-the-stack.">RawEthRxPacket  Receive handler for Raw Ethernet traffic in the stack.</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> RawEthRxPacket (PBM_Handle hPkt);</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPkt: Handle to the packet which is passed up to the stack by the Ethernet</li>
</ul>
<p><strong>Return Value</strong></p>
<ul>
<li>0: Success</li>
<li>1: Error</li>
</ul>
<p><strong>Description</strong> This API is called by the NIMU layer when the Ethernet if a raw Ethernet socket object exists for the Ethernet type in the packet and if so enqueues in the socket buffer for the application to receive. No copies are made of the packet and the buffers further on the receive path by the Raw Ethernet socket layer and the packet is as is handed over for the application to use. This API also increments the Raw Ethernet receive stats accordingly.</p>
<h2 id="a.16-obtaining-stack-statistics">A.16 Obtaining Stack Statistics</h2>
<p>Stack statistics are available from global structures or global arrays exported by the stack library. The declaration of these global identifiers appears in the interface specification for the individual protocols. The following protocols contain statistics information:</p>
<table>
<thead>
<tr class="header">
<th>Protocol</th>
<th>Statistics Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IP</td>
<td>IPIF.H</td>
</tr>
<tr class="even">
<td>ICMP</td>
<td>ICMPIF.H</td>
</tr>
<tr class="odd">
<td>TCP</td>
<td>TCPIF.H</td>
</tr>
<tr class="even">
<td>UDP</td>
<td>UDPIF.H</td>
</tr>
<tr class="odd">
<td>Raw Transport (non-TCP/UDP)</td>
<td>RAWIF.H</td>
</tr>
<tr class="even">
<td>Network Address Translation</td>
<td>NATIF.H</td>
</tr>
<tr class="odd">
<td>Raw Ethernet</td>
<td>AWETHIF.H</td>
</tr>
</tbody>
</table>
<p><a name="ApxB"></a></p>
<h1 id="b-network-address-translation">B Network Address Translation</h1>
<p>This section is required only for system programming that needs low level access to the Network Address Translation (NAT) layer. <strong>This API does not apply to sockets application programming.</strong></p>
<p>This section describes functions that are callable from the kernel layer. You should be familiar with the operation of the operation of <em>llEnter()</em>/<em>llExit()</em> functions before attempting to use the APIs described in this section (see <a href="#proper-use-of">Section A.1.2</a>).</p>
<p>NAT has a unique status in the stack software because it can be an integral part of programming at both the user and kernel levels, or can be entirely redundant and even purged from the stack build.</p>
<p>This section describes the operation of the Network Address Translation software included in the NDK, how to configure it, how to install port mappings, and how to program proxy filter routines to support protocols like FTP.</p>
<p><a name="nat-operation"></a></p>
<h2 id="b.1-nat-operation">B.1 NAT Operation</h2>
<p>NAT is a translation of packet IP address. It is used by the stack when routing, to translate the IP address of a packet to/from a private LAN from/to a public WAN. NAT is required when the IP address paradigms on either side of the router are incompatible; for example, virtual addresses vs.physical addresses, or private vs.public. In the case of a home LAN, NAT allows multiple clients on the home LAN to use a single ISP account by sharing the router WAN IP address obtained from the ISP.</p>
<h3 id="b.1.1-typical-configuration">B.1.1 Typical Configuration</h3>
<p>For the examples that follow, consider the typical configuration illustrated in Figure B-1. The NDK is executing as a home router (HR) and connects the home LAN subnet (192.168.0.x) to the Internet (WAN) via an ISP that has assigned HR an address of 128.1.2.12. The hosts on the home network (H1 and H2) have obtained their internet addresses from HR via DHCP. The IP of HR on the home LAN as well as the IP subnet used by the home LAN is pre-configured in HR. Figure B-1 also shows a host on the public internet (IH) to which the LAN hosts will connect. Lastly, it is assumed that the home LAN subnet is virtual, and NAT is required to allow H1 and H2 to share the WAN IP address assigned to HR by the ISP (128.1.2.12).</p>
<p><img src="data:image/gif;base64,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" title="Basic Home Network Configuration" alt="Figure B-1 Basic Home Network Configuration" /></p>
<p><a name="basic-nat"></a></p>
<h3 id="b.1.2-basic-nat">B.1.2 Basic NAT</h3>
<p>When sharing a single WAN IP address, the IP address obtained from the ISP is assigned to the router (the NDK in routing mode). Client machines that are to share the IP address are placed on the home LAN. The router routes traffic between the LAN and the WAN (internet via the ISP).</p>
<p>As packets traverse from the LAN to the WAN across the router, the source IP address of the packet (a LAN address) is replaced with the public IP address of the router. The result is that all packets sent to the WAN appear to have originated from the router with the public IP address obtained from the ISP.</p>
<p>As packets traverse from the WAN to the LAN across the router, the destination IP address of the packet (the routers WAN IP as obtained from the ISP) is replaced with the home LAN IP address of the physical client machine to which the packet is ultimately destined.</p>
<p>To perform this translation successfully, some details must be addressed. First, to allow multiple clients to share the public IP address in a non-ambiguous fashion, there must exist a deterministic method of mapping packets from the WAN to their correct destination on the LAN. This is done by keeping records of LAN IP clients that have initiated IP traffic, and by altering the TCP/UDP port (or ICMP Id field) as well as the IP address when performing the translation.</p>
<p>Every time a LAN client sends a packet to the WAN, the local IP address, port/id, and protocol is recorded for reverse mapping, as well as the destination IP address and port for security. When a packet is received from the WAN, the destination port/id is checked against the current database of NAT entries to see if the packets destination address and port/id should be translated to a LAN client.</p>
<p>For example, when accessing the Internet, all communication is normally initiated by the client. In this case, communication will be initiated by H1 or H2. Assume that H1 attempts to establish an HTTP connection with the Internet host (IH). It will send a connection request to the IP address assigned to IH, and a TCP port value of 80, which is HTTP. The request will be from its own IP address with an ephemeral port value that is picked from a pool (consider it random for these purposes- for example, 1001). So the request will be addressed as follows:</p>
<p><strong>Packet 1</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 80</td>
<td>192.168.0.32 : 1001</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>When the router HR receives this packet, it searches for a NAT entry that matches the <em>From</em> address of the packet. Because this is the first packet, assume the table is empty. When no entry is found, (skipping proxies for now) the router will create a new entry. It does this by recording information from packet 1, as well as picking a new port value from its own pool that has been specifically reserved for NAT (assume the range is 50000 to 55000, and that it chooses 50001). The new port is used as the packets source port. The NAT entry record would look like the following:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td>80</td>
<td>192.168.0.32</td>
<td>1001</td>
<td>50001</td>
<td>TCP</td>
<td>SYNSENT</td>
<td>00:01:00</td>
</tr>
</tbody>
</table>
<p>The <em>Local IP</em> and <em>Local Port</em> values are those that are local to hosts on the home LAN. The <em>Foreign IP</em> value is the foreign side of the connection as viewed by hosts on the home LAN. The <em>Mapped Port</em> value is the source port when the packet is sent from HR. The source IP address used in the packet is that assigned to HR by the ISP. The IP protocol of the packet is recorded, and when using TCP, the state of the TCP connection is tracked to establish a reasonable timeout value. The SYNSENT value indicates that a connection request was sent. Before a full connection is established, the timeout is set fairly low - for example, 1 minute.</p>
<p>As the packet is transmitted from HR to the ISP, it would look like the following:</p>
<p><strong>Packet 1 (modified)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 80</td>
<td>128.1.2.12 : 50001</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>When IH receives the packet, it believes that the connection request came from HR. It thus sends the response packet to HR. The packet would be addressed as follows:</p>
<p><strong>Packet 2 (response to packet 1)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>128.1.2.12 : 50001</td>
<td>64.1.1.100 : 80</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>When HR receives the packet, it checks the NAT entry table for an entry with a <em>Mapped Port</em> value equal to the destination port of the packet (in this case 50001). The value of <em>Protocol</em> and the source IP address/port values must also match the <em>Protocol</em>, <em>Foreign IP</em>, and <em>Foreign Port</em> fields of the NAT entry. This helps ensure that the reply is from the desired server.</p>
<p>Here, HR finds the entry and proceeds to modify the packet. It replaces the destination address/port with the local address/port stored in the entry. It also resets the timeout of the entry. After modification, the packet would be addressed as follows:</p>
<p><strong>Packet 2 (modified)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.0.32 : 1001</td>
<td>64.1.1.100 : 80</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>Once a connection is established, the timeout of the entry is set high (for example, five hours), because TCP connections can stay connected for an indefinite period of time without exchanging any packets.</p>
<p>If H2 attempts to connect to the same host simultaneously, it can share the public IP address assigned to HR. For example, H2 sends a connection request to IH addressed as follows:</p>
<p><strong>Packet 3</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 80</td>
<td>192.168.0.33 : 1024</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>HR would not find a NAT entry for 192.168.0.33:1024, so it would create one:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td>80</td>
<td>192.168.0.33</td>
<td>1024</td>
<td>50002</td>
<td>TCP</td>
<td>SYNSENT</td>
<td>00:01:00</td>
</tr>
<tr class="even">
<td>64.1.1.100</td>
<td>80</td>
<td>192.168.0.32</td>
<td>1001</td>
<td>50001</td>
<td>TCP</td>
<td>CONNECT</td>
<td>04:59:23</td>
</tr>
</tbody>
</table>
<p>The modified packet and its reply would proceed similar to packets 1 and 2. Packets that pass from the LAN to the WAN are searched based on <em>Local IP</em> combined with <em>Local Port</em>. Packets that pass from the WAN to the LAN are searched based on <em>Mapped Port</em>. Note that for all entries on the NAT entry table, these values are unique.</p>
<h3 id="b.1.3-nat-port-mapping">B.1.3 NAT Port Mapping</h3>
<p>So far, you have examined communication that has been initiated by hosts on the home LAN. Note that any unsolicited packets sent to HR from the WAN will not match any entry in the NAT table. These packets will be forwarded to the internal protocol stacks on HR, where they may or may not be used.</p>
<p>Now assume that a host on the home LAN (for example, H2) must place an HTTP server on the Internet. With what has been examined so far, it would be impossible to contact such a server from the WAN because no unsolicited traffic (like an HTTP connect request) can pass from the WAN to the LAN. However, H2 can acquire a portion of HRs WAN presence by mapping one of the well-known port values on the public WAN IP address to itself through port mapping.</p>
<p>In port mapping, a NAT entry is created to send all traffic destined for a specific port on the public IP address to an alternate destination. For well-known ports like HTTP, the port value is not usually altered. Only the destination IP address changes. In this case, port 80 (HTTP) on the public IP address is mapped to port 80 of the LAN host H2. The entry would look as follows:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wild</em></td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>80</td>
<td>80</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
</tbody>
</table>
<p>When a connection request arrives from a remote host for the public IP address assigned to HR, as with the basic NAT discussion of the previous section, the destination port of the packet is matched with the <em>Mapped Port</em> value of the NAT entry. Normally, the <em>Foreign IP</em> and <em>Port</em> of the NAT entry must also match for source IP and port of the packet, but here the values are <em>wild</em>. This is because when the entry is created, the foreign peer is unknown. Because, every TCP connection state must be tracked in its own NAT entry, a second entry must be spawned. Any match of a wild NAT entry will spawn a fully qualified entry. For example, assume the following packet arrives:</p>
<p><strong>Packet 4</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>128.1.2.12 : 80</td>
<td>64.1.1.100 : 2006</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>The resulting NAT entry table would be:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td>2006</td>
<td>192.168.0.32</td>
<td>80</td>
<td>80</td>
<td>TCP</td>
<td>SYNSENT</td>
<td>00:01:00</td>
</tr>
<tr class="even">
<td><em>wild</em></td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>80</td>
<td>80</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
</tbody>
</table>
<p>The packet sent to the LAN by HR would be:</p>
<p><strong>Packet 4 (modified)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.0.32 : 80</td>
<td>64.1.1.100 : 2006</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>Note that the wildcard entrys timeout is STATIC. This means that the entry will never expire. Note that when the new entry is spawned, it acquires a timeout.</p>
<p>One last point to note here is that the installation of a port map for port 80 does not prohibit HR from running its own HTTP server hosted on its private LAN IP address (192.168.0.1). This means that local hosts could get to a local HTTP server on 192.168.0.1, and the public HTTP server on 192.168.0.32, but outside hosts connecting to 128.1.2.12 could only get to the public HTTP server on 192.168.0.32.</p>
<p>For example, assume the same topology as before, with the HR running both and HTTP and Telnet servers, H1 running an HTTP server, and H2 running a Telnet server. This is illustrated in Figure B-2.</p>
<p><img src="data:image/gif;base64,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" title="Public Servers on the Home Network" alt="Figure B-2 Public Servers on the Home Network" /></p>
<p>To make the servers on H1 and H2 public, the following NAT port mapping entries are installed on HR:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wild</em></td>
<td><em>wild</em></td>
<td>192.168.0.33</td>
<td>23</td>
<td>23</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
<tr class="even">
<td><em>wild</em></td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>80</td>
<td>80</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
</tbody>
</table>
<p>With these mappings, the externally available HTTP server and Telnet server publicly accessible on the WAN IP (128.1.2.12) are actually executing on H1 and H2. However, HR can have its own HTTP and Telnet servers and make them available to hosts on the LAN.</p>
<p>Also note that, regardless of how hosts on the LAN access HR (either through 192.168.0.1 or 128.1.2.12), their packets are not processed via NAT. Thus, they are never altered. The following are some connection examples:</p>
<table>
<thead>
<tr class="header">
<th>Client</th>
<th>Protocol Used</th>
<th>Target Address</th>
<th>Resulting Server Connection</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IH</td>
<td>HTTP</td>
<td>128.1.2.12</td>
<td>HTTP on H1</td>
</tr>
<tr class="even">
<td>H2</td>
<td>HTTP</td>
<td>128.1.2.12</td>
<td>HTTP on HR</td>
</tr>
<tr class="odd">
<td>H2</td>
<td>HTTP</td>
<td>192.168.0.1</td>
<td>HTTP on HR</td>
</tr>
<tr class="even">
<td>H2</td>
<td>HTTP</td>
<td>192.168.0.32</td>
<td>HTTP on H1</td>
</tr>
<tr class="odd">
<td>IH</td>
<td>Telnet</td>
<td>128.1.2.12</td>
<td>Telnet on H2</td>
</tr>
<tr class="even">
<td>H1</td>
<td>Telnet</td>
<td>128.1.2.12</td>
<td>Telnet on HR</td>
</tr>
<tr class="odd">
<td>H1</td>
<td>Telnet</td>
<td>192.168.0.1</td>
<td>Telnet on HR</td>
</tr>
<tr class="even">
<td>H1</td>
<td>Telnet</td>
<td>192.168.0.33</td>
<td>Telnet on H2</td>
</tr>
</tbody>
</table>
<h3 id="b.1.4-nat-proxy-filters">B.1.4 NAT Proxy Filters</h3>
<h3 id="b.1.4.1-problem-synopsis">B.1.4.1 Problem Synopsis</h3>
<p>Translating the IP destination address of a packet via NAT guarantees that all packets can be redirected to their correct physical destination, but it does not guarantee that the information will be understood by the recipient. Because one side of the connection always believes they are actually connected to a different IP address than their physical peer, there is a possibility that the application using the information will become confused. The confusion arises when there is information in the packet payload that is dependent on the IP address/port of the peer connection.</p>
<h3 id="b.1.4.2-problem-example---ftp-clients-on-the-lan">B.1.4.2 Problem Example - FTP Clients on the LAN</h3>
<p>As a straightforward example of a situation that requires a proxy filter, consider FTP (file transfer protocol). FTP actually uses two ports to transmit a file. The first port establishes the control connection. Then, new ports establish the data connection to actually send the file. The FTP protocol allows an FTP client to specify its port for the data connection to the server. If no port is specified by the client, the clients control port value is used.</p>
<p>The above scenario presents a couple problems for standard NAT. First, if NAT creates an entry for the FTP control connection, the entry could not be used for the data connection. As an example, H1 sends an FTP connection request to IH. The packet would be addressed as follows:</p>
<p><strong>Packet 1</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 21</td>
<td>192.168.0.32 : 1137</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>HR would not find a NAT entry for 192.168.0.33:1137, so it would create one:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td>21</td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>SYNSENT</td>
<td>00:01:00</td>
</tr>
</tbody>
</table>
<p>The modified packet and its reply would proceed as discussed in <a href="#basic-nat">Section B.1.2</a>. The modified packet would be:</p>
<p><strong>Packet 1 (modified)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 21</td>
<td>128.1.2.12 : 50003</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>Now assume that eventually the FTP server on IH attempts to establish a data connection back to what it thinks is the FTP clients ephemeral port (50003). Note classic FTP uses port 20 to establish data connections. Its connection request packet would be:</p>
<p><strong>Packet 2 (Data connection request)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>128.1.2.12 : 50003</td>
<td>64.1.1.100 : 20</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<p>Because there is no NAT entry record that will match the address values in this packet (specifically port 20 in the <em>From</em> field), this packet will not be forwarded to the FTP client. For this to work, there must be a port mapping installed for 64.1.1.100 that has a wildcard port value (it is not certain that the connection request will arrive on port 20). The NAT entry table would be as follows:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
<tr class="even">
<td>64.1.1.100</td>
<td>21</td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>CONNECT</td>
<td>04:58:39</td>
</tr>
</tbody>
</table>
<p>With such a mapping, if a connection request from port 20 arrived, the wild card entry would be matched, and another entry spawned for port 20 on IH. The table would look as follows:</p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td>20</td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>SYNSENT</td>
<td>00:01:00</td>
</tr>
<tr class="even">
<td>64.1.1.100</td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
<tr class="odd">
<td>64.1.1.100</td>
<td>21</td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>CONNECT</td>
<td>04:58:39</td>
</tr>
</tbody>
</table>
<p>The second issue in dealing with an FTP client is that the client can change the port on which the FTP server attempts connection. This is done via a PORT command sent from the client to the server. The PORT command contains information about the client in the packet payload.</p>
<p>For example, assume the FTP client (H1) creates a new socket for the data connection, and its ephemeral port value is 1142. H1 would then send an FTP PORT command on the control connection to the server. The server would then attempt a connection. The following is an approximation of the operation (it is not the exact syntax of the port command).</p>
<p><strong>Packet 3 (FTP Client H1 Sends Port Command for Port 1142)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
<th>Packet Payload</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 21</td>
<td>192.168.0.32 : 1137</td>
<td>TCP</td>
<td>PORT 192.168.0.32, 1142</td>
</tr>
</tbody>
</table>
<p>As a reminder, the FTP server would normally see the packet as:</p>
<p><strong>Packet 3 (modified incorrectly)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
<th>Packet Payload</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 21</td>
<td>128.1.2.12 : 50003</td>
<td>TCP</td>
<td>PORT 192.168.0.32, 1142</td>
</tr>
</tbody>
</table>
<p>This packet creates a couple of problems. First, the IP address in the PORT command does not match the IP address of the FTP servers connected peer. This would produce an error. Plus, the IP address in the PORT command is not a real Internet address. Lastly, even if the FTP server tried to connect to 128.1.2.12:1142, there is no mapping for the port number in the NAT entry table.</p>
<p>The correct procedure for modifying this packet is to solve all the above problems. First, a new NAT entry is created for 192.168.0.32:1142. The foreign IP address is left as a wildcard because as before, because it is not certain what port the FTP server will use. The NAT entry table would then look as follows:</p>
<p><strong>NAT Entry Table</strong></p>
<table>
<thead>
<tr class="header">
<th>Foreign IP</th>
<th>Foreign Port</th>
<th>Local IP</th>
<th>Local Port</th>
<th>Mapped Port</th>
<th>IP Protocol</th>
<th>TCP State</th>
<th>Timeout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100</td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>1142</td>
<td>50004</td>
<td>TCP</td>
<td>-</td>
<td>00:02:00</td>
</tr>
<tr class="even">
<td>64.1.1.100</td>
<td><em>wild</em></td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>-</td>
<td>STATIC</td>
</tr>
<tr class="odd">
<td>64.1.1.100</td>
<td>21</td>
<td>192.168.0.32</td>
<td>1137</td>
<td>50003</td>
<td>TCP</td>
<td>CONNECT</td>
<td>04:58:39</td>
</tr>
</tbody>
</table>
<p>To review, note that you have the original NAT entry for the FTP control connection, and now two wildcard entries for possible FTP data connection requests.</p>
<p>The final step of the modification is to alter the payload of the packet so that the information in the PORT command matches the WAN IP address of HR (128.1.1.21) and the <em>Mapped Port</em> of the new NAT entry (50004). The correctly modified packet would be:</p>
<p><strong>Packet 3 (modified correctly)</strong></p>
<table>
<thead>
<tr class="header">
<th>To</th>
<th>From</th>
<th>Protocol</th>
<th>Packet Payload</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>64.1.1.100 : 21</td>
<td>128.1.2.12 : 50003</td>
<td>TCP</td>
<td>PORT 128.1.2.12, 50004</td>
</tr>
</tbody>
</table>
<p>It is also possible for a client to request the FTP server to create a new port (the PASV command), but that does not create any issues for FTP clients on the LAN. If the FTP server were on the LAN and the client on the WAN, the proxy process would key off the PASV command.</p>
<p><a name="ndk-support-for-proxy-filters"></a></p>
<h3 id="b.1.4.3-ndk-support-for-proxy-filters">B.1.4.3 NDK Support for Proxy Filters</h3>
<p>The modification procedure discussed above does have some multifaceted problems:</p>
<ol>
<li>The creation of the first data connection wildcard entry depends on the knowledge by some entity that an FTP control connection has occurred, and what IP/PORT the connection occurred on.</li>
<li>The creation of the second data connection wildcard entry depends on the detection of a PORT command being passed from the client to the server.</li>
<li>The modification of the data payload of the packet containing the PORT command requires that some entity is examining packet payloads.</li>
<li>Modification of a TCP packet payload can permanently alter the values of the TCP sequence and acknowledge fields in the TCP header of all future packets on the control connection.</li>
</ol>
<p>The first three problems are very specific to FTP, and the fourth problem (TCP sequence) is specific to any alteration of a TCP packet payload. Fortunately, the proxy filter support routines remove much of the burden of supporting these transformations.</p>
<p>The solution is twofold. First, the stack allows you to install proxy filter callback functions on specified TCP/UDP port values, either outgoing (for clients) or incoming (for servers). There are three callback functions involved.</p>
<p>The first callback function <em>Enable</em> is called when a new connection is attempted, or when the NAT entry expires. This function allows you to establish the basic connection state for the protocol in question. In the case of the FTP client example, the first wildcard data connection mapping would be installed here. Note that this function can also be used to filter connection requests. If this function returns zero, the connection request is ignored.</p>
<p>The second and third callback functions are mirrors of the other. They are the Tx and Rx functions. The Tx callback is called with the IP header of every packet that passes from the LAN to the WAN for the connection in question, while the Rx callback is called with the IP header of every packet that passes from the WAN to the LAN. While in these functions, the programmer can call a packet modify function to modify the payload of the packet. The system will automatically track and perform modifications to the TCP sequence values (when using TCP).</p>
<p>In the case of the FTP client, there would be no Rx callback because only packets from the client need to be examined. The Tx callback would look for PORT commands from the client, and when one was detected, it would install the second wildcard port mapping as discussed in the previous section, and then modify the packet payload so that the PORT command reflected the WAN IP of HR, and the Mapped Port of the NAT entry.</p>
<h3 id="b.1.4.4-ftp-proxy-filter-example-code">B.1.4.4 FTP Proxy Filter Example Code</h3>
<p>From the discussion in this section, it would be easy to draw the conclusion that developing proxy filter code would be horribly complicated. However, the actual implementation is straightforward. The code to implement the filter discussed in <a href="#ndk-support-for-proxy-filters">Section B.1.4.3</a> is shown below. The API for NAT and Proxy is discussed in the following sections.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// GetVal - Convert ASCII decimal string to integer</span>
<span class="co">//</span>
<span class="dt">static</span> <span class="dt">uint32_t</span> GetVal( <span class="dt">unsigned</span> <span class="dt">char</span> **pData )
{
    <span class="dt">uint32_t</span> v = <span class="dv">0</span>;
    <span class="cf">while</span>(**pData &amp;gt;= <span class="ch">'0'</span> &amp;amp;&amp;amp; **pData &amp;lt;= <span class="ch">'9'</span>)
        v = v*<span class="dv">10</span> + (*(*pData)++ - <span class="ch">'0'</span>);
    (*pData)++; <span class="cf">return</span>(v);
}

<span class="co">//</span>
<span class="co">// FTPCProxyEnable - Proxy for FTP Clients behind firewall</span>
<span class="co">//</span>
<span class="co">// </span><span class="al">NOTE</span><span class="co">: Proxy callback function operate at the kernel level. They</span>
<span class="co">// may not make calls to user-level functions.</span>
<span class="co">//</span>
<span class="dt">int</span> FTPCProxyEnable( NATINFO *pin, <span class="dt">uint32_t</span> Enable )
{
    <span class="dt">void</span> *hNat;

    <span class="co">// Some implementations of FTP require the host to listen for</span>
    <span class="co">// connections on the ephemeral port used to connect to the FTP</span>
    <span class="co">// server. We create a STATIC mapping to handle this.</span>
    <span class="cf">if</span>( Enable )
    {
        <span class="co">// Create it</span>
        hNat = NatNew( pNI-&amp;gt;IPLocal, pNI-&amp;gt;PortLocal, pNI-&amp;gt;IPForeign, <span class="dv">0</span>,
                       IPPROTO_TCP, pNI-&amp;gt;PortMapped, <span class="dv">0</span> );
        pNI-&amp;gt;pUserData = hNat;
    }
    <span class="cf">else</span>
    {
        <span class="co">// Destroy it</span>
        NatFree( pNI-&amp;gt;pUserData );
    }
    <span class="cf">return</span>(<span class="dv">1</span>);
}

<span class="co">//</span>
<span class="co">// FTPCProxyTx - Proxy for FTP Clients behind firewall</span>
<span class="co">//</span>
<span class="co">// </span><span class="al">NOTE</span><span class="co">: Proxy callback function operate at the kernel level. They</span>
<span class="co">// may not make calls to user-level functions.</span>
<span class="co">//</span>
<span class="dt">int</span> FTPCProxyTx( NATINFO *pNI, IPHDR *pIpHdr )
{
    <span class="dt">uint16_t</span>    Length, Offset;
    TCPHDR    *pTcpHdr;
    <span class="dt">unsigned</span> <span class="dt">char</span>     *pData;
    <span class="dt">void</span> *hNAT;
    NATINFO   *pNINew;
    <span class="dt">char</span>      tmpstr[<span class="dv">32</span>];
    <span class="dt">uint16_t</span>    PortNew;
    <span class="dt">uint32_t</span>       IPNew;

    pData = (<span class="dt">unsigned</span> <span class="dt">char</span>*)pIpHdr;

    <span class="co">// Get pointer to TCP header</span>
    Offset = (pIpHdr-&amp;gt;VerLen &amp;amp; <span class="bn">0xf</span>) * <span class="dv">4</span>;
    pTcpHdr = (TCPHDR *)(pData + Offset);

    <span class="co">// Get length of the IP payload</span>
    Length = HNC16(pIpHdr-&amp;gt;TotalLen) - Offset;

    <span class="co">// Get the offset into the TCP payload and payload size</span>
    Offset += pTcpHdr-&amp;gt;HdrLen &amp;gt;&amp;gt; <span class="dv">2</span>;
    Length -= pTcpHdr-&amp;gt;HdrLen &amp;gt;&amp;gt; <span class="dv">2</span>;

    <span class="co">// Get pointer to TCP payload</span>
    pData += Offset;

    <span class="co">//</span>
    <span class="co">// For clients, we only care about sending PORT commands</span>
    <span class="co">//</span>
    <span class="co">// For example, if our client IP is 192.138.139.32, and it reports</span>
    <span class="co">// port 384, the form of the command sent to the FTP server would</span>
    <span class="co">// be: &quot;PORT 192,138,139,32,1,128\r\n&quot;</span>
    <span class="co">//</span>
    <span class="co">// We replace the Client IP with the router's IP, and the client</span>
    <span class="co">// port with a NAT port which is mapped to the client port.</span>
    <span class="co">//</span>
    <span class="cf">if</span>(!strncmp( pData, <span class="st">&quot;PORT &quot;</span>, <span class="dv">5</span>) )
    {
        <span class="co">// Get the IP/Port declared by sender</span>
        <span class="co">// Form is &quot;i1,i2,i3,i4,p1,p2&quot;</span>
        pData += <span class="dv">5</span>;
        IPNew = ((<span class="dt">uint32_t</span>)GetVal (&amp;amp;pDada)) &amp;lt;&amp;lt; <span class="dv">24</span>;
        IPNew |= ((<span class="dt">uint32_t</span>)GetVal (&amp;amp;pDada)) &amp;lt;&amp;lt; <span class="dv">16</span>;
        IPNew |= ((<span class="dt">uint32_t</span>)GetVal (&amp;amp;pDada)) &amp;lt;&amp;lt; <span class="dv">8</span>;
        IPNew |= ((<span class="dt">uint32_t</span>)GetVal (&amp;amp;pData));
        IPNew = htonl(IPNew);
        PortNew = GetVal(&amp;amp;pData);
        PortNew = (PortNew&amp;lt;&amp;lt;<span class="dv">8</span>) + GetVal (&amp;amp;pData);

        <span class="co">// Add a NAT mapping to client's IP and Port</span>
        hNAT = NatNew(IPNew, PortNew, pNI-&amp;gt;IPForeign, <span class="dv">0</span>, IPPROTO_TCP,
                      <span class="dv">0</span>, NAT_IDLE_SECONDS);
        <span class="cf">if</span>(!hNAT)
            <span class="cf">return</span>(<span class="dv">0</span>);

        <span class="co">// Get Server IP and Mapped Port</span>
        IPNew = htonl( NatIpServer );
        pNINew = NatGetPNI( hNAT );
        PortNew = pNINew-&amp;gt;PortMapped;

        <span class="co">// Print a replacement string with IP and Port</span>
        sprintf(tmpstr, <span class="st">&quot;%u,%u,%u,%u,%u,%u</span><span class="sc">\r\n</span><span class="st">&quot;</span>,
                ((uint)(IPNew &amp;gt;&amp;gt; <span class="dv">24</span>)), ((uint)(IPNew &amp;gt;&amp;gt; <span class="dv">16</span>)&amp;amp;<span class="bn">0xFF</span>),
                ((uint)(IPNew &amp;gt;&amp;gt; <span class="dv">8</span>)&amp;amp;<span class="bn">0xFF</span>), ((uint)(IPNew)&amp;amp;<span class="bn">0xFF</span>),
                PortNew&amp;gt;&amp;gt;<span class="dv">8</span>, PortNew&amp;amp;<span class="bn">0xFF</span>);

        <span class="co">// Replace the original string with ours</span>
        ProxyPacketMod( Offset+<span class="dv">5</span>, Length-<span class="dv">5</span>, strlen(tmpstr), tmpstr );
    }
    <span class="cf">return</span>(<span class="dv">1</span>);
}</code></pre></div>
<h2 id="b.2-nat-port-mapping">B.2 NAT Port Mapping</h2>
<p>NAT port mapping allows a client machine on the LAN (or home network) to appear on a specific port of the routers public WAN IP address. This API (and NAT in general) is only used when the NDK is acting as an IP router, and when the IP network on one side of the router is using virtual IP addresses.</p>
<p>The functions described in this section illustrates how to install and remove port mappings. The functional operation of NAT and NAT Port Mapping is discussed in more detail in <a href="#nat-operation">Section B.1</a>.</p>
<h3 id="b.2.1-function-overview">B.2.1 Function Overview</h3>
<p>The following functions create and destroy port mappings:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NatNew()</td>
<td>Create a new NAT entry (for port mapping)</td>
</tr>
<tr class="even">
<td>NatFree()</td>
<td>Free a NAT entry</td>
</tr>
<tr class="odd">
<td>NatGetPNI()</td>
<td>Get a pointer to a NAT entrys NATINFO structure</td>
</tr>
</tbody>
</table>
<p><a name="nat-entry-information-structure"></a></p>
<h3 id="b.2.2-nat-entry-information-structure">B.2.2 NAT Entry Information Structure</h3>
<p>A port mapping is just a NAT entry. Each NAT entry has its own information structure. This NATINFO structure allows you to examine the status of a particular entry.</p>
<p>The specification of the NATINFO structure is as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> _natinfo {
        <span class="dt">uint32_t</span> TcpState;          <span class="co">// Current TCP State (Simplified)</span>
<span class="pp">#define NI_TCP_CLOSED  0            </span><span class="co">// Closed or closing</span>
<span class="pp">#define NI_TCP_SYNSENT 1            </span><span class="co">// Connecting</span>
<span class="pp">#define NI_TCP_ESTAB   2            </span><span class="co">// Established</span>
        <span class="dt">uint32_t</span>      IPLocal;      <span class="co">// Translated IP Address</span>
        <span class="dt">uint16_t</span>      PortLocal;    <span class="co">// Translated TCP/UDP Port</span>
        <span class="dt">uint32_t</span>      IPForeign;    <span class="co">// IP Address of Foreign Peer</span>
        <span class="dt">uint16_t</span>      PortForeign;  <span class="co">// Port of Foreign Peer</span>
        <span class="dt">unsigned</span> <span class="dt">char</span> Protocol;     <span class="co">// IP Protocol</span>
        <span class="dt">uint16_t</span>      PortMapped;   <span class="co">// Locally Mapped TCP/UDP Port (router)</span>
        <span class="dt">void</span>          *hProxyEntry; <span class="co">// Handle to Proxy Entry (if any)</span>
        <span class="dt">uint32_t</span>      Timeout;      <span class="co">// Expiration time in SECONDS</span>
        <span class="dt">void</span>          *pUserData;   <span class="co">// Pointer to proxy callback data</span>
} NATINFO;</code></pre></div>
<p>The individual fields are defined as follows:</p>
<ul>
<li><code>uint32_t TcpState;</code> This is a condensed version of the state of the TCP connection that is being translated by this entry. This field is only valid when the Protocol field is set to IPPROTO_TCP. The defined values are:
<ul>
<li>NI_TCP_CLOSED: The connection is closed</li>
<li>NI_TCP_SYNSENT: The peers are in the process of connecting</li>
<li>NI_TCP_ESTAB: A connection has been established</li>
</ul></li>
<li><code>uint32_t IPLocal;</code> This is the IP address (in network format) of the peer host on the local network (LAN). It is the entity that has been assigned a virtual IP address behind the firewall.</li>
<li><code>uint16_t PortLocal;</code> This is the port in use by the peer host on the local network (LAN). It is the entity that has been assigned a virtual IP address behind the firewall.</li>
<li><code>uint32_t IPForeign;</code> This is the IP address (in network format) of the peer host on the public network (WAN). It is the entity that is on the physical network outside the firewall.</li>
<li><code>uint16_t PortForeign;</code> This is the port in use by the peer host on the public network (WAN). It is the entity that is on the physical network outside the firewall.</li>
<li><code>unsigned char Protocol;</code> This is protocol in use by the NAT entry. It must be IPPROTO_TCP, IPPROTO_UDP, or IPPROTO_ICMP.</li>
<li><code>uint16_t PortMapped;</code> This is the port in use by the router on its public (WAN) IP address. It is this port that maps back to a specific local IP/port on the LAN.</li>
<li><code>void *hProxyEntry;</code> When a NAT entry is created as a result of a proxy filter being installed on a specific port, the pointer to the proxy filter that spawned the NAT entry is stored here.</li>
<li><code>uint32_t Timeout;</code> This is time in seconds when the proxy entry will expire. The system checks with a fairly large granularity, so the actual expiration can occur 10 to 20 seconds later. If this value is ZERO, the entry is static. A NAT entry must be specified as STATIC when it is created. Setting Timeout to ZERO will cause the entry to expire in 0 to 20 seconds.</li>
<li><code>void *pUserData;</code> This field is reserved for use by proxy filter callback functions. It is not used by the system software.</li>
</ul>
<p>The NAT information structure is of little importance when only port mapping is required. It is mostly for use in NAT proxy filters.</p>
<h3 id="b.2.3-nat-api-functions">B.2.3 NAT API Functions</h3>
<h4 id="natnew-create-a-nat-entry-for-port-mapping">NatNew  Create a NAT Entry (for Port Mapping)</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *NatNew( <span class="dt">uint32_t</span>      IPLocal,
              <span class="dt">uint16_t</span>      PortLocal,
              <span class="dt">uint32_t</span>      IPForeign,
              <span class="dt">uint16_t</span>      PortForeign,
              <span class="dt">unsigned</span> <span class="dt">char</span> Protocol,
              <span class="dt">uint16_t</span>      PortMapped,
              <span class="dt">uint32_t</span>      Timeout );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>IPLocal: IP address (in network format) of host on the LAN to map</li>
<li>PortLocal: TCP/UDP port value of host on the LAN to map</li>
<li>IPForeign: IP address of WAN peer (usually NULL/wild for port mappings)</li>
<li>PortForeign: TCP/UDP port of WAN peer (usually NULL/wild)</li>
<li>Protocol: IP protocol (IPPROTO_TCP or IPPROTO_UDP)</li>
<li>PortMapped: Port on routers public WAN to map (usually a well-known port)</li>
<li>Timeout: Timeout of entry in seconds (NULL for STATIC)</li>
</ul>
<p><strong>Return Value</strong> Handle to NAT entry, or NULL on error.</p>
<p><strong>Description</strong> This function creates a NAT entry with the parameters as specified.</p>
<p>For example, to allow a host on a virtual IP address of 1.2.3.4 to run a Telnet server reachable via the routers public (physical) IP address, a mapping would be installed to map TCP port 23 (telnet) to 1.2.3.4:23. If the connection were to be open to all foreign hosts, then <em>IPForeign</em> and <em>PortForeign</em> would be left NULL. The value of <em>Timeout</em> would also be NULL to make the entry STATIC.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">hNatTelnet = NatNew( htonl(<span class="bn">0x01020304</span>), <span class="dv">23</span>, <span class="dv">0</span>, <span class="dv">0</span>, IPPROTO_TCP, <span class="dv">23</span>, <span class="dv">0</span> );</code></pre></div>
<p>The function returns a handle to the NAT entry created. This handle should be freed with <em>NatFree()</em> when the mapping is no longer desired.</p>
<h4 id="natfree-destroy-a-nat-entry">NatFree  Destroy a NAT Entry</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> NatFree( <span class="dt">void</span> *hNat );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hNat: Handle to NAT entry created with <em>NatNew()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function frees the supplied NAT entry. It is called to remove a STATIC NAT entry that is no longer required.</p>
<h4 id="natgetpni-get-a-pointer-to-a-nat-entrys-natinfo-structure">NatGetPNI  Get a Pointer to a NAT Entrys NATINFO Structure</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">NATINFO NatGetPNI( <span class="dt">void</span> *hNat );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hNat: Handle to NAT entry created with <em>NatNew()</em></li>
</ul>
<p><strong>Return Value</strong> Pointer to NATINFO structure or NULL on error.</p>
<p><strong>Description</strong> This function returns a pointer to the NATINFO structure defined in <a href="#nat-entry-information-structure">Section B.2.2</a>. It is used mainly by NAT proxy filter callback functions.</p>
<h2 id="b.3-nat-proxy-filters">B.3 NAT Proxy Filters</h2>
<p>NAT proxy filters allow NAT to operate correctly with network protocols that have addressing specific data in their packet payload data. This API (and NAT in general) is only used when the NDK is acting as an IP router, and when the IP network on one side of the router is using virtual IP addresses.</p>
<p>The functions described in this section illustrate how to install and remove port proxy filters and their associated callback functions. The functional operation of NAT and NAT Port Mapping, and NAT Proxy is discussed in more detail in <a href="#nat-entry-information-structure">Section B.2.2</a>.</p>
<h3 id="b.3.1-function-overview">B.3.1 Function Overview</h3>
<p>The following functions create and destroy proxy filters:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ProxyNew()</td>
<td>Create Proxy Filter for NAT entries</td>
</tr>
<tr class="even">
<td>ProxyFree()</td>
<td>Destroy a Proxy Filter declaration</td>
</tr>
</tbody>
</table>
<p>The following function can be called from within a proxy filter callback function:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ProxyPacketMod()</td>
<td>Modify a packet being processed by NAT</td>
</tr>
</tbody>
</table>
<h3 id="b.3.2-nat-proxy-filter-callback-functions">B.3.2 NAT Proxy Filter Callback Functions</h3>
<p>The proxy filter callback functions allow the proxy programmer to examine NAT entry properties as the entries are created, plus the examination of packet data as packets pass between the LAN and WAN. This section describes the syntax of the callback functions that are supplied to the proxy filter when it is first installed in the system.</p>
<h4 id="proxyenablecallback-proxy-enable-callback-function">ProxyEnableCallback  Proxy Enable Callback Function</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> SampleProxyEnableCallback( NATINFO  *pNI,
                               <span class="dt">uint32_t</span> EnableFlag );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNI: Pointer to NATINFO structure of NAT entry created</li>
<li>EnableFlag: Set to 1 for an enable request</li>
</ul>
<p><strong>Return Value</strong> 1 to allow normal operation, or NULL to abort new NAT entry.</p>
<p><strong>Description</strong> This function is called when a NAT entry containing a proxy is created or destroyed. When the entry is created, the value of <em>EnableFlag</em> is 1. When the entry is being destroyed, the value of <em>EnableFlag</em> is zero.</p>
<p>When <em>EnableFlag</em> is set, the return value of this function determines if the NAT entry will be enabled. If this function returns NULL, the NAT entry is immediately destroyed (in this event, the callback is not called a second time for this destroy). This can be used to restrict peer connections.</p>
<h4 id="proxytxrxcallback-proxy-txrx-callback-functions">ProxyTx/RxCallback  Proxy Tx/Rx Callback Functions</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> SampleProxyTxCallback( NATINFO *pNI,
                           IPHDR   *pIpHdr );

<span class="dt">int</span> SampleProxyRxCallback( NATINFO *pNI,
                           IPHDR   *pIpHdr );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>pNI: Pointer to NATINFO structure of NAT entry in use</li>
<li>pIpHdr: Pointer to the IP header of the packet being translated</li>
</ul>
<p><strong>Return Value</strong> 1 to allow normal operation, or NULL to abort the supplied packet.</p>
<p><strong>Description</strong> This function is called when a packet is crossing the router from the WAN to the LAN (Rx callback) or from the LAN to the WAN (Tx callback). The NAT entry containing a proxy that matches the packet is described by the supplied NATINFO structure. This structure was described in <a href="#nat-entry-information-structure">Section B.2.2</a>.</p>
<p>The purpose of the callback is to examine the packet and take appropriate action based on its contents. The packet payload can be easily modified by the <em>ProxyPacketMod()</em> function described later in this section. The translation of the IP address and port information cannot be altered by this callback; however, the callback can act as a packet filter and discard unwanted packets by returning a value of NULL.</p>
<h3 id="b.3.3-nat-proxy-api-functions">B.3.3 NAT Proxy API Functions</h3>
<h4 id="proxynew-create-a-new-proxy-filter-for-nat-entries">ProxyNew  Create a New Proxy Filter for NAT Entries</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *ProxyNew( <span class="dt">uint32_t</span>      NatMode,
                <span class="dt">unsigned</span> <span class="dt">char</span> Protocol,
                <span class="dt">uint16_t</span>      Port,
                <span class="dt">uint32_t</span>      IPTarget,
                <span class="dt">int</span> (*pfnEnableCb)(NATINFO *, uint),
                <span class="dt">int</span> (*pfnTxCb)(NATINFO *, IPHDR *),
                <span class="dt">int</span> (*pfnRxCb)(NATINFO *, IPHDR *) );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>NatMode: Port direction to detect (NAT_MODE_RX or NAT_MODE_TX)</li>
<li>Protocol: Protocol to use (IPPROTO_TCP or IPPROTO_UDP)</li>
<li>Port: Port value for RX or TX packets to detect</li>
<li>IPTarget: New IP destination NAT_MODE_RX proxy</li>
<li>pfnEnableCb: Pointer to proxy <em>Enable</em> callback function (NULL if none)</li>
<li>pfnTxCb: Pointer to proxy Tx callback function (NULL if none)</li>
<li>pfnRxCb: Pointer to proxy Rx callback function (NULL if none)</li>
</ul>
<p><strong>Return Value</strong> Handle to new proxy, or NULL on error.</p>
<p><strong>Description</strong> This function creates a hook that is examined whenever a new NAT entry is created.</p>
<p>The calling parameter <em>NatMode</em> specifies the direction of the proxy (NAT_MODE_RX for servers behind the firewall, and NAT_MODE_TX for clients behind the firewall).</p>
<p>The <em>Protocol</em> and <em>Port</em> values are the IP protocol and well-known port of the protocol to proxy.</p>
<p>For example, if setting up a FTP client proxy, set:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">NatMode = NAT_MODE_TX
Protocol = IPPROTO_TCP
Port = <span class="dv">21</span></code></pre></div>
<p><em>IPTarget</em> is used only in server proxies (when <em>NatMode</em> is set to NAT_MODE_RX). This specifies the machine behind the firewall that is actually providing the service.</p>
<p>The three pointers to callback functions correspond to the proxy filter callback functions described in the previous section.</p>
<p>The function returns a handle to the new proxy. Note that a proxy handle is not the same as (or compatible with) a NAT entry handle.</p>
<p>The proxy should be destroyed by calling <em>ProxyFree()</em> when it is no longer needed.</p>
<h4 id="proxyfree-destroy-a-proxy-filter-declaration">ProxyFree  Destroy a Proxy Filter Declaration</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ProxyFree( <span class="dt">void</span> *hProxy );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hProxy: Handle to Proxy Filter entry created with <em>ProxyNew()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function frees the supplied Proxy Filter entry. It is called to remove an entry that is no longer required.</p>
<h4 id="proxypacketmod-modify-the-contents-of-a-packet">ProxyPacketMod  Modify the Contents of a Packet</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">IPHDR *ProxyPacketMod( <span class="dt">uint32_t</span>      Offset,
                       <span class="dt">uint32_t</span>      OldSize,
                       <span class="dt">uint32_t</span>      NewSize,
                       <span class="dt">unsigned</span> <span class="dt">char</span> *pNewData );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Offset: Offset in bytes from start of IP header to first modified byte</li>
<li>OldSize: Size of old data at <em>Offset</em></li>
<li>NewSize: Size of new data to replace old data at <em>Offset</em></li>
<li>pNewData: Pointer to new data to replace old data</li>
</ul>
<p><strong>Return Value</strong> Pointer to new IP header of packet. This pointer is used for further modifications (if needed).</p>
<p><strong>Description</strong> This function may only be called from a proxy filter callback function. Its purpose is to modify the contents of a TCP or UDP packet, and perform the necessary adjustments for packet size - including TCP sequencing adjustment.</p>
<p><a name="ApxC"></a></p>
<h1 id="c-point-to-point-protocol">C Point-to-Point Protocol</h1>
<p>Point to point protocol (PPP) was originally designed as a replacement for SLIP (serial line IP) in sending IP packets via a serial line. In addition to its massive popularity in performing this function, PPP has also been increasingly used for the transmission of packets over other media. This is due to PPPs inherent peer-to-peer nature, allowing for per-connection security and billing.</p>
<p>The NDK has built-in support for both PPP servers and clients. The PPP support API is designed to be shared by one or more physical devices. One obvious device that can be hooked to PPP is a serial line, but the stack also contains support for PPP over Ethernet (PPPoE). The low level PPP API as well as Serial HDLC and PPPoE are all discussed in this appendix.</p>
<h2 id="c.1-low-level-ppp-support">C.1 Low Level PPP Support</h2>
<p>This section describes the operation of the PPP support API included in the NDK.</p>
<blockquote>
<p><strong>NOTE:</strong> Unlike the HDLC and PPPoE APIs that are application callable, the low level PPP support API is designed to be called from the kernel layer only. You should be thoroughly familiar with the operation of the kernel and the <em>llEnter()</em>/<em>llExit()</em> functions before attempting to use the APIs described in this section.</p>
</blockquote>
<h3 id="c.1.1-ppp-operation">C.1.1 PPP Operation</h3>
<p>PPP is very much like Ethernet in that there is a defined packet format. The basic PPP packet is shown below. It consists of flag delimiters, address and control bytes, protocol field (similar to ether-type under Ethernet), and a two byte checksum.</p>
<p><em>Figure C-1 Standard PPP Frame Over Serial Line</em></p>
<table>
<thead>
<tr class="header">
<th>Flag (7E)</th>
<th>Addr (FF)</th>
<th>Control (03)</th>
<th>Protocol</th>
<th>Payload</th>
<th>CRC</th>
<th>Flag (7E)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1500</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>To abstract out the actual processing of the PPP data from the processing of the PPP frame encoding, the PPP support included in the NDK expects a smaller frame, consisting of the protocol and payload fields only. This format is shown in Figure C-2.</p>
<p><em>Figure C-2 PPP Frame Processed by PPP API</em></p>
<table>
<thead>
<tr class="header">
<th>Protocol</th>
<th>Payload</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>Size specified by layer 2 (about 1500)</td>
</tr>
</tbody>
</table>
<p>The abstraction of PPP from the layer 2 encoding allows PPP to be carried by a variety of physical devices. The programming interface to the PPP layer called by the application is actually exposed by the layer 2 encoder. This layer 2 encoder is referred to as a serial interface (SI), but does not have to be a serial port. This interoperation between PPP and the SI is shown in Figure C-3. The functions shown in the dotted rectangle are those provided by the serial interface software.</p>
<p><img src="data:image/gif;base64,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" title="Serial Interface (SI) Abstraction" alt="Figure C-3 Serial Interface (SI) Abstraction" /></p>
<p>As shown in Figure C-3, the SI interface has the responsibility of providing for connection control, a timer used by PPP for timeout, packet encoding and decoding, and a SI callback function for status messages and packet transmission. Note that the SI driver developer also defines the actual API used by the application software to establish and tear down PPP connection sessions. There is no specific requirements in specifying the session API for any particular PPP device, but the APIs defined for HDLC and PPPoE can be used as a guide.</p>
<h3 id="c.1.2-function-overview">C.1.2 Function Overview</h3>
<p>The SI interface module is charged with communicating with both the hardware and the application program, but the PPP packets themselves are processed via the PPP support functions in the stack. The PPP support software provides the following functions for use by the SI module:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pppNew()</code></td>
<td>Create a new PPP connection instance</td>
</tr>
<tr class="even">
<td><code>pppFree()</code></td>
<td>Destroy an existing PPP connection instance</td>
</tr>
<tr class="odd">
<td><code>pppTimer()</code></td>
<td>Inform PPP that a 1 second timer tick has expired</td>
</tr>
<tr class="even">
<td><code>pppInput()</code></td>
<td>Pass in a received PPP packet for processing</td>
</tr>
</tbody>
</table>
<p>The formal declaration of these functions appear later in this section (see <a href="#ppp-api-functions">Section C.1.6</a>).</p>
<blockquote>
<p><strong>NOTE:</strong> These functions can only be called in kernel mode. See <a href="#ApxA">Appendix A</a> for programming in kernel mode.</p>
</blockquote>
<h3 id="c.1.3-supported-protocols">C.1.3 Supported Protocols</h3>
<p>In keeping with trying to maintain a small footprint, the PPP software supports a subset of the general PPP protocols. The following are supported:</p>
<ul>
<li>Link Control Protocol (LCP)</li>
<li>Internet Protocol Control Protocol (IPCP)</li>
<li>Password Authentication Protocol (PAP)</li>
<li>Challenge Handshake Authentication Protocol (CHAP) using MD5</li>
<li>Internet Protocol (IP)</li>
</ul>
<p><a name="si-module-callback-function"></a></p>
<h3 id="c.1.4-si-module-callback-function">C.1.4 SI Module Callback Function</h3>
<p>The PPP support API is used for connection instance creation and destruction, and to pass received packets to the stack. To get information about PPP back from the stack, and to allow the stack to request the transmission of PPP packets, the SI module supplies a callback function. A pointer to this callback is passed to PPP as a parameter to <em>pppNew()</em>.</p>
<blockquote>
<p><strong>NOTE:</strong> This function is called in kernel mode. See <a href="#ApxA">Appendix A</a> for programming in kernel mode.</p>
</blockquote>
<h3 id="c.1.4.1-function-declaration">C.1.4.1 Function Declaration</h3>
<p>The SI callback function is provided in the SI code module using the following definition:</p>
<h4 id="sicontrol-notify-the-serial-interface-of-a-change-in-status-or-when-si-needs-to-transmit-a-packet">SIControl  Notify the Serial Interface of a Change in Status, or when SI Needs to Transmit a Packet</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> SIControl( <span class="dt">void</span>       *hSI,
                <span class="dt">uint32_t</span>   Message,
                <span class="dt">uint32_t</span>   Data,
                PBM_Handle hPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSI: Handle to SI private data</li>
<li>Message: Message code describing the PPP event</li>
<li>Data: Additional data concerning the message</li>
<li>hPkt: Handle to a PBM packet when Message is SI_MSG_SENDPACKET</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called when a PPP needs to notify the serial interface (SI) of a change in status, or when it needs SI to transmit a packet.</p>
<p>The <em>hSI</em> parameter is a handle (pointer to a void) that is originally passed to PPP via <em>pppNew()</em>. This value allows the SI module to know which of its own connection instances is in use. The PPP instance handle in use is not supplied, but rather should be obtained by reference from the supplied SI handle. If the programmer of the SI module does not wish to track handles, then this parameter may be NULL (always as originally supplied to <em>pppNew()</em>). This is NOT the handle to the PPP instance that is passed to other functions in the PPP API.</p>
<p>The purpose of the callback is determined by the value of the <em>Message</em> parameter. The following message values are defined for this parameter:</p>
<ul>
<li>SI_MSG_CALLSTATUS: PPP connection status has changed</li>
<li>SI_MSG_SENDPACKET: PPP is requesting a packet to be encoded and transmitted</li>
<li>SI_MSG_PEERCMAP: LCP has received the peers 32 bit asynchronous character map</li>
</ul>
<h3 id="c.1.4.2-si_msg_callstatus-message">C.1.4.2 SI_MSG_CALLSTATUS Message</h3>
<p>When this message value is set, the callback function was called by PPP to update the status of the connection instance. When the callback is called with this message, the value of <em>Data</em> contains additional information about the call. <em>Data</em> can be set to any of the following values:</p>
<ul>
<li>SI_CSTATUS_WAITING: Connection instance is idle</li>
<li>SI_CSTATUS_NEGOTIATE: Instance in LCP negotiation stage</li>
<li>SI_CSTATUS_AUTHORIZE: Instance in authorization stage</li>
<li>SI_CSTATUS_CONFIGURE: Instance in IP configuration stage</li>
<li>SI_CSTATUS_CONNECTED: Instance is fully connected and operational</li>
<li>SI_CSTATUS_DISCONNECT: Connection dropped</li>
<li>SI_CSTATUS_DISCONNECT_LCP: Connection dropped in LCP stage</li>
<li>SI_CSTATUS_DISCONNECT_AUTH: Connection dropped in authorization stage</li>
<li>SI_CSTATUS_DISCONNECT_IPCP: Connection dropped in IP configuration stage</li>
</ul>
<p>If <em>Data</em> is set to any of disconnect messages, <em>pppFree()</em> should be called to destroy the connection instance. For all other status values, no action is required.</p>
<blockquote>
<p><strong>NOTE:</strong> It is always safe to assume that when the value of Data &gt;= SI_CSTATUS_DISCONNECT, the message is some type of disconnect.</p>
</blockquote>
<h3 id="c.1.4.3-si_msg_-sendpacket-message">C.1.4.3 SI_MSG_ SENDPACKET Message</h3>
<p>When this message value is set, the callback function was called by PPP to transmit a packet. The <em>Data</em> parameter is set to the 16 bit PPP protocol of the packet, and the <em>hPkt</em> parameter contains a handle to a packet (PKT) object that contains the packet payload. It is the job of the SI callback function to encode the packet and transmit it on the physical hardware.</p>
<h3 id="c.1.4.4-si_msg_-peercmap-message">C.1.4.4 SI_MSG_ PEERCMAP Message</h3>
<p>Serial interfaces to PPP require a translation map for the first 32 character values. This map informs the packet encoded which characters must be escaped and which do not. The default value of the peer CMAP should be 0xffffffff, and updated only when this message is received. Whether or not PPP will attempt to exchange CMAP information with its peer, is determined by passing flags to <em>pppNew()</em> when the connection instance is created.</p>
<h3 id="c.1.4.5-example-callback-function-implementation">C.1.4.5 Example Callback Function Implementation</h3>
<p>The following is an example of a SI module callback function from the HDLC module code in the example applications. The code illustrates the basic processing that must be done for the various SI callback messages. The function calls made in this example are described in <a href="#ApxA">Appendix A</a>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//--------------------------------------------------------------------</span>
<span class="co">// SI Control Function</span>
<span class="co">//--------------------------------------------------------------------</span>
<span class="dt">void</span> hdlcSI( <span class="dt">void</span> *hSI, <span class="dt">uint32_t</span> Msg, <span class="dt">uint32_t</span> Aux, PBM_Handle hPkt )
{
    HDLC_INSTANCE  *pi = (HDLC_INSTANCE *)hSI;
    <span class="dt">void</span> *hTmp;
    <span class="dt">uint32_t</span> Offset,Size;
    <span class="dt">unsigned</span> <span class="dt">char</span>          *pBuf;

    <span class="cf">switch</span>(Msg)
    {
    <span class="cf">case</span> SI_MSG_CALLSTATUS:
        <span class="co">// Update Connection Status</span>
        pi-&gt;Status = (uint)Aux;
        <span class="cf">if</span>( Aux &gt;= SI_CSTATUS_DISCONNECT )
        {
            <span class="co">// Close PPP</span>
            <span class="cf">if</span>( pi-&gt;hPPP )
            {
                hTmp = pi-&gt;hPPP;
                pi-&gt;hPPP = <span class="dv">0</span>;
                pppFree( hTmp );
            }
        }
        <span class="cf">break</span>;

    <span class="cf">case</span> SI_MSG_PEERCMAP:
        <span class="co">// Update Out CMAP for Transmit</span>
        pi-&gt;cmap_out = Aux;
        llSerialHDLCPeerMap( pi-&gt;DevSerial, Aux );
        <span class="cf">break</span>;

    <span class="cf">case</span> SI_MSG_SENDPACKET:
        <span class="cf">if</span>( !hPkt )
        {
            DbgPrintf( DBG_ERROR,<span class="st">&quot;hdlcSI: No packet&quot;</span> );
            <span class="cf">break</span>;
        }

        Offset = PBM_getDataOffset( hPkt );
        Size = PBM_getValidLen( hPkt );

        <span class="co">// Make sure packet is valid, with room for protocol, room for checksum</span>
        <span class="cf">if</span>((Offset&lt;<span class="dv">4</span>) || ((Offset+Size+<span class="dv">2</span>)&gt;PBM_getBufferLen(hPkt)))
        {
            DbgPrintf( DBG_ERROR,<span class="st">&quot;hdlcSI: Bad packet&quot;</span> );
            PBM_free( hPkt );
            <span class="cf">break</span>;
        }

        <span class="co">// Add in 2 byte Protocol and 2 byte header. Also add in size for</span>
        <span class="co">// 2 byte checksum. Note that the outgoing checksum is corrected</span>
        <span class="co">// (calculated) by the serial driver.</span>
        Offset -= <span class="dv">4</span>;
        Size += <span class="dv">6</span>;
        PBM_setDataOffset(hPkt, Offset);
        PBM_setValidLen(hPkt, Size);
        pBuf = PBM_getDataBuffer(hPkt)+Offset;
        *pBuf++ = <span class="bn">0xFF</span>;
        *pBuf++ = <span class="bn">0x03</span>;
        *pBuf++ = (<span class="dt">unsigned</span> <span class="dt">char</span>)(Aux/<span class="dv">256</span>);
        *pBuf = (<span class="dt">unsigned</span> <span class="dt">char</span>)(Aux%<span class="dv">256</span>);

        <span class="co">// Send the buffer to the serial driver</span>
        llSerialSendPkt(pi-&gt;DevSerial, hPkt);
        <span class="cf">break</span>;
    }
}</code></pre></div>
<h3 id="c.1.5-tips-for-implementing-a-ppp-serial-interface-si-module-instance">C.1.5 Tips for Implementing a PPP Serial Interface (SI) Module Instance</h3>
<h3 id="c.1.5.1-multiple-instances">C.1.5.1 Multiple Instances</h3>
<p>PPP supports multiple instances, but the SI module implementation tracks multiple instances of itself. This is done in two ways. One method is for the SI module to have a locally global head pointer to its first instance, and an array or linked list for additional instances. Or, the instance can be bound to the next layer down. In the case of the HDLC module, one PPP instance is bound to one serial port driver instance. So the HDLC module does not need to track instances independently.</p>
<p>When a new PPP connection is established, a new SI module instance should be allocated and a handle to the new SI instance is passed to the <em>pppNew()</em> function. The handle that <em>pppNew()</em> returns must be associated with the handle to the SI instance. The PPP handle must be passed to all other PPP API functions, and PPP will pass back the SI instance handle to the SI callback function.</p>
<p>When new data arrives from the hardware, it is the responsibility of the SI module to associate that data with a specific SI instance. The SI instance can then be accessed to retrieve the handle to the PPP instance to use with any PPP function calls. In the case of HDLC, the SI instance is known because it is associated with a particular serial device instance.</p>
<h3 id="c.1.5.2-using-the-timer-object">C.1.5.2 Using the Timer Object</h3>
<p>PPP requires that its <em>pppTimer()</em> function be called once every second. This can be PRD driven if necessary, but the timer callback cannot be called from a PRD because it must be called from within kernel mode (an <em>llEnter()</em>/<em>llExit()</em>) pairing.</p>
<h3 id="c.1.5.3-registering-packet-padding-requirements">C.1.5.3 Registering Packet Padding Requirements</h3>
<p>Although a serial interface will probably not have any special requirements for packets from the stack, it must at least be able to construct valid packets to send to the <em>pppInput()</em> function. For a serial interface that does not use the packet buffer to physically send the packet, the size of the PPP header would be 4 bytes (2 byte HDLC header and 2 byte protocol field), and the padding would be 2 bytes (checksum).</p>
<p><a name="ppp-api-functions"></a></p>
<h3 id="c.1.6-ppp-api-functions">C.1.6 PPP API Functions</h3>
<p>The following is the full description of the PPP functions described in this section.</p>
<h4 id="pppnew-create-a-new-ppp-connection-instance">pppNew  Create a New PPP Connection Instance</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *pppNew( <span class="dt">void</span>     *hSI,
              <span class="dt">uint32_t</span> pppFlags,
              <span class="dt">uint32_t</span> mru,
              <span class="dt">uint32_t</span> IPServer,
              <span class="dt">uint32_t</span> IPMask,
              <span class="dt">uint32_t</span> IPClient,
              <span class="dt">char</span>     *Username,
              <span class="dt">char</span>     *Password,
              <span class="dt">uint32_t</span> cmap,
              <span class="dt">void</span> (*pfnSICtrl)(<span class="dt">void</span> *, uint, <span class="dt">uint32_t</span>, <span class="dt">void</span> *) );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hSI: Handle to SI module to be passed back to callback function</li>
<li>pppFlags: Connection option flags</li>
<li>mru: Maximum receive unit (maximum size of Payload)</li>
<li>IPServer: IP address of server in server mode (NULL in client mode)</li>
<li>IPMask: IP subnet mask of client in server mode (NULL in client mode)</li>
<li>IPClient: IP address of client in server mode (NULL in client mode)</li>
<li>Username: Pointer to username in client mode (NULL in server mode)</li>
<li>Password: Pointer to password in client mode (NULL in server mode)</li>
<li>cmap: 32-bit local CMAP to pass to peer</li>
<li>pfnSICtrl: Pointer to SI module callback function</li>
</ul>
<p><strong>Return Value</strong> Handle to new PPP connection instance, or NULL on error.</p>
<p><strong>Description</strong> This function is called to create a new PPP connection instance. The type of connection created is determined by the calling parameters.</p>
<ul>
<li><em>hSI</em> - This is a private handle created by the caller that points back to the callers instance data. It is passed back to the caller via the callback function pointed to by <em>pfnSICtrl</em>, and can be used to link back to callers instance data when the callback is executed.</li>
<li><em>pppFlags</em> - The flags determine what type of connection instance to create, and what type of options to support in the connection instance. In the <em>pppFlags</em> parameter, one and only one of the following flags must be set:
<ul>
<li>PPPFLG_SERVER: Create PPP server connection instance</li>
<li>PPPFLG_CLIENT: Create PPP client connection instance</li>
</ul>
When operating in SERVER mode, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_AUTH_PAP: Require PAP authentication</li>
<li>PPPFLG_OPT_AUTH_CHAP: Require CHAP authentication</li>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as server</li>
<li>PPPFLG_OPT_LOCALDNS: Claim Local IP as DNS server</li>
<li>PPPFLG_SIOPT_SENDCMAP: Send an async character map</li>
<li>PPPFLG_SIOPT_RECVCMAP: Accept an async character map</li>
<li>PPPFLG_CH1: Allow server channel/group 1 account users</li>
<li>PPPFLG_CH2: Allow server channel/group 2 account users</li>
<li>PPPFLG_CH3: Allow server channel/group 3 account users</li>
<li>PPPFLG_CH4: Allow server channel/group 4 account users</li>
<li>PPPFLG_OPT_ALLOW_IP: Allow client to declare its own IP address</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul>
When operating in CLIENT mode, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as client</li>
<li>PPPFLG_OPT_CLIENT_P2P: Treat the connection as a pure peer to peer (i.e., do not create a default route using the peer as a gateway)</li>
<li>PPPFLG_SIOPT_SENDCMAP: Send an async character map</li>
<li>PPPFLG_SIOPT_RECVCMAP: Accept an async character map</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul></li>
<li><em>mru</em> - The MRU is maximum receive unit, or the maximum size of the payload portion of a PPP packet. For a standard serial link, the MRU is typically 1500, but can be smaller.</li>
<li><em>IPServer</em> - When creating the PPP instance in SERVER mode, this is the IP address in network format of the NDK reported to the peer. When operating in CLIENT mode, this value is NULL.</li>
<li><em>IPMask</em> - When creating the PPP instance in SERVER mode, this is the IP subnet mask of the peers IP network reported to the peer. When operating in CLIENT mode, this value is NULL.</li>
<li><em>IPClient</em> - When creating the PPP instance in SERVER mode, this is the IP address in network format of the peer reported to the peer. When operating in CLIENT mode, this value is NULL.</li>
<li><em>Username</em> - When creating the PPP instance in CLIENT mode, this is a pointer to a NULL terminated string containing the username to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN. When operating in SERVER mode, this value is NULL.</li>
<li><em>Password</em> - When creating the PPP instance in CLIENT mode, this is a pointer to a NULL terminated string containing the password to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN. When operating in SERVER mode, this value is NULL.</li>
<li><em>cmap</em> - When the PPPFLG_SIOPT_SENDCMAP flag is set in the pppFlags parameter, this is the CMAP value that is sent to the peer; otherwise it is NULL.</li>
<li><em>pfnSICtrl</em> - This is a required pointer to the callers callback function to handle status updates from the stack, and requests to transmit PPP packets. See <a href="#si-module-callback-function">Section C.1.4</a> for more detail.</li>
</ul>
<p>When run in SERVER mode, the name of the PPP server defaults to DSPIP in CHAP authentication; however, this can be changed by using the CFGITEM_SYSINFO_REALMPPP configuration tag. For example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">&gt;<span class="co">// Name our authentication group for PPP (Max size = 31)</span>
<span class="co">// This is the authentication &quot;realm&quot; name returned by the PPP</span>
<span class="co">// server when authentication is required.</span>
<span class="co">// (Note the length &quot;16&quot; includes the NULL terminator)</span>

CfgAddEntry( hCfg, CFGTAG_SYSINFO, CFGITEM_SYSINFO_REALMPPP,
    <span class="dv">0</span>, <span class="dv">16</span>, (<span class="dt">unsigned</span> <span class="dt">char</span> *)<span class="st">&quot;PPP_SAMPLE_NAME&quot;</span>, <span class="dv">0</span> );</code></pre></div>
<p>When successful, this function returns a handle to a new PPP instance. This handle is used by the caller when calling other functions in the PPP API.</p>
<h4 id="pppfree-destroy-ppp-connection-instance">pppFree  Destroy PPP Connection Instance</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> pppFree( <span class="dt">void</span> *hPPP );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPP: Handle to PPP instance created with pppNew()</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to close and destroy a PPP connection instance created with <em>pppNew()</em>. This function must be called to free the PPP handle, even if the PPP connection itself is already disconnected.</p>
<h4 id="pppinput-send-a-ppp-packet-to-ppp-for-processing">pppInput  Send a PPP Packet to PPP for Processing</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> pppInput( <span class="dt">void</span>    *hPPP,
               PBM_Pkt *pPkt );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPP: Handle to PPP instance created with <em>pppNew()</em></li>
<li>pPkt: Pointer to a PBM packet</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called when a PPP packet is received on an active serial interface. The packet is data decoded into the PPP protocol and payload fields, and given to PPP as a packet object. The handle <em>hPPP</em> is the PPP connection instance returned from <em>pppNew()</em> for this connection, and <em>pPkt</em> is a packet object created by the packet buffer manager (PBM).</p>
<h4 id="ppptimer-notify-ppp-of-one-second-tick">pppTimer  Notify PPP of One Second Tick</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> pppTimer( <span class="dt">void</span> *hPPP );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPP: Handle to PPP instance created with <em>pppNew()</em></li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called on an active PPP instance to notify PPP that one second has elapsed. Because the PPP API is entirely stateless, it relies on the serial interface for time tick notification.</p>
<h2 id="c.2-serial-hdlc-client-and-server-support">C.2 Serial HDLC Client and Server Support</h2>
<p>This implementation of HDLC for the NDK library is included in the example applications. It interfaces to the serial port driver described in the HAL.</p>
<blockquote>
<p><strong>NOTE:</strong> The HDLC API is user-callable. Unlike the low level PPP support API, you should <em>not</em> use the <em>llEnter()</em>/<em>llExit()</em> functions when calling the functions described in this section.</p>
</blockquote>
<h3 id="c.2.1-function-overview">C.2.1 Function Overview</h3>
<p><strong>Called by Application:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>hdlcNew()</td>
<td>Create a Serial HDLC Client Session</td>
</tr>
<tr class="even">
<td>hdlcFree()</td>
<td>Destroy a Serial HDLC Client Session</td>
</tr>
<tr class="odd">
<td>hdlcGetStatus()</td>
<td>Get the Call Status of a Serial HDLC Client Session</td>
</tr>
<tr class="even">
<td>hdlcsNew()</td>
<td>Create a Serial HDLC Server Session</td>
</tr>
<tr class="odd">
<td>hdlcsFree()</td>
<td>Destroy a Serial HDLC Server Session</td>
</tr>
<tr class="even">
<td>hdlcsGetStatus()</td>
<td>Get the Call Status of a Server HDLC Client Session</td>
</tr>
</tbody>
</table>
<p><strong>Called by Serial Port Driver:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>hdlcInput()</td>
<td>Send HDLC input buffer for processing</td>
</tr>
</tbody>
</table>
<h3 id="c.2.2-hdlc-api-functions">C.2.2 HDLC API Functions</h3>
<h4 id="hdlcnew-create-a-serial-hdlc-client-session">hdlcNew  Create a Serial HDLC Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *hdlcNew( <span class="dt">uint32_t</span> Dev,
               <span class="dt">uint32_t</span> pppFlags,
               <span class="dt">uint32_t</span> cmap,
               <span class="dt">char</span>     *Username,
               <span class="dt">char</span>     *Password );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Dev: Physical index of serial port to use</li>
<li>pppFlags: Connection option flags</li>
<li>cmap: Async control character map</li>
<li>Username: Pointer to client account username</li>
<li>Password: Pointer to client account password</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a handle to a HDLC client instance. Otherwise, it returns NULL.</p>
<p><strong>Description</strong> This function is called to create a new serial HDLC client instance on the physical serial interface specified by the index <em>Dev</em>.</p>
<ul>
<li><em>pppFlags</em> - The flags determine what type of connection instance to create, and what type of options to support in the connection instance. In the <em>pppFlags</em> parameter, the following flag must be set:
<ul>
<li>PPPFLG_CLIENT: Create PPP client connection instance</li>
</ul>
In addition, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as client</li>
<li>PPPFLG_OPT_CLIENT_P2P: Treat the connection as a pure peer to peer (i.e., dont create a default route using the peer as a gateway).</li>
<li>PPPFLG_SIOPT_SENDCMAP: Send an async character map (strongly recommended)</li>
<li>PPPFLG_SIOPT_RECVCMAP: Accept an async character map (strongly recommended)</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul></li>
<li><em>cmap</em> - This is the desired value of the async character control map that is sent to the peer to allow frame compression by skipping the escape coding of characters when it is not required. The mask contains a set bit for each character (0 to 31) that <em>must</em> be escaped when sent by the peer. If the PPPFLG_SIOPT_SENDCMAP option is not set, it is assumed that all 32 characters must be sent via the escape sequence.</li>
<li><em>Username</em> - This is a pointer to a NULL terminated string containing the username to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN.</li>
<li><em>Password</em> - This is a pointer to a NULL terminated string containing the password to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN.</li>
</ul>
<p>When successful, this function returns a handle to a new serial HDLC instance. The current status of the connection can be queried at any time by calling <em>hdlcGetStatus()</em>.</p>
<h4 id="hdlcfree-destroy-a-serial-hdlc-client-session">hdlcFree  Destroy a Serial HDLC Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> hdlcFree( <span class="dt">void</span> *hHDLC );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hHDLC: Handle to HDLC Client Session</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to close and destroy a serial HDLC client session that was created with <em>hdlcNew()</em>. This function is always called once for every HDLC instance handle. If the connection is no longer active, it frees the instance memory. If the connection is still active, it disconnects the call first.</p>
<h4 id="hdlcgetstatus-get-the-status-of-a-serial-hdlc-client-session">hdlcGetStatus  Get the Status of a Serial HDLC Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> hdlcGetStatus( <span class="dt">void</span> *hHDLC );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hHDLC: Handle to HDLC Client Session</li>
</ul>
<p><strong>Return Value</strong> This function returns a uint32_t that will be set to one of the following values:</p>
<ul>
<li>SI_CSTATUS_WAITING: Connection is idle (HDLC session opening)</li>
<li>SI_CSTATUS_NEGOTIATE: Connection in LCP negotiation stage</li>
<li>SI_CSTATUS_AUTHORIZE: Connection in authorization stage</li>
<li>SI_CSTATUS_CONFIGURE: Connection in IP configuration stage</li>
<li>SI_CSTATUS_CONNECTED: Connection is fully connected and operational</li>
<li>SI_CSTATUS_DISCONNECT: Connection dropped</li>
<li>SI_CSTATUS_DISCONNECT_LCP: Connection dropped in LCP stage</li>
<li>SI_CSTATUS_DISCONNECT_AUTH: Connection dropped in authorization stage</li>
<li>SI_CSTATUS_DISCONNECT_IPCP: Connection dropped in IP configuration stage</li>
</ul>
<p><strong>Description</strong> This function is called to get the connection status of a serial HDLC client session using the HDLC instance handle returned from <em>hdlcNew()</em>. This function can be called any time after the handle is created with <em>hdlcNew()</em>, and before it is destroyed with <em>hdlcFree()</em>.</p>
<h4 id="hdlcsnew-create-a-serial-hdlc-server-session">hdlcsNew  Create a Serial HDLC Server Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *hdlcsNew( <span class="dt">uint32_t</span> Dev,
                <span class="dt">uint32_t</span> pppFlags,
                <span class="dt">uint32_t</span> cmap,
                <span class="dt">uint32_t</span> IPServer,
                <span class="dt">uint32_t</span> IPMask,
                <span class="dt">uint32_t</span> IPClient );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>Dev: Physical index of serial port to use</li>
<li>pppFlags: Connection option flags</li>
<li>cmap: Async control character map</li>
<li>IPServer: IP address of server in network format</li>
<li>IPMask: IP subnet mask in network format of the peers network</li>
<li>IPClient: IP address in network format of the client</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a handle to a serial HDLC server instance. Otherwise, it returns NULL.</p>
<p><strong>Description</strong> This function is called to create a new serial HDLC server instance on the physical serial interface specified by the index <em>Dev</em>.</p>
<ul>
<li><em>pppFlags</em> - The flags determine what type of connection instance to create, and what type of options to support in the connection instance. In the <em>pppFlags</em> parameter, the following flag must be set:
<ul>
<li>PPPFLG_SERVER: Create PPP server connection instance</li>
</ul>
In addition, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_AUTH_PAP: Require PAP authentication</li>
<li>PPPFLG_OPT_AUTH_CHAP: Require CHAP authentication (PAP is fallback when specified)</li>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as server</li>
<li>PPPFLG_SIOPT_SENDCMAP: Send an async character map (<em>strongly</em> recommended)</li>
<li>PPPFLG_SIOPT_RECVCMAP: Accept an async character map (<em>strongly</em> recommended)</li>
<li>PPPFLG_CH1: Allow server channel/group 1 account users</li>
<li>PPPFLG_CH2: Allow server channel/group 2 account users</li>
<li>PPPFLG_CH3: Allow server channel/group 3 account users</li>
<li>PPPFLG_CH4: Allow server channel/group 4 account users</li>
<li>PPPFLG_OPT_ALLOW_IP: Allow client to declare its own IP address</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul></li>
<li><em>cmap</em> - This is the desired value of the async character control map that is sent to the peer to allow frame compression by skipping the escape coding of characters when it is not required. The mask contains a set bit for each character (0 to 31) that <em>must</em> be escaped when sent by the peer. If the PPPFLG_SIOPT_SENDCMAP option is not set, it is assumed that all 32 characters must be sent via the escape sequence.</li>
<li><em>IPServer</em> - This is the IP address in network format of the NDK reported to the peer.</li>
<li><em>IPMask</em> - This is the IP subnet mask of the peers IP network reported to the peer.</li>
<li><em>IPClient</em> - This is the IP base address in network format of the IP address to be assigned to the client.</li>
</ul>
<p>When successful, this function returns a handle to a new serial HDLC server instance. The current status of the connection can be queried at any time by calling <em>hdlcsGetStatus()</em>.</p>
<p>The name of the PPP server defaults to DSPIP in CHAP authentication; however, this can be changed by using the CFGITEM_SYSINFO_REALMPPP configuration tag. For example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Name our authentication group for PPP (Max size = 31)</span>
<span class="co">// This is the authentication &quot;realm&quot; name returned by the PPP</span>
<span class="co">// server when authentication is required.</span>
<span class="co">// (Note the length &quot;16&quot; includes the NULL terminator)</span>

CfgAddEntry( hCfg, CFGTAG_SYSINFO, CFGITEM_SYSINFO_REALMPPP,
             <span class="dv">0</span>, <span class="dv">16</span>, (<span class="dt">unsigned</span> <span class="dt">char</span> *)<span class="st">&quot;PPP_SAMPLE_NAME&quot;</span>, <span class="dv">0</span> );</code></pre></div>
<h4 id="hdlcsfree-destroy-a-serial-hdlc-server-session">hdlcsFree  Destroy a Serial HDLC Server Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> hdlcsFree( <span class="dt">void</span> *hHDLC );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hHDLC: Handle to HDLC Server Session</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to close and destroy a serial HDLC server session that was created with <em>hdlcsNew()</em>. This function is always called once for every HDLC instance handle. If the connection is no longer active, it frees the instance memory. If the connection is still active, it disconnects the call first.</p>
<h4 id="hdlcsgetstatus-get-the-status-of-a-serial-hdlc-server-session">hdlcsGetStatus  Get the Status of a Serial HDLC Server Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> hdlcsGetStatus( <span class="dt">void</span> *hHDLC );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hHDLC: HDLC Server Session</li>
</ul>
<p><strong>Return Value</strong> This function returns a uint32_t that will be set to one of the following values:</p>
<ul>
<li>SI_CSTATUS_WAITING: Connection is idle (PPPoE session opening)</li>
<li>SI_CSTATUS_NEGOTIATE: Connection in LCP negotiation stage</li>
<li>SI_CSTATUS_AUTHORIZE: Connection in authorization stage</li>
<li>SI_CSTATUS_CONFIGURE: Connection in IP configuration stage</li>
<li>SI_CSTATUS_CONNECTED: Connection is fully connected and operational</li>
<li>SI_CSTATUS_DISCONNECT: Connection dropped</li>
<li>SI_CSTATUS_DISCONNECT_LCP: Connection dropped in LCP stage</li>
<li>SI_CSTATUS_DISCONNECT_AUTH: Connection dropped in authorization stage</li>
<li>SI_CSTATUS_DISCONNECT_IPCP: Connection dropped in IP configuration stage</li>
</ul>
<p><strong>Description</strong> This function is called to get the connection status of a serial HDLC server session using the HDLC instance handle returned from <em>hdlcsNew()</em>. This function can be called any time after the handle is created with <em>hdlcsNew()</em>, and before it is destroyed with <em>hdlcsFree()</em>.</p>
<h2 id="c.3-pppoe-client-and-server-support">C.3 PPPoE Client and Server Support</h2>
<p>The PPPoE (PPP over Ethernet) specification allows for PPP packets to be transmitted in a peer to peer method over an Ethernet tunnel. The standard has gained in popularity because it allows for the use of multiple user accounts on a single Ethernet network.</p>
<p>The implementation of PPPoE supplied in the NDK library is built into the stack library code, and linked to the Ether object that handles packets from all Ethernet devices in the HAL layer. Thus, is it not necessary to access or alter the HAL to use PPPoE.</p>
<p>The software can be used as a PPP server or PPP client, but not both simultaneously. In both cases, PPPoE uses the PPP programming interfaces described earlier in this section. Thus, for server mode, the PPP server will use the same user account information as a serial based server.</p>
<blockquote>
<p><strong>NOTE:</strong> The PPPoE API is user callable. Unlike the low level PPP support API, you should <em>not</em> use the <em>llEnter()</em>/<em>llExit()</em> functions when calling the functions described in this section.</p>
</blockquote>
<h3 id="c.3.1-function-overview">C.3.1 Function Overview</h3>
<p>The PPPoE function API is short:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pppoeNew()</td>
<td>Create a PPPoE Client Session</td>
</tr>
<tr class="even">
<td>pppoeFree()</td>
<td>Destroy a PPPoE Client Session</td>
</tr>
<tr class="odd">
<td>pppoeGetStatus()</td>
<td>Get the Call Status of a PPPoE Client Session</td>
</tr>
<tr class="even">
<td>pppoesNew()</td>
<td>Create a PPPoE Server Session</td>
</tr>
<tr class="odd">
<td>pppoesFree()</td>
<td>Terminate a PPPoE Server Session</td>
</tr>
</tbody>
</table>
<h3 id="c.3.2-pppoe-api-functions">C.3.2 PPPoE API Functions</h3>
<h4 id="pppoenew-create-a-pppoe-client-session">pppoeNew  Create a PPPoE Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *pppoeNew( <span class="dt">void</span>     *hEther,
                <span class="dt">uint32_t</span> pppFlags,
                <span class="dt">char</span>     *Username,
                <span class="dt">char</span>     *Password );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hEther: Handle to Ether device on which to look for a PPPoE server</li>
<li>pppFlags: Connection option flags</li>
<li>Username: Pointer to client account username</li>
<li>Password: Pointer to client account password</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a handle to a PPPoE client instance. Otherwise, it returns NULL.</p>
<p><strong>Description</strong> This function is called to create a new PPPoE client instance on the Ether type interface specified by the handle <em>hEther</em>.</p>
<ul>
<li><em>pppFlags</em> - The flags determine what type of connection instance to create, and what type of options to support in the connection instance. In the <em>pppFlags</em> parameter, the following flag must be set:
<ul>
<li>PPPFLG_CLIENT: Create PPP client connection instance</li>
</ul>
In addition, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as client</li>
<li>PPPFLG_OPT_CLIENT_P2P: Treat the connection as a pure peer to peer (i.e., do not create a default route using the peer as a gateway)</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul></li>
<li><em>Username</em> - This is a pointer to a NULL terminated string containing the username to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN.</li>
<li><em>Password</em> - This is a pointer to a NULL terminated string containing the password to use in PAP or CHAP authentication. The maximum string length is defined by PPPNAMELEN.</li>
</ul>
<p>When successful, this function returns a handle to a new PPPoE instance The current status of the PPPoE connection can be queried at any time by calling <em>pppoeGetStatus()</em>.</p>
<h4 id="pppoefree-destroy-a-pppoe-client-session">pppoeFree  Destroy a PPPoE Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> pppoeFree( <span class="dt">void</span> *hPPPOE );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPPOE: Handle to PPPoE Client Session</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to close and destroy a PPPoE client session that was created with <em>pppoeNew()</em>. This function is always called once for every PPPoE instance handle. If the connection is no longer active, it frees the instance memory. If the connection is still active, it first disconnects the call.</p>
<h4 id="pppoegetstatus-get-the-status-of-a-pppoe-client-session">pppoeGetStatus  Get the Status of a PPPoE Client Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> pppoeGetStatus( <span class="dt">void</span> *hPPPOE );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPPOE: Handle to PPPoE Client Session</li>
</ul>
<p><strong>Return Value</strong> This function returns a uint32_t that will be set to one of the following values:</p>
<ul>
<li>SI_CSTATUS_WAITING: Connection is idle (PPPoE session opening)</li>
<li>SI_CSTATUS_NEGOTIATE: Connection in LCP negotiation stage</li>
<li>SI_CSTATUS_AUTHORIZE: Connection in authorization stage</li>
<li>SI_CSTATUS_CONFIGURE: Connection in IP configuration stage</li>
<li>SI_CSTATUS_CONNECTED: Connection is fully connected and operational</li>
<li>SI_CSTATUS_DISCONNECT: Connection dropped</li>
<li>SI_CSTATUS_DISCONNECT_LCP: Connection dropped in LCP stage</li>
<li>SI_CSTATUS_DISCONNECT_AUTH: Connection dropped in authorization stage</li>
<li>SI_CSTATUS_DISCONNECT_IPCP: Connection dropped in IP configuration stage</li>
</ul>
<p><strong>Description</strong> This function is called to get the connection status of a PPPoE client session using the PPPoE instance handle returned from <em>pppoeNew()</em>. This function can be called any time after the handle is created with <em>pppoeNew()</em>, and before it is destroyed with <em>pppoeFree()</em>.</p>
<h4 id="pppoesnew-create-a-pppoe-server-session">pppoesNew  Create a PPPoE Server Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *pppoesNew( <span class="dt">void</span>     *hEther,
                 <span class="dt">uint32_t</span> pppFlags,
                 <span class="dt">uint32_t</span> SessionMax,
                 <span class="dt">uint32_t</span> IPServer,
                 <span class="dt">uint32_t</span> IPMask,
                 <span class="dt">uint32_t</span> IPClientBase,
                 <span class="dt">char</span>     *ServerName,
                 <span class="dt">char</span>     *ServiceName );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hEther: Handle to Ether device on which to invoke the PPPoE server</li>
<li>pppFlags: Connection option flags</li>
<li>SessionMax: Maximum number of client connections allowed</li>
<li>IPServer: IP address of server in network format</li>
<li>IPMask: IP subnet mask in network format of the client address pool</li>
<li>IPClientBase: IP base address in network format of the client address pool</li>
<li>ServerName: Server name reported via PPPoE protocol</li>
<li>ServiceName: Service name reported via PPPoE protocol</li>
</ul>
<p><strong>Return Value</strong> If it succeeds, the function returns a handle to a PPPoE server instance. Otherwise, it returns NULL.</p>
<p><strong>Description</strong> This function is called to create a new PPPoE server instance on the Ether type interface specified by the handle <em>hEther</em>.</p>
<ul>
<li><em>SessionMax</em> - This value is the maximum number of simultaneous peer connections to be allowed at any given time. Thus, it is also the minimum size of the client IP address pool.</li>
<li><em>pppFlags</em> - The flags determine what type of connection instance to create, and what type of options to support in the connection instance. In the <em>pppFlags</em> parameter, the following flag must be set:
<ul>
<li>PPPFLG_SERVER: Create PPP server connection instance</li>
</ul>
In addition, any of the following flags can also be set:
<ul>
<li>PPPFLG_OPT_AUTH_PAP: Require PAP authentication</li>
<li>PPPFLG_OPT_AUTH_CHAP: Require CHAP authentication</li>
<li>PPPFLG_OPT_USE_MSE: Use MS extensions as server</li>
<li>PPPFLG_OPT_LOCALDNS: Claim Local IP as DNS server</li>
<li>PPPFLG_CH1: Allow server channel/group 1 account users</li>
<li>PPPFLG_CH2: Allow server channel/group 2 account users</li>
<li>PPPFLG_CH3: Allow server channel/group 3 account users</li>
<li>PPPFLG_CH4: Allow server channel/group 4 account users</li>
<li>PPPFLG_OPT_ALLOW_IP: Allow client to declare its own IP address</li>
<li>PPPFLG_OPT_ALLOW_HC: Allow peer to negotiate PFC/ACFP</li>
</ul></li>
<li><em>IPServer</em> - This is the IP address in network format of the NDK reported to the peer.</li>
<li><em>IPMask</em> - This is the IP subnet mask of the peers IP network reported to the peer.</li>
<li><em>IPClientBase</em> - This is the IP base address in network format of the IP address pool to be assigned to and reported to peer connections. The size of the address pool is determined by the value of SessionMax.</li>
<li><em>ServerName</em> - This is a required pointer to a NULL terminated string containing the server name that is reported to PPPoE clients. The maximum length of this name including the NULL terminator is defined by PPPOE_NAMESIZE. If a longer name is supplied, this function will fail.</li>
<li><em>ServiceName</em> - This is a required pointer to a NULL terminated string containing the service name that is reported to PPPoE clients. The maximum length of this name, including the NULL terminator, is defined by PPPOE_NAMESIZE. If a longer name is supplied, this function will fail.</li>
</ul>
<p>The name of the PPP server defaults to DSPIP in CHAP authentication. This is independent of the PPPoE server name. However, the name can be changed by using the CFGITEM_SYSINFO_REALMPPP configuration tag. For example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Name our authentication group for PPP (Max size = 31)</span>
<span class="co">// This is the authentication &quot;realm&quot; name returned by the PPP</span>
<span class="co">// server when authentication is required.</span>
<span class="co">// (Note the length &quot;16&quot; includes the NULL terminator)</span>

CfgAddEntry( hCfg, CFGTAG_SYSINFO, CFGITEM_SYSINFO_REALMPPP,
             <span class="dv">0</span>, <span class="dv">16</span>, (<span class="dt">unsigned</span> <span class="dt">char</span> *)<span class="st">&quot;PPP_SAMPLE_NAME&quot;</span>, <span class="dv">0</span> );</code></pre></div>
<p>When successful, this function returns a handle to a new PPPoE server instance. The status of individual connections is not available to the caller, but tracked automatically by PPPoE. When sessions are added or destroyed, the IP address callback supplied to <em>NC_NetStart()</em> is called and connections can be tracked by the applications programmer via this function callback.</p>
<h4 id="pppoesfree-destroy-a-pppoe-server-session">pppoesFree  Destroy a PPPoE Server Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> pppoesFree( <span class="dt">void</span> *hPPPOES );</code></pre></div>
<p><strong>Parameters</strong></p>
<ul>
<li>hPPPOES: Handle to PPPoE Server Session</li>
</ul>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to close and destroy a PPPoE server session that was created with <em>pppoesNew()</em>. This function is always called once to shut down the PPPoE server. Any external client currently connected to the server is disconnected.</p>
<h2 id="c.4-creating-ppp-server-user-accounts">C.4 Creating PPP Server User Accounts</h2>
<p>To use the PPP or PPPoE protocol in server mode, it advisable to protect access to the system through the use of a PPP authentication protocol. The PPP supplied in the stack library allows for the use of either PAP or CHAP in user authentication. The database of authorized users (name and password) is stored in the configuration system.</p>
<h3 id="c.4.1-adding-and-reviewing-user-accounts">C.4.1 Adding and Reviewing User Accounts</h3>
<p>The definition of the user account entry in the configuration system is defined in <a href="#client-user-account">Section 4.3.6</a>. Note in that section that the server channel flags PPPFLG_CH1 through PPPFLG_CH4 are duplicated in both the server flags and the client account flags. This allows the system programmer to allow different classes of services for different channels.</p>
<p>The methodology of adding, querying, and removing user accounts is the same for any other tag in the configuration system. Some simple examples follow. More example code can be found in the sample console program.</p>
<h3 id="c.4.1.1-adding-a-ppp-user-account">C.4.1.1 Adding a PPP User Account</h3>
<p>The following code adds a PPP user account for the user supplied in <em>name</em> with a password supplied in <em>password</em>. Note that it also uses the <em>AcctFind()</em> function to verify that the account does not already exist.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> AcctAdd(<span class="dt">char</span> *name, <span class="dt">char</span> *password)
{
    CI_ACCT CA;
    <span class="dt">void</span> *hAcct;
    <span class="dt">int</span> rc;

    <span class="co">// Check string lengths for name and password</span>
    <span class="cf">if</span>(strlen(name) &gt;= CFG_ACCTSTR_MAX ||
        strlen(password) &gt;= CFG_ACCTSTR_MAX)
    {
        printf(<span class="st">&quot;Name or password too long, %d character max</span><span class="sc">\n\n</span><span class="st">&quot;</span>,
                CFG_ACCTSTR_MAX-<span class="dv">1</span>);
        <span class="cf">return</span>;
    }

    <span class="co">// See if the account already exists</span>
    hAcct = AcctFind(tok2);
    <span class="cf">if</span>(hAcct)
    {
        printf(<span class="st">&quot;Account exits - remove old account first</span><span class="sc">\n\n</span><span class="st">&quot;</span>);

        <span class="co">// We must de-reference the account we found</span>
        CfgEntryDeRef(hAcct);
        <span class="cf">return</span>;
    }

    <span class="co">// Fill in the CA record</span>
    strcpy(CA.Username, name);
    strcpy(CA.Password, password);

    <span class="co">// Give user access to all channels</span>
    CA.Flags =
        CFG_ACCTFLG_CH1|CFG_ACCTFLG_CH2|CFG_ACCTFLG_CH3|CFG_ACCTFLG_CH4;

    <span class="co">// Add it to the configuration</span>
    rc = CfgAddEntry(<span class="dv">0</span>, CFGTAG_ACCT, CFGITEM_ACCT_PPP,
                     CFG_ADDMODE_NOSAVE, <span class="kw">sizeof</span>(CI_ACCT), (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;CA, <span class="dv">0</span>);

    <span class="cf">if</span>(rc &lt; <span class="dv">0</span>)
        printf(<span class="st">&quot;Error adding account</span><span class="sc">\n</span><span class="st">&quot;</span>);
    <span class="cf">else</span>
        printf(<span class="st">&quot;Account added</span><span class="sc">\n</span><span class="st">&quot;</span>);
    <span class="cf">return</span>;
}</code></pre></div>
<h3 id="c.4.1.2-searching-for-a-ppp-user-account">C.4.1.2 Searching for a PPP User Account</h3>
<p>The following code implements the <em>AcctFind()</em> function called in the previous example. Note that the same method could be used to print out a list of all accounts.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *AcctFind(<span class="dt">char</span> *name)
{
    <span class="dt">void</span> *hAcct;
    CI_ACCT CA;
    <span class="dt">int</span> rc;
    <span class="dt">int</span> size;

    <span class="co">// Get the first user account</span>
    rc = CfgGetEntry(<span class="dv">0</span>, CFGTAG_ACCT, CFGITEM_ACCT_PPP, <span class="dv">1</span>, &amp;hAcct);

    <span class="co">// If there are no accounts, then we did not find it</span>
    <span class="cf">if</span>(rc &lt;= <span class="dv">0</span>)
        <span class="cf">return</span>(<span class="dv">0</span>);

    <span class="co">// Search until we run out of accounts or have a match</span>
    <span class="cf">while</span>(<span class="dv">1</span>)
    {
        <span class="co">// Get the data for this entry into CA</span>
        size = <span class="kw">sizeof</span>(CA);
        rc = CfgEntryGetData(hAcct, &amp;size, (<span class="dt">unsigned</span> <span class="dt">char</span> *)&amp;CA);
        <span class="cf">if</span>(rc &lt;= <span class="dv">0</span>)
        {
            <span class="co">// This is an unexpected error - deref the handle and abort</span>
            CfgEntryDeRef(hAcct);
            <span class="cf">return</span>(<span class="dv">0</span>);
        }

    <span class="co">// See if the username matches the search name. If so, return</span>
    <span class="co">// the referenced handle</span>
    <span class="cf">if</span>(!strcmp(name, CA.Username))
        <span class="cf">return</span>(hAcct);

    <span class="co">// Since we did not match, get the next entry. If there is no</span>
    <span class="co">// next entry, we are done searching.</span>
    rc = CfgGetNextEntry(<span class="dv">0</span>, hAcct, &amp;hAcct);
    <span class="cf">if</span>(rc &lt;= <span class="dv">0</span>)
        <span class="cf">return</span>(<span class="dv">0</span>);
    }
}</code></pre></div>
<h3 id="c.4.1.3-removing-a-ppp-user-account">C.4.1.3 Removing a PPP User Account</h3>
<p>Removing a specific user account is done by finding the account and removing the entry handle.</p>
<p>The following uses the <em>AcctFind()</em> function to find the target account.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> AcctDelete(<span class="dt">char</span> *name)
{
    <span class="dt">void</span> *hAcct;

    <span class="co">// Find the account to delete</span>
    hAcct = AcctFind(name);

    <span class="co">// If we found the account, remove it</span>
    <span class="cf">if</span>(hAcct)
    {
        CfgRemoveEntry(<span class="dv">0</span>, hAcct);
        printf(<span class="st">&quot;Account removed</span><span class="sc">\n</span><span class="st">&quot;</span>);
    }
}</code></pre></div>
<p><a name="ApxD"></a></p>
<h1 id="d-hardware-adaptation-layer-hal">D Hardware Adaptation Layer (HAL)</h1>
<p>As discussed in the introduction, hardware devices are supported through a Hardware Adaptation Layer. This section describes the HAL API.</p>
<p>This section is required only for system programming that needs low level access to the hardware for configuration and monitoring. <strong>This API does not apply to sockets application programming.</strong></p>
<h2 id="d.1-overview">D.1 Overview</h2>
<p>The function of the HAL is to provide resources to the stack library functions and allow them to operate independently of the current run-time environment. The HAL contains the functionality required by the stack that depends directly on the hardware in a particular environment.</p>
<h3 id="d.1.1-hal-function-types">D.1.1 HAL Function Types</h3>
<p>The HAL is interspersed with two different types of functions; those that are called at kernel level (inside an <code>llEnter()</code> / <code>llExit()</code> pairing), and those that are not. (For more information on the <code>llEnter()</code> and <code>llExit()</code> functions, see <a href="#internal-stack-functions-overview">Section A.1</a>.)</p>
<p>To distinguish kernel level functions from application support functions, both have been given a different naming conventions. Kernel level functions are named with an ll prefix, without a leading underscore, for example: <code>llPacketSend()</code>, while application functions have an underscore, for example: <code>_llPacketInit()</code>.</p>
<h3 id="d.1.2-external-calls-from-hal-functions">D.1.2 External Calls from HAL Functions</h3>
<p>Because HAL functions are called from the stack kernel, they are executing within an <code>llEnter()</code> / <code>llExit()</code> pair. These HAL functions can call the stack API directly, but should not call normal application functions.</p>
<p>If a HAL function must call an external application function, or if it is going to call a potentially blocking function, then it should first call <code>llExit()</code>. Then, when it has completed, it should call <code>llEnter()</code> before returning to the stack. <strong>It is important not to block while in an <code>llEnter()</code> / <code>llExit()</code> pair.</strong></p>
<h2 id="d.2-low-level-led-driver-lluserled">D.2 Low-Level LED Driver (llUserLed)</h2>
<p>The User LED driver is not really a driver at all. It is a collection of functions to control (ON|OFF|TOGGLE) LED lights on a given hardware platform.</p>
<h3 id="d.2.1-function-overview">D.2.1 Function Overview</h3>
<p><strong>Application Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>_llUserLedInit()</code></td>
<td>Initialize the LED displays to their default state</td>
</tr>
<tr class="even">
<td><code>_llUserLedShutdown()</code></td>
<td>Shut down the LED environment</td>
</tr>
<tr class="odd">
<td><code>LED_ON()</code></td>
<td>Turn on a LED</td>
</tr>
<tr class="even">
<td><code>LED_OFF()</code></td>
<td>Turn off a LED</td>
</tr>
<tr class="odd">
<td><code>LED_TOGGLE()</code></td>
<td>Toggle the state of a LED</td>
</tr>
</tbody>
</table>
<h3 id="d.2.2-low-level-led-api-functions">D.2.2 Low-Level LED API Functions</h3>
<p>The following functions are required.</p>
<h4 id="lluserledinit-initialize-the-led-displays-to-their-default-state">_llUserLedInit  Initialize the LED Displays to their Default State</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llUserLedInit();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function initializes anything necessary to get the LED displays to their default state.</p>
<h4 id="lluserledshutdown-shutdown-the-led-environment">_llUserLedShutdown  Shutdown the LED Environment</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llUserLedShutdown();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called when shutting down the system to shut down and clean up the LED environment. Typically, this is an empty function.</p>
<h4 id="led_on-turn-on-an-led">LED_ON  Turn On an LED</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> LED_ON( <span class="dt">uint32_t</span> ledId );</code></pre></div>
<p><strong>Description</strong> This function turns on the specified LED in the calling argument.</p>
<h4 id="led_off-turn-off-an-led">LED_OFF  Turn Off an LED</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> LED_OFF( <span class="dt">uint32_t</span> ledId );</code></pre></div>
<p><strong>Description</strong> This function turns off the LED specified in the calling argument.</p>
<h4 id="led_toggle-toggle-the-state-of-an-led">LED_TOGGLE  Toggle the State of an LED</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> LED_TOGGLE( <span class="dt">uint32_t</span> ledId );</code></pre></div>
<p><strong>Description</strong> This function toggles the on/off state of an LED specified in the calling argument.</p>
<h2 id="d.3-low-level-timer-driver-lltimer">D.3 Low-Level Timer Driver (llTimer)</h2>
<p>The stack code requires a very basic simple time function. It consists of two parts: a function API, which can be called from the stack to get the current time, and a scheduler that sends timer event notifications every 100ms using the STKEVENT event object.</p>
<h3 id="d.3.1-function-overview">D.3.1 Function Overview</h3>
<p><strong>Application Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>_llTimerInit()</code></td>
<td>Initialize Timer Environment</td>
</tr>
<tr class="even">
<td><code>_llTimerShutdown()</code></td>
<td>Shutdown Timer Environment</td>
</tr>
</tbody>
</table>
<p><strong>Kernel Layer Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>llTimerGetTime()</code></td>
<td>Get the Current Time</td>
</tr>
<tr class="even">
<td><code>llTimerGetStartTime()</code></td>
<td>Get the Initial Startup Time</td>
</tr>
</tbody>
</table>
<h3 id="d.3.2-low-level-timer-api-functions">D.3.2 Low-Level Timer API Functions</h3>
<p>The following functions are required.</p>
<h4 id="lltimerinit-initialize-timer-environment">_llTimerInit  Initialize Timer Environment</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llTimerInit( STKEVENT_Handle hEvent,
                   <span class="dt">uint32_t</span>        ctime );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to initialize the timer environment, and to set the initial time. The value of <em>ctime</em> is the number of seconds elapsed from a known reference. An initial value of zero is also acceptable. The stack software is only tracks relative time. Take care when setting this value because the stack does not manage the timer value wrapping. This occurs every 136 years, or in 2116 if time is based off of Jan 1, 1980.</p>
<p>Every 100mS, the timer driver will indicate a timer event to the event object specified by <em>hEvent</em>. This STKEVENT object is discussed in <a href="#stack-event-object">Section A.6</a>.</p>
<h4 id="lltimershutdown-shutdown-timer-environment">_llTimerShutdown  Shutdown Timer Environment</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llTimerShutdown();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called when shutting down the system, to shut down and clean up the timer environment.</p>
<h4 id="lltimergettime-get-current-time-in-seconds-and-milliseconds">llTimerGetTime  Get Current Time in Seconds and Milliseconds</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llTimerGetTime( <span class="dt">uint32_t</span> *pMSFrac );</code></pre></div>
<p><strong>Description</strong> Returns the number of seconds that have elapsed since the timer driver was started. If the pointer <em>pMSFrac</em> is non-zero, the function writes the fractional seconds (in milliseconds) to this location (0 to 999).</p>
<blockquote>
<p><strong>NOTE:</strong> Although the stack does not require real time, do not simply use a millisecond timer and divide by 1000, as the value will wrap every 50 days. Device drivers should attempt to provide a time value accurate down to millisecond granularity.</p>
</blockquote>
<h4 id="lltimergetstarttime-get-the-initial-startup-time">llTimerGetStartTime  Get the Initial Startup Time</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llTimerGetStartTime();</code></pre></div>
<p><strong>Return Value</strong> Initial start time in seconds.</p>
<p><strong>Description</strong> Returns the initial start time that was passed to <em>_llTimerOpen()</em>.</p>
<h2 id="d.4-low-level-packet-driver-llpacket">D.4 Low-Level Packet Driver (llPacket)</h2>
<p>The stack code requires a very basic packet function library. Note that although the high level packet API is documented here, the HAL contains a generic packet driver that implements this API. It is more efficient to use the standard llPacket driver and provide a hardware specific mini-driver than to implement the llPacket API from scratch. The llPacket mini-driver is described in the support package documentation for your hardware platform.</p>
<h3 id="d.4.1-function-overview">D.4.1 Function Overview</h3>
<p><strong>Application Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>_llPacketInit()</code></td>
<td>Initialize Driver Environment and Enumerate Devices</td>
</tr>
<tr class="even">
<td><code>_llPacketShutdown()</code></td>
<td>Shutdown Driver Environment</td>
</tr>
<tr class="odd">
<td><code>_llPacketServiceCheck()</code></td>
<td>Check for Packet Activity</td>
</tr>
</tbody>
</table>
<p><strong>Kernel Layer Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>llPacketOpen()</code></td>
<td>Open Driver and Bind Logical Ether Object to Device Id</td>
</tr>
<tr class="even">
<td><code>llPacketClose()</code></td>
<td>Close Driver and Unbind Logical Ether Object from Device Id</td>
</tr>
<tr class="odd">
<td><code>llPacketSetRxFilter()</code></td>
<td>Set Packet Receive Filter</td>
</tr>
<tr class="even">
<td><code>llPacketGetMacAddr()</code></td>
<td>Get MAC address</td>
</tr>
<tr class="odd">
<td><code>llPacketGetMCastMax()</code></td>
<td>Get the Maximum Number of Multicast Addresses</td>
</tr>
<tr class="even">
<td><code>llPacketGetMCast()</code></td>
<td>Get Multicast Address List</td>
</tr>
<tr class="odd">
<td><code>llPacketSetMCast()</code></td>
<td>Set Multicast Address List</td>
</tr>
<tr class="even">
<td><code>llPacketService()</code></td>
<td>Service a Queued Packet</td>
</tr>
<tr class="odd">
<td><code>llPacketSend()</code></td>
<td>Send a Packet</td>
</tr>
<tr class="even">
<td><code>llPacketIoctl()</code></td>
<td>Execute Driver Specific IOCTL command</td>
</tr>
</tbody>
</table>
<h3 id="d.4.2-low-level-packet-api-functions">D.4.2 Low-Level Packet API Functions</h3>
<p>The low-level support layer must provide the following functions:</p>
<h4 id="llpacketinit-initialize-driver-environment-and-enumerate-devices">_llPacketInit  Initialize Driver Environment and Enumerate Devices</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> _llPacketInit( STKEVENT_Handle hEvent );</code></pre></div>
<p><strong>Return Value</strong> Returns the number of physical packet devices.</p>
<p><strong>Description</strong> This function is called by NETCTRL to initialize the packet driver environment. This function also enumerates all the physical packet devices in the system, and returns a device count. The stack will then call the <em>llPacketOpen()</em> function once for each physical device indicated.</p>
<p>The <em>hEvent</em> calling parameter is a handle to a STKEVENT object that must be signaled whenever a packet is received. This STKEVENT object is discussed in <a href="#stack-event-object">Section A.6</a>.</p>
<h4 id="llpacketshutdown-shutdown-driver-environment">_llPacketShutdown  Shutdown Driver Environment</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llPacketShutdown();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called by NETCTRL to indicate a final shutdown of the packet driver environment. When called, there should be no currently open packet drivers, and <em>_llPacketInit()</em> will be called again before any call to <em>llPacketOpen()</em>.</p>
<h4 id="llpacketservicecheck-check-for-ethernet-packet-activity">_llPacketServiceCheck  Check for Ethernet Packet Activity</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llPacketServiceCheck( <span class="dt">uint32_t</span> fTimerTick );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called by NETCTRL to check if packets are available from the Ethernet device. In a polling system, this function is called continuously. In an interrupt driven semaphore system, it is called when packet activity is indicated via the STKEVENT object, and also by the scheduler at 100ms timer intervals for dead man polling checks.</p>
<p>In both polling and interrupt environments, the <em>fTimerTick</em> flag will be set whenever a 100ms timer tick has occurred.</p>
<p>If any new packets are detected from within this function, the packet driver should signal the STKEVENT object in the passive mode (do not set the <em>fHwAsynch</em> flag in the <em>STKEVENT_signal()</em> function). This only applies to new packet events detected from within this function. The STKEVENT object is discussed in <a href="#stack-event-object">Section A.6</a>.</p>
<h4 id="llpacketopen-open-driver-and-bind-logical-ether-object-to-device-id">llPacketOpen  Open Driver and Bind Logical Ether Object to Device ID</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llPacketOpen( <span class="dt">uint32_t</span> dev,
                       <span class="dt">void</span>     *hEther );</code></pre></div>
<p><strong>Return Value</strong> This function should return 1 on success, and 0 on failure.</p>
<p><strong>Description</strong> Opens the low level packet driver specified by the ones based index <em>dev</em>. The maximum value of <em>dev</em> is the number of devices returned from the <em>_llPacketInit()</em> function. When opening the device, the packet driver should bind the physical index with the logical Ether object handle specified in <em>hEther</em>. This handle is used in receive indications to the stack.</p>
<h4 id="llpacketclose-close-driver-and-unbind-logical-ether-object-from-device-id">llPacketClose  Close Driver and Unbind Logical Ether Object from Device ID</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketClose( <span class="dt">uint32_t</span> dev );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Closes the low level packet driver specified by the ones based index <em>dev</em>. The maximum value of <em>dev</em> is the number of devices returned from the <em>_llPacketInit()</em> function. After this call, the packet driver should no longer attempt to indicate received packets to the stack.</p>
<h4 id="llpacketsetrxfilter-set-packet-receive-filter">llPacketSetRxFilter  Set Packet Receive Filter</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketSetRxFilter( <span class="dt">uint32_t</span> dev,
                          <span class="dt">uint32_t</span> filter );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to set the types of packets that should be received via the receive indication function. Each level of filter is inclusive of the previous level. They are:</p>
<ul>
<li>ETH_PKTFLT_NOTHING: No Packets</li>
<li>ETH_PKTFLT_DIRECT: Only directed Ethernet</li>
<li>ETH_PKTFLT_BROADCAST: Directed plus Ethernet Broadcast</li>
<li>ETH_PKTFLT_MULTICAST: Directed, Broadcast, and selected Ethernet Multicast</li>
<li>ETH_PKTFLT_ALLMULTICAST: Directed, Broadcast, and all Multicast</li>
<li>ETH_PKTFLT_ALL: All packets</li>
</ul>
<h4 id="llpacketgetmacaddr-get-mac-address">llPacketGetMacAddr  Get MAC Address</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketGetMacAddr( <span class="dt">uint32_t</span>      dev,
                         <span class="dt">unsigned</span> <span class="dt">char</span> *pbData );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Copies the 6 byte MAC address of the physical device index <em>dev</em> into the supplied data buffer.</p>
<h4 id="llpacketgetmcastmax-get-the-maximum-number-of-multicast-addresses">llPacketGetMCastMax  Get the Maximum Number of Multicast Addresses</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llPacketGetMCastMax( <span class="dt">uint32_t</span> dev );</code></pre></div>
<p><strong>Return Value</strong> The maximum number of 6 byte MAC addresses that can be supplied for <em>llPacketSetMCast()</em>.</p>
<p><strong>Description</strong> Called to get the maximum number of multicast addresses that can be supported on the physical packet device.</p>
<h4 id="llpacketgetmcast-get-multicast-address-list">llPacketGetMCast  Get Multicast Address List</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llPacketGetMCast( <span class="dt">uint32_t</span>      dev,
                           <span class="dt">uint32_t</span>      maxaddr,
                           <span class="dt">unsigned</span> <span class="dt">char</span> *pbAddr );</code></pre></div>
<p><strong>Return Value</strong> The number of 6 byte MAC addresses written to <em>pbAddr</em>.</p>
<p><strong>Description</strong> Called to get the current list of multicast addresses installed on the physical device. The maximum size of the list (supplied as an address count) is in <em>maxaddr</em>. The list is a contiguous stream of 6 byte addresses pointed to by <em>pbAddr</em>. The function returns the number of addresses in the list supplied.</p>
<h4 id="llpacketsetmcast-set-multicast-address-list">llPacketSetMCast  Set Multicast Address List</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketSetMCast( <span class="dt">uint32_t</span>      dev,
                       <span class="dt">uint32_t</span>      addrcnt,
                       <span class="dt">unsigned</span> <span class="dt">char</span> *pbAddr );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to install a list of multicast addresses on the physical device. The size of the list (supplied as an address count) is in <em>addrcnt</em>. The list is a contiguous stream of 6 byte addresses pointed to by <em>pbAddr</em>. The new list preempts any previously installed list, and thus an address count of ZERO removes all multicast addresses.</p>
<h4 id="llpacketservice-service-a-queued-packet">llPacketService  Service a Queued Packet</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketService();</code></pre></div>
<p><strong>Description</strong> This function is called to inform the driver that it may now indicate any queued packet buffers to the Ether object corresponding to the physical ingress device. Packet drivers must internally queue their own packets. Queued packets cause events to be sent to the scheduler that will in turn call this function.</p>
<p>Packets are passed to the Ether object via <em>EtherRxPacket()</em>.</p>
<h4 id="llpacketsend-send-a-packet">llPacketSend  Send a Packet</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llPacketSend( <span class="dt">uint32_t</span>   dev,
                   PBM_Handle hPkt );</code></pre></div>
<p><strong>Description</strong> Called to send a packet out the physical packet device indicated by <em>dev</em>. The information about the packet (size and location) is contained in the PBM packet buffer specified by the handle <em>hPkt</em>. Once the packet has been sent, the packet buffer must be freed by calling <em>PBM_free()</em>.</p>
<p>The PBM packet buffer object is described in detail in <a href="#packet-buffer-manager-pbm-object">Section A.3</a>.</p>
<h4 id="llpacketioctl-execute-driver-specific-ioctl-command">llPacketIoctl  Execute Driver Specific IOCTL Command</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llPacketIoctl( <span class="dt">uint32_t</span> dev,
                        <span class="dt">uint32_t</span> cmd,
                        <span class="dt">void</span>     *arg );</code></pre></div>
<p><strong>Return Value</strong> This function returns 1 for success.</p>
<p><strong>Description</strong> Called to execute the driver specific IOCTL command. For detailed information about the set of commands specific to your device, check the NDK Support Package document of your hardware platform.</p>
<h2 id="d.5-low-level-serial-port-driver-llserial">D.5 Low-Level Serial Port Driver (llSerial)</h2>
<p>In the current directory structure, the serial port driver (llSerial) may or may not be part of the HAL directory (as it is an optional component). However, it is part of the HAL architecture, and should be programmed using the same guidelines used for the llTimer and llPacket drivers..</p>
<h3 id="d.5.1-function-overview">D.5.1 Function Overview</h3>
<p><strong>Application Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>_llSerialInit()</code></td>
<td>Initialize Driver Environment and Enumerate Devices</td>
</tr>
<tr class="even">
<td><code>_llSerialShutdown()</code></td>
<td>Shutdown Driver Environment</td>
</tr>
<tr class="odd">
<td><code>_llSerialServiceCheck()</code></td>
<td>Check for packet activity</td>
</tr>
<tr class="even">
<td><code>_llSerialSend()</code></td>
<td>Send Raw Data to the Serial Port</td>
</tr>
</tbody>
</table>
<p><strong>Kernel Layer Functions:</strong></p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>llSerialOpen()</code></td>
<td>Open Driver in Character Mode</td>
</tr>
<tr class="even">
<td><code>llSerialClose()</code></td>
<td>Close Driver Character mode</td>
</tr>
<tr class="odd">
<td><code>llSerialOpenHDLC()</code></td>
<td>Open Driver HDLC Session</td>
</tr>
<tr class="even">
<td><code>llSerialCloseHDLC()</code></td>
<td>Close Driver HDLC Session</td>
</tr>
<tr class="odd">
<td><code>llSerialConfig()</code></td>
<td>Set Serial Port Configuration</td>
</tr>
<tr class="even">
<td><code>llSerialHDLCPeerMap()</code></td>
<td>Update the HDLC encoding peer CMAP</td>
</tr>
<tr class="odd">
<td><code>llSerialService()</code></td>
<td>Service HDLC Packets</td>
</tr>
<tr class="even">
<td><code>llSerialSendPkt()</code></td>
<td>Send a Serial Data Packet</td>
</tr>
</tbody>
</table>
<h3 id="d.5.2-low-level-serial-api-functions">D.5.2 Low-Level Serial API Functions</h3>
<p>The low level support layer must provide the following functions:</p>
<h4 id="llserialinit-initialize-driver-environment-and-enumerate-devices">_llSerialInit  Initialize Driver Environment and Enumerate Devices</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> _llSerialInit( STKEVENT_Handle hEvent );</code></pre></div>
<p><strong>Return Value</strong> Returns the number of physical serial devices.</p>
<p><strong>Description</strong> This function is called by NETCTRL to initialize the system to use the serial port. It also enumerates all the physical devices in the system, and returns a device count. The stack will then call the <em>llSerialOpen()</em> function and/or the <em>llSerialOpenHDLC()</em> function for each physical device it requires.</p>
<p>The <em>hEvent</em> calling parameter is a handle to a STKEVENT object that must be signaled whenever a serial packet (or raw data) is received. This STKEVENT object is discussed in <a href="#stack-event-object">Section A.6</a>.</p>
<h4 id="llserialshutdown-shutdown-driver-environment">_llSerialShutdown  Shutdown Driver Environment</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> _llSerialShutdown();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called by NETCTRL to indicate a final shutdown of the serial driver environment. When called, there should be no currently open serial drivers, and <em>_llSerialInit()</em> will be called again before any call to <em>llSerialOpen()</em> or <em>llSerialOpenHDLC()</em>.</p>
<h4 id="llserialservicecheck-check-for-serial-port-activity">_llSerialServiceCheck  Check for Serial Port Activity</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> _llSerialServiceCheck( <span class="dt">uint32_t</span> fTimerTick );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called by NETCTRL to check if serial packets (or data) are available from the serial device. In a polling system, this function is called continuously. In an interrupt driven semaphore system, it is called when packet activity is indicated via the STKEVENT object, and also by the scheduler at 100mS timer intervals for dead man polling checks.</p>
<p>In both polling and interrupt environments, the <em>fTimerTick</em> flag will be set whenever a 100mS timer tick has occurred.</p>
<p>If any <em>new</em> serial packets are detected from within this function, the packet driver should signal the STKEVENT object in the passive mode (do not set the <em>fHwAsynch</em> flag in the <em>STKEVENT_signal()</em> function). This only applies to new packet events detected from within this function. The STKEVENT object is discussed in <a href="#stack-event-object">Section A.6</a>.</p>
<p>Finally, if the driver is only open in character mode (not HDLC), and there are characters for the character mode device waiting, they are passed into the user application from this function by calling character mode input callback function passed to <em>llSerialOpen()</em>.</p>
<h4 id="llserialsend-send-raw-data-to-the-serial-port">_llSerialSend  Send Raw Data to the Serial Port</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> _llSerialSend( <span class="dt">uint32_t</span>      dev,
                        <span class="dt">unsigned</span> <span class="dt">char</span> *pBuf,
                        <span class="dt">uint32_t</span>      len );</code></pre></div>
<p><strong>Return Value</strong> The number of bytes sent to the serial port.</p>
<p><strong>Description</strong> This function is called by the application to send raw unpacketized serial data to the serial port. This function may only be called when the serial driver is not open for HDLC mode. The function returns the number of bytes sent, which will always be either the number of bytes it was told to send specified by the <em>len</em> parameter, or NULL on an error.</p>
<p>Note that this function is provided mainly for convenience to the application programmer. The implementation of this function is to packetize the data specified in the <em>pBuf</em> and <em>len</em> parameters into a PBM buffer, and then call <em>SerialSendPkt()</em>.</p>
<h4 id="llserialopen-open-driver-in-character-mode">llSerialOpen  Open Driver in Character Mode</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llSerialOpenCharmode( <span class="dt">uint32_t</span> dev,
                               <span class="dt">void</span> (*pCharmodeRxCb)(<span class="dt">char</span> c) );</code></pre></div>
<p><strong>Return Value</strong> This function should return 1 on success, and 0 on failure.</p>
<p><strong>Description</strong> Opens the low level serial driver specified by the ones based index <em>dev</em> in character mode. The maximum value of <em>dev</em> is the number of devices returned from the <em>_llSerialInit()</em> function.</p>
<p>Character mode input simply passes all characters received at the port to the character mode receiver.</p>
<p>When opening the device, the driver should save the callback function pointer <em>pCharmodeRxCb</em>. This function is called for each character received while in character mode when the <em>_llSerialServiceCheck()</em> function is called. Serial drivers queue up serial data, signaling an event to the STKEVENT object passed to <em>_llSerialInit()</em>, and then pass the serial data to the application callback function from within the <em>_llSerialServiceCheck()</em> function.</p>
<p>When the driver is opened in HDLC mode, no character mode input is received. When the HDLC mode is closed, the character mode becomes active again.</p>
<h4 id="llserialclose-close-driver-character-mode">llSerialClose  Close Driver Character Mode</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialClose(<span class="dt">uint32_t</span> dev);</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Closes the character mode of the low level serial driver specified by the ones based index <em>dev</em>. Once called, the serial driver should not attempt to call any character mode callback function.</p>
<h4 id="llserialopenhdlc-open-driver-hdlc-session">llSerialOpenHDLC  Open Driver HDLC Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> llSerialOpenHDLC( <span class="dt">uint32_t</span> dev,
                           <span class="dt">void</span>     *hHDLC,
                           <span class="dt">void</span> (*cbTimer)(<span class="dt">void</span> *h),
                           <span class="dt">void</span> (*cbHDLCInput)(PBM_Handle hPkt));</code></pre></div>
<p><strong>Return Value</strong> This function should return 1 on success, and 0 on failure.</p>
<p><strong>Description</strong> Opens the low level serial driver specified by the ones based index <em>dev</em> in HDLC mode. The maximum value of <em>dev</em> is the number of devices returned from the <em>_llSerialInit()</em> function.</p>
<p>The <em>hHDLC</em> parameter is a handle to the HDLC device. Any HDLC packet received has its Rx interface in the PBM packet buffer set to this device handle.</p>
<p>The callback function <em>cbTimer</em> is called by the driver every second to drive any timeouts required by the caller. Note the serial driver calls <em>cbTimer</em> from kernel mode.</p>
<p>Serial drivers queue up HDLC packets. When a complete HDLC packet is ready, the driver signals an event to the STKEVENT object passed to <em>_llSerialInit()</em>, and then passes the HDLC packet (as a PBM packet buffer) to the application callback function <em>cbHDLCInput</em> from within the <em>llSerialService()</em> function.</p>
<p>This is similar to character mode operation, but different because the entire packet is passed over at one time, and it is done from the <em>llSerialService()</em> function, not from <em>_llSerialServiceCheck()</em> as with character mode data. The <em>cbHDLCInput</em> function is called from kernel mode while the character mode application callback is not.</p>
<p>When the driver is in HDLC mode, the driver receives serial data as HDLC packets, and creates a PBM packet buffer object to hold each HDLC frame. Note that the HDLC flag character (0x7E) is always removed from the HDLC packets. The HDLC packet passed to the <em>cbHDLCInput</em> function is formatted as follows:</p>
<table>
<thead>
<tr class="header">
<th>Addr (FF)</th>
<th>Control (03)</th>
<th>Protocol</th>
<th>Payload</th>
<th>CRC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>1500</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The serial driver processes the HDLC packet data as it arrives to remove any escaped characters and to verify the CRC. When a HDLC packet is ready, the driver signals an event to the STKEVENT object.</p>
<h4 id="llserialclosehdlc-close-driver-hdlc-session">llSerialCloseHDLC  Close Driver HDLC Session</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialCloseHDLC( <span class="dt">uint32_t</span> dev );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Closes the HDLC mode of the low level serial driver specified by the ones based index <em>dev</em>. Once called, the serial driver should not attempt to indicate HDLC frame buffers to the scheduler or stack. Any queued buffers should be flushed.</p>
<h4 id="llserialconfig-configure-serial-port">llSerialConfig  Configure Serial Port</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialConfig( <span class="dt">uint32_t</span> dev,
                     <span class="dt">uint32_t</span> baud,
                     <span class="dt">uint32_t</span> mode,
                     <span class="dt">uint32_t</span> flowctrl );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to configure the serial port attributes for the indicated device.</p>
<p>The value of <em>baud</em> is the baud rate, and must be an even denominator of 230400, up to a maximum baud rate of 230400. For example: 230400, 115200, 57600, 38400, 28800, and 19200 are all legal values, while 56000 is not.</p>
<p>The value of <em>mode</em> indicates the mode of the device including data bits, parity, and stop bits. Only the two most commonly used modes are defined:</p>
<ul>
<li>HAL_SERIAL_MODE_8N1: 8 Data Bits, No Parity, 1 Stop Bit</li>
<li>HAL_SERIAL_MODE_7E1: 7 Data Bits, Even Parity, 1 Stop Bit</li>
</ul>
<p>The value of flowctrl indicates the desired flow control operation. Legal values for this parameter are:</p>
<ul>
<li>HAL_SERIAL_FLOWCTRL_NONE: No Flow Control</li>
<li>HAL_SERIAL_FLOWCTRL_HARDWARE: Hardware Flow Control</li>
</ul>
<p>This function can be called before or after the device is opened.</p>
<h4 id="llserialhdlcpeermap-update-the-hdlc-encoding-peer-cmap">llSerialHDLCPeerMap  Update the HDLC Encoding Peer CMAP</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialHDLCPeerMap( <span class="dt">uint32_t</span> dev,
                          <span class="dt">uint32_t</span> peerMap );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> When in HDLC mode, the serial driver sends all serial data as HDLC frames. This requires it to add the frame flag characters, and do any character escaping necessary to encode the frame for transmission over the serial link. This includes escaping characters that appear in the peers character map (CMAP).</p>
<p>By default, the CMAP is set to 0xFFFFFFFF. For character codes 0 to 31, if the bit (1&lt;&lt;charval) is set in the CMAP, then the serial driver performs an HDLC escape sequence when sending the character in an HDLC frame.</p>
<p>This function allows the application to update the peers CMAP as it gets information from the peer allowing it to do so.</p>
<h4 id="llserialservice-service-hdlc-packets">llSerialService  Service HDLC Packets</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialService();</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> This function is called to inform the driver that it may now indicate any queued HDLC buffers to the HDLC callback function corresponding to the serial port. Serial drivers internally queue a PBM packet buffer for each HDLC frame received. When a new packet is received, the driver signals the STKEVENT object, which will cause this function to be called by the network scheduler.</p>
<h4 id="llserialsendpkt-send-a-serial-data-packet">llSerialSendPkt  Send a Serial Data Packet</h4>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> llSerialSendPkt( <span class="dt">uint32_t</span> dev,
                      PBM_Handle hPkt );</code></pre></div>
<p><strong>Return Value</strong> None.</p>
<p><strong>Description</strong> Called to send a serial data packet out the physical serial device indicated by <em>dev</em>. The information about the packet (size and location) is contained in the PBM packet buffer specified by the handle <em>hPkt</em>. Once the packet has been sent, the packet buffer must be freed by calling <em>PBM_free()</em>.</p>
<p>The data is treated as raw bytes when the driver is not open in HDLC mode. When in HDLC mode, the data packet is an HDLC frame with the following format:</p>
<table>
<thead>
<tr class="header">
<th>Addr (FF)</th>
<th>Control (03)</th>
<th>Protocol</th>
<th>Payload</th>
<th>CRC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>1500</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Note that the CRC on the packet does not need to be valid. The serial port driver will validate the CRC when the packet is sent. However, the 2 byte space-holder for the CRC must be present in the packet.</p>
<p><a name="ApxE"></a></p>
<h1 id="e-web-programming-with-the-http-server">E Web Programming with the HTTP Server</h1>
<blockquote>
<p><strong>NOTE:</strong> the HTTP Server is no longer provided in the NDK. The Network Services Component provides a more capable HTTP Server.</p>
</blockquote>
<p><a name="ApxF"></a></p>
<h1 id="f-bsd-sockets-support">F BSD Sockets Support</h1>
<p>The NDK no longer provides a Berkeley Software Distribution (BSD) API support layer. This layer is now provided by SlNetSock, which is part of the Network Services (NS) Component, typically distributed in your SDK.</p>
<p>Applications can access the BSD APIs via SlNetSock, but applications <em>must not include both</em> the BSD headers and the NDK headers in the same compilation unit.</p>
<h2 id="f.1-using-bsd-sockets-provided-by-slnetsock">F.1 Using BSD Sockets Provided by SlNetSock</h2>
<blockquote>
<p><strong>NOTE:</strong> The NDK no longer provides a Berkeley Software Distribution (BSD) API support layer. This layer is now provided by NS.</p>
</blockquote>
<p>Applications can access the BSD APIs via SlNetSock, but applications <em>must not include both</em> the BSD headers and the NDK headers in the same compilation unit.</p>
<p>To use BSD APIs, make the following changes to your application.</p>
<p><strong>Update your compilers file search path</strong> to include the following directory within your SDK installation. This allows the #include statements in an existing BSD application to be resolved. For SimpleLink SDKs, for example, the following include path should be added:</p>
<p><code>&lt;SIMPLELINK_SDK_INSTALL_DIR&gt;/source/ti/net/bsd</code></p>
<p><strong>Include the BSD socket header file</strong>.</p>
<p><code>#include &lt;sys/socket.h&gt;</code></p>
<p><strong>Add a new C function</strong> that will be run as a thread. (The Task is created in the next step.) Copy the contents of your BSD sockets code into this new Task function.</p>
<p><strong>Create a new thread</strong> that will be used to run your BSD sockets code. The Task thread can be created dynamically using native OS APIs, as described in the <em>TI Network Developers Kit (NDK) Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>). You must ensure that the Task cannot run until the stack is up and all IP addresses (IPv4 or IPv6) have been bound and are ready. This is usually achieved by using a semaphore to block at the beginning of the sockets Task, and posting the same semaphore from the NDK IP address hook function, which is called when the IPv4 address has been bound. This prevents the Task from running the sockets code until it unblocked. Another way to prevent the Task from running too early is to create the Task dynamically in the program at a time when the stack is ready. For example, the Task may be created in the Network IP address hook function, which is run when an IPv4 address is added or removed from the system. Refer to the section on Creating a Task in the <em>NDK Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) for details.</p>
<h2 id="f.2-things-to-remember-about-bsd-compatibility">F.2 Things to Remember About BSD Compatibility</h2>
<p>Remember the following issues when integrating BSD sockets code into an NDK application.</p>
<p><strong>Include statement:</strong> Most BSD sockets applications should have the following include statement:</p>
<p><code>#include &lt;sys/socket.h&gt;</code></p>
<p><strong>File separation:</strong> In general, a BSD application should contain BSD-style sockets code in a separate C file. That is, BSD sockets code should not be mixed with NDK code, such as NDK sockets code or standard (non-BSD) NDK APIs. This must be done in order to avoid type and function name conflicts between standard NDK headers and BSD layer headers.</p>
<p>The file containing BSD-style code can include BSD header files (for example, sys/socket.h) and should not need to include any NDK header file found in ti/ndk/inc.</p>
<p>A good rule to follow is to organize BSD sockets code into a separate file that includes only BSD style header files along with OS related header files as needed. Code that performs NDK-specific functionalityfor example, NDK network open or close hooks, IPv6 system initialization and deinitialization callsshould go a separate file or files that include the NDK header files found in ti/ndk/inc.</p>
<p><strong>Types and domains:</strong> While BSD sockets (for example, in Linux) can support many different domains and types (such as PF_APPLETALK or SOCK_SEQPACKET), only existing NDK socket domains and types are supported. No support for new types or domains has been added. The domains and types supported in the BSD layer are AF_INET and AF_INET6.</p>
<p><strong>IPv6 support:</strong> In order for IPv6 sockets code to work correctly, application code must be compiled with _INCLUDE_IPv6_CODE defined and with IPv6 enabled in XGCONF.</p>
<p><a name="ApxG"></a></p>
<h1 id="g-ip-version-6-ipv6-stack-api">G IP Version 6 (IPv6) Stack API</h1>
<p>This section discusses use of the API for the IPv6 stack.</p>
<h2 id="g.1-synopsis">G.1 Synopsis</h2>
<p>The IPv6 stack is designed to be modular and coexist with the traditional IPv4 stack. The IPv6 stack can be easily built in or out of an application using the _INCLUDE_IPv6_CODE compilation flag. IPv6 stack is available only with NIMU enabled architectures. Default stack builds are provided with IPv6 stack enabled.</p>
<p>The IPv6 stack is similar in its architecture to the IPv4 stack with respect to the components it is made of. Figure G-1 shows the main building blocks of IPv6.</p>
<p><img src="data:image/gif;base64,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8iTKlCpXsrTXLR/LmChbABBoMeHChiB38uzp8yfQoEKHOhRJUibSpEqXpqRpsyJOhkSnUq1q9SpWqkaZcu3qtaTTi1F1Zi1r9izatEO3fm3rdmXYmwqlqq1r9y5evP5s3/J9GxfqXLJ5BxMubBjk3r6Ku/6lOPYw5MiSJxNMvPhy0sYTH1Pu7PmzWcuYR8OtKTYw6NSqV/sUTfq1Sc0SObOubfu2RNewX8uOSBs38OC1de8e3Rvib+HKl08mXvzy8YfJmVOvrheAgATat3Pv7v07+PDix3sXYFpuTuvq16t1AuA9/Pjy59Ovb/8+/vs/Tqdn7/9/VcJsIQWBBRp4IIIJKrgggw0qmMUu/NEFIIUVWujTdBdquCGHyKHWIYghgpihiCWaaB2JJ6q44m0psvgijJ25GCONNQ42o4056mgWjjv6+ONQPQI5JJEfRbXFGEkquSSTTTr5JJRRSv45JZVVWnkllllq+eQVW3r5JZhhijkmmVFuYcY+0BSzJpttuvkmnHHKOSedddp5J5556rknn3Ku0CeggQo6KKGFGkonNM8puiijjcp0g6ORSjoppZVaeimlkGK6KaedevopqM9pGiqppZp6KqqXjpoqq626+iqsj8Y6K6212srpqrfquiuvvbqVq6/BCjusr8ASeyyyyaJqrLLNOvvspMxCOy211S4mrbXZarttTNhy+y241nobLrnlIjuuuemqqyu667r7bqvtwjsvvZ/KWy++na6jQw79+vsvwAELPDDBBRt8MMIJh5Awww07/DDEAevATr62ygNEPhlrvDHHHf57/DHIIYs8Msklm3wyyimrvHI+QMxTca3zAAGztS7TPKvMN1Nrs86v5tzzszwDzerPQysrtNGnFp30sUgzTerSTwvrtNSfRl11r1RjzenVW+uqtdeXdh12rWCTTenYZ8dqttqRpt22q2zDzejbc6cqt93P1Z23qXjzDdvef4fqt+CjBV64p4QLqw89jTv+OOSRSz455ZVbfjnm9LTjQ+ade/456Jj3FTrppZtuuQ/tnL4666TrYwwE+ck+O+2123477rnrvvsH5bRFzge7Cz888cUbf3x+EPyBPPPNO/889K20xQr01Vt/Pfb29fGeGG54/z344Ys/Pvnlm38++v7pq78+++27jz4U763S1irvQfE+/vnrvz///fv/vRjesz0AiANxiqKF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" title="NDK IPv6 Architectural Block Diagram" alt="Figure G-1 NDK IPv6 Architectural Block Diagram" /></p>
<p>The IPv6 stack components and the RFCs it supports are as follows:</p>
<ul>
<li>IPv6 Core Stack
<ul>
<li>Neighbor Cache Support</li>
<li>Routing Table Support</li>
<li>Extension Header Support</li>
<li>Fragmentation/Reassembly</li>
<li>Binding Lifetime Management</li>
<li>Routing Table Lifetime Management</li>
<li>RFCs</li>
</ul></li>
<li>RFC 3596 DNS Extensions to Support IPv6</li>
<li>RFC 2460 Internet Protocol Version 6 - Only support for processing of extension headers</li>
<li>RFC 2461 Neighbor Discovery for IPv6</li>
<li>RFC 2462 IPv6 Stateless Address Autoconfiguration</li>
<li>RFC 2463 IPv6 Internet Control Message Protocol (ICMPv6) for IPv6</li>
<li>RFC 2464 Transmission of IPv6 Packets over Ethernet Networks</li>
<li>RFC 3484 Default Address Selection for IPv6 - Implemented partially</li>
<li>RFC 3587 IPv6 Global Unicast Address Format</li>
<li>RFC 3493 Basic Socket Interface Extensions for IPv6 - Implemented but not fully. No compatibility with IPv4 nodes and multicast.</li>
<li>RFC 2373 IPv6 Addressing Architecture - No support for IPv6 addresses embedded with IPv4.</li>
<li>Layer4 Support
<ul>
<li>ICMPv6</li>
<li>RAW</li>
<li>UDP</li>
<li>TCP</li>
</ul></li>
<li>Socket Layer Extensions for IPv6</li>
<li>Application Support
<ul>
<li>TFTP</li>
<li>Telnet</li>
<li>Web Server</li>
<li>DNS</li>
</ul></li>
</ul>
<h2 id="g.2-initialization-and-deinitialization">G.2 Initialization and Deinitialization</h2>
<p>To enable IPv6 in your application, users must take the following steps:</p>
<ul>
<li><p>Update your compiler options to define _INCLUDE_IPv6_CODE</p></li>
<li><p>Update your linker options to link against the IPv6 versions of the NDK libraries instead of the IPv4 versions. For information on including these libraries see section 1.3.3 on the Library Directory Structure in the <a href="NDK_Users_Guide.html">NDK Users Guide</a></p></li>
<li><p>Update the application code to initialize the IPv6 stack. See the example code listed after these steps for more information on this.</p></li>
<li><p>Build your application.</p></li>
</ul>
<p>The following example illustrates how the code to initialize the IPv6 stack can be done in the networkOpen function. Note the initialization does not have to be done here, but it serves as convenient place for this code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define IPv6_DEVICE_INDEX 1</span>


<span class="co">/*</span>
<span class="co"> *  ======== IPv6DADStatus ========</span>
<span class="co"> *  IPv6 initialization callback function</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> IPv6DADStatus(IP6N Address, <span class="dt">unsigned</span> <span class="dt">short</span> dev_index, <span class="dt">unsigned</span> <span class="dt">char</span> Status)
{
    <span class="dt">char</span> strIPAddress[<span class="dv">40</span>];

    <span class="co">/* Convert the IP Address to String Format. */</span>
    IPv6IPAddressToString(Address, strIPAddress);

    <span class="co">/* Print the status of the address. */</span>
    printf(<span class="st">&quot;IPv6 address: %s on device %d is %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strIPAddress, dev_index,
        (Status == <span class="dv">1</span>) ? <span class="st">&quot;UNIQUE&quot;</span> : <span class="st">&quot;DUPLICATE&quot;</span>);

    <span class="cf">return</span>;
}


<span class="co">/*</span>
<span class="co"> *  ======== networkOpen ========</span>
<span class="co"> *  User defined function (hook) that's typically passed as an argument to the</span>
<span class="co"> *  NC_NetStart() API. Here, it's used to initialize the IPv6 stack.</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> networkOpen()
{
    <span class="dt">int</span> status = <span class="dv">0</span>;


<span class="pp">#ifdef _INCLUDE_IPv6_CODE</span>
    <span class="co">/* Initialize IPv6 */</span>
    llEnter ();
    <span class="co">/*</span>
<span class="co">     * IPv6_DEVICE_INDEX should be set to the interface ID of the interface to</span>
<span class="co">     * initialize IPv6 on. For most users this value should be set to 1. Also</span>
<span class="co">     * note that this value should always be 1 or greater.</span>
<span class="co">     *</span>
<span class="co">     * IPv6DADStatus is a function callback that is called when the IPv6 DAD</span>
<span class="co">     * (Duplicate address detection) process has completed on an address.</span>
<span class="co">     */</span>
    status = IPv6InterfaceInit(IPv6_DEVICE_INDEX, IPv6DADStatus);
    llExit ();

    <span class="cf">if</span> (status &lt; <span class="dv">0</span>) {
        <span class="co">/* Unable to initialize the IPv6 stack */</span>
    }
    <span class="cf">else</span> {
        <span class="co">/* IPv6 stack has been initialized */</span>
    }
<span class="pp">#endif</span>
}</code></pre></div>
<p>Deinitialization follows a similar pattern. The following example uses the NetworkClose function to illustrate this:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> *  ======== networkClose ========</span>
<span class="co"> *  User defined function (hook) that's typically passed as an argument to the</span>
<span class="co"> *  NC_NetStart() API. Here, it's used to deinitialize the IPv6 stack.</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> networkClose()
{
    <span class="dt">int</span> status = <span class="dv">0</span>;

<span class="pp">#ifdef _INCLUDE_IPv6_CODE</span>
    <span class="co">/* Enter the kernel Mode. */</span>
    llEnter ();
    status = IPv6InterfaceDeInit(IPv6_DEVICE_INDEX);
    llExit ();

    <span class="co">/* Were we able to deinitialize the stack? */</span>
    <span class="cf">if</span> (status &lt; <span class="dv">0</span>) {
        <span class="co">/* unable to deinitialize the IPv6 stack */</span>
    }
    <span class="cf">else</span> {
        <span class="co">/* IPv6 stack deinitialized */</span>
    }
<span class="pp">#endif</span>
}</code></pre></div>
<h2 id="g.3-api-functions-and-data-structures">G.3 API Functions and Data Structures</h2>
<h3 id="g.3.1-socket-support-for-ipv6">G.3.1 Socket Support for IPv6</h3>
<p>The following is a list of Socket API that is supported:</p>
<ul>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>connect</li>
<li>getpeername</li>
<li>getsockname</li>
<li>send</li>
<li>sendto</li>
<li>recv</li>
<li>recvfrom</li>
<li>setsockopt (limited IPv6 options supported)</li>
<li>getsockopt (limited IPv6 options supported)</li>
<li>close</li>
<li>shutdown</li>
</ul>
<p>The No-Copy variants for receive are not supported for IPv6 sockets.</p>
<p>In order for IPv6 sockets code to work correctly, application code must be compiled with _INCLUDE_IPv6_CODE defined and with IPv6 enabled in XGCONF.</p>
<h3 id="g.3.2-architecture">G.3.2 Architecture</h3>
<p>Figure G-2 illustrates the internal architecture block diagram for the socket layer:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbgAAAGFCAYAAACPLubAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAIkcSURBVHhe7Z0FXBVNF4f/xmu++lqf3d3dHSiCCkgoKnZ3oWKhYovdip2Igi0iqCgqdnd3d/f99py7FwHBJO69nMffujuzc5ed2Z09E2fOiTVt6lTN+LEjIcRQNOr+T4ml7gXD5G+fvyDoMbFfPH+uHgqCIAiC8RBrhIuLxm3ODA5MnTkHqVOn5mNBEARBMDQePnyIbh3b83EIAbfCwxPp0qXjY0EQBEEwNO7evYsmDWz5ODb/LwiCIAhGhgg4QRAEwbgg5TdlEwEnCIIgGCUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJ0QLL1+8RGM7W9hY1IX7ypVqbMQy1HkwX//8+fMc7tS+HYffv3/P4b/l+LHj2BOwRw0BDvYN0aRhAzUU8RzYv5/vX7c1tK6Pjm3bYIKrKx49eqSmih5GjxjB90RlIgj6ggg4IVrYts0H9+7fxdNnT+G71RuarxHvt+Xd27d8/a9fv3I4adL/kCLV//j4b9mwfj16de+M27dvqTFA8hQpkDx5CjUU8Xz69Jnz8/nzZ2TNngOpUqfGg/v3sGnDWnRu1xZPnjxRU0Y9iRIn5rKN+09cNUYQoh8RcEK04L99O+8zZ86Kq1cv4+DBAxzWceXKFZw6eZIF38ULF+C/cyceP36sngVevXzF5+/fv4/Xr15jl/+un/YeWrRujW49eiJ+vPhqDPDs2XPs3bMXO7bvwL1799RYLV++fMWhg4fgs9UHJ46fwJs3bzn+2dNnuKrcn0ajwdOnT5X7v8rxHTt3QYcuXfhYB12DfkvXv33rthqr5eaNm5wH6lHeunkLfr5+nO+fkStPPkyYPAUzZs/B0pUeqFSpKh49fojlS5eqKbR8/PARBw4cwO5du7/r4Z0/d457tnR/x44e5TJ49/Ydn7t06RJ27tjx3W/oeoH79nF5nD59msM6LOvX57LNljUbh+mZnT17lo/p71D+ycq7IEQl4k1AiHJOnTqFbp3ao2ChIqhSrTpmTJ0Ek1q1MXCws5oC6N2jB44eOYg69ayweeM6jkv2XzL0GzgYZcuVQ0BAAJwH9EOlytVw9vRJPHmq7b3UMDHl68SKHQv9HHvj4IFAzJgzD/nz5+chxDt3bmGLz3YkTJSQP7rTJo3H8xdan4jx/omHNh06wa5BAxamA/r1xaWL2uFNIn36jBg5dpwilE5houtoNRYoU6Y8xowfj7q1aykC+Ss2b/PjeP+d/nx96nURsWPHgV3DRmjfoSPf39jRo7F1y0ZYWdthwzovpaf5BbFixUKnrj1ga2fHvwkODYcOHtAXJUqWwfhJk9RY7VBpz26dkC1bDixYohVynqvXYIHbbLx9pxXKiRImQsu27YOua29jzX8rS7bsOLB/L8cVKFAYBQsXxqqVyzicOPG/Sr4momDBgrh27RoGOfXD3bvfhHRuRdCOUsojZcqUcB44EAG7dyqCdxqKlyiBVs2a4snjRyhXsRJ8vDdz+n//TYIhLiNRslRJDgtCZMDeBBqKNwEhmtjhpxUAFStXUQRSTSSInwAB/jvDnEe6cf0aXCdORdv2nVkQzZo+jYfodOwJ8EfDJk0xbsIU5MmTH9v9fLBp00b1bPjQcB4Jn0/KtQY6u2Do8NGInyAB5s+ZxT2NgwcO4s3r12jYyIEFZC1Tc/64U3yRIkVgUrM2X8esjgXq22orU3Do+hPGjcbbt2/RsUsPvn7u3HlYeGzYsF5NpeXUiePK/U9G+05duVe4ZeMG9cyvkSVLFt7fvXObe2TUu5o5fQoSKPlx7DcQ/QcNRbJkyTFz2mS+fx33H9xDqv/9T+kJuiFf/oI4c+YkAvfuYSFlXtdC6bG+DnpW1HP79PEj2nbojGmz5qJM2QpKL+0cTp44wefD4uWrl9wrnDpjtnI9S7x+/QrbfbepZwUh8hEBJ0Qp9MHz3+6Lf+L+g+o1aiB58mSoUKkKPnz8gG0+Pmqqb9g3duAWf2OHJtzDuHnzetCQIEG9GepxlSpdCjbKnjh98iTvfwT1ekhgVqpcVRFWJqhStQrGTZyMpe4e7PTXvI45lq/yUARYHZw7ew7Pnz/j3z1WeiWZs2RG+owZOZxZES5lypbl4+AcPnSYP+g1a5ujQcMGfP027TvyuYBdu3ivw6xOPSUfJWBpacXhZ2pv9FeJG1c770XC+tOnj8rfPsS9QRult1inbh1FONdCg8ZNWHgG7A75t+0bNUb+AgWQM1duDlevWYt7YGXLlefw0yfaYeHGTZrAY+06lCxZEqeVHjjljfjZsGPDxo1RSOkVVlB6csTLly95LwhRgQg4IUrZvt2PBcuXr1/RoXVL1rwL3BugPbfN5ztlk5QpvyltpEihPX72VDvkRyRLlkw9AlKlSsX7X/mIPn+mFViJ//2X90TevHnxP6VHQ5AQ7diuLVo4NMKm9WuVXuMXjlekhHb/E3TKJ/8L5iE/Q8YMvKehu+D8l+w/3tOwKfVmqWx+hztKz41Ily4999qoJ0cE986fNm1a3j8NpYiSJk0a3sdT5yV15Zk4cWLef1WfBzUIWiiNjPZtWiq9Ol8e3iRIaP4I3TP5Vy1nncKPIEQFIuCEKMV/xw7e582XH1mz5+Qtb/6CSJokKa5du4L9+wP5vI5Lly7zngRf8A+5juvXrgYJxdu3tedTqh/VH6ETPDphQMx3c8OkCRNw/fp1rFy2DOfPnUHvvv2xcOkyVK5aVZtI/bDr+Pol7A+2TlDS/ek4pypdZMiYifc64iq9WR06wfGrUN63envzcdHiJXifUtUUvRasp3vlslZ5JV16rZDVoev96aB5wrBYtGA+bty4hjHjJ2Hu/AUoVkI7j/az+9Up9PxmtgQhQhABJ0QZ1Cs6cvgAK4uQFuCEyZODtrpW1pxGN+ejY8mCebxObrzrWNa2LFqsBA8R6rh8+SLGjBoJj1WrsGLJYo6rVLky739EqVKlkClTFgTu24MpkyZh9syZWLViGXbv3I5UKVPh3TutRuH1a9ew3W87Nqz14vB7NZ56SsTxY0fg5enJx8GpUqUqUv8vjZKfbbxObfGiRZg1bSoLhHqWlmqqP+PalUsY5uwM5wED0E7pBa9fu4bLtHnLlny+hokJEiZICE8Pd8yaMRNuc+dixdJFSJwosfK3LTjN7/JOVVa5cP48C9RtW7SKI+/fRcyaQkGIDETACVGGrzrHVrFKtSABoaNmrVr88Q/YtTPEvE71mqZYunA+tmzawIoQ3Xr2Us9oIQ3Ghw8fYNb0KXjx4jnatO8U5pxYaGg40GngIOQvUAjrvFaz8gf1bpwGOePfJP/CtkFDFlCeq90xyXUMylesxL2bq1e0PcpSpUsjRfIUOHRwP/y2fT93SMOOQ4aPQMlSZeHn441F8+dyb6nfAOdfur8fQVqZ/jv9WDiTEkt1k1qYMHV6UK8xZ86cGDjEBTly5YaXcv8k3Chvzi4jgxRSfpdGTZpyL3vhvDlwmzUD1UxqcnzwHqog6BuyTEDQS3TLBObMW4isWbPh2fNnQfNFhG6ZQE1TMwwYNBgPHjxA8mTJES9+PDXFr0Pr2kjJJU3qNKy+r+PTx0+8Ni59hvTfDeURdJ6Ecfr06UP8LjS0zu358+dB82BRCa0RfP/hfdBc2N9A+Xj08BEyZsz4w/wKQnQiywQEg4KEVnDhFhZ0/k+EG5E8RXIWPqE/2v/E+4eHQ8MSbgSdJ8WRn33sqbcaHcKNoN5oRAg3gvKRKXMmEW6CwSACTtBLsmXPgdJlyiFhwkRqTEhouIzOZ8gQUmFDEARBhwxRCoIgCEaDDFEKgiAIRo8IOEEQBMEoEQEnCIIgGCUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkIs9Ca7f2nSRI9JIUEQBEH4Wx48uM9+C4kQAk4QBEEQjIXYSZImVQ8FQRAEwXiI9fbtW82smTPw8sXP3fzrM1cuXUS2nDkRO5ZhTytSPrLnyoVYyj9D5vKlC+yPTPKhH1y6eAG5cudRQ4aLseRDX3n+/BmuXL6EEiVLqzGGS9L/lM6bxkhoZGeref36lRoyXBra2mio0WHoNLCur/nw4YMaMlzsrK00Hz9+VEOGi42VpebL589qyHCxtrTQfP36VQ0JEc3evXs0jr16qiHDR7QoBUEQBKNEBJwgCIJglIiAEwRBEIwSEXCCIAiCUSICThAEQTBKRMAJgiAIRokIOEEQBMEoEQEnCIIgGCUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDjhh1y6dBFrVq/Gy5ch/QX6bPXGKnd3NSQIgqB/iIATfoj/Tn849uyKG9evqzHA1y9fsHrVKkyfMkmNEQRB0D9EwAlh0r1rF+TKmgmjRwzjcP165hymLUfWjPDz3YrPnz7xOUEQBH1EBJwQJj169ULqNGmRKFEiDidJkgT//ZeMt9T/S4NcufOiTYdOfE4QBEEfEQEnhEm2bNmx98AhDHEZicJFisNj7XocPnGKtwNHj8N3hz9at2mjphYEQdA/9E7AXb1yhZUaXrx4rsZo2bbNB+4rV6ghIaqwa9AAGzZvQcKECdUY4OiRI/jw/r0aEgRB0E/0TsDt3r2blRouXbqkxmiVGrwUoTd5vKsaI0QVGo0GTn37wN7WRo0BRo8cDlOT6jh54oQaIwiCoH/ojYDr3bMHKzCMGDqYw/Y29UMoNWz13oRPnz7yOSHq2LhxA9xXLOVjXa8tZar/4caNa5g8aQKHBUEQ9BG9EXA9e/dG2nTpkTAcpYacufKgXaeufE6IOs6cPo1YsWJh6Up3xE+QgONmz3VDlao1cOLoEQ4bCgcO7Me4sWMw1NkZQ5wHB21TJstyB8G4efzoEZ48ecwjMjEJvRFwGTNmQkDgAbiMHMNKDUvdV4dQavDbuQvtO3RQUwtRRQJFqFGlePf2nRqjHbZ89+6dIvC+zcvpO4cPH0KLJo0wc9pkLFowF4sXuAVt27Z6q6kEwbigxlvZEsVQslghuCuN1AFOTpg4Ybx61vjRuzm4+tbWrNRQsGBB/ohev349xrU69Imy5cohbpy4aN28KQ8j03ycVb26OLB/L0qVKaum0n+2+/nh3ft3qGtRH7369MdAZ5egrXnL1moqQTAe5syejUnjx+LN2zdImiQpx127egVTJ43nqYeYgN4JOCJg9240tLFGgTw50a1zJ+zcuQNNG9njwYP7agohqihXrjy69OiF58+fwXO1O8/HnTh+BCVLlUX/AQPVVPoPDXknVHqck6dOQ7fu3dG2XbugrUHDhmoqQTAetvv6IG/e/Nh/+Cjy5S/IcePGT1DqQlLs3xfIYWNH7wTcrZs30bt7Vxw8GIg0qdNw3PVr1xAQ4I9hQ4ZwWIhaevTshc0+fhgzfhL3eOYvXobVXmuRNl06NYX+Y2Fpif8p79OSxYsMbkTgzp07cOzV86fb2DGj1V/oP3v37sG+fXvVkBAZPHv2DNly5ETixP+qMeA6+68SjhU7lhpj3OidgPPx8cHDRw8wc868IEsZLVq0RJ16VtgXsIvDQtSTPUcOWFpaoWatWqhevQYrnhgSBw8cQNy4ceEyZBDy5siKciWLo0KZUrw1bdxITaWfPH3yBGs8Vv5027N7t/oL/efY0WNo3MAGVvXqYPasWd+texX+noKFCsPHezPat23No18nTxxDq+ZNce/+XeTLl19NZdzonYB7/vw5z/mUKVtOjVFuMk4cpEyVCrFj6+WIahCkqRRWyzr0NnLEcPUXhoG//07YWFkif+7s6N2jO7b5bEWLpg6slWUoPHr0GFevXubjDx8/cCW/c+cWb0+fPuF4fSVL1qzce+bNdSKyZMmGUqXLov+goRg2Ygwa2DtwK71dx47qL/SfQoUKoUyZ8jhx/CjGjByGimVLc93YExCgphD+lr79nJA7T14WctevX+X9HqWTYFbHAo2bNFFTGTkaPcPXd5sma8a0mto1a2haNmuqqVSujGZgfyeN0urWNGvSSE31PY3sbDWvX79SQ9HD1atXNFkypPnpVqt6NfUX39PQ1kbz9u1bNRT9UJ6KF8rPz6RsiWIaa0sLjdLi5nx069JZTfU9Dazraz58+KCGop8vnz9rPn78GOb26dMnNdX32FlbcRp9YfHiRZp8ObNpXr58qcZoad+2jUbpiaqh71EaKFwG+sapU6c0w12GaapVqhBUP9q3aa2e/R56/75+/aqGhJ9B7+6ypUs1I1xcNKNGjtBs2rhBPRM2e/fu0SgNDTVk+Ohdl8jEpCaatWyD8+fOYMf2bbh58zqWLVnIE6N9nAaoqfSTNGnSfmtpK1uOHLlQrHhJ9BswmJc/NGrSHIkTJUb7ToZjpHirtzeeKD0ct4VL0Lx1W44jG5SmZnUQuMdwWts0CvDPP//w9vnzZ9y7e5eHLClMe0PhxrVrUAQyHjx4oMZoLf28eP4Mly6cV2MMB9KWtrCwRI2apkiZIiXH3b9/j/fC30PvdxMHBwwcPJiVwszMzNUzMQO9HPMb5jIcS1d4oFtPR7Ro3Q4DnYdh2w5/rgz6DFnet7dvxFvsWLFx88Z1zF+0BB07dUaz5i0weuxYmJiaYdXKleov9J8XL14gfrz4KF26jBoDFghkzUTfh4xDs2PHdlhb1uOhVsdePbBly2aDG2rNl78APn3+hGaNGqKvoyN69+yJenXMELhvDwoWKaKm0n9oOH/6tKk89G1Ztzbc5sxALKXOODRvhWHDR6qphL+BllkN7N+fy5rM6lWtWB6F8udh4wYxBb37Qt2+fYu13CpWqoRevR0xdJgL2rZrj6RJk8LLy1NNpf9cu3YVn798xl2lp6CD8vX82VNcUHqnhkIR5aNJc1aN7Gz5I/pUEQYD+jvBc9VKFChUWE2l/1y+fBmO3bvi+LGjSJtGq/1588YN+O/0wwgXFw4bArZ2dmjYyAH3H9yHh/syeK5eiTOnT7JxhIGDDUfL2N3dHePHjsLRIwdRpmwFDB0+GgH7D2LEyFEoUrSomkr4G0aPGonlSxfiyJHDWLp0Cc/DKR8hNm6wbu1aNZVxo3cCzs/XjxcU0zCSDj8/X1hZ1MNMpcVnKOQvUIAFWqumTXjynFraFkpLe5f/DhQpVlxNpf+YmdeBQ7OWOHv2FHbt3K4I7itYsXQRUqRIib5O/dVU+g8NtT5VGhfzFy+FQ4tWHEcNp5pKj3r/3j0cNhTGuo6H1/pNPOw9YPBQHj5ev2kzsmbNqqbQf5ImTYImTVtittsCuK9egxYtW+LMmdM8/CpEDEcOKo2HMuVRuHARbNuyCenSpsfBYyd4KPiogZnZ+1P0TsCR+rnXmlXo0qkjTp8+jU4d2qNty2Y4dfKY0rIzHMFQr54FD7eQhh6pcFNL+9TJ4yhQsDAGDRmqpjIMRowajcXL3IMNGbvAZ4c/8uTNq6bQf16+fMELvUuXLq3GfBtqjWVgQ62BgfvYfdTVK1d5jRxpHg4d4oypU6aoKfQfB4emePfuLVyDrd0b5uwMs1omOHfurBoj/A1v3rxGvgIFEaC8Hy+U979i1WqsbZtCeeffvX2rpjJu9K5m29rZcqt665aNqGdWE1s2rWdFjXmLlmLCJMMyikvDLWs3bsHwUePgNHAI5sxbiI2bvZErV241hWFw8OAB7N8fiJcvXnKvlIaRJ4x3xaSJE9UU+k+hwoXZVFdDWxscPBDI8xL9+/XD2tWrUKBQITWV/kMGo1s6NA7Tpqavz1Y1lf7j6enJDVkaqSElGSJ16tS4cvkiphhYPddXSOntkPK+rPNcw+FKlStj8qSJuHzpAtKlT89xxo7eCThqYcyZOw/2TZrxxzRjxsyY7TYfNWqYqCkMh0OHDsLbe4tSaS/j3r272LdvH4YNG6oIBsNxM3P06NEfGCneoqbSf6hH3dihOc9X0VArrYlbuXwx9+AMaah1x/bteP/hPSysbMKwqakdejUEaDjyn7j/YKXHGtZwJeYvWoxy5Sri1InjHBb+jvq2trhw/qzy3QlA9uw5Ubu2GQJ27cL/UqVGQ3v9Nm4QUcRShEi02y26f+8eWjRzUEPfuHLpImuMkVJAshQpkC5deixcovVNFprGDezgtnBhCLM00cmJ48fZUgMZOg1Nnjz54bN9hxoKib3Sg6U8BvegHZ24jhuLGVMnsZFiWjQa/L5I8aehvb0aCgnZEiUXO/HixVNj9INd/v486f7y5Uv2YEF2KCkf4dHApj6Wu3uwurU+MG3qFMyaNgWnz18KEgy/gm19K3is8fyt30QmY0aPwtxZM7B9VwCyZcvOcdSTs7aywMsXL7Bjd9jzoqR1uWbtOoOzpBNdkDk0UrCqVbMWm+lapHwjixcvjsLhaNxS+rVK79p1guGMzvwIvejB0cQyrXsLvZFwI+4/uMfhW7ductgQIMUYEm7mdS2/a2m3bKtdT2YI0PpDWiYwacrU74wUhyfc9JFLSmNpzerVKF6iRJB2bhvlOZBNRI9Vq9RU+o+VVX2kSJkKS5Ys4REOQ6VMWa0nCgf7hqyE1a+PIyzr1cHxY0dQotS3eVLh76ClPNt9t8GqrjmqV67IPecMGTOoZ2MA1IOLbsjCwt07d0Jshw4dDDreutVbc+XyZc2DBw/UX3yPPlgyCc7cObM1ObNk/G1rHvpmyYTKv3L5skp+5vyWBQl9s2Sis75y5vRpNUb73pG1nCoVyqkx36NvlkwUYaypWrE85yV3tsxsXaZ86ZK8/cjSjz5aMhk3dgznQWfBhDZ6/x8/fqSm+B6xZPLr0DeULEAFL1/a6tSupXn/7p2aKiRiySQSoGETmvTUbdOmTUXndm2Dwovnz0fLZg64ffu2+gv9h+Z8MmTMhIULFhh0S3v//v2sbTjSxfk7I8VNlNa3vkPauLmyZsLYUVr7nxbmphymLUfWjGwtx5BU05WPPy/VIL63qfmM4w2FPn37YZOPL0aPm4DBQ0dg0bKVvGQgpdJDjSp8tnqzF4bVHh5qzPfMmjmD09C0Q1jQFAudHztmjBrzPb5KL4rSuK9cocZ8j9Io5jTknDcsLl648FseGNyU63358oXXGJ65cBn7Dx2DfeOmOH3qBJYsWaymMm70TsmEXjhaZxVH+ai+evWK41KkSsUmuyYbkCfaAwcOII4iuEePGMqCgbzq6gRDowa2air95/Hjx7hy5RIfG5qRYqJHr97sJoeszBDkF+6//5Lxlvp/aZArd160aW84nuLbK/d66dqtMLe1GzaqqQwH0igmV0Y1TExQpUpVNTbqIE3D7NlzIH2G8LUKM2fJwmmSJ0+uxoQkYaKEfD5HjhxqzPeQ6y9KkyFDRjXme7KofydlSq3JstD8l+w/pPoN4X/1yhWUq1CR1xiSbgLNwQ0fOYqnHGiJSYxA25HTH2jYgrrR58+dU2O0tG7ZXFMwby419D36NkQ5f57bd0MDus2QjC3/qZFifRuidF+5UlPP3IyNR/8O+jZEGZw3b95orl279ktDdvo4RLltm4/Gql4dNuTdqIGdZq2Xl6Z1i+aa58+fqSm+R4Yofx0yvk3D78G/i4GB+/gbNHHCBDUmJDJEGckkSJCA92RHLTjv3r5Dgvjac4ZAy1atw2xl07bZZ5uaSv8JbqQ49GZIRopJIWbD5i1BGntEcGs5hgQpMNW3qIsCeXLAqY8jNm7cgFYtmik96qdqCv3nwvnzbDrtxPFj30yn3bwJP9+tBmU6TZ8pVqIEm+eyqlcXgwb0Z2WeDq1bInbsOKhQsYKayrjROwFXtlw5Xh/TXnkQvXp0h1PfPmwgd++eXSgVzEecvkNqzGEJBdoMSTAQtNBb6VljqLMzG2rVbYa00JtYsXwZVrm78zE5gcyXMxsvy7h+/TrHGQKkDaoTDGR6ibh54yZ2+G3DyOGGIxhofejLVy+xZLk77B2aclzHTp1QvUYtHAjcx2Hh7+jcpSt7/bh08Tx7ZCGLSq9fv0anLt1DGE83ZvROwJUqVRrde/fBK+XlJ0sH7iuW4uiRQyheohQGDBqkptJPyHgvzbH1cezNH1PdnFvozZDm4IxloTctBxjUvx8OKcKazFyR80dqbOwP3IOJ413VVPqP9xZvNru0cMlyNGrajOPad+gAk5q1sf83FBCiG/JSQfNCJUqWVGO0rl1SpExpcF4q9BVagzrHbT68fXfAedgIVuTZ7OMHx7591RTGj16+SV26dsMW5aGQTzVaN0ZmujzXbeCFufrMl69fWPni1cuXeP/+fZAyRujt6RPDGUra7ueLt+/e8kLv0Ov5WrRqo6bSf/bu2YO4ceKgcRMHbFy/nuPGTJgEG7tGOHbkMIcNAbKpmShhIpQKZlNTKxj03+N9cMh02uvXr3gh/eGDB/Ho0UMerdmw1pPtJwoRR758+dGqdRv242hI9mMjAr2tEWQZnfyq0YJicoJqCJYLaH7n+u37mD3XjV8oOg5rC8+KiT5iLAu93759i3TpM6BgoUII8N+BVCn/x84fU6ZKqTRIXqip9J9ChQqzAYGGttY4dOAAHpNg6NcX6zw9kF/P/SUGx9raBnb2TdgAecDunTyMRqM1adKmQ18nJzWV8LtMnTI5zFGj0Nv0adPUXxg3eingyIzSoIEDYFK1MkoVLYzGDRtg507DEQqhoXVWmzdvYqvvhqbYYGlpibTp0rOJH40Br+cjQ75kCWfI4MF4/uI5KlapisB9+7BVeS6Zs35TPNF3LK2s2E4rrWXavWsHLl++CPflS3gpRD8993gfGtfxE7Bw6Qp06d4bLdu0xxCXkdjqtz2EIpDwe1BDLqxRo9AbeXKIEWiVKfUHUgEmlf/QqvU5MmdgteLw0JdlAk+ePNE49u7FatmjR43UvHjxQmNRxzwoH5Z1zTXKh1ZN/T36tkzAy9NTU71yRb730JYzlIaHmup79G2ZwKOHDzXlSpXgfOTKmkmz1XuLZsrkyayirghvNdX36OsyAaXBp3EdN04zdIgzL0lRGoXqmbDRt2UC9+7eDfP9OHb0qEZp3Kqh75FlApGLLBOIZNavW8fWr83rWsB/z36cu3QNE6dMR8JEiTB31kw1lf7Sp1dPrHZfjsOH9mP2jKloYt8AJ44fQY4cuZDsv2Rsa2/eXDc1tf5j6Au9daT63/94HpechC5194BpbTOUKl0Ko10nonmLFmoq/YYMH5w8cYKPq1athvIVyiNBgoRQBAWePzMMKybbt/uxz7dypYujeOECcJs7l+NpZIOseNjb1hdvAhEAvSsPHtxXQ1rIEoryzVdDMQO9E3CXL2k/pn36OfE8HFmvt7axhUktM5w7e4bP6StKS59dsWTLloMdhNa3acBzDORV189/NzZ6b2MFgVMntR8pQ6B16/DX823cot/+x0ilnuYbyO/bksWLYFvfEnNmzkCvbl053rFHd0ybNBFNG+u/6xAa4q5WsTzGjBrJYXf3lWje2B6zpk9mM2T1zGqxrzh9Z8zIEUo9Po04seOwkonr6BEstJspz2DW9CnsCihfflEy+RvIqHiV8mWwfNkyNUZLt84dUdukhkG8JxGF3gk4MidDHDt2jPcEte6uX7uCjJkyqzH6ydMnT/D5y2eUKlMOVapWhV1Dra3GbDlysJJMpsyZkTpNWkUQfuB4Q4AWer99+4bXvZnVrIGKimBo1awpz1/p+3q+Tx8/cU+Tlpy8e/cDrVY974l+eP8eYxXB8PjJIzaEQK3wmVOnsLcN0m4tX74SzysuWbRI/YV+QnPR165cRuEixXHw2ElMmjoTHz99RNdOHXjUhkynjVF61KPHjlV/IfwutKZz+JBBePrsKW7fuqXGAg8fPmTjGRcunEWntq3Z4W9MQO8EXNVqVZEwQUIMduqL7l27wHnQQNS3qIdjRw+jREn9dqNBHqOJuP9oP/w0fEQk/vebj7p48eMrH96Pakj/IR9dbVu1ZPugpNDw4OF9BAT4o3VzB71X/MlfoABrrU6fOYvXioXWZtVtm7fqt2WZY8ePsS3WWqbmmDt/AXbt8ucwDXtPnTYdy1a6I2vW7LiqCA995trVq9wAJF9kKVKkQJ26dbnhd+PGNVSuUh2e6zfCvlFjNbXwJ3iuWc3rJEkRaazrN9u9pGRFo0jUIHqiNOhWrFiunjFu9E7A0Vq3Ac7DyBQI1q9do7RK5+PUyWMoXqI0evbqpabSf6i1+vWr1hW/0uTmMG3U+jakYXBPT08cPBDIFWP33gM4e/EqXCdOZUHtNmuWmspwobkKnVFvfeXhgwe8L1y0KPeat/n4cLhUmbLcw6aN1Ovv3dFvbxuk4UeQIXWCFiInSpSYHQCTN28a4RD+jrt37vC+ZctWvD4yOBRu2649H9++ZTieWf4GvRNwRNNmzbB3/yEewug3YDDmzFuINV5rWVHAEKDeTq5smWBrVY/D891mc5g2Wu9jSFy+rJ0THThoMFtVJ6v8dg0aoLpJLXZCa+hYmNeGvZ2NGtJPsufIyfsrly/zPO9OX22Ps1x5rT3Be3fv4oLyLGg5hyGg+fo1qMFHi9OzZdcuC9DFGaqNUH0gudIzJu7c1Qq60Dx6rB2aTJI0Ce+NHb0ScG/evMZxde4tWfLk7Hn2zes3uHTpksHYCyQ7mj/bYsfRy3ZFmKRVegbE4WDWPugjdP3aVWTQ8zlRYyF/vnysuLTOazUqlyvDmqwUNjM3x7KlS1lA0xxc2fIV1V/oNzQqo2vw0fzoVu9NQWHaSBlI+DPIEAAxfcpk1poMzrlzZzme0KUzdvTmS0sW0mtUroRhQwZzeMP6dWhq3wDTp07E+LGjYFnXDLv8/fmcvkILVC9dv/XTzXubn/oL/adKlSpsycTJsRd6du/GC/Ct6tVh7dDiJUupqYTIhIYgR7uOR/bsOXH/wT0WbsNHjeEhvosXL/AcVvkKldFVeT76DBsgD6PBF3oja/fCn0GGAGqb1WX7vaRZa25ak23fmtaoDgszU16mVNPUDFb166u/MG70QsDRkASpD1Pl1bnLmTltKq+7oodVpVoNbuktWbSQzwlRR/YcOeA0yJmHldZ6emDZ4gU4c/okSpcph549DWdO1NApW7Yctu8KQODBo9gZsBcVK1XieDJjR0P4y1asjFJP2H9CkaJFw2zwhd681m9QfyH8Ca4TJ6F1u47scPnsmVMI3LeHtSdpOLh5q7aYMGmKmtL40QsBd/78eVy+dIE1qRYvW8Eu28+fP4v06TNi2sxZWLx0OfLmK4Ar6nyQELWQb7t9B48EzYnOXbAYq9Z48TCyPkMKPaQO/aPN0Ba+pksfcp6tstLDpkXr1MsTBIK81g92HoIDR0/Afc1aVgpbsnwVAg8fwzCX4UiaNKma0vjRCwGnW3FfqEgRHnbx3ryZw6QlptMEormgO7dvGdwHydAht/cECbP61tawsbVD6VKlDcL4NVneL1ms0A83cggpCMYICTrq+ZNSGDWEaGlGTEMvBFyePHl4T1pitO5qu6olRs5PiSdPHuPs6VNsDd4QPqzGAPm2s7GyRNfOHdUYLYsWLkDl8mXYarm+EytWbDaP9rMtceLE6i8EQTAm9ELA0do3Ms+zdctGlC9dklvVNDxpYWkJj1WrYFffCg8fPUD5itp5ByHyGe4yFEcOH8CtG9fZkoaOR48e4fWbN5joOgaL9dxyBg3FHD9z/qebh+da9ReCIBgTeiHgiDHjxvOCT1I0yZQpC1xGjWaPv1euXMbVq5dRqnRZdO/RU00tRCa3bt6Er483cuXOC6+NWxBfVfwhyMWJ68TJrOnmtWa1GisIgqB/6I2AIw0rcgS6/9Ax7N63n7XDiKrVqmHW3PlYsWr1dxPsQuRw7vw53ldXnkHOnNpFxsGhebjCRYrimuplQBAEQR/RGwGng4wtB59nK1euPMzM63xndkaIPNKpi7ufPQ3bBQsp+rx4/hwp9FwtXRCEmI3eCTgh+ilQoADSpkmHjes84eXlqcZqIXuCw4YOwbVrV1AghlhDEATBMBEBJ3wHranq1deJvSP06tYZlcuXRUMba7ZgUqF0CSyaPxcpkqdAb8c+6i8EQRD0DxFwQpg0aNiQF4iSSxZyzXLgwD428/Ps+TOUKVsBcxcuZisngiAI+ooIOCFcaIGoz/ad2LTVD5OnzcKM2W7w898D99VrUFLsUAqCoOeIgBN+CPkfK1iwIBtnrVO3HmtVymJ7QRAMARFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJwiCIBglIuAEQRBiKJcuXURzh8ZB26Txrti/b2+IuOnTpqqpDY9YGgP1IEr+yMgeog7yIVe1ugnixNHKbLJ279inTwhL+PrIlMmT8PLFCzUE+G3zQTWTmogT+1s++vTrx45g9ZlJEyfi9auXagjw9dmKGrVMEVtdUkDWUfr2c9J7m6ITJ4zHm9ev1RCwbas3TExrB+UjTty4nA9aPqHPTFA+VG/fvFFDgI/3FtQyM4dugUdc5Tn0U/Kh757Ax7u64t3bkPkwVfKhw1Dyoc+0adkCfr5b1VBIEsRPgDXrN/FSIUPEYAUctSrGjx2lhr7H2rYhJk6eoob0FxLU5FstPGwbNML4iZPUkP5CAm7KxHFq6Hsa2Dtg3Pjxakh/IcEwbfIENfQ99k2aYczY8POpL7iOG4sZU8N/bxo3bYFRo8N/7/SFsWNGY9b08OuxQ/NWGDEy/O+A8HOOHzuGBtaW+PjpoxrzDUN5T8LDYAXcp0+fYFbLBJcvXVBjvvHvv0mwaasvsmbNqsboLx8/foRZzRq4EobrmSRJkmKLjx8yZc6sxugvlI/aJtXZd19okir58PbbiQwZMqgx+gs5dzVV8kFOd0ND3r+9fXcYhNumd+/ewbRGNTazFprkyZJj6/adSJMmrRqjv5Bxb8rHrVs31JhvpEyREj7b/ZHqf/9TY4Q/pY9jb6x2X66GtBjSexIeBjsHR0Ndbdt3VEMhsW/S1CCEG0FDj63btVdDIWnk0MwghBtB+WjZpp0aCknjZi0MQrgRNKT9o3wYik/ChAkTKvloq4ZC0kTp9RjKRytRokRo3qqNGgqJQ4tWItwiiB49e3FDNDiG9J6Eh8H24HQ0sKmPgwcC1RD5MksPnx3+SJo05MPSd2zrW+Hwof1qCEifPiPbgUySJIkaYxhYW9bD0SOH1BAUwZYJ23bsZO/shoRl3To4cfyIGgJ7mafnQR9cQ4GqtkUdc5w6eUyNgdLwy670QrezADQUKB91zUxx5vRJNUabDx+/HXo/x25IjB41EnNmTuNjQ3xPwsLgtSg7dunKihg6mrVqbXDCjejYpUuIfFCr1dCEG9Ghcxf1SEuL1m0NTrgRHTp3Vo+0UG/IkIQbQTZDQ+eDnoehfbQoH+07dlJDWlq1ay/CLYLp0rUbUv8vDR8b4nsSFgYv4KpVq45atbVaVbnz5EPbcIb79J0aNUxgUqs2H+fNmx9t24Y9vKTv1KplGpSP/AUKoXXr1nxsaJiZmaO6SS0+LlioCFoqDSdDpE6duqhazYSPixQtgRYtW/KxoWFhaYXKVarzcbHiJdGsWXM+FiIOalBbWtuykDPU9yQ0PEQ5csRwnDpxQo0yPD58eI9jRw+zYEiWPIUaa3gE5SNfASRLllyNNTzev3/HvuPy5S+I//5LpsYaHrp8kKBOmvQ/NdbwIIUTGm4tUKAwkhjg6IYOUjg5eeIoChRU8hFqvkiIGD5+/IBnT58iTdp0aozhUqRYMa2AIw2aChUqwrS2tuVtiLRr3QrTZ81CvHjx1RjDpF2rlpgxZ67erxf7GW1btcCcefNDDLsaIrRGyG3BQoN3EdS6RXPMW7jI8PPRvBnmL16ihgQhbLy9t2B/YKBWwPV1dISFpSUqVqqknhYEQRAEw2RPQAA2bFgvproEQRAE40QEnCAIgmCUiIATBEEQjBIRcIIgCIJRIgJOEARBMEpEwAmCIAjGh0YEnCAIgsHz9OlTttn5M168eP5L6Yjnz56pR4aLCDhBEAQDhIRal04dUbpYERQvnB8FcudAi6YO7N8tOA8e3EfP7t1QpUI5FC2YD4Xy5UZDG2vs3LlDTfGNy5cvo02rFiheKD+KFsqHkkUKYdDAASwYdVhbWnD8iePH1RjwtcqXKsHx5MSZ0KULayPDzhvWrwvznG4b0N+Jr/M3iIATBEEwQLp17ohNG9YiRapUsLCyQfqMmeC/0w89u3Vhs2bEkyePWZit9fRgH5pkJzZP3vw4eDAQbVs0w9Il36zCnD59GnZW9eC3bSsyZMqCWqZaG7/LFi9Ah7Ztgnp+r169xOMnj/DlyxcOHz58CI7du+LuvTswt7BE9x49OV6XLkOmzMiZO0+ILXnyFPg3SZKgcMpU/+O0sWPH/haXMiVf568gSyZ9evfWBOzeTYeCIAiCnvPixQtNziwZNUpPS/Pl82eOe/PmjaZCmVKaQnlzafx37uQ4+rZnyZBGY29no3n+/BnHEQsXLOD4MsWLah4/fsRxrVs257ghgwdzmDh/7pwmf+4cmlxZM2n27AngOJNqVTjdkcOH+Xz50iU53L9fXz6vI3i6n7F40UJO275tGzXm7yB5RnmXHpwgCIKBQZb/ySD7k6dP0LypAxYvWqT00D5iz/6DOHnuIqpUrco9rh2+Ppy+fafOIQyfk7cA8spw/8E97Nyxkw1y+2/3Q/x48dHL0VFNBaW3lxfL3VfjyMkzbK84OA8ePkDnju1x584t2DZohJGjx6hnQqIIXh7iDL59VXt/kY0IOEEQBAODjGb3duqPxIkSI2D3TgwZ5IRyJYujbeuWCAzcx2meKsKPhv0obenSZTguONmy5+D9jRvXce7sWXz+8hnp0mf4zp9m0WLFwvRNOWLoEFy+dIGPyVdieIa8mzZugCIF8obYTp785rw2MhEBJwiCYIDY2zfC+i0+6NilB0qULMNzbL4+3uigCDlSAIkbNy4LnVixfvyZp7m0d+/fqaFfh3puJjVrI0H8BFi5bAl279qlngkJpbGsbxtiS5EiatyaiYATBEEwMC5duojly5bh5s0b6OfkBM9167F73wFUqlwNL16+gO+2bTwkmT59Rnz9+gWHDx1Sf/mN69eu8j5zliwoWLAgC8P79+7izZvXHK9j7pzZWLliOV69eqXGaKlrUR+z3eahQWMHfPr8CWNGjcDHjx/Vs9/o1KUrpkybHmKjvxkViIATBEEwMGhIcaCTI8aPHRMkVNKlT4/UadLw8cdP2riy5bXzZm6zZwVpVhIkHI8eOYTkyZKjSuUqLAxLlymP9x/eY8b06Woq7bKBmVMno3/f3jhz5rQaq6VV6zbcS+zt6Ij06TLg7JlTGO86Tj2rH4g/OCFSoHUxfXv2wKPHD9UYQQib/6VKjXGTJqNatepqjPAzSCmkfr06OH/+LAoWKoIiRYvjsVLXdvhuw5evX7HCYw3Kli3Ha+Cs6pjj3v27yJ49J4oUK4GnTx4hYPcu7tn1GzAYHTt15mvu3x+Ilg6NebiSeoIkLPfs8seDh/dhalYHc9zmc7qa1avi0sXz8Fq/GcVLlOC4hQvmY5jzQB6uXOrugVKlSgelq1SpKhImTszpdGTPkQNO/QeoIWDJ4kVwHuiE2ub1MHuumxr757A/uPXiD06IJHb5+4twE34Jek/ofRF+nYQJE2L8pCmoUrW60nM6jeVLF2L7Nh9kyZoNzsNGsHAj0qRJCw+vdTCrY4GHDx9grecqFm45c+XGhMnTgoQbQb9ZtHylIrRKY/++PfBc7c4aj3b2TTBx8hQ1Vdi0aNkKJUuV5R7gqOEu+Pz5s3oGCAjwx7atm0Ns50L1BiML6cEJkYLz4EFYsnAeH9eztMY///zDx4Kgg5QiNq734uNmLdvAZfgIPhZ+Dxp6vHrlCrJlz4bEif9VY7+HVPMvXbrEQ5mhNSVDQ/NtN27cQO7cuREvXjw11nDQ9eBEwAmRQnABd/jYKaT63//4WBB0PH70CCWLFeJjEXBCRCJDlIIgCIJRIwJOEARBMEpEwAmCIAhGiQg4QRAEI2bqlMmssj91yo81IY0REXCCIAhGzIsXL3g92suXL9SYmIMIOEEQBIEXeq9yd8eOHdvZjxzx8uVL7Nu3N4RzU4J8wFG8zooKLVXYts0H69etw507dzhOB6U7eeIEx9N50p6NKkTACYIgxGBoUXabli1gb1sf/Rx7oFWzJuz9e/PmTbx2rm3L5mhibxdko/Le3btoZGuN/n0ceX0rCT/LuuZo16o5unfpgFrVKrNlE0Kj0aBxAxs49uqBJg3t+Lyb21w+FxWIgBMEQYjBHDp0kA0v1zQ1w+q1G9Chcze8fv0Kvj4+SJY8OWrUNOUw9b6I9evXs3HlGrVM2UDzqBHDeQiUzH7NmbcQadOlx/ixo3Hzxg1OT1y8cI7d87Tv1BVW9eursZGPCDhBEIQYTLly5eHnvxvDR4zCuXPncOf2bY5/eP8+783q1OH9btWc2t6A3by3tLTi4cYD+/ciRfIUIOeo/8SLh8JFi3Nvz9fXl9PpGD5qFPoPGIh8+fKrMZGPCDhBEIQYzNOnT9GqRTNULFsKM6dMxpvX2qFIjfKPqF3bDNmy5UDAbn9203MgcC+KlyiFIkWL4vqN65yG5uq6derAm6/PFvz7b5KgeTzin7j/IEOGjGoo6hABJ8QYqCLTnIAgCN9YtHABdvhtg32Tpth38DA6dunC8bGUf7yPFQu1zMy5VzZ86FB2xVPdpBafy5olK5/PrOxPnbuI0+cvwX21F7zWb0Kfvv04DUHueChdVCMCTjBqSKh16dQRpYsVQfHC+VEgdw60aOqA48eOqSn+HrK7WbJIIaz28FBjfg/SQJsyeZIaCp95bm78d8oUL4rbt2+psVoon3ROt5UrWZzXPjVqYIvNmzaqqQDLunX4/OlTp9QYIaYQ4O+Pdm1ah9iWLV2Kd2+13rxpaHLT5k2YOkn7Lr4J5j/OxsYWsWPHwe5dO9gljl0DO44nG7PVqtfE1auX0d+pHxYvWoR2rVvC1KQqa2XqiC5j6yLgBKOmW+eO2LRhLVKkSgULKxukz5gJ/jv90Kt71xAOIP+GD+/f4/GTR/ikOpn8XeqZmWLRvJ9rlm3ZtIH/DvnnWrF8uRqrRaP5yueeP3+GnLnzIF2GDHj14gUC9+1BbyWvpKZNvHr5gtN9+fKFw0LM4cKFs9+5rblx4zqat2yBAgUKY+cOX/Tu1gUZMmVC5sxZceXyxSAv3rnz5EGFClpj/JWqVmM3PDrGuI7nHp3nqpUYMsgJ79+9Rf9BQ3huL7oRAScYLeTLav++vUiZIiW2bN2GqdNnYP2mzciQIRMeP3qIQwcPqim1XL9+HV6ea7jlGdyflY5r165irZcXNmxYz9cOD7oOrf0J3kt8/uwZq117b9nMvS0dR48cwa2bN1jg0G9oLiMsDh48wB6Ys2bNzkM93kqvLKzh1oSJEsF99Rp4rd+InXv2oUTJMuyjy9vbW00hxDQGOw/B9dv3w9wGDhqMjEqjb+MWb+zYtRcnzl7AmLHjsHvffh5uTJIkiXoV8HtE1KipHZ7UkTp1aixYtIR/6+Pnj8BDR9GufQc+R+8q/Z3Aw0c5HNWIgBOMlqRJ/0Py5Cnw5OkTNG/qwMMnJLj2HjiEk+cuokrVqpyO1vXY29miasWySs+uC68HamBjzRPqOsaNHQPT6lXRs1sndOvUHtUqlueFraE5ffo0GlpbsWfka9eucRylq21SHZ3bt0HHdq35Orphw769e/KcxstXL3m9UPBhneCsUwQrYWffGMWKl1KufQUbFUH7I8gpZoaMUT+xLxgesePEYS/biZQGUmhGjRzBQ9uHDu5nZRMargwL+i1pUsZPkECNiX5EwAlGC7Ueezv1R+JEiRGweycPn9DcVNvWLREYuE9NBYwY7oL9gXtgXtcSM+bMQ6MmzZXe0kE4DxzAvSSy7DBr+hRkyZYdbguXoG//QXj67CnGK0IveC/q+fPn6NGlE2uPDR42AvWtrfHu3TuMchnGcROnTOft8+dPGKN8NOhcl+49WcOMHFWOHDMehQpq/aMFh9Jt897Ccx+2iiA2qaVtQW/a+G1uTcfnT5/Y5iAJ5J7du2HLxvVcDiVKllBTCMLvQaMKNOJRoWIVjBrnalDOi0XACUaNvX0jrN/ig45devBwHXmR9vXxRgdFyJEFBurR7dm1E8mTJceESZNRp05djBozBrly5+X5q0sXLyrCcTcLMitrW9SsWQudOnfBCg9PrFmrFR46Zk2fisuXL6KOhRUcmjblOBoGvX79KnLnyceLZmkrWLgobt26wUOStOg1duzYiKd8NJo4OLC35dCsXu3B82a6uQ9buwZImCAh/Lf74tbNm2oqLe/ev8NE19GYOW0y1np6IH78+OjcrRdMTGqqKQTh96AhSxr1WO6+Si/m1X4HEXCC0UJDjMuXLcPNmzfQz8kJnuvWY/e+A6hUuRpevHwB323b2NU/HadJm46H9AgSWunSaQXNDeW3z9Q5s//++4/3RPnyFb5z+//q1UvuiW339eH5OuLevXu8J0sPunVCx44e5nVC9+9pF9L+DOq9EfsCdrMGpHnNGiyoaWhzxYqQyibUW501dz73NNes26h8mA7DsU8f9awgxCxEwAlGy7mzZzHQyZGHEnVGYamHlDpNGj4mAZExUyYkSpiIFT0ePNAKHNKKvKwIRxJ0BQsUDEpPGmcE2efr1qUznAcN5OFDHY0dmqNH775s1miCqyvHpUuXjvdly1fkSXvaFi1bgS0+ftxjI+jvhKfVePbMGezbu4cFYqEixVhDkrbCRYvxeVI2ofvRQXMpZuZ1uKdZsmQp7jEKQkxFBJxgtNSsZYq8efMrQuIUbKwsMLB/f177s95rDa/pqV6jBk+M17Gsjzdv36Bd69aYNHECWrVojrt3b8PKugELxHr1LHj+y335UoweNRLdunbBhnWeOH/ubFCvjyhYqBBaK9coWKgINm9cx3N3FStWRJ48+bEnYBfGjB4Ft7lz0LyxPcxNTYKsridOnBiv37zha4e22u65ZjW+fv3C84OkHanb1nitY1VuGv7cGMZcnCAIIuAEI4aEz/hJU1ClanWcOX0Ky5cuxA5fH2TNlh3Ow0agbNlynG7osGGwb9wU9+/ewZSJrjh6+CCHXUaM4POFCheGy6ixrJU5Z+Y0XldH83kjRo3h88GhHlTHLl15zm7a5EmIFTs2Jk+fjqLFSmDurBkY6TJE6VWlwIjR45AhQwb+jal5XRZibrNn4pwiNHXQ/ODWLZv52KyOOe910N8xNdPaCNy08cfalIIQU4mlVERNX0dHWFhaomIl7UI+QfhbyLrHkoXz+PjwsVNs8SA6oUXdNN+WLXs2nicLD5o7o3VB4WmK0Rq3f5Ue15/kh7TRaBg0myJg48aNq8Zqod5cYqU3GZOGFMlQb8liWq3RZi3bwGW4tkEhCH/LnoAAbFi/XnpwQsyAhiJpCPFHwo0g4fMjNeisWbP+sbAmpZRcuXJ/J9wI6s3JfJkgRCwi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJwiCIBglIuAEQRAEo0QEnCAIgmCUiC1KIVIIbovSrmFj/BMvHh8Lgo5PHz9i9aoVfCy2KIWIRGeLUgScECkMdXbGogVz1ZAg/JgWrdphqIuLGhKEv0OMLQuRSrkK5ZEkSUiP14IQFkmV94TeF0GIaKQHJ0Qa5Gn6g+pJW9DSqIEtVnqsUUMCET9ePPZvJwgRhQxRCkI0YG1ZD17rxQO3IEQmMkQpCIIgGDUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJwiCIBglIuAEQRAEo0QEnCAIgmCUiIATBEEQjBIRcIIgCIJRIgJOEARBMEpEwAmCIAhGiQg4QRAEwSgRAScIgiAYJSLgBEEQBKNEBJwgCIJglMTSKPR1dISFpSUqVqqkRguCEBEsWbIYXz5/UUPA0kUL0LRFKzUExIkbB82aNVdDgiBEBHsCArBh/XoRcIIQmfTu2ROeq1eqoe+xsWuECZMmqSFBECICnYCTIUpBiES69+iBJEmSqqGQUDydFwQhchABJwiRSOYsWWDfpKkaCgnF03lBECIHEXCCEMl0694D6dNlUENaKEzxgiBEHiLgBCGSSZIkCZq1aqOGtFCY4gVBiDxEwAlCFNCuXTvkzVeAj2lPYUEQIhcRcIIQBcSOEwdNm7fkY9pTWBCEyEUEnCBEAfv27cW8ObP4mPYUFgQhchEBJwiRjNvcuWjbohmuXbvCYdpTmOIFQYg8RMAJQiTx7t079OrRHSNdnPHm7RuOK1mqLO8pTPF0ntIJghDxiIAThEjgwvnzaGhrA681qzj8779J4DJyDNasXcd7ChN0ntJRekEQIhYRcIIQwaz18kLjBjY4eeIoh3PlzouFS5ejWfMWHKY9hSmeoHSUnn4nCELEIQJOECIIjUaDkcOHo0/Pbnjy9AnH1TI1x2rPtShVqjSHdVCY4uk8Qenpd/R7uo4gCH+PCDhBiAAePLiP5g5N4DZnBj5/+Yx4/8RD1x69MXf+AiRLnlxNFRKKp/OUjtLT7+j3LZo24esJgvB3iIAThL8kYPduNLSxxu5dOzicNk06TJk5G70d+3D4Z1A6Sk+/I3b57+Dr0XUFQfhzRMAJwl8wZ/ZstG/dAtevX+UwaUmuXOMJMzPt0OOvQunpdzotS7oeXZeuLwjCnyECThD+gLdv36JHt64YPWIo3r57y3GNm7bASo/VyJYtO4d/F/od/Z6uQ9B16fr0d+jvCYLwe4iAE4Tf5OyZM2hoa411Xqs5TH7dXEaNxajRY/DPP/9w3J9Cv6fr0PV0fuTo79Dfo78rCMKvIwJOEH4DL881cLC3w6mTxzmcO08+LF62Es2aNedwREHXo+vS9Qn6e/R36e8LgvBriIAThF/g65cvGD5sKPr26oGnz55ynKlZHaz2WoviJUpwOKKh69L16e8Q9Hfp79N90P0IgvBjRMAJwk+4f+8emjd1wHy32SGWAMxxm4///kumpooc6Pr0d4IvJaD7oPuh+xIEIXxEwAnCD9jl748GNvURsHsnh8kT9/Q5br+8BCCioL9Hf1fnGZzuh+6L7k8QhLARAScI4TBzxnR0aNMSN29e53CZMuXhvsYLtWqZcjiqob9Lf5/ug6D7ovuj+xQE4XtEwAlCKEglv3vXLhg3egTevX+H2LHjwKFZSyxzX4XMWbKoqaIH+vt0H3Q/dF90f3SfdL+ylEAQQiICThCCcfrUKdhZW2H9Wq22YtIkSTF81FiMGDX6r5cARBR0H3Q/dF90fwTdL9033b8gCFpEwAmCymoPDzRt1ABnTp/kcJ48+bFouTuaODhwWN+g+6L7o/sk6L7p/ikfgiCIgBMEVrkfNnQI+jn2xLPnzziutlldeHh5oXjx4hzWV+j+6D7pfgm6f8oH5UeWEggxHRFwQozm3t27aObQGAvnzcHXr18QP1589OjdF7Pd5kX6EoCIgu6T7pfum+6f8kH5oXxR/gQhpiICToix+PtrVe33BOziMKngT5s9Fz169uKwoUH3TfevW0pA+aL8UT4FISYiAk6IkUybOgUdWrfErVs3OFymbIVoXQIQUQQtJVDyQ1D+KJ+UX0GIaYiAE2IUb968RpdOHTFh3Gi8//CeVe2btmiN5ZGwBMDa0gIlixTC8WPH1JiogfJB+aF8Uf4on5RfyjflXxBiCiLghBjDqZMn0cDaGps2rOUwqdiPGD0Ww0eMRNy4cTkuInn9+hUeP3nE5rWiGsoP5Yvyp1tKQPmm/FM5CEJMQAScECNwd1+pXQJwRvtxz5uvAJau9EDjJlG7BCAwcB/fy4b16/D40SM1NvKg/FE+Kb8E5Z/Kge5BEIwdEXCCUUOq8kOdnTGgryOev3jOceZ1LeDhuRZFihblcFTw6dMntGjqgEZ21nBy7IlunTugSoWyWL9unZoi8qB8Un4p3wSVA5UHlYssJRCMllgi4AQj5vbtW3BoZI9FC+aGWAIwc/ZcJE2qHbaLKrb5bIX/Tj9YWNlg/6FjmDxtFnLmzotz586qKSIXyi/lO/hSAioXKh8qJ0EwRkTACUbJ9u1+aGhjjX37AjicIUMmzHSbH21LAFKmSoVYsWJh04Z16NCuDS5evIDpM2fBqf8ANUXUQPmncqDyIKh8qJyovATB2BABF4OZ5+bGWn5mtUxCaNc9f/YMJlUr87m1Xl5qrOEwdcpkdFaEyJ072p5JufIVscrTCzVqmHA4OihbthwGDRmOwkWK4sTxo5g5bbJSxpUwoL+TmiLqoHKg8qByIaicqLyo3KKDnTt38LtWo0qlEPOSewICOL53z55qjCD8HiLgYjCtWrVCpixZcO7MaUycMEGNBSZMGI/Lly6ikPIxrm9trcbqP69evUKnDu0x0XVM0BKAZi3bYOkKd2TMqO2xRBdPnz5FtuzZWKvRd2cAuvfqi3/ixcOKpYuiRNkkNFQeVC5UPrqlBFRuVH5UjlEJzU+StumVK5cwdsxoNVaJ/6yNf/dOvCQIf4YIuBhM7Dhx0G/AQMSjD+2SRTh9+rTSuzgOjxXLkCRpUvQfOEhNCT63yt0d+/btxdevX9VYLeRZmnp6K5YvYy3B6IDum6zpb9m0nsP/Jf0Po8aNh8vwEZGyBOB32bB+PVo1a4I+vXrg0MED+Pfffzk+Teq0SJEiBR9HNVQuVD5UTlReBJUfWT+h8owOPFev+qnllQ/v32PbNh9W0BFTZMKPEAEXw6Ghs0ZNmyut5HdKC36c0pNzxYcPH9CmfUfkzpOH0zgPGggLs5ro17sHGtvZoFmTRtwjITzXrIZJtcro2a0TBvRzZC3BVs2b4fPnqFv75b5yBZo1bojz585wOF/+gqwab2/fiMP6QIuWLdG+U1fcuXUT/fv2xkgXZ6RNmw7Dx4zlhkZ0QuVE5UXlRpw7e5rLk8o1KkmeLDkrv0wYNzbc92fWzBkoXrgA2rVqju5dOvAwrzh8FcJDBJyAvv36IXuOnNjhtw27dmxH0eIl0LlLVz7n5bkGSxbOR/GSZeDuuRZNmrXEnt27MH3aVD6/bMliblF7eK3H7r0HUKeeFTQaDc6fP8/nIxP6CA5WhO+Afn3w4uULjjOva8kq8YWLFOFwdLJt+05cv30fJUuW4nB/pbd8+MRp+O7cjcCDR+Hnv1tvTINReWmXElhymMqTypXKN6oaKxWrVEOp0mVx6uRxzJg+TY39xv79gZgwdjQSJ/4XLqPGYozrRCRPkRLjlTg/P181lSB8QwScwB+MHr0d+ZiGrZwGDgoa1tu7Zw/vaS0VeYwuW74cn9sXsJvjkymtbpor6dyuLcYrPUBTMzMsWLwEBQtqewORBam2N21sj6WL5nOrP0H8BOjdtz9mzp6DJEmSqKn0DxoOzpUrN9KlT6/G6A9UblR+VI5UnlSuVL5UzlGxlIC0TPs49Ue8f+Jh/pxZeHD/vnpGi//OnWwVpnGz5mimbPaNGqNF67Z8n1u3bFFTCcI3RMAJTMVKlXmfKHFiHrbU8fTJE96vXLYE3Tp1QP8+vZEgYULWtCQGOg9BPUtrpZX/CRvWeSpp2rMG5tEjR/h8ZODruw0N6lshcJ9W+OqWAHTt1p3Dwt9B5Rh8KQGVM5U3lXtkU7p0Gdg7NMPLVy8xb+4cNVbLzRtaw9jp02u9JRAZMmqPnzx+zHtBCI4IOOGHpEiZiveDhrrg9PlLOHTsJGa7LYCv/25WNnmn9Opqm5vjwNETmDJ9tiIoq7A23Lq1kbO8YPKkiejSvi3u3rvD4QoVq8DDax2qV6/BYSFioPKkcqXyJai8qdyp/CObPn37IUuWbLh86YIaoyV1mjS8v3Dh2/D3ubPahfIZMmbkvSAERwSc8ENMzWrzfr7Sml66ZAmc+vaBg70d70nAdevcEZ3bt4Hr2LH4QkOFCRJy+ogegnvx4jk6tFM+sBPG4cPHD6za3qJVOyxdvkLpaXxr0UcnNFdF92ksULlS+VI5U3lTuVP5d+rQDi9fvlRTRTw0VNotjAX59etbI1HCRKzxO8R5MIa7DFPey9n4998kaNK0qZpKEL4hAk74IaQE4ewyAi+eP8fg/n2xcZ0nqiit+yHDXHguznXSZBQtVgJuc2agV7fOCNi1E/ZNmqFtu/bqFf6eo0ePshX8rVs2cjjZf8kwetwEDHVx+WUNRNL6LF+qBC8cPntGq22pY/euXRxvblqTFWSC075ta+TLmY3V0sNjx47tsKxbB4Xy5kKRAnlRulgRDB3ijI8fP6op/p7K5cvy9qeQB4GVK5aroV+HypfKmcqbyp3YsmkD7Opb8XOJLGxs7VDL1FwNaaF54LETJyNXnnws5ObPnYVMmTJj0rQZyJcvv5pKEIKhVGhNn969NQG7d9OhIITLtWvXNA8ePFBDIbl//57m7Nkzmvfv3qkxEcOypUs1iuDQZMmQhjfzWjU1ysdaPft7tG7RnK8xdsxoNUbLoIEDOH5gfyc1RsuC+fOC/u5W7y1qbEjOnD6tyZM9C28O9g017dq00hTOl5t/owg5NdXfUyBPTt7+hE2bNmpyZ8us6d+vrxrzZ1C5U/nryoSeCz2f6ODFixeae3fvqiFBCAnJsz6OvTXSgxN+maxZsyJ16tRqKCRp0qTlVnT8BAnUmL+DrFsMGtAfgwf0Y4UDoq5FfXh4eaFgoUIc/l2qqaa6du3cwXtCqQsIUBcWm9Wpw3vi8uXLmDpxvBoKH1qUTFZArO0aYulKd8xxm4+BQ1zYoPHRw4fVVFpoCJPMT61ZvZqvHxqy7L937x7uaVG6H3Ho0EFedH/njnYukiDDzR6rVmkX46teAmgo8fSp0zy8qAiFv1L+oXKn8qfnQNBzoedDz4meV1RCxqPTpkunhgQhHEjaSQ9O0CduXL+uaWBdP6inkDdHVs20qVPVs3/OmzdvgnpXx44e5bhd/v4cNq1RjcPE169fNQ6N7DXFC+XXtGzelM+H14Nb7eHB56k301dpMe7YsZ1/HxovT09NicIFOS1tOTJn0DgPHhSUlnrADW1tgs7TRmHqqRDBe3BTJk/m82a1TIJ61NRbzJYpfdBvG9nZah49fKjx8/MNiqOtasXynP5voedBz0V3XXpe9NwEQR+QHpygl9Bcl72tNQ4c0Jr8ypQpC2bNW4AuXbULz/+GRIkSoXpN7cLqzZs28V63QLiaSU3eEzOmT0fA7p3o3rsPkif/sRktG1tbXhxNvZlVK5ehZdPGPFdGC6Rp3SDx4MF9DBnoxAatHfsNZFc5eZTe7uIFbmzwmhg/bhz2B+6BXcPGWLzMHSY1a3N49qyZfF4HOSqdOtEVOXLk4t4i9ajJeerCeXNQtFhxuK9Zi2YtWrOXADKeXCB/ATRq0px/W7WaCbr17M3Hfws9D3ou9HwIel703H40VykIUY0IOEFvmD5t2vdLADzXomrVahyOCExq1eL9Ln/tMCUNT5KGIGnoEaSMMWv6FFZwaNa8Bcf9CFqcTIujZ7ktYOFE6u23bt3gBdId27XhNNv9/FgA1rWsz4LBqn599O7bj8+R9Rhi354Avg/nocNQpWpVjBg1Gl4btqCXugCfIIsxw50H8WJnx35OyJQ5M8frFuMXLlKMhWq58uV5sTRdk4bx8ubLx+fTZ8gQocaz6bnQ8wm9lIAaCIKgD8Si7lxfR0dYWFqiYqVKarRgSBw/dgyuY8eoIcNEeQ0RqPQ6aE9UqVYDCxctiXA7jTQ3VblCOdy+fRMDnYdhpMsQlClTnt3HEN26dOYF6+RKJknS/3Dx/Dlcv34VZcpWgJUiHBo1bsLpdJAfNVqAbF6nDs9D6uJ6dOmE169fISDwIBYvWgS32TPQpVsvOPbty2lu3byJSuVLc0+MTHblzpaZrZycuXiFz4emYN5cfD2yOkM9QZNatTFvwSI+16ZVC/ht28oq9MHLK75yPTINtmTxYgwZ5ITGDs0xasxY9WzEQWXaskUz7Nq5ncMk9MuVr8R7Q6avU/8o9fouRBw0h71hw3oRcMYAWfqfOX0axoxzVWMMk8EDB2D92jV8TL0ZGmpzHjIkwoUcGY9eovSwyII+2VzsN2AwOnbqzOfatWmNbVs383FoOnTu9p2D0s4dO2DzxnXo1LUH+iq9KoLWwlWvVAFPnj7Btu27EKBUtuFDB6G2eT3MnqsdkiQbn726d0G16jWxcMlSVFPSX7t2BT5+/siTN6/Sw/THKveVKFuuHPckScBRD27+4mWYNWMaWxeZNmsu6tWzQL8+jjw86jJyDKel5Qn7AwNRtFgxVsZYsngRnAc6wb5x0wh/R0i4uQwbxuVJJrMIy/q2GD5yFB8bKrTOs0vXbshfoIAaIxgSOgEnSiZGAKmqd2zfTg0ZNhMnjGeVdp3yQuOGDTR379xRz0YMgYH7gq5P6v3hLX0gevXozunCUzKheFIYyZklo6Z9m9aaAU5OGnNTrSp9PXMzTvP48SNN2RLFNFkzplWu14OXKZQpXpSVQrZu9eY0o0aO4N9Y1DHXuI4bx0ovFJ49axafD65kQnWVflu7Zg2NIsxYsYWuXaVCOc3ixYs0Pbp149/S/RA6RRhS8Z8w3pXjIgJ6LvR86Nq00XOj52cMUH2ieiUYJqJkIuglPXv1xrTZc5E+ndY6yd49u9g/GXl9jijI1mb+AtqlBpWqVgt36cOvYFrbDM7DRyJDxkzY6r0Jy5cuxPVrV1GpUlWMGjuO06RMmQqTZ8xEuXIVsUXp7ZE37zhx42LkmHEwNa3NaXr07AVaIH/h3BlMnzKBr0HOSNu1/37BPI201LWwYrc2c2bPQrVq1TF0+Gi8ef0azgP6Ya3nKlSqXA1DXYZz+spVqiBr1uw4c+Ykli6cz3F/Cz0Pei70fAh6XvTc6PkJgt5A0k56cIaNMfXgdIReKkA9ralTJqtn9RNS9T9/7pzmy+fPasz3vH379ofq9B8+fNBcOH+e0/0J4S3G//Tpk+bSpUu8/1voOdDz0D0bY1wiID04w0Z6cIJekzlLFixf5YGmLVrzfBwtpp4wbjS6dOrIShb6CCmZ0PzZj+YMEyZMyHkLD1I0IUezlO5PCG8xPplVy5kzZ5AbpD+Byp3Kn54DPQ96LvR86Dn9KE+CEC1oZJmAoMfQx3j4iJEYMXoskiZJynGbNqyFbX0rnDxxgsNC1EDlTeVO5U/Q86DnQs/nb4SmIEQmIuAEvadxEwcsWbEKefNqDerS3FOzxg150bMQ+VA5U3lTuRN58xXA0pUe/FwEQZ8RAScYBKTyTv7JzOtacPj5i+cY0NcRQ52dg+wuChELlSuVL5UzlTdB5U+Lu2V9mGAIiIATDAZa0zVz9lz06N2XjRnTuqtFC+bCoZE9bt++pabSXzQaTdBCdn2HypPKlcqXypnKm8qdyp+egyAYAiLgBIODVOpnus1HhgyZOEx2FxvaWLMFEX3k8OFDaO7QGIXz5+EF26Rer882G6kcqTypXAkqZypvKndBMCREwAkGSY0aJmxei0xqEXfu3ELndm1ABob1ievXr6NT2zbYv28vqlY3gaW1La5duYLunTogMFBrUFqfoPKjcqTyJKh8qZypvAXB0BABJxgsGTNmwtIV7rwgWreUYKLrGHTq0B6vXr1SU0Uvfr6+ePbsKewaNcG0GTMxavQYtG7fEe/ev8NWb281VfRD5UXlRuWnWwJA5UrlS+UsCIaICDjBoCEVdZfhIzBq3Hi2LUls2bQedtZWOHH8OIejkzZt2+LspatwHjJUjQEuX7rI+9Sp0/A+uqFyovKiciOoHKk8qVxlCYBgyIiAE4wCe/tGrLqeL39BDp8/d0a7lGDlCg5HJ//88w8v4CbIsPkaj5XsYqZFy5+744lsqHyonKi8CCo/KkcqT0EwdETACUZD4SJFWIWdHJAS5ClgQL8+7Hz08+fPHBedjHd1hYf7Mp7Xmu02j13fRBdUHlQuVD5UTgSVG5UflaMgGAMi4ASjIkmSJOyAtHff/kgQPwGruJPz0aaNo38pwZ7d/izUZs1x4/uMLqgcqDyoXKh8qJyovKjcovO+BCGiEQEnGCVdu3UPsZSA/Kc1qG8FX1+tB+3owLxuPV5Llix5cjUm6qH8UzlQeRAZM2bmcqLyEgRjQwScYLRUr14Da9au5/ku4u69O+jSvi0mT5rI4ahm04YNmD9nFjsujQ4o35R/KgeCymW11zouJ0EwRkTACUZNuvTpsXT5CrRo1Y5V3z98/IDJE8ahU4d2ePnypZoqanj+7CnuP7iHr1FszYTySfmlfFP+qRyoPKhcqHwEwVgRAScYPeS+ZqiLC8aOn4TkybTDg1s2bYBdfSscPXqUw1HB7n37cf32/T92hfMnUP4on5RfgvJP5UDl8SO3PoJgDIiAE2IMdg0asAp8gQKFOXzhwlm0aGKP5cuWcdjYoHxR/iifBOWb8k/lIAgxARFwQoyiYKFC8PDyQj1Law6/fPUSgwf0w6AB/fHp0yeOM3QoH5Qfyhflj6D8Ur4p/4IQUxABJ8Q4SFWfzGY59huIhAkSsqr8siUL4WDfEDdv3FBTGSZ0/5QPyg/li/JH+aT8Rue6O0GIDkTACTGWLl27Yta8BciUKQuHDxzYB3tba7229P8j6L7p/ikfBOWL8kf5FISYiAg4IUZTtWo1tt5RsdK3pQRdO7TDpIkTOGwo0P3SfeuWAFB+KF+UP0GIqYiAE2I8pCq/ZNkKtG7bIWgpwZSJrujQtg1eqJ6s9RW6P7pPul/dEgDKB+VHlgAIMR0RcIKgQCrzg4cMxbgJk4OWEmz13oQG1tZRupTgd6D7ovuj+yTovun+KR+yBEAQRMAJQghs7eywfNUaFCpclMO6pQTLli7lsL5A9xN8CQDdL9033b8gCFpEwAlCKPIXKIBVa7xgWd+Ww6RqP6h/Hwzo7xTtSwno79N90P3olgDQfdL90n0LgvANEXCCEAaJEiXClGnT0bf/IFa1J1YsXYQm9g2ibSkB/V36+3QfBN0X3R/dJ92vIAghEQEnCD+gU+cumLtgMbJkycbhgwcC0cDaCj5bvTkcVXh7b+G/S3+foPuh+6L7EwQhbETACcJPqFS5Mjy81qJyleocJoPJXTu2x4TxrhyObOjvdO/Ugf8uQfdB90P3JQhC+IiAE4RfIE2atFi8bDnatO+EuHHi4uOnj5g2eQLat20daUsJ6Lp0ffo79Pfo79Lfp/ug+xEE4ceIgBOEXyRWrFgYNNgZ4yZNQcoUKTnOx3szbOtb4fDhQxyOKOh6dF26PkF/j/4u/X26D0EQfo4IOEH4TaytbbBs1eqgpQSXLp5Hy6ZNsGSxVvnjb6Hr0PXougT9Hfp79HcFQfh1RMAJwh+QL19+NoVV36Yhh1+9egnngU7o368fPn78yHG/C/2Ofk/XoesRdH36O/T3BEH4PUTACcIfQo5LJ02Zgv6DhiJRQq2a/srli9G4YQNcu3aVw78Kpaff0e8Juh5dl64flQ5SBcGYEAEnCH9J+w4dWGU/a9bsHD58aD8a2dqwav+vQOkoPf2OoOvQ9ei6giD8OSLgBCECqFipEjy81qFqNRMOk0o/qfaPHzeOw+FB54MvAaDf03XoeoIg/B0i4AQhgkidOjUWLlmKtu07By0lmD51Itq2bonnz56pqbRQmOLpvG4JAP2Ofk/XEQTh7xEBJwgRCKnwDxw8GBOmTEeqlP/jOF8fb9haW+HQoYMcpj2FKZ6gdJSefidLAAQh4hABJwiRgKWVFVZ4rEGRoiU4fPnSBVb9HzSgP+8pTNB5SkfpBUGIWETACUIkkTtPHrivXgMbu0Ycfv36FZYtWch7guLpPKUTBCHiEQEnCJEIqfhPmDQJA51dkDhRYo6j/aAhwzlelgAIQuQhAk4QooC27dphwdLlaNaiNe/btG2rnhEEIbIQAScIUUSZMmXhMmIk7wVBiHxEwAmCIAhGiQg4QRAEwSgRAScIgiAYJSLgBEEQBKNEBJwgCIJglIiAEwRBEIwSEXCCIAiCURJLo9DX0REWlpbiosNAePLkMfx37lRDFH6CHX5+sGuo9S5NJEueHDVqaF23CILwY7Zv9wvh8WH1qlWobmKClClTqjHkyqiaEk6lhgR9Zk9AADasXy8CzhD5/PkzzE1r4uKFc2rM9/TtPwidOndRQ4Ig/IiZM6Zj3OgRauh7cufJhy0+vogbN64aI+gzOgEnQ5QGCFWytu07qqHvocrYrr14gxaEX4XqC9Wb8KD6JsLN8BABZ6DYNWiAMmUrqKGQSGUUhN/jR41GqmdU3wTDQwScAdOpS1fEjh1HDWmRyigIf0ZYjUaqX1TPBMNEBJwBU6VqVdQ2r6OGpDIKwt8SutFI9YvqmWCYiIAzcLp274EE8RPwsVRGQfg7gjcaqV5R/RIMlwjVovz48SO2bvXGJ2UvRB3rPD2xd28A+g9yRooUKdRYISrIkSMnihYrpoYinuPHjuHKlctqSIgKnj59itEjXFChQiVY2diosUJUEC9+fJia1ka8ePHUmD8jUpYJ9OndC6tXrVBDgmD8xPsnHjy81keKkCPh1sDaEh8/SYNRiDnYNWwM1wkT1dCfESnLBG7dvKkeCULMgITPpUuX1FDEQtcV4SbENCJSjkRoD87ezhb7A/cgQ4ZM6NWnrxorCMbHuXPnMG/OTD52nTg1UjRXV3t4oE+vbnzcpn0n5MsX/jotQTB0JrqOw507t1C2XEW4r16jxv4ZkTJEqRNwOXPlgd/OXWqsIBgfnmtWo3cPrcZqVAi4CZOnwcbWjo8FwRgxqVYFly9diFABJ1qUgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJwiCIBglIuAEQRAEo0QEnCAIgmCUiIATBEEQjBIRcIIgCIJRIgJOMAhevXqFr1++qCFBEP4GqksvX75UQ8ZLtAq4lSuWo2SRQmhoY63GfGPk8OF8bojzYDVGy+3bt1C+dEnewqNDu7b82w3r16kxEU/ZEsVgUrWyGtI/NBoNFi1ciGvXrqoxP+fAgf1sgkpHndq1uBw/vH+vxkQ9Dx7ch521FYoUyItC+XJj967vTcDdv3cPs2fNUkOAU98+fN8bN25QY2IG9MzNaplw3r29t6ixWsiAbamihbnePH/2jOPc3VfCxsqS0zdqYItDhw5yfGh8tnpzmjatWqgxEc+okSP4byxZvEiN0T/OnjmDpUuWqKGf8/btW0ye9M0q/qyZMziPweOiA/r7xQrlV+pUHnTv2kWNDQl9m0+dPMnHR48e5ftu17oVhw2JaBVw5nXq4N37d8qHdR9OHD+uxmrZ7uuDx08efWcfc9gQZ9y9exsfP3xQY77n3ds3/NvPnz+rMRHPkyePgz4U+kiXTh0xdHB/vHzxa620Ve7ucGhoh/Pnz6sxQPLkyZEqdWrEih19r8n6detw6OB+FCteEh26dEORokXUM1pIgJvXqoEdftvUGOX5v3unff6fIu/56yOxYsVCsRIlOe9+276VB7FhwwY8evwQ+QsWRDLluXqsWoX+fXrhwf17KFy0GA4pjZs+PXuEWWc+fPzI13z7+o0aE/G8VxpR9Dc+fvykxugX27f7wcayLo4fO6rG/ByLOmZYMHe2GgISJEjI9Yn20cni+W549fo1unTvhdrm5mrsN8g2cf++vfHk6RMOf/78iZ/NmzeR9/wji2gVcP/9lwxVqtXg402bNvKe2Lt3D65evYysWbPDxKSmGgssXDAfvj7eaujX2b8/kAXop0+f4Ofny61bXa+EWideXp54+PAhh4nr169j3769ePHiOX9AyejtuXNn1bPhc/HCBRYU1MsI/qGga9D1aJjtgiJA1qxejZs3bvC5x48e8d+n+wiN7m/7++9kZ7I66F7pevfu3mVBu27tWk5DLXiC7uPG9Wt8TAKLer0EDUvs2LEdy5ct4/S6IQpy8Hju7Fl8Ul5kEtq6xkaP3o5wHuaCf/75h8ME/Y2DBw9wHigvwbl65UpQPqkM6d6PHjming0fyhvdF+VDd68E5V/niqZg4cKoULESvzM6+F4OHMTTZ0+5tUx/O/QHmsqCPubU+g4N3T+dI8OskdkYikrMVW/Uu5TyDP7O7N2t7fnWUOvT8qXansjUmbOxYPESNG/dFqXKluN36mfQu6urH5cvX+Z3gZ49Qe/SWi8vfkd07yOVLaU/ffo01zsfn63cK/zZyMCbN685Hb0Xwe+L6jFdj+okpdmsfDvo/aG/Q3+T6h+N3tD9BYf+HtV/L88137lkod7r4cOH+Pf0vaCRDBoZIOhvnDxxghvjr5Q6E7ynS+8o5Z/yTO+aDqrPt2/ewJevX4PKqpapKdenOkrDPjg0SkF/j/JAjTMd9Px0+dTdO41KUP36GfRc6N2mvOiG9nX17NnzZ0ibJi3KlS+PMmXK8jkd9BxvKHkirl29yvU4OFTPNm/eFObzC/68dGUX7SgPVNOnd29NwO7ddPhXNLS10WTJkEZTo2plNebnKA+Wf1OrejU1RqMZ4jyY44YNHaLGaDTKh05TtEBeTYumDpoShQvyFh7NmjTi39O1iQJ5cmqqVaqgsbO24njaGthYa/o79QsKFyuYT3P82DFOP3SIM8cp3XdNziwZ+ThH5gyaKZMn8XmC4oPfw6iRIziN7nr0t+7eucPnBg7oz3FKryooTf7cOTSTJ03UKF3/oN/QNXTQudzZMgedq2duprly+TKfW7xoIcd16tA+xO/btWnF5zt37BAUR9t413GaZ0+faizqmIeIL1O8qEaprEHPQLfR3yIqli3N4ffv3nF461ZvTbmSxYPSZc2Ylt8d5YPD53Xl6dirpyZX1kxBacaNHcPnw2Kem5umYN5cQdfMmyOrZtLECXxugJNTUDxtpjW+vSME3Vfw87Q9evhQ061LZz5u3aJ5iOdHf0vHiOEuIZ5XA+v6GuUjqp79OWtWewT9VvmQqLERC11X9zfo7/0qNatX5d94eq7h8K1bNzmvRfLn0SgfKN7oudDzPXLkiGb2rFka5cPHacNi/fp1fL1GdrYcHu4yjMP0numeMz23iRMmaMqWKMZh2oYMHszpHzx4wGHLuuYa81o1g87T+3j//j1OM3jQQI5zmzuXw/ReUp3VpaU6vGTxYj534/p1jqtvUS8or7R1bN+O64AuTL/XPdMzp09ratesEXSO7pfyrYPea9ratv72e/reKAJGozS4g+JoozwS06dNC3q/dBt9u4jg90Xbli2buU7T8ZjRozgNPYf2bVprsmVKH5SOvp30Nwmq7xRH35K6Zqbf0lSppHn8+BGnCQ2VjbWlRVBa2uhbd+3ataDrBd+8PD3VX2rp18cxxHn6Bh84sJ+P6RtNdVB3rr5FXc2HDx/4d5SmasXyQeeoTi9dsoTP/SqUd/otyZG/heQZfZuiXcmknoUlUv8vDS5cOMtzQESA0rsg6taz4L1yvxg2eBAPwQxxGc7734V6hDly5sYqz3XszufA/r04qrTYFi9zh3ldC+4FrFu3Vk2tJXBPAMZOnIyx4ycjceLEmDFlEk6fOqWe/ca2bT6YO2s68uYvgJWrvdC6bQelZxEIRSCqKbScPX0K8xYvRYvW7bi1M3nCOLTt2ImvT6xx13pDp3KYNmkCMmXOgmUrV6Nrj95KC/IoJox35fM6dvptQ/fefTBn3kL8l/Q/+Hhv5l6JXYOGyJ1H6zusVx8n7gXv2LlD6Z09RQN7B6xeu4G95t5/cA9+vr4oWbIU6ts05PS1zeqibYcOfBwcut9B/fri0aOH6N6rj9Lyn4PiJUrDw30Zpk2dqqbSclBpNU6bPVdprY7gZ7d6Zdhe3qmnOHak0kOMG1d5riO5HNKkTYcpE12xYcN6WNa34mdD2Ng1UsqhJx/roJ4l5Y+g/I4cMx5J//uPwwT1BucvXgangUPw+ctnrPFw53hqZbrNnoF8BQry82qlPC8aJp8yWfscDJ1qNUx4779jB+/JbQjlv3pNUyRMmBBXlFY6PZeXSq+isZ01xowchpZNG0P5mHH6X+Xk8WOYPX8h2nfqyr2bKRPHoUnzFpg4dQbixokLj5XL+O/oOH7sCIoUL44ly1fBpFZt5fkfwZRJIeuIjlHDXbjODhoyHLPmzkfKlKngOnpEiJ7c0SMHYWpmjqUrPJA8WXJs2bQeb16/5jpdpmwF/v3GjdqRobGjR+Lc2dPo6dgPbguXIHOWbJjkOiZEr+vuvTuIq7yL9E6Y17Xkng4NkefOlRvNWrTmNBUrVYGjU3/uFVGvOEPGTFi0bCXfY6KEibDBS+vmpXPX7ogfLz7H0XtZuHDIoXWC6vNW700oW7Y8ps2ai45deuDK5YsY5NSP65sO+paUq1CR76tQ4WJK7+wiP9OwcBk2BEcOH1Dqji1mzJkH2waN+Fs3ZPBApE2XDi4jx3C6dGnTY8z4SUrdD6nLYGFlxX+DoPsxCzaEefHiOdRRvtfua9YiX/6CSvkfgveWLfyM6Xldu3aF6zz93eTJU/Dziu6eXLQLOPpIVa9Zi4+psAID9ykV8BIKFymO4kplIGZMn46AAH90Uz6sWbNm5bg/wbFvH+6S58mr/fjXVR5WlapVUalyFQ4/efyY9zosbWxhbW2Dhvb2MK9nhQ8fP/CQQWiU1gI/5CJFi/MQQ+myZfnFDtjlr6bQYmpeB1WrVkP5ChU4nDdfAbRr34GvT0Kexrzpxfbf6c8fpEJFirFH52JKOaRMkVL5YPnx73RUrFINDk2bwrS2GV+LUFrLnKf/1A99lSpVlfsqyvnYtTcQHTp2VD40x4Py+lBJnzlLFkX45+BwJuW4ntqwCI7/zp08h2NiaoaevXrDQim7wUOG8jm/bVt5r6OupRVMTWujVes2XA6PnzwO8aHTsUP5AFP+GjZpipatWnM5tGnfkdP6+vigdOky/AEhsmXPjjp16/Gxjthx4nD+iGTJkqGJgwPixYvHYcKyvjUqV6mCli1bcvjJo0e8p+dFFClajJ9XGeV5JUyQEHt2h3xehopV/frcCNylvC+Uv70BARxf09SU9+/eveX9i5cv0EVpPPnuDFDKogQWL5gXrqJJWNRU3rvq1WtwGRM0pdClazd+1+i5vVX+TvAPHL3DLsNHcPp+/Qdw3JFDh3gfHBo+pI9n2jTpkD1HdsRPkIDnCV++egk/v291gOpMb8c+Sv2tjKzZte+vXcNG/P6XKFWKw0pPh4fVAhRhlCRJUhQoWBBxlPemSLHieP/hPXyVBl5wuiuNqHLlyqNqteocfvH8OVL97388d0lQA4z88tG7t8JjNbx9t7NQPaTkg949aijTML+lIihix47NApPeywwZMvDvg7Nf/ZaMHDuW61w/Jyfl3mvw94/qhg7K54CBg/i+SpUpw3HPwpj/p2dNjXIqt/ETJ6FOnboY5zoeWRRhvmvndv4N3ReRMFEi2Ns3UhrRmTmso3z5CkiVKhUflylbBqVKleZjgjoIXbt1VwRyOa47BE2R3Lhxgxsv6dNlQNZs2bgRRc+L3q/t27dzuugi2gUcYWpmxvvdSi9jm/JhI3StUGLOzGn8Adq3dw/atWmNV8qLThsd68b+fwZ9aKkVSCRQKgyRMmVK3if+91/ef/36lfc6SMlCR4qUKXj/7FnIcX1CJyzWrlmFbp06oHf3rlwBXikPmOYLdFCrhqDeIKH7+8S/SZLwnuYRniovDbF18wa+Hm000U8freAfjP+Uj7qOxEm0efjyNWxVeionW6VHVKNqRSxbvBAfVCWdMOROmFCrn0iTJi3viTx58/L+QahWWjKlNa2D5sy+KvekCVW2xK2b2nnIdErLUkdmtcI9VnqKf0vq1Kl5Tx/IBPETKM9COyf15Il28txr9bfnFUf5EFGPxhjm4vLly4+SpcrwB2bRwgVKj3ofMmXKAtNaWgGXLWs23lMPo3WbNsiZMyfKV6zIz4kaP7+Krn78m1j77qX6n7a8iX//1b7Pwd/H5IqAow8+kVW5B3qfde96cOiDSZBw0r3/O7f78jXpg6ojpSJ4dND3gUiTNg3vE6v39PXLV+V61zlvpCTRo0snvh719uh6zxSBFBzdB/+//5Lynn4XHmPHjEbp4kXg2KMbLik9wX/+0Tauvv5ipbp04Ty/l9myZVdj6P619evB/Qe8J4LnU/ftoHyFhrzMv3n7BqkVIaybN6fvUFolTFxX5+X/lP8Fu48EihAjqL7o9AkePnwQ9LyoMR76eUUHeiHgqimtpRw5cvGQgpeHO/6J+w9sbGzUs6QV+ZaHQLZt3cwbtbyoN0XHz1+8UFP9GHrQoYkTR1vZwuPq1W8q9nfv3OF9WvUFDE5KtcXTw7EvTp+/hOOnz2Gm0k0P2H8whIJG3Lgh74FakmGRQhXEbTp04uudOncRM2a7cQ+Mhhl0BL92LOVfcGLH0j7aL+oE86xZM3H40H4e0qPrUO+G+Dbaqz0ILeR1pEuXnvdXLl3kPUHKQISu9awjeC+KPmLh8T9VAAUfJjp9WjsEnDFTyJZleOiu/yWMCh879rfyDX4fuoZFT6UsqHyPnTrLz2t34IGgD7ChU7W6toE4e/pUVh6iURJdHaAeCQ1RUe/5kapcdf/efd4nURtKvwL1UIIT3vus487tW6xQQZAKOvXU06b/vmeTJUsW3ufMlZufD20rVq2B1/pN3MPSEfrvE2E9vyxZsvKQKX3oT545z9fz8FyH1WvXY8CAgWoqLQnix9cehHpvdfXp61et8CKFmVnTp/B7uv/IMSxdsRJJkmqFYmz1t3R/pGQSHjQFQd8y3dQMcemitn7pRlSIuMr3UMeP6lN2pfdEjZYb166wsg9BCilXr1zm/BdUe6E/I1ZsXZ0KKdyD16fg0AgQkStP3qDntdx9NT8v6vFFJ3oh4IjqJtphSmp1li1fMajQiMs3buP67ftB2/9SpUaqlP/jY90wZmRA4+kjhrtg5Ijh2LJxPQ+xBB+T1kHLHejFW7poIRYvWoQBTk5o1qQhenTtqqb4PerVq4d4Smtw1fJlWDB/Hq8FbO5gj/ZKa/tXSZBI28JaoVyDNK+okUBcvXKVtTaXquuNdFpbidT0x44cwbSpU/g4OHWVe8qWLQcPFXft3AnjXV15XpRo2Kgx738XGsqiVt5q9xUYNKA/lzN9kKk13sShqZrqx+jm3Ejzi9ZS6Sr2jzALel4LeN3VAKd+/Lx6du+mpjB8qIFIHzuqTwQ9v+BY2TZgAdOjW1cMHeIMv23eXKeqVdcOzUUG1Ejt3qULZs6YjqHq+tbqJt9GanRQL4rmus6fP8vvBdWpti2b83KQY2FoG/+MRIkS8dA6LS/q4+iIJUsWo2O7NjCrWR3+oaYRwiNx4kS8p3l013FjeQSJePHsGXbu2AmXYUO5gU7Q3B1BvUiqX7SmNywtaZrPIpwce/N8HK3fpXnFcsr3j6Yyfhda/lG7Tj1+5m1btcSkiRN4T1MLtvaNQ2gg/wjdMoYN69aFWBcbHjRtVL5CZZ7jHDxoIBYuWBD0vEIv/4pq9EbAWVhaBrVOwnrpo4M6FlbYunkTKySkUITb0JGjg4a9gkNj46PGjue1eUMGObHiBb2kLiNGqil+j/wFCmD85KmIp7QmXYYMwpKF83gd2KgxY9UUP6dqtRrcE17jsRJHDh/m+TAai1/ruQqD+vVB6TJlWJBcPH9Om16pUOnTZ+QK5umxiuOCQ+PqU6bPROUq1bHD1wfTp0zg/A4eOgJ2DRqoqX4PGuKcMGUa8hcsBI+Vy7mc0yg9xYlTp6NoMe0Y/8+gykUfQ1qns9BtzndqzWFRoUJFfl6k5uw80AmrV61A+fKV/vh56SPU069YWTs/WaBg4RBzKUSPHj1Y4ej0yeNYNH8uD58PHz0mxBB0RENzdNRrdx0zUhEUJ2Ft2xCdOnVWz4bEdcIkVKlaHatWLOM6Rb2JgUOGoXiJEmqK34PqTi1Tc2xc5wnnAf1Y4cqx30CeQ/wVaJ4+Z87crAy3aN5cVswiRa179+8qDdmOOKl8yOn6xKGD2nnFWmbmPMQ53202zoexzKh79x5o17ELj5pMmzwB27dthalZHYyfNOWHPbUfMXzkKFYsuXXjOitrnTx+FE2atoSzOl/+K9D8IzWO1q9dg/37v/Uuf4TrxEn8bXBftgTDnAdwngYOcfnlehxpKK24aF0moI/olgmQGrHyoDRXr17h/a9A6ri65QERAal43759Ww39HrQ0IPhvSZ3/4sULQaq9ofn48SMvx/jy+bMaEzb0e1JHjkhevHjxx+VGz4ZUoN+8eaPG/Dp/+rz0eZnA7/D69St+J371/f4TdMsESHVeF37+/Bkf/wx6pufPnQv3nf1daGkJXU+39OV3oHpB9YPqiQ5a5vCj94fqH9XDn3Hzxo0/en/DQ1cngt/r70D1ke7pd/mb52WUywT0HWpJ0STwr7aoqEeRLr12vioiyJgxU5gaWL8CDVkE/y3NT+TKlTvEHFlwaE6PFA7Cmq8MDv0++BByRJA0adI/Ljd6Ntlz5OChqN8lop+XoUHDaPRO/GmP4U+gUZBfHS6jZ0o9/fDe2d+FFI7oerT/XaheUP0IPvdNPd4fvT9U/6ge/gwalv2T9zc8dHUi+L3+DlQfQ2tY/goR/bz+FhFwYZBeeWErVKyC/6X+pjUkCMKfEU/5yFJ9yl/g15QcBCGiEAEXBm3btcdy91WsBCEIwt9BPRiqT5OnTlNjBCFqEAH3G5BGVHALAxEJrZeLCe4rBCE4v6L1+qfQgmvNry70FIySGCvgdO54dFvpYkVQtWJ5tGzW9DtrJaSmbFqjOgrny42CeXOhSoVybF1FB5l+Cn6tciWLs6sZx149f2q8ln5b18wUhZTrFs6fG2WKF+WlCRG54JiuaVJNa23iTyAVZzLc+jPs7Ww5/2G54CCzZcHLiMrQ3LQmq+aTwWlCV46R6ZZFiBzu3LkT4vnSVqFMKa4H48eNCyFoaGFwqxbNUKxgPhQvnJ/rFKnIBzfaoHuXdFv1yhXZpQ8Z8v0R1EikpQ/kzqpooXzIlzMbmjay/y0LLT+DlrPQPdFygz+BtHdJhf9nLFu6lP8OuTkKvlaUoAZx8PKhb07N6lXR0NaGDT/roDCdD77WLiYRYwXchw9a9xy0jipPvvzInjMXL8zcucMX3Tp2COpN0Zoxcjtz/94dVCGzRFWrs4sR1zEj+AUkPiovG12L3ErkyJUb/0uTFvfu3GYV/fr16oTwVBAcEhxdO7bH1cuXUKZ8BdQ0NWPzRvPmzOS1NhHF06dPeL3On0CVxd7GKkxr/MGhRsH+wD1cDls3b+QPXnDIcgqdIwsIOZSypkWxly9ewFpPD/TuqV0MGhVuWYTIgWwz0rOj9WFUn3LnyYt06TOwtY7pUyeGaBDS2ixyb5Qxc1bUtajPS3C2btkY9B4QdB26XroMGZElW3a2NBO4bw+r5E+d8v06TR29lAbTOq/VSKLUawsrG2TJmp3XbvZShF5o7wJ/CgkourdPf+jax9rSgtd7/owtmzby36F1bKvcV6qx36BzT54+Rs7ceZRyyoDXyjeL7E72692DvQgQr1+94nTGYKHnT4jxQ5S169Tl+QH31WuwfVcAihYrwS8EufsgAvfu5dZnlx69MG/BIixeupxdiyROlBiH1DQ6yHjvqjWe2LB5C3btO4DqNWqxQeOJE8arKUKyy9+frUk0aOTA13WbvxB9+g/kNSjHjhxWU2mhF5TcupDAIRcdodGdJyeWOgsj4UGtORJIwc1+kQAjtx9UMXStbfognDlzmu/x+fNnYS5W1bFebVnTYnCyMrNy+XIOh6aaSU2s8vTCJm8fNnpL7PLfEdSLEwybpEn/4/pEdhrXrF2HQUNdOP7Ece27Q8bKaS1Z3rz5sXGLN6bPnIWVqz3ZWDhZySE3L8FxGjgQnuvWw3eHPyZOmc7agfOVBmBYIyPkDobsiZJm6KYtWzF1+gxs9N6K7Nlz4oXy/u4P1H70dZAxbnKdQ/UmuEk9HbSmkuobGf7+kckpsp1J9Sm4ayhqIHtv2cyufIK/28ePHcPNm9e5jtFvwvMpSZZSAvcF8NpBsiDivXlTmPcYRzlH3y6v9Rvhv2cfL7im+qozeRjTkTk4FXrhyHwQGR+mBdAlS2itbOvMcC2c54bhLsP4I99/wECcuXgFU6Z9a5WGJkmSJGjZWmt55Eg4wyO6RePrlF6MU7++LPCaNWuOC1dvwMPz21AM+ZgrXawwHBrZoWe3TjCtXpWHWHVQRaUhHTrv5NgTTRra8rBMWPOFZIGkodIjGzNyJC8kJ8haRJ3aJnDs2RX2tvXR3KEJVzyq+NSbJKhVPKBfHz4ODf2dbd6b2SrJAGetRXpvpRcXfFgqLIoUKcIWW+ij9av2+wTDgYwc6xzokgcPImPGjNyAu3DhHNq2bskNMrJpeeLsBZw8d5HV8MPD2sYWpcuUZ0sdJBxCQ6rp/0udht9HmmogK0CvX7/Gjt17+NpklJwggePQqCEqlSut9Pi6cL2hXhUJFR00pF67RlWub906tUf1ShVY0IWGBLK9nQ2aN7bHxYvaYUSqx2Y1a6Bju9bo3KEtalarzCNBxKABTtw7JSHUuIEN/JW0YUEWRKj+1LOqz0YjyAqLl6f2GuFBSx8yZNIaJxe0xHgBN3vGNOTKmgnZM6eHRR1T3L9/D8NGjglau9Kpcxfu1dELNn/uLFhbmKO28vJSr+xnH3CdMWKyKhDWEEGjRo14WPK50lNyX76EzXHR3BSZ5tI5E6T5CrJmQsN3/QYMZlck2XPkhNucGUFzAK5jx7KdycYOzdlVCDmRpWGZeW5ufF4HpZ85bTLy5MmPOW7zkCJFCp5bW7ZkIUqVLsuuhBo1aY7du3Zg+vRp7IWArDUQ5N6kU5ewTY95rPJg80Rk/7BmzVpsOYMsogd3YqvjqvJBmDplMjcWmjd14IqeP3+hMC3ECIYHDadp61MG5M+dHSuWLmJLMz179eLzVK/IZitZ2SHnxdQgK1uiKDp1aB9CwISHbs3Z7du3eR+aXn36cUNrn9L7oXpToXQJnu8joaODTLrtCdiFmrXM2LULucI5dfIYBivCh4ZayaMJuatKmy49u6Iilz3kyWDC2DF8Xsfr16/QpWN7/jY4DRoC+0aNuZc1cvgwjhvjOhFTps9WBG98jFP+JvXq2nXsxD1Myj+50SkRhmUWuoaP0vsj+5HkuaBGTa2T2i2bNvA+OGTMmoZsaUqjd88eWLfGg+Oj3YKInhDjBRy5zqlmUovdVJDLEGLMiGFBw3y04HHN2vX8stapZ8WuK86fO4Opk8azIPoROsOvJNy+hCHgaOEoDUuSLygbO3uldZsZN25cw+IFbujcSeuTjVzlU4vUytoOHTt15qULXXtqPxbbfbfxfs+undwqHjJ0GLsKGTVmHDZu2YauXb/ZVnyptHpHDRvCpoOcBg0K+lAEqi1hcvVD1tbLlS/HQyKBe/bwIvNcuXPzebo3C0utq43Q+Hhv4T15LCZMVKv1mzd8XyH37tmFia5juLFA/sCoZT981Gj1rGDokHV8qk81lIYOmT9LkzotCxNn1W4pQe/xmnUb0bpdRxQqXBSvlfeOrPu3a9n8u7nb0OgMLNNwZFjUt7bGRm8fdO7WkxttVPdovo96UjQ0z0ODAbt5imH8pMnsUoZMtNF9HDt6GMePH9d65P/yGRb1rbnX16ZtWyxftQbrN20JYQRh3pxZ/C2oVducvTIQNAp0UemdkvH41GnSIEnSJChYuAhPVfj772Q3U+T/kPJBbnTCWkxNPuhIQJarUIkNEdjaNWBXP+TyJ7QXfcrPRNfRmDF1EjxXu/M3h/zz0d8RRMCxW5658+Zj0dJlygu8WWlhdWafTosXLODzpLVFWpQN7RthxqzZ2H/4aJDTQF/1wx4ely9f4j1ZHA/LcoKvIqDmz5unfAjKY4JS2fbsP4g58xexax9/RbDRUMqN61pXFDo3GkT27Fr3GjScSj09ut9///036G+Q9YRChQuHqIw0L0YT9cTqYBqROlc/1NImNxc0DEnWCEK7EQkPcuVPE9vE0EEDWGOLbPUR5OKEhk+DY1bHArPcFrDTy03evtjmt+OP7QsK+gd9iKk+UcON5uE2bt3GPZZVK5byPC+9L2TgmpSpBjsPURpiW7Ftxy5uXJLDUd9t2kZbeOi8H9BQZ2hobnr5smW4dOkS+vTth9Ve67D34BHUMDHl3pbfNl+edyZhQ659qPGqQ+elg97XZ+rSBcqLDvKTFtoiCQ01Ut7IzZdOCev2HW3P8sb1a0GuYw7s38e9ykcPf22emebbiCOHDnB9ouHR9+/eceN01Sqt014d1BglZ6tzFyyGh9d6BAQe5CkUQYvMwYWChgUIasERs2dOx/Chg4LUk0loFCxYiOeNPipCI/iQRXCoZbXaQztcUKKU1klhaDzcV/K1ddqYRIniJdi8Ds1J0bo7nX+ry8Hc1OgsqpO5LBJq5PqEhBwNZxLkYZyGfKiy66CW9bxFSxRhUkqpQBtYuBK6OUZnl5Hs5uLg0ROYrQggn+1ar+qUTyI8v1ienms4r2SINnfe/KzRla9AIfY/RkJ1RShlE3LVYmZmzk4vCxYqFEIIC8YHWTEh6B2h3tSBAwfYwPX0KZM5jqB5N51vOapT4UFKHOTbjoRFOUXghIZ8Fg50csS40aN4/o+goe80qvCi9zGN0qtKqgiue3fvBNUXGhK8rLqpyZs3H/e8CJ2/QqJn9+4Y2L9/CE1MGnXpP2gIe0mYrKr9Z8ygFbzFSpQMch2zZMUq7lXqennsRiec7wYptuz238E9zMJFi3N9oo2Oia2bNoZQNiHXPGbmdVCrlik7CKb6JXwjxgu4nUpPiRyn0torWmcze4ZWfbdipcq8J6/fxOAB/XjNFimDdO/SiStnparVQ3ygqZLQtWjMv7ZJDax2X84udhz7hK2cUbeeJQuQGVMmKQKpHQb0d0LTJo14Er1kqdI8fFG/vjW7B9q0YR36Ojqyk8WJ48ayIG7UxIGvU0t5wel+6P5oLJ4qOA35BK8I1Bolrwed1GHLaZMns3DWDSu6zZnFgrZfH0eedB+o3AuRUOlNEqT9RXNnwaHrb9uymY9HjXNlbS7d1qO3I8d7KxVS9yETjB/q1VAdaNe6FZo3bcJrHWmIneZlCxcpAgtLC/ZaQcOWDWzqs9Bo0dQBu/y3s3JXbVURRMfMadNYGaVxAztWniIh1aJ1Ox66Cw15d6ehxsuXLsDGyoLrE62vW+O+gusZuQKi+mphbctzvx3bt+X1aFT3r127AvO6lsidJw/qWVhwz8zTw53XpFK9Ii8cJ08cC2FDk0yP0TBjyVJlsc1nCzYrPS8ajShUuBgOHghkRTAaoWnRxB7mNWsEaYgmVgQ0NaDpvE5bWwcplJH/PnLvE7w+kSZprtx5uZf7Ky5sBC0xXsCRDyNynLprx3acOnmCnXd279WH3csQnbt05fF8aonSmi1SBiFP3VQZBg/RagzqoAl2ulaA/06lBfkGtc3rYfFy93CNsZL7eOdhI9gNPk0g0zAhtRrJTciIUdphUBo6mTxjJkopvcANa9ewk8VEiRNjtOvEIJ9Rffr2hZ19E3Z9QmPxd27dROu2HdCiZUs+HxwTk5owrV1HqaxHMW+eG7f+Bjq74NmTxxjUv48iSNcqH4KaGDJsGKevWq0q98Yo/cqlWrV+HaTVRe5CChYqwq3H4Fha1ecPGX04NoahfSYYJ+TAk+qA7zZvHAzch/fv3qK2WV1MnKxtOJJx4vGTp6B0mXI4fOgAli9diL2KsMuXv6DSSJrwnRFvmrMlZZSzZ07xGlNyz9RbaeiFBY18TJg0BSY1a+PC+XNcn7Zt3YIMGTNxT4scKxODBzvDoVlL5Z1/wi5l9u/dw72xUaO1dY6MT48c48rDmKRFTPWeFM1objs0JDg7d+umbahOncK9VNKuLluuIhbOm8MjNCQsh44YHaQhamJam/fz5s5U8vXNjQ41BEkbmdA1PINDrnSILZu0Q5jCL6AUqrjL+QXI/QS5iCH3KpEBudwgNxM/clVDrijIfU54/I0rEILcApErk9AoPTV2E0J7QYuxuMuJTsgly6mTJzVv375VYyIOqgOnTp3iv/EjqD7/yLXLzRs3/tiNE/1tckUUlsuae3fvap48eaKGBELc5UQj1EKj1mVYQyMRAfXyaFnBj+akSPmDNBvDg+bj/tQVCEFugcJS1yfNLGp96rRCBSEiICUPmoclZ7oRDdWBggULhlAkCQuqzz9y7ULTBOGNwPwM+tvUGwzLZQ2NzNAyHSFyEQEnCIIgGCUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKIlFq77JxqGFpSUqVqqkRv8Z5HRzf+AepE2TDi3btldjBcH4IMv1ZLaNcJ04FXYNGvBxRELGuvv00toOtW/SjBfiC4KxstBtDnt6IDNnZH/zbyBnzRvWr48cAScIMYmoEHCCEFOISAEXoUOUufJo3dILQkyBDOkWKFBADUUsdF26viDEJCJSjkRoD47Yvz+Q/ZgJQkwgZ46cYXpljihu3byJy1e0blYEwdghu6Rly5ZTQ39OpAxRCoIgCEJ0EylDlIIgCIKgL4iAEwRBEIwSEXCCIAiCUSICThAEQTBKRMAJgiAIRokIOEEQBMEoEQEnCIIgGCUi4ARBEASjRAScIAiCYJSIgBMEQRCMEhFwgiAIglEiAk4QBEEwSkTACYIgCEaJCDhBEATBKBEBJwiCIBgl7A+uj2NvPLh3T40SBEEQBMMmXfr0WgH34MF9xIkdB7Fix1JPCYIgCIJhovmqwVeNBv8H6ZxDopIgszsAAAAASUVORK5CYII=" title="Internal Architecture Block Diagram for Socket Layer" alt="Figure G-2 Internal Architecture Block Diagram for Socket Layer" /></p>
<p>When a socket is created, it is marked as either an IPv4 socket or an IPv6 socket, i.e., in the socket creation the socket family selected is either AF_INET (IPv4) or AF_INET6 (IPv6). This is then used as a de-multiplexing field to differentiate which socket implementation needs to be selected. This architecture reduces the impact on the existing IPv4 implementation of sockets.</p>
<h3 id="g.3.3-socket-options">G.3.3 Socket Options</h3>
<p>The IPv6 socket layer supports all the standard socket properties except the following:</p>
<ul>
<li>SO_IFDEVICE The option binds the socket to an interface and ensures that packets are transmitted on the specified interface.</li>
<li>SO_TXTIMESTAMP This is a Texas Instruments specific option that was used for time stamping the path through the IPv6 Stack.</li>
</ul>
<p>Of all the IPv6 specific options, the only one supported is the IPV6_UNICAST_HOPS, which allows the configuration of the Hop Limit in the packet.</p>
<h3 id="g.3.4-daemon6">G.3.4 Daemon6</h3>
<p>NDK supports a module called <em>Daemon</em>, which is a single network task that monitors the socket status of multiple network servers. When activity is detected, the daemon creates a task thread specifically to handle the new activity. This is more efficient than having multiple servers, each with their own listening thread.</p>
<p>Since the Daemon operates on sockets, a new module called Daemon6 has been created that does the same functionality as Daemon except that it operates on V6 sockets.</p>
<p>The following snippet of code indicates how Echo Servers on UDP can be made to operate on both IPV4 and IPV6</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">hEchoUdp = DaemonNew( SOCK_DGRAM, <span class="dv">0</span>, <span class="dv">7</span>, dtask_udp_echo, OS_TASKPRINORM,
                      OS_TASKSTKNORM, <span class="dv">0</span>, <span class="dv">1</span> );

<span class="pp">#ifdef _INCLUDE_IPv6_CODE</span>
hEchoUdp6 = Daemon6New (SOCK_DGRAM, IPV6_UNSPECIFIED_ADDRESS, <span class="dv">7</span>,
                        dtask_udp_echo6, OS_TASKPRINORM,
                        OS_TASKSTKNORM, <span class="dv">0</span>, <span class="dv">1</span>);
<span class="pp">#endif</span></code></pre></div>
<h3 id="g.3.5-nettools-applications">G.3.5 Nettools Applications</h3>
<p>The Net-Tools module in the NDK stack has multiple applications that are provided to System developers. These applications provide basic services such as Telnet, TFTP etc. This section documents the modifications in these applications to support IPv6.</p>
<h4 id="g.3.5.1-telnet">G.3.5.1 Telnet</h4>
<p>Telnet is implemented as a server daemon that resides on port 23 and waits for incoming connections. The Telnet protocol by itself is agnostic to the Layer3 implementation i.e.IPv4 or IPv6. To be able to support IPv6 the following code needs to be added in the application startup code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">hTelnet6 = Daemon6New (SOCK_STREAM, IPV6_UNSPECIFIED_ADDRESS, <span class="dv">23</span>,
                              (<span class="dt">int</span>(*)(SOCKET,<span class="dt">uint32_t</span>))telnetClientProcess,
                              OS_TASKPRINORM, OS_TASKSTKLOW,
                              (<span class="dt">uint32_t</span>)ConsoleOpen, <span class="dv">2</span>);</code></pre></div>
<p>The code uses the Daemon6 API described above and starts the Telnet Daemon that opens an IPv6 socket on port 23. There is no conflict since the IPv4 Telnet daemon has also opened port 23 since the socket library for IPv4 and IPv6 are different.</p>
<p>With these modifications the Telnet daemon works over IPv6. There is one minor change in the Telnet code base that needs to be addressed. This is a display issue; after performing the telnet the server displays the Peer IP Address and Port Information.</p>
<p>For example, on IPv4 the display is as follows:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">TCP/IP Stack Example Client
Welcome connection : 192.168.1.2:3881


Welcome to the console program.
Enter '?' or 'help' for a list of commands.
&gt;</code></pre></div>
<p>On IPv6, the display code needs to be modified as follows to display the IPv6 address of the peer:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">TCP/IP Stack Example Client
Welcome connection : fe80::a00:9ff:fedc:fbdc:1061


Welcome to the console program.
Enter '?' or 'help' for a list of commands.
&gt;</code></pre></div>
<h4 id="g.3.5.2-tftp">G.3.5.2 TFTP</h4>
<p>The TFTP is an IPv6 client that implements the Trivial File Transfer Protocol over IPv6. The TFTP protocol uses the IP Address and Port information to ensure that data packets being received match the peer server and port information; this is typically implemented by most TFTP implementations for a more secure file transfer.</p>
<p>To achieve modularity, a new module TFTP6 has been created, which was based on the TFTP module. Modifications have been done to ensure that the TFTP6 module uses the AF_INET6 family for socket creation and the security checks are done with respect to the IPv6 addresses.</p>
<p>The following new API has been published to be able to retrieve a file over an IPv6 network through TFTP:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> Nt6TftpRecv (IP6N TftpIP, <span class="dt">char</span> *szFileName, <span class="dt">char</span> *FileBuffer,
                        <span class="dt">uint32_t</span> *FileSize, <span class="dt">uint16_t</span> *pErrorCode );</code></pre></div>
<h3 id="g.3.5.3-dns-client">G.3.5.3 DNS Client</h3>
<p>The existent DNS Client in NDK is capable of doing IPv4 forward and reverse name resolutions [2]. This is extended to do IPv6 forward and reverse AAAA (Quad-A) type DNS lookups as described in RFC 3596 [2] over IPv4 network. There is no support for the DNS client to communicate with an IPv6 DNS server; i.e., the DNS client is only capable of doing name resolutions by communicating with an IPv4 DNS server.</p>
<p>To support IPv6 name resolution, the following changes have been made to the existing implementation of DNS:</p>
<ul>
<li>A new Record type T_AAAA specific to the Internet class has been defined that can store a single IPv6 address. The IANA assigned value of the type is 28 (decimal) [2].</li>
<li>The basic HOSTENT data structure has been modified (as shown below) such that it can hold both IPv4 and IPv6 addresses.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co"> * </span><span class="an">@brief</span>
<span class="co"> * The structure describes the Host Name - IP Address record</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@details</span>
<span class="co"> * The HOSTENT structure holds information such as IPv4/v6</span>
<span class="co"> * address, host name mappings for a given host. It is used</span>
<span class="co"> * by the DNS resolver in conveying such HostName - IP Address</span>
<span class="co"> * mappings to a user application.</span>
<span class="co"> */</span>
<span class="kw">struct</span> _hostent {
    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    This is the official name / Fully Qualified Domain Name</span>
<span class="co">     * (FQDN) of the host.</span>
<span class="co">     */</span>
    <span class="dt">char</span> *h_name;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    This indicates the address family of the IP address that</span>
<span class="co">     * maps to the given hostname. The values it takes are AF_INET (v4) /</span>
<span class="co">     * AF_INET6 (v6).</span>
<span class="co">     */</span>
    <span class="dt">int</span> h_addrtype;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    This indicates the length (in bytes) of the IP address that follows.</span>
<span class="co">     * For IPv4 address it is set to 4, and for IPv6 address set to 16 bytes.</span>
<span class="co">     */</span>
    <span class="dt">int</span> h_length;

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    This is the number of IP addresses returned for the given</span>
<span class="co">     * hostname.</span>
<span class="co">     */</span>
    <span class="dt">int</span> h_addrcnt;

<span class="pp">#ifndef _INCLUDE_IPv6_CODE</span>

    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    List of up to MAXIPADDR IPv4 addresses (Network format) that map</span>
<span class="co">     * to the given hostname.</span>
<span class="co">     */</span>
    <span class="dt">uint32_t</span> h_addr[MAXIPADDR];

<span class="pp">#else</span>
    <span class="co">/**</span>
<span class="co">     * </span><span class="an">@brief</span><span class="co">    List of up to MAXIPADDR IPv4/IPv6 addresses that map to given hostname.</span>
<span class="co">     */</span>
    <span class="dt">char</span>* h_addr_list[MAXIPADDR];
<span class="pp">#endif</span>
}</code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> The field <em>h_addr_list</em> is an array of strings that holds the IPv4/v6 addresses as pointers to IPN/IP6N, respectively. The following is an example illustration of how one could use the h_addr_list field to access IPv4/IPv6 address from the HOSTENT structure.</p>
</blockquote>
<p><strong>IPv4 Illustration:</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">uint32_t</span> IPTmp;
retcode = DNSGetHostByXXX( arg1, ... argn );

<span class="cf">for</span>( retcode = <span class="dv">0</span>; retcode &lt; phe-&gt;h_addrcnt; retcode++ )
{
    IPTmp = (<span class="dt">uint32_t</span>)RdNet32(phe-&gt;h_addr_list[retcode]);
    ConPrintf(<span class="st">&quot;IPAddr = &quot;</span>);
    ConPrintIPN(IPTmp);
    ConPrintf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<p><strong>IPv6 Illustration:</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">IP6N IPv6Tmp;
retcode = DNSGetHostByXXX( arg1, ... argn );

<span class="cf">for</span>( retcode = <span class="dv">0</span>; retcode &lt; phe-&gt;h_addrcnt; retcode++ )
{
    IPv6Tmp = *(IP6N *)phe-&gt;h_addr_list[retcode];
    ConPrintf(<span class="st">&quot;IPv6 Addr = &quot;</span>);
    ConIPv6DisplayIPAddress(IPv6Tmp);
    ConPrintf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<ul>
<li>Two new APIs have been added for hostname to IPv6 address and IPv6 address to hostname resolution. The following are the two new APIs:</li>
</ul>
<p><strong>IPv6 Address to Hostname Resolution API (reverse DNS lookup for IPv6):</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co"> * </span><span class="an">@b</span><span class="co"> </span><span class="cv">Description</span>
<span class="co"> * </span><span class="an">@n</span>
<span class="co"> *      This function does reverse DNS lookup on the supplied</span>
<span class="co"> *      IPv6 Address. On a successful return, pScrapBuf can be</span>
<span class="co"> *      treated as a HOSTENT structure. The size of the scrap</span>
<span class="co"> *      buffer (size) must be greater than the size of the structure</span>
<span class="co"> *      as the structure will contain pointers into the scrap</span>
<span class="co"> *      buffer, and the scrap buffer is also used for temporary</span>
<span class="co"> *      name storage. 512 bytes of scrap buffer memory should be</span>
<span class="co"> *      sufficient for most requests.</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@param[in]</span><span class="co"> </span><span class="cv">IPAddr</span>
 *      The IPv6 address that needs to be resolved in IP6N format.
 *
 * @param[out] pScrapBuf
 *      Scrap buffer area to hold the results on a successful
 *      DNS resolution.
 *
 * @param[in] size
 *      Size of the scrap buffer available.
 *
 * @retval
 *      Success - <span class="dv">0</span>
 *
 * @retval
 *      Error - &gt;<span class="dv">0</span>, error code to determine the error.
 */
<span class="dt">int</span> DNSGetHostByAddr2(IP6N IPAddr, <span class="dt">void</span> *pScrapBuf, <span class="dt">int</span> size);</code></pre></div>
<p><strong>Hostname to IPv6 Address Resolution API (forward DNS lookup for IPv6):</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co"> * </span><span class="an">@b</span><span class="co"> </span><span class="cv">Description</span>
<span class="co"> * </span><span class="an">@n</span>
<span class="co"> *      This function does DNS lookup on the supplied hostname.</span>
<span class="co"> *      On a successful return, the pScrapBuf can be treated as a</span>
<span class="co"> *      HOSTENT structure. The size of the scrap buffer (size)</span>
<span class="co"> *      must be greater than the size of the structure as the</span>
<span class="co"> *      structure will contain pointers into the scrap buffer, and</span>
<span class="co"> *      the scrap buffer is also used for temporary name storage.</span>
<span class="co"> *      512 bytes should be sufficient for most DNS requests.</span>
<span class="co"> *</span>
<span class="co"> *      If the host name &quot;Name&quot; is terminated with a dot ('.'), the</span>
<span class="co"> *      dot is removed. If the name contains a dot anywhere, it is</span>
<span class="co"> *      used unmodified for an initial lookup. If the lookup fails -</span>
<span class="co"> *      the appropriate DNS error code is returned. No default</span>
<span class="co"> *      domain lookups are performed for IPv6, so if the hostname</span>
<span class="co"> *      provided by user does not contain a dot, implying no</span>
<span class="co"> *      domain name is provided, this function returns a format error.</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@param[in]</span><span class="co"> </span><span class="cv">Name</span>
 *      The hostname to be resolved supplied by the user.
 *
 * @param[in] af_family
 *      The family (AF_INET/AF_INET6) of the IP address to which the
 *      query needs to be resolved to. If AF_INET is provided as the
 *      argument, then DNSGetHostByName is called in turn <span class="cf">for</span> IPv4
 *      lookup.
 *
 * @param[out] pScrapBuf
 *      Scrap buffer area to hold the results on a successful
 *      DNS resolution.
 *
 * @param[in] size
 *      Size of the scrap buffer available.
 *
 * @retval
 *      Success - <span class="dv">0</span>
 *
 * @retval
 *      Error - &gt;<span class="dv">0</span>, error code to determine the error.
 */
<span class="dt">int</span> DNSGetHostByName2(<span class="dt">char</span> *Name, <span class="dt">unsigned</span> <span class="dt">char</span> af_family, <span class="dt">void</span> *pScrapBuf, <span class="dt">int</span> size);</code></pre></div>
<h3 id="g.3.6-configuring-the-ipv6-stack">G.3.6 Configuring the IPv6 Stack</h3>
<p>One of the key differences between IPv6 and IPv4 is that the IPv6 stack needs to be instantiated at run time. This is because all IPv6 enabled interfaces automatically get a link local address, which is identified by the unique MAC address. Once an IPv6 address is assigned, it is mandatory that the IPv6 stack perform the Duplicate Address Detection process to ensure address uniqueness.</p>
<p>This implies that unlike IPv4 addresses cannot be assigned to the interface before the Ethernet Link is up because this will imply that the DAD packets never get transmitted out hence defeating the overall purpose.</p>
<p>RFC 2462, Section 5.3, states the following:</p>
<p>A node forms a link-local address whenever an interface becomes enabled. An interface may become enabled after any of the following events:</p>
<ul>
<li>The interface is initialized at system startup time.</li>
<li>The interface is reinitialized after a temporary interface failure or after being temporarily disabled by system management.</li>
<li>The interface attaches to a link for the first time.</li>
<li>The interface becomes enabled by system management after having been administratively disabled.</li>
</ul>
<p>In order to support IPv6 all Platform Support Packages should be modified such that the above mentioned APIs are added in the Ethernet Link Change code. This is outside the context of the document and should be addressed in the NDK Support Package documentation.</p>
<p>Initialization and de-Initialization of the IPv6 stack is the responsibility of the system application and should be used in conjunction with the Link change events described above. Figure G-3 showcases the various entities in the system:</p>
<p><img src="data:image/gif;base64,R0lGODlhRwGlAPcAAB8aFx8bFyAcGCEcGCEdGiMeGyQfHCUgHSYhHiciHygjICkkISolIiomIysnJCwoJS0oJS4pJi8qJzArKDEsKTItKjMuLDQvLTUwLjYxLzcyMDgzMTk0Mjk1Mzo2NDs3NTw4Nj05Nz46OD87OUA8OkE9O0I+PEM/PUNAPkRBP0VCQEZCQUdDQUdEQkhFQ0lGREpGRUpHRUtIRkxJR0xJSE1KSU5LSk9MSlBNS1FOTFFOTVJPTlNQT1RRT1VSUFZSUVZTUldUU1hVU1lVVFlWVVpXVltYVlxYV1xZWF1aWV5bWV5cWl9cW2BdXGFeXWFfXWJfXmNgX2NhX2RiYGViYWVjYmZkYmdkY2dlZGhmZWlnZWlnZmpoZ2tpaGxqaW1ram5sa29tbHBubXBubnFvbnJwb3JwcHNxcHRycXRzcnVzc3Z0c3d1dHd2dXh2dnl3dnl4d3p4eHt5eHt6eXx7en17en18e359fH99fX9+fYB/foGAf4KAf4KBgIOCgYSCgoSDgoWEg4aFhIeGhYiHhoiHh4mIh4qJiIuJiYuKioyLio2Mi46NjI6NjY+OjZCPjpGQj5GQkJKRkJOSkZOSkpSTk5WUk5aVlJaVlZeWlpiXl5mYl5qZmJqZmZuampybm52cm56dnJ6dnZ+enqCfn6Ggn6GhoKKhoKKhoaOioqSjo6Wko6alpKempaenpqinp6moqKqpqauqqqyrqq2sq62trK6tra+urrCvr7Gwr7GxsLKysbSzsrS0s7a1tLa2tbi3tri4t7m5uLq6ubu7ury8u729vL6+vb+/vsC/v8HAwMLBwcPCwsTEw8XFxMbGxcfHxsjIx8nJyMrKycvLys3MzM3Nzc/OztDPz9HQ0NLR0dPS0tPT09XU1NbW1djX19nY2Nra2dvb293c3N7e3d/f3+Hg4OLh4ePj4uTk5Obl5efm5ujo5+np6evq6uzs6+3t7e/u7vDw7/Hx8fLy8vT08/X19fb29vj39/n5+fr6+vv7+/38/P39/f7+/v///yH5BAkAABkALAAAAABHAaUAAAj+ACkFGEiwoMGDCBMqXMiwocOHEBECmEix4sRe/zJq3Mixo8ePIP/xikiyJEmLKFOqRGmy5Z+WMGPKnHly5cRTIXPq3GmKps+aNoOu/NnwZYBm45IqXcq0qdOnUKNKnUq1qlWqqW7u3Mp1Y88Aqq6KHUu2rNmzzAYaNde1rdu3cOPK9aVVrt2vvuzq3cu378dyagey9Uu4sOGtdAHgPMxzYF7GkCMXBhxgreTLmOfWzcwRL+fPoENSthy6tOnEi0t7Ns3682jBrWNjRs16tezbh18HGIy7t1/apm37Hm5XN2/iyN8CV+04uXO3xp9LR7w5tPDp2DtGLx3PXna7y63+N//usd86f863f1YkQoAAFKzc5luEHnt40Nc7jpEgR6MZCcmApE8k9/CVhATdgAROEQ4AsEAX6YBGjDA6qZeZQBl0UUQBBRjTVg4B8JPdfZ/lx9EWARTQTEZdBFAMSEAEUA9fPQSwzUf9gDDADmB8AMARn00iQCcVBrYbaEoE8FgYDAACjzLXaOSMMiJu84os4GRkjQUBJOPOP/4480o2GlHTjD/M3BLPP9zIchxnJHJm4kYoBoCDiC2++A89vtyiTkbXcBDAMOAo801G0SiDnjnKRPgPO7QYU+A/9RjKjS711HhjNsp4s1EzAeyQ0TcNVADPP84wk9E7nf5TjjL/75wjy40ZKWONPsT4MumqthAz4z/5KLPNOLh480UAftAKkoWYlRGACYMkmNE6CVCQzz/fCODCP34QMBABhfyjA0Gw2OMEQWqgNwMDVAyEwh/eJgBMaHFmNqdGKFIQgCX/5PkPNSUM5EAq/whBECUG8PCPPAcEMM0/XASAzD1YeBsACs78I00APkAQACya6nJABmRqZA6HV8CCz0YUJJDRLAGI8Q8hAXyBQIqJ/MNPAC6AGAAMbO1DRgEDhTCMqwHYcEEANxBERU7MXmZOwAEIcEMoGVkRQC3/LBIAIvQU8MI41vjgxT7ATBBAK+YIEsAY0TwRgCv/zBAAFtQQEUAG/sTUEYAW9FaH33ggoVhJAROg4++4ogAjQgTrDINBAKiMM0QBkA4UyT4VfOBPIAEM8UsiBJRQz8YBrOEHPjW2AoEEz3S0CNEBSOAFORm1/HLMMwdQwSy1WGBANTsHUAYzLco8SdK8TILABu5Q9gUgz0wRQBvIQG3km5jVA4oUEgx0yT+1BACGuAWQw3kAJ8xBjUYbhPhP06IYY0kAXtQdwDLcBhAHqgH4QeAUUxvCfQRFyHBDzfKEjgBowBjGaBHBRCCjf0AiAKaIwwEwQAViBIAN/6hBAMKRkSYEYBcb24CI/lGjBwQAEh+hBh5i4K0RyOMfuvsHzGRGMzxkBA8B/pDEzhZQIHcI4AP/QEIAMvYPMGAQMAxY2T/sEAAiaa8ysOHMPWRBsH/swxAB6IEXOzABbggASP8gRhMUMJAh0OMf8RNRBwLggDo6QAn6E8c/EPE1NgVAYaCpF2bulREExqMDAjiBi0BVADs64BH/oOCMwiGAL8CAB12wQB6U9I8FHKA+bAiAJzYWA43U6AAHSMG1NlKNUlhjVCzYGg4JgJ6e8DAAjcjIBf2wswxopAEK+IcHAvCOjLxkEYDxgEaoaEXRbO8z+5AAAR72D1oEoAYZuUMAjhAArNWDGcuARylMIEtB6WN+AUgQOqCxMruVY48BYIQfAfkZQV6GkP9A/+A/VEGQYjRwBYACB3pGEIAb/sMGExCAHz4RAApcYB//WEEAYvePHQTAGBsLgikDAIo24JIjjwiAFDTCg7X9Y45rCuktv5CRNQSAEzsjwDj+IQ72/cMHJ8zIuWYBmG39MACbKBIWj/QZOjT0DGjg0iAAJQA6zoNNB4CAJ1ixAgK8UpF5cMYFhbAKg8nTnfCUJzf+OMDUiIeTIdHnP5YwkBdxUw6kwEABXvmCANhBGf8YxECCQY6mjkGXASCBIrIQACH4Y2NG2Og21jEBCTgqI+XgEhDkwM0HrMlgadCEoG5pgDsMYgERSEfxbmCJGgXiH6MIAAcOIQYByCAfgJmBRv7ctgRQXJE0nMmHHBowEAywYZUVrZlGXAGCgVQgqP8AnQA2wY898PYAaoAoWPkoVrIGUnAlMqBH1MqNBbjoH+pQggECYAFRZAQR7qHEP6pBx5XFkhYZ8ccgKGgAK0QIsYr9hyICcAaOHKNpATjADOb1D2RkIAAeuN8twUDQDOBCZ3tDAwEI4AXv/CMSiizAEvQYW41AQ21CuG0WQcOPcKyDI/6QQQB0sRF+mGMcK8wIO76UEX58w6DEsadk8KkTe3wDuP9oB413cg4Lx0Ue3AAymN65EZpBwh/kqM/OOvCPd5yKI+l4I0jwMY76LOuZt9FDDALQghiTByQ6jgyPz/4MEidzZMqRiZppxNCBIlSDzTlJM2TWjOeOkKIIdNuIP4qAhTiDuc/2wa6ctIvo9By60c/RM2P4DOnWyLnSvpH0YSiN6dJc2i7twIAE1AsXIkhgpiHQgFt6kb15SIAGrdG0YThtlw1IQAIWKAEP4tOVUUjgtGf+tFwiMZAWxKVpJNQBrLuSiAAQjB4tYEKsFW0vRjOGARzbQQgCQAAPcaUTAfBhsB/dlxgIgAQBIIZGrIFXatSiHRlxhzLMAQ9bUBSdJEyVRtSBC1mgQyP46AUrnOGdc1whAIboBj+UIQ2N5MMYt3gsNhR1jVjosTCyLgyt5YLtN+4DCgGAQ0bIIf+LWSjrH+7gBSxm+g9w+7AdymAGeiD1CmvE+ByxmIY+lKGNGi8DFtLKjLDhsgyOCYSlGdGBAMYwEAu86BUBoILa3pYRZP9DAgvIiCgcMBAFkOIf4aCgu9DhtYF4QR7PykgoXBgABTgiI0P44EASMAuMU3uQ1j5MxzNiVJGDomEDWUNGXjH1A/DL5fEYcy57wduBNAE9suA6/gLghH/EwwgDEQAdODP0t5whAJdgRwIYQONx9SAZfFwBP6BuAE4MQwUBeAW+r551cTAAA7h4hQIkMI9KrLYaIF+FNthKB2ag3QT/yMYBKECKWYxAALz4R9yB4Aw9BACPhMk4YTYeF2z+I6IQZrhZLP7RhA8UoxgRWAA/2DGBCMTCFhBQwDrATQcl8iEjaMAALZhBTnLUYwMFQArRgAOU9w/a1AbQwE0shhmd1xb0EAEK8CVV8EJJ913/0AIjBHVQoHYBkAazh3X/wFD98Q/WUEwZUQ2RACKL8A8uRTDH9w8htVT/gArCFXe5QIIBsGy/cXf3lHeGgW0EkQB5AHC8sAcVEAA4FwBhkBHYwA4tFwAuBAMbsQ/FIAgUZAxpQQQZUT6VJ1GsYAyN0IFCR256wVAFcGtsZGziYiMZgXnLAHV/9Q+7EABW8IFZdwgBIAgc8QwoEAAvYFGKwILOtjBp5yxf9w/JEAD/Whh3sWMOAVBK2ceDO+aDhYFttiAM0gBvGeEIEGgEgmIOlxAAc8AR4BYAvPUYqHABBuADilQMtkCHGZGIlRcBdGRHVTCGQ8U9dvEDSRMEvkiL6jYuq6AzBKUOUIdN/yAQ/WF1INgTW5ARcdAG5oB5LMZHK+hRpUCIyFcIATCClSCGcXdn5/CIdkdAwUGJhLF3G3EOAmACpwIDSIgLAbAEGcEHaeAN4FYEykAAMLAP+hABEoA7UXBR1hAAI3BOjFCAEvVv5UANSgYZDcgV2CAAFgBc2sRS48IBkdAiSfAPUGc+kIABBKAqzJh18KABBlAHb3BE+gAigbAKxfUH/7BJ/1FACi8IDhBwAHIACBCwANggfQEgjuQYiebIHGh1GeqoEdtAXrUgCE2lDfYwAgTgBnZgABUwDy7XRPtyDwhwAKpQCTdzg7zII9hWeTSjBKxgUZiAi7i1F34jeBoxkaQ3LnfARjugR1DHBDZgiuNjhxmBDBgYACywIrxwhBTABwWIDB7DBC+YRjnQMCnwC3AXlP8wjpD4GwNhCgV0lJKRlBohB011A4SlmdFAAwNBAhSSleTQABfgDo7QMCiABgFACP+wDlEwATvgCbCoD3GAbQkwB2ZmaLmYGePiDffwb4PHX/9gDg/pEepgDl6GD+EQnPbAZB0xD38CJ5m5mY/RGv/tgJwc0Q7QmRPzYJ3/cA+HUAo3VD5voBH7AA5axpYjJhnFyRFQ11+d5hG+sJ3nyJmd1oc+QAbDZAuWRoaMwQZFcA4cQQxF8Hb52RH7iUHc+aBMqAUpAAI94AmxEZEUWk/8aZTd2aG4waEiOhsfelYhWqIbaqAqWhoRqpn9maItahokOqOM8aITaqMFOpw6yho4GqM9yho1GqSYKaFASqShMaRIuhc/CqJLChpK+qRzcaKD459SKpxGwQZ4sKVc2qVe+qVgGqZiOqZkWqZmeqZoaqZ1AqNGuQVp+qZwGqdyOqd0GkoBADpEkad6uqctgQqsQYN8GqiCOqgFQQySR6j/iJqoM5EBWWIa4HBgihqpkhoRDnCe63CpmJqpmrqpnNqpnvqpoLoO5rADoVqqpnqqpnpOraEPqNqqrtqqO2AOrzqrtMqpu3Jm+AAEV/qkQCBFu8oZufqrSNqrwgqsulqsPUqsyHoZwbqsNqqszgoZzRqtKgqt1GoY03qtHWqt2uoX2dqt+cmt4LoX3zqulSau5ioX5ZquiIau7PoW6/qubOau8toV8Vqv30Gv+LoT97qv06Gv/hoS/RqwzgGwBOsRA3uwxGGwCrsRCduwvcGwEPsPDzuxsiGxEFuxFtsaGNuwGruxptGxCvuxIBsaInuwJFuyn3GyBJuyKpsZLBuw/y77spcRs/7KOmCQszq7szzbsz77s0AbtEI7tEQLBliABUWbtEq7tEw7tD3gqzSrEfxgDVRbtVZ7tVibtVq7tVzbtV77tVQrCIIAtmRbtmZ7tl8bnFF7pZqgCWv7ts7RtnA7t8Mht3R7t7Jht3i7t6Wht3z7t5nht4DLrvtwZdkhuGx2D08FsS4gAVmiAbeWa7sWEv5gCCtgAVlwYqggAWQQEvPhZTqxCFyHdHFhBxJQCSDRDBKQBRkhDqMgF4jLEdFEAct5axKQASlQBMEQEvcwByWQAWlQIIcgATL4EfIgCV3RBglAAMAWF2Jgux5wA5sAuh1hARKgqh6hBhKwgP+wECXYQUGe4l0+oG3c5m0eAUQ1gFOsKwoB8IwgQYDUGxISUACPsLty4VEO6hHT0AJq8A/P0ADuCxexO4Xc9g/kEAAIEAQ7oAEBwAAX5xEHJwRjpgf/AAgBcH8fcQ8cMAJcsQ6+Qwn3BheEpQI84AJEA0IgMV7NmRF70AIUAgfplh3g20kB4HEgFwfeoAzZWSnW0A4OwAH4oA9fMITs+4yv8g7oIAvQoCVc4iVgwgyvoCzXoAz1YAvaIAyqpQynkg60AAs2pxHwwAuvcCjr5goNlxH4+w/boAz6sA2wQMbzwHP3IBBJsCIC7LYhsQ8FfMAbkBH2oGKTMMVrgnLK0A3/1UAAOOAP6rAF8mTB95fD9gAOsNBz/2AMAdABVPwP+mAMsvDA0AAN8FAL3FAKTKMMBRIOsGALnqIR69BvChpfYlIy/0BYhxgNDlAA0ZAR9eALtpCd/6DCwbIN9yAMu/ArOfwO4WAwm8By0jHD3qVlRhUHDNW5/3A/dvALdwMMmFAyRdw7Y+BdAXAHazgQsFAP5zIQ6VIwAcAEASBRBHELscBGAwE4IgGpBRAu/vB5AwEFM5LGA7kGTXUAfqoMlLeUAwEBcTHA7rnHAdDHGWE9k9AHCMd3AYAJmxBus8AJuFPBF/wPYtCB3kIA/DI5AzEN6ECAAWAAOfMPIIABIuTO/wOhDZJAOwGwB1oneQrwuuZCEGmAHrSsEc6SS9egSKZ4iCp8wD0AjxdTTE5kC3FAEOI8Hc78NeAnfvXQWN6hdNqQWhjgHgkwjN1MMxfAC7JgAAjAD2mzNm3zNnEzN+rMAo8QC/zEAbKQDl2gAbywDB4gAPFADx6QAKiwCxtAAN3QE0hADWYQADnjz0mzDNwoKgTtBPNgwT9Qd3ecE3pMAAYcABDQCILABQJAANIADgUAUPvAAZYFOl1dOy/iyB4dACpgDN+IAv/gCnvjCvHgRICwDDhAALFTXD+wCLtAbDMgC/EQBCSwDL+QAL40Dg2Ae7rHe3olBtEAcq0wywFwiP//AEb9y4ucIAwk4AD/dtQDEQjSIELm1dTSACKF8D5SHQDhWxBCmBEKZAoTOQT/oAkpzQyqewH6ENYBsHnCFADwFj/osZf1cz8sZTB+qo0aoQ/B4AeCMg0etIFqHCEoYgjGMAsCICqMrQqbjXyRLYftC7t4DBKZvdkF8QCoS34BoAzl07lAlAHccAsFgE2u/dH8cg8NtScGmREVUAC8YAyIeVrFxT/+GwAd6ce3cAceYw+g4D9aUkwEGArGEIpdgN3a3Wxj4A7kBUFOZF7kjQEZYX251NT/YD3q9r3wTcO3gIma+C8B0AR7EADZWD46kBHsnA0AHogXGAB/YuAnVYv/dYRHBmO/jdkJFIAAQkBQ0sAK5sMRMcIAdkTbjL279PDjIz6HAfwWCp0RKX7AFeALw0ANOBYLAeAGWtAlFxYAWf4PKWAA+ZDjbt1JEeDjHGwPVeNI/VtcG/0MSp4RgtAADaAER1gPeKiHGzFMjtSRP50RoWQI05AijhSI5O1TzRaIaK7mMtzmz+wRPpAAI2ABBdIN5yYisIcOAA5D/+ACgP4P5oRO6sRO6pzLDk4PzP0nejMNRXcD51UG1IAiNygPzNDPAfB2A3kMlKLpBTgSrJvQJ/4Rod7QHrEPH+ABDwCJc1gEFOsAEOAPtA5f/8AAt14PARACQE5E/wAO2ABR/8WlZcDekdgQADLwVBRkDzRIz3IgjQTIDf+QDvT+7OuQASPZDu3IhNyAHuS9bPul7QFAoO1iv+8d3/G5EaEwEP+TEXJzBc4iRuueEe7+J1ilVYXVVR9lMK/k4O1AAAwAC41ANMawD2NGBnvAAA2ADuXTAqqABWLI2Apv8hw84sgQWMru6RFf8Qzt0B1hwQEwCfHVAgKQBtbDUiGfESQPJgagAIEQDgqUBaqAgeNXXKsU8/+QFh5wC0AUAOlwkikJB0eUD8TGVQazgoR1A1RwBGpTBiWU6qMw2A239BnR9FpJoMfiBbLA5lTvEfZQAQKQ9j+PBE21A57y9e3+7soFU/7OFWDRpc5p35iDQDQtEAZB9A/a0ANN9QEE+g+VoDYCQAU35PcLH/gFiA/urgA41haf7kWJ/xHiYAAMABDv/g3URiOAgCfs/gEKwOefmAC0BjKIMBBMgAK+7IlREKDBoIEgAuQb+CxAkoFkAgT4ESWArX/IWqxUwewfPz4NAhxIo+9flpUBHLRYdG9gOycGAlTwNFBpPnIBaAxUFEDRv4swaSUIUGbgV7BhxY4lW9bsWbRk26VLC5adu6/8vslrC8/cWHjj+IH1Jw5u27D+xvkEHFaTpsKJB577C/gcva/6vtlry27dWHXm/IHlF45uW3vfSCr+N+8cadSpVa9m3f7atdnDr2XPpl3b9m3cuXXDRrzb92/gwYUPJx6b+HHkyZUvP26c+XPo0aVPJ+uc+nXs2bXbtr7d+3fw4cV2F1/e/Hnm5NGvZ9/+tnr38eXPLwyf/n38+O3n598f/X7/AhRQOwAHNPDA9HpDcEEGE2zwQQiHKzBCCl+DZx0MM9RwQw479PBDEEMUccR1HHGERBRTVHFFEeGpELg3gpJxRhprtPFGHHPUcUcee/TxRyCDDOCNF30bQUgkk1RySSabdHKEIncTIQAQ2LDySiyz1HJLLrv08kswwxRzTDLLNDNMkaCMMrcpgyDnTTjjlHNOOuu0804889RzTz779PNPPf+DCEDNNW9rE1BEE1V0UUYbdTROQQkttLZDH7X0Ukwz1XTOSCc1NAA3NxV1VFJLrbNTTykF1VRWW3XVUVRTna3SV2u19dZTB5WVNlpx9fXXVmPd1bVegTX2WEyFHZa1YpF19llElV1WtWahtfbaO6WdFrVqsfX2W223Vazbb8uFNlxxCyPXXHaNRTfdttZtd95b34UXLXnp1TdYXe/ldtV9A8bVXn/LyldghDMluOCxDk74YVj7ZVhdgCG2eNOFJwbL4YvhtCacjvPMWOOBOH5VFgjc9AQCljNAgQlk7oQGCgw++GNOcMbIAKMZYIHTllT8HAMCUcwdmWSTXXUlABv+yMkkAApyiEGnEsSpExwRBFhigwA+kRMiD6iIIQAImCHnEQEE8ZOLADwxWmKS8a342aWbflqJN51ZIIBbbrFlnDeXsSWaRgIYg5xXqtBEzg8CeOZNGxyohBovAkBDmDeB0cQUZ+JcxhNRsnmTbbeVsQUYbI/WOOlW63Y6ALzJGUcDvoEIoJU3bwhgF7YrmcQSbebUHQZCooFTkqCAICeMoAqA5M06ClgpAp9JB0aCBFZJHe64zWKdVdefVuEPOHgIYAJwntaCHGMCmIEcIZZaaQTj48SFgpUI4MEUcpaZIgAuwCIaKLCBLyIRgB0gLgAngAUhAqACcrAtER8oQCf+vKW6iX3PVOGb0QZYQQ5wXOAB3IhDABZBjh0EIAfRwEMAwjCnahACCB0xgCrIYYcAqO1N18jERUBAjjVY5U284EYEPRKALoCLe90jiwZLxcEbrEIWwgAHnNgQgEqEwAHB+98gyGGNAMQgTtTYxCjexA22ceGGOQThFgwgASYI4APkuEIAMiEntgVgAQ+o37UwyDAnkoqDsZMTMgRQAiS+CYduIMctWOK580njTX4IwBTIcYcA3IwTAWgCOLZBJXLIIQB1IIc4onAGcLBNDYcA4AWXyESxBHJUg8wV394UDQUsAA4vCIAh5GSEAHhADFbY2+IEEQAeJAISAYCBKf7+RwFyCAMBDrCDS3hgRE+I4wQEwMX2JAXLhs3NWbSk0yYC4II4oYJ2BSgD4OI0jSooJQAc0MObhoG/F3TDBwdxggwCEDNO0C4AN1gGNskhigDgwJvg9J44LTYOZXTDTuFAxjXkBA5muNMZopuTM6yxrz8WTJYhIymkXsnQkjm0pCv1U0j9NVKWhsyl94JpTC82U3jV1KYQw2m6dLrThPVUXD8FqsCEui2iFhWkJ0VpUpVKr6NOy6lPbVdUlzVVqr7tmyj9ClazqsStcvUfXv3qQsUaFrKW1VpWHVZa1fostu5qSjpgRl3tele85lWve+VrX/36V8AGVrCDJWxhAatCA6YydEpOYmxjHftYyOIorFzVXWQte1nMZlZHNzhrWLRBiD+EVrSjJW1pTXta1KZWtatlbWtd+1rYxta1hNCGeQICADs=" title="IPv6 Stack Instantiation Placement" alt="Figure G-3 IPv6 Stack Instantiation Placement" /></p>
<p>The IPv6 stack provides the necessary APIs, which are responsible for the initialization and cleanup of the IPv6 stack instance on the interface.</p>
<p>For user convenience, a sample command prompt demonstration has been provided with the IPv6 stack to initialize and attach the IPv6 stack to a desired interface, and to demonstrate the use of various IPv6 utilities. For more details, see the IPv6 Stack Testing section of the <em>TI Network Developers Kit (NDK) v2.21 Users Guide</em> (<a href="NDK_Users_Guide.html">SPRU523</a>) document.</p>
<h1 id="related-documentation-from-texas-instruments">Related Documentation From Texas Instruments</h1>
<p>Additional information about the NDK can be found in the <a href="NDK_Users_Guide.html">NDK Users Guide</a>. If you have questions, you can ask them on the forum for your target device in TIs E2E community.</p>
<p>If you have questions, you can ask them on the forum for the SDK that contains your NDK in <a href="http://e2e.ti.com/">TIs E2E community</a>.</p>
<!-- Close div from before_body_template.html -->
</div>
<footer id="tiFooter">
  <p>TI is a global semiconductor design and manufacturing company. Innovate
  with 100,000+ analog ICs and embedded processors, along with software, tools
  and the industrys largest sales/support staff.</p>
  <p>
    <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
    <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
  </p>
</footer>
</body>
</html>
