

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4 Network Control Functions &mdash; NDK Users Guide  documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5 OS Adaptation Layer" href="05_os-adaptation-layer.html" />
    <link rel="prev" title="3 Stack" href="stack.html" /> 
</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> NDK Users Guide
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="02_overview.html">1 Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_network-application-development.html">2 Network Application Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="stack.html">3 Stack</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4 Network Control Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-netctrl-source">4.1 Introduction to NETCTRL Source</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#history">4.1.1 History</a></li>
<li class="toctree-l3"><a class="reference internal" href="#netctrl-source-files">4.1.2 NETCTRL Source Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#main-functions">4.1.3 Main Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additional-functions">4.1.4 Additional Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#booting-and-scheduling">4.1.5 Booting and Scheduling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#netctrl-scheduler">4.2 NETCTRL Scheduler</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scheduler-overview">4.2.1 Scheduler Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scheduling-options">4.2.2 Scheduling Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scheduler-thread-priority">4.2.3 Scheduler Thread Priority</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tracking-events-with-stkevent">4.2.4 Tracking Events with STKEVENT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scheduler-loop-source-code">4.2.5 Scheduler Loop Source Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#disabling-on-demand-services">4.3 Disabling On-Demand Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="05_os-adaptation-layer.html">5 OS Adaptation Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="99_endmaterial.html">Related Documentation From Texas Instruments</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NDK Users Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>4 Network Control Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="network-control-functions">
<h1>4 Network Control Functions<a class="headerlink" href="#network-control-functions" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the network control functions.</p>
<div class="section" id="introduction-to-netctrl-source">
<h2>4.1 Introduction to NETCTRL Source<a class="headerlink" href="#introduction-to-netctrl-source" title="Permalink to this headline">¶</a></h2>
<div class="section" id="history">
<h3>4.1.1 History<a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h3>
<p>The NETCTRL module was originally a recommended initialization and scheduling method to execute the NDK. Although mostly simple, this code became standard. Eventually, it was separated out into the NETCTRL library.</p>
<p>The NETCTRL module is the center of the NDK because it connects the HAL and the OS Adaptation Layer to the NDK. It controls both initialization and how events are scheduled for execution within the stack. Understanding how the NETCTRL module works helps you tune your networking application for ideal performance.</p>
</div>
<div class="section" id="netctrl-source-files">
<h3>4.1.2 NETCTRL Source Files<a class="headerlink" href="#netctrl-source-files" title="Permalink to this headline">¶</a></h3>
<p>Source code to the NETCTRL library consists of two C files located in the <code class="docutils literal notranslate"><span class="pre">/ti/ndk/netctrl</span></code> directory:</p>
<ul class="simple">
<li><p><strong>netctrl.c</strong> – Network Control (Initialization and Scheduling) Module</p></li>
<li><p><strong>netsrv.c</strong> – Configuration service module (system configuration service provider)</p></li>
</ul>
<p>There are two include files associated with NETCTRL in the <code class="docutils literal notranslate"><span class="pre">/inc/netctrl</span></code> directory:</p>
<ul class="simple">
<li><p><strong>netctrl.h</strong> – Interface specification to NETCTRL</p></li>
<li><p><strong>netsrv.h</strong> – Interface specification to NETSRV</p></li>
</ul>
</div>
<div class="section" id="main-functions">
<h3>4.1.3 Main Functions<a class="headerlink" href="#main-functions" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">netctrl.c</span></code> source module contains source code for all the functions with the NC_ prefix. The function of the NETCTRL module has three basic parts.</p>
<p>The first function of <code class="docutils literal notranslate"><span class="pre">netctrl.c</span></code> is to perform the system initialization and shutdown that is necessary before calling any other stack functions. These functions are declared as <code class="docutils literal notranslate"><span class="pre">NC_SystemOpen()</span></code> and <code class="docutils literal notranslate"><span class="pre">NC_SystemClose()</span></code>.</p>
<p>The second function of <code class="docutils literal notranslate"><span class="pre">netctrl.c</span></code> is to perform the driver environment initialization and configuration bootstrap necessary to start the stack functionality. This startup function and its shutdown counterpart are declared as <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> and <code class="docutils literal notranslate"><span class="pre">NC_NetStop()</span></code>.</p>
<p>The final function of <code class="docutils literal notranslate"><span class="pre">netctrl.c</span></code> that is hidden from the caller, is implementing the stack’s event scheduling, which is the center of the stack’s operation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">netsrv.c</span></code> module contains the code that boots all the services on the stack. This code takes what is stored in the stack’s configuration and implements the necessary stack functions to keep the configuration current. When an active item in the configuration is changed, there is code in the NETSRV module to execute that change in the NDK.</p>
</div>
<div class="section" id="additional-functions">
<h3>4.1.4 Additional Functions<a class="headerlink" href="#additional-functions" title="Permalink to this headline">¶</a></h3>
<p>There are some additional NETCTRL functions that are not documented in the <a class="reference external" href="../../NDK_API_Reference.html">NDK API Reference Guide</a>. These functions are <code class="docutils literal notranslate"><span class="pre">NC_BootComplete()</span></code> and <code class="docutils literal notranslate"><span class="pre">NC_IPUpdate()</span></code>. They are both called from the NETSRV module.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> function initiates the configuration boot process by creating a boot thread with an entry point of <code class="docutils literal notranslate"><span class="pre">NS_BootTask()</span></code> (from netsrv.c). The <code class="docutils literal notranslate"><span class="pre">NC_BootComplete()</span></code> function is called by the configuration boot thread when the configuration boot is complete. It signals to NETCTRL that it can now call the <code class="docutils literal notranslate"><span class="pre">networkOpen()</span></code> application callback that was passed to <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> by the application. On return from <code class="docutils literal notranslate"><span class="pre">NC_BootComplete()</span></code>, the boot thread is terminated. Therefore, the application programmer may take control of the <code class="docutils literal notranslate"><span class="pre">networkOpen()</span></code> callback thread, although this is not recommended.</p>
<p>The IP address update function is called by NETSRV when an address is added to or removed from the system. It is this function that then calls the <code class="docutils literal notranslate"><span class="pre">networkIPAddr()</span></code> application callback that was originally passed to <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code>.</p>
</div>
<div class="section" id="booting-and-scheduling">
<h3>4.1.5 Booting and Scheduling<a class="headerlink" href="#booting-and-scheduling" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="03_network-application-development.html#ndk-initialization">“NDK Initialization”</a> discussed using the network control NETCTRL module. This section examines the internal source code of the main NETCTRL module and the operation of the event scheduler.</p>
<p>The stack event scheduler is the routine that calls the stack to process packet and timer events. The scheduler is called from within <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> and does not return until the stack is being shut down, which explains why the <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> function does not return to the application until the system is shut down and the scheduler terminates.</p>
<p>The basic flow of <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NC_NetStart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Initialize_Devices</span><span class="p">();</span>

    <span class="n">CreateConfigurationBootThread</span><span class="p">();</span>
    <span class="n">NetScheduler</span><span class="p">();</span>
    <span class="n">CloseConfiguration</span><span class="p">();</span>
    <span class="n">CloseDevices</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Out of the functional stages for <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code> listed above, the two that are of the most concern are the creation of the boot thread, and the implementation of the network event scheduler.</p>
<p>The boot thread is handled by a second C module in the NETCTRL library named netsrv.c. This name is an abbreviation for Network Service Manager. The NETSRV module hooks into the configuration system as a configuration service provider. The configuration system module is just an active database. In contrast, the network service module turns configuration entries into actual NDK objects. The service module can be altered to fit a particular need. This likely involves the creation of custom configuration tags for the configuration system. However, a full understanding of the code in NETSRV requires a basic understanding of nearly all the API functions discussed in the <a class="reference external" href="../../NDK_API_Reference.html">NDK API Reference Guide</a>.</p>
<p>You should be most concerned about the <code class="docutils literal notranslate"><span class="pre">NetScheduler()</span></code> function because this scheduler runs the NDK. It looks for events that need to be processed by the NDK, and it performs the work necessary to start processing.</p>
</div>
</div>
<div class="section" id="netctrl-scheduler">
<h2>4.2 NETCTRL Scheduler<a class="headerlink" href="#netctrl-scheduler" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scheduler-overview">
<h3>4.2.1 Scheduler Overview<a class="headerlink" href="#scheduler-overview" title="Permalink to this headline">¶</a></h3>
<p>The NETCTRL scheduler code is an infinite loop function named <code class="docutils literal notranslate"><span class="pre">NetScheduler()</span></code> and appears at the end of the source file netctrl.c. It looks for activity events from the low level device drivers, and acts when events are detected. The loop terminates when a static variable is set through an outside call to <code class="docutils literal notranslate"><span class="pre">NC_NetStop()</span></code>.</p>
<p>Although the NDK provides a reentrant environment, the core of the stack is not reentrant. Portions of the code must be protected from access by reentrant calls. Instead of using critical sections that block out all other Task execution, the software defines an operating mode called kernel mode. Kernel mode is defined such that only one Task may be in kernel mode at any given time. It does nothing to prevent Tasks from running that do not use the NDK. This provides protection for the stack, without affecting the execution of unrelated code. There are two functions defined to enter and exit kernel mode, <code class="docutils literal notranslate"><span class="pre">llEnter()</span></code> and <code class="docutils literal notranslate"><span class="pre">llExit()</span></code>. They are part of the OS adaptation layer, and are discussed in more detail in <a class="reference external" href="05_os-adaptation-layer.html#choosing-the-llenter-llexit-exclusion-method">“Choosing the llEnter()/llExit() Exclusion Method”</a>. In short, <code class="docutils literal notranslate"><span class="pre">llEnter()</span></code> must be called before calling into the stack, and <code class="docutils literal notranslate"><span class="pre">llExit()</span></code> must be called when done calling stack functions.</p>
<p>The basic flow of the scheduler loop can be summarized by this pseudo code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">NetScheduler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SetSchedulingPriority</span><span class="p">();</span>

    <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">NetHaltFlag</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">WaitOrPollForEvents</span><span class="p">();</span>
        <span class="n">ServiceDeviceDrivers</span><span class="p">();</span>

        <span class="c1">// Process current events in Kernel Mode</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">StackEvents</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Enter Kernel Mode</span>
            <span class="n">llEnter</span><span class="p">();</span>
            <span class="n">ServiceStackEvents</span><span class="p">();</span>

            <span class="c1">// Exit Kernel Mode llExit();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sections that follow address each of the highlighted functions in turn. Note that the code continues to run until the <code class="docutils literal notranslate"><span class="pre">NetHaltFlag</span></code> is set. This flag is set when an application calls the <code class="docutils literal notranslate"><span class="pre">NC_NetStop()</span></code> function.</p>
</div>
<div class="section" id="scheduling-options">
<h3>4.2.2 Scheduling Options<a class="headerlink" href="#scheduling-options" title="Permalink to this headline">¶</a></h3>
<p>There are three basic ways to run the scheduler. They can be viewed as three operating modes:</p>
<ol class="arabic simple">
<li><p>Scheduler runs at low priority and only when there are network events to process.</p></li>
<li><p>Scheduler runs continuously at low priority, polling the device drivers for events.</p></li>
<li><p>Scheduler runs a high priority, but only when there are network events to process.</p></li>
</ol>
<p>The best way to run the scheduler depends on the application and system architecture.</p>
<p>Mode 1 is the most efficient way to run the NDK. Here, the scheduler loop runs at a low priority. This allows applications that potentially have real-time requirements to have priority over networking where the real-time restrictions are more relaxed. In addition, the scheduling loop only runs when there is network related activity; therefore, an idle loop can also be used.</p>
<p>Mode 2 is used when the device drivers are prevented from using interrupts. This is best for real-time Tasks, but worst for network performance. Since the scheduler thread runs continuously, it also prevents the use of an idle loop. This is the mode that NETCTRL must use when using a device driver that requires polling.</p>
<p>Mode 3 is the most Unix-like environment. Here, the network scheduler Task runs at a higher priority than any other networking Task in the system. The stack runs whenever new network related events are detected, pre-empting other Tasks from potentially using the stack. This is the best method for keeping the networking environment up to date without placing restrictions on how network applications are written.</p>
<p>Setting priority and polling or interrupt driven scheduling is done when the application first calls <code class="docutils literal notranslate"><span class="pre">NC_SystemOpen()</span></code>. This is discussed further in <a class="reference external" href="03_network-application-development.html#pre-initialization">“Pre-Initialization”</a> and in the <em>NDK Programmer’s Reference Guide</em>.</p>
</div>
<div class="section" id="scheduler-thread-priority">
<h3>4.2.3 Scheduler Thread Priority<a class="headerlink" href="#scheduler-thread-priority" title="Permalink to this headline">¶</a></h3>
<p>The first lines of the actual implementation of <code class="docutils literal notranslate"><span class="pre">NetScheduler()</span></code> include the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set the scheduler priority</span>
<span class="n">TaskSetPri</span><span class="p">(</span><span class="n">TaskSelf</span><span class="p">(),</span> <span class="n">SchedulerPriority</span><span class="p">);</span>
</pre></div>
</div>
<p>This code changes the priority of the Task thread that calls into <code class="docutils literal notranslate"><span class="pre">NC_NetStart()</span></code>, so that there is a single control point to set the scheduler priority. The priority used is that which was passed to the <code class="docutils literal notranslate"><span class="pre">NC_SystemOpen()</span></code> function. This is discussed further in <a class="reference external" href="03_network-application-development.html#pre-initialization">“Pre-Initialization”</a> and in the <em>NDK Programmer’s Reference Guide</em>.</p>
<p>The scheduler priority (relative to network application thread priority) affects how network applications can be programmed. For example, when running the scheduler in low priority, a network application cannot poll for data by continuously calling <code class="docutils literal notranslate"><span class="pre">NDK_recv()</span></code> in a non-blocking fashion. This is because if the application thread never blocks, the network scheduler thread never runs, and incoming packets are never processed by the NDK.</p>
</div>
<div class="section" id="tracking-events-with-stkevent">
<h3>4.2.4 Tracking Events with STKEVENT<a class="headerlink" href="#tracking-events-with-stkevent" title="Permalink to this headline">¶</a></h3>
<p>As previously mentioned, the NETCTRL module is the interface between the stack and the device drivers in the HAL layer. In older versions of the NDK, device drivers signaled the NETCTRL module through a global Semaphore. In order to improve this process slightly, the simple Semaphore has been encapsulated into an object called a <code class="docutils literal notranslate"><span class="pre">STKEVENT</span></code>.</p>
<p>From the device driver’s point of view, this event object is a handle that is passed to a function called <code class="docutils literal notranslate"><span class="pre">STKEVENT_signal()</span></code>. In reality, this function is only a MACRO that operates on a structure of type <code class="docutils literal notranslate"><span class="pre">STKEVENT</span></code>. The NETCTRL module operates directly on this structure. The <code class="docutils literal notranslate"><span class="pre">STKEVENT</span></code> structure is defined as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stack Event Object</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_stkevent</span> <span class="p">{</span>
    <span class="kt">void</span>       <span class="o">*</span><span class="n">hSemEvent</span><span class="p">;</span>
    <span class="kt">uint32_t</span>   <span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_NUMEVENTS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">STKEVENT</span><span class="p">;</span>

<span class="cp">#define STKEVENT_NUMEVENTS    5</span>

<span class="cp">#define STKEVENT_TIMER        0</span>
<span class="cp">#define STKEVENT_ETHERNET     1</span>
<span class="cp">#define STKEVENT_SERIAL       2</span>
<span class="cp">#define STKEVENT_LINKUP       3</span>
<span class="cp">#define STKEVENT_LINKDOWN     4</span>
</pre></div>
</div>
<p>There are two parts to the structure, a Semaphore handle and an array of events. Each driver signals an event by setting a flag in the <code class="docutils literal notranslate"><span class="pre">EventCode[]</span></code> array for its event type, and then optionally signaling the event semaphore. The semaphore is only signaled when the driver detects an interrupt condition. If the event is detected during driver polling (either periodic polling or constant in the case of a polling only driver), the event is set, but the semaphore is not signaled.</p>
<p>You can provide a hook function to run when a driver signals a <code class="docutils literal notranslate"><span class="pre">STKEVENT_LINKUP</span></code> or <code class="docutils literal notranslate"><span class="pre">STKEVENT_LINKDOWN</span></code> event, meaning that the link has come up or gone down. Note that such a hook function will only be called if the driver has code to call <code class="docutils literal notranslate"><span class="pre">STKEVENT_signal(STKEVENT_LINKUP)</span></code> and <code class="docutils literal notranslate"><span class="pre">STKEVENT_signal(STKEVENT_LINKDOWN)</span></code>.</p>
<p>The hook function should accept a single int status parameter. If the function receives 0, the link is now down (for example, because a cable was disconnected). If the function receives a 1, the link is now up. To register your hook function, call <code class="docutils literal notranslate"><span class="pre">NC_setLinkHook()</span></code> as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NC_setLinkHook</span><span class="p">(</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">LinkHook</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>The NETCTRL module creates a private instance of the <code class="docutils literal notranslate"><span class="pre">STKEVENT</span></code> structure that it passes to device drivers as a handle of type <code class="docutils literal notranslate"><span class="pre">STKEVENT_Handle</span></code>. The private instance that is operated on directly by NETCTRL is declared as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Static Event Object</span>
<span class="k">static</span> <span class="n">STKEVENT</span> <span class="n">stkEvent</span><span class="p">;</span>
</pre></div>
</div>
<p>In the full source to <code class="docutils literal notranslate"><span class="pre">NetScheduler()</span></code> that follows, the <code class="docutils literal notranslate"><span class="pre">STKEVENT</span></code> structure is referred to by its instance <code class="docutils literal notranslate"><span class="pre">stkEvent</span></code>.</p>
</div>
<div class="section" id="scheduler-loop-source-code">
<h3>4.2.5 Scheduler Loop Source Code<a class="headerlink" href="#scheduler-loop-source-code" title="Permalink to this headline">¶</a></h3>
<p>The code for the scheduler implementation included in the NDK is shown below. This implementation fleshes out the pseudo code shown in <a class="reference external" href="#scheduler-overview">“Scheduler Overview”</a>, using the methods and objects described in this section. In this code, the number of serial port devices and Ethernet devices is passed in as calling arguments. This device count is obtained from the device drivers when they are asked to enumerate their physical devices.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define FLAG_EVENT_TIMER     1</span>
<span class="cp">#define FLAG_EVENT_ETHERNET  2</span>
<span class="cp">#define FLAG_EVENT_SERIAL    4</span>
<span class="cp">#define FLAG_EVENT_LINKUP    8</span>
<span class="cp">#define FLAG_EVENT_LINKDOWN  16</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">NetScheduler</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">SerialCnt</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">EtherCnt</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">fEvents</span><span class="p">;</span>

    <span class="cm">/* Set the scheduler priority */</span>
    <span class="n">TaskSetPri</span><span class="p">(</span> <span class="n">TaskSelf</span><span class="p">(),</span> <span class="n">SchedulerPriority</span> <span class="p">);</span>

    <span class="cm">/* Enter scheduling loop */</span>
    <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">NetHaltFlag</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">hSemEvent</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SemPend</span><span class="p">(</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">hSemEvent</span><span class="p">,</span> <span class="n">SEM_FOREVER</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Clear our event flags */</span>
        <span class="n">fEvents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* First we do driver polling. This is done from outside */</span>
        <span class="cm">/* kernel mode since pure &quot;polling&quot; drivers cannot spend */</span>
        <span class="cm">/* 100% of their time in kernel mode. */</span>

        <span class="cm">/* Check for a timer event and flag it. EventCodes[STKEVENT_TIMER] */</span>
        <span class="cm">/* is set as a result of llTimerTick() (NDK heartbeat) */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_TIMER</span><span class="p">]</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_TIMER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">fEvents</span> <span class="o">|=</span> <span class="n">FLAG_EVENT_TIMER</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Poll only once every timer event for ISR based drivers, */</span>
        <span class="cm">/* and continuously for polling drivers. Note that &quot;fEvents&quot; */</span>
        <span class="cm">/* can only be set to FLAG_EVENT_TIMER at this point. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">||</span> <span class="o">!</span><span class="n">stkEvent</span><span class="p">.</span><span class="n">hSemEvent</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">NIMUPacketServiceCheck</span> <span class="p">(</span><span class="n">fEvents</span><span class="p">);</span>

            <span class="cm">/* Poll Serial Port Devices */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">SerialCnt</span> <span class="p">)</span>
                <span class="n">_llSerialServiceCheck</span><span class="p">(</span> <span class="n">fEvents</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Note we check for Ethernet and Serial events after */</span>
        <span class="cm">/* polling since the ServiceCheck() functions may */</span>
        <span class="cm">/* have passively set them. */</span>

        <span class="cm">/* Was an Ethernet event signaled? */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_ETHERNET</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="cm">/* We call service check on an event to allow the */</span>
            <span class="cm">/* driver to do any processing outside of kernel */</span>
            <span class="cm">/* mode that it requires, but don&#39;t call it if we */</span>
            <span class="cm">/* already called it due to a timer event or by polling */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_TIMER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">hSemEvent</span><span class="p">)</span>
                <span class="n">NIMUPacketServiceCheck</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

            <span class="cm">/* Clear the event and record it in our flags */</span>
            <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_ETHERNET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">fEvents</span> <span class="o">|=</span> <span class="n">FLAG_EVENT_ETHERNET</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Check for a Serial event and flag it */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">SerialCnt</span> <span class="o">&amp;&amp;</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_SERIAL</span><span class="p">]</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* We call service check on an event to allow the */</span>
            <span class="cm">/* driver to do any processing outside of kernel */</span>
            <span class="cm">/* mode that it requires, but don&#39;t call it if we */</span>
            <span class="cm">/* already called it due to a timer event or by polling */</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_TIMER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">stkEvent</span><span class="p">.</span><span class="n">hSemEvent</span> <span class="p">)</span>
                <span class="n">_llSerialServiceCheck</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>

            <span class="cm">/* Clear the event and record it in our flags */</span>
            <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_SERIAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">fEvents</span> <span class="o">|=</span> <span class="n">FLAG_EVENT_SERIAL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Check if link went up */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_LINKUP</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="cm">/* Clear the event and record it in our flags */</span>
            <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_LINKUP</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">fEvents</span> <span class="o">|=</span> <span class="n">FLAG_EVENT_LINKUP</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Check if link went down */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_LINKDOWN</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="cm">/* Clear the event and record it in our flags */</span>
            <span class="n">stkEvent</span><span class="p">.</span><span class="n">EventCodes</span><span class="p">[</span><span class="n">STKEVENT_LINKDOWN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">fEvents</span> <span class="o">|=</span> <span class="n">FLAG_EVENT_LINKDOWN</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Process current events in Kernel Mode */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Enter Kernel Mode */</span>
            <span class="n">llEnter</span><span class="p">();</span>

            <span class="cm">/* Check for timer event. Timer event flag is set as a result of */</span>
            <span class="cm">/* llTimerTick() (NDK heartbeat) */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_TIMER</span> <span class="p">)</span>
                <span class="n">ExecTimer</span><span class="p">();</span>

            <span class="cm">/* Check for packet event */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_ETHERNET</span> <span class="p">)</span>
                <span class="n">NIMUPacketService</span><span class="p">();</span>

            <span class="cm">/* Check for serial port event */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_SERIAL</span> <span class="p">)</span>
                <span class="n">llSerialService</span><span class="p">();</span>

            <span class="cm">/* Exit Kernel Mode */</span>
            <span class="n">llExit</span><span class="p">();</span>

            <span class="cm">/* Check for a change in link status.  Do this outside of above */</span>
            <span class="cm">/* llEnter/llExit pair as to avoid illegal reentrant calls to */</span>
            <span class="cm">/* kernel mode by user&#39;s callback. */</span>

            <span class="cm">/* Check for link up status */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_LINKUP</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Call the link status callback, if user registered one */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">NetLinkHook</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* Pass callback function a link status of &quot;up&quot; */</span>
                    <span class="p">(</span><span class="o">*</span><span class="n">NetLinkHook</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* Check for link down status */</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">fEvents</span> <span class="o">&amp;</span> <span class="n">FLAG_EVENT_LINKDOWN</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Call the link status callback, if user registered one */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">NetLinkHook</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* Pass callback function a link status of &quot;down&quot; */</span>
                    <span class="p">(</span><span class="o">*</span><span class="n">NetLinkHook</span><span class="p">)(</span><span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="disabling-on-demand-services">
<h2>4.3 Disabling On-Demand Services<a class="headerlink" href="#disabling-on-demand-services" title="Permalink to this headline">¶</a></h2>
<p>The NETCTRL library is designed to support “potential” stack features that the user may desire within an application (e.g. DHCP server). However, the drawback of this is that the code for such features will be included in the executable even if the application never uses the features. This results in a larger footprint than is usually necessary. To minimize this problem, the following different versions of the NETCTRL library are available:</p>
<ul class="simple">
<li><p><strong>netctrl_min.</strong> This minimal library enables only the DHCP client. It should be used when a minimal footprint is desired.</p></li>
<li><p><strong>netctrl.</strong> This “standard” version of the NETCTRL library enables the following features and has a medium footprint:</p>
<ul>
<li><p>Telnet server</p></li>
<li><p>DHCP client</p></li>
</ul>
</li>
<li><p><strong>netctrl_full.</strong> This “full” library enables all supported NETCTRL features, which include:</p>
<ul>
<li><p>Telnet server</p></li>
<li><p>NAT server</p></li>
<li><p>DHCP client</p></li>
<li><p>DHCP server</p></li>
<li><p>DNS server</p></li>
</ul>
</li>
</ul>
<p>Each of these NETCTRL library versions is built for both pure IPv4 as well as IPv6.</p>
<p>If you configure the NDK using the SysConfig tool, the appropriate NETCTRL library will be automatically added to the generated linker.cmd file.</p>
<p>If you need even more control over which features are available in the NETCTRL library used by your application, you can #define the following constants in <code class="docutils literal notranslate"><span class="pre">/ti/ndk/inc/netctrl/netsrv.h</span></code>, which control the features brought into the NETCTRL library if <code class="docutils literal notranslate"><span class="pre">_NDK_EXTERN_CONFIG</span></code> is not defined.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NETSRV_ENABLE_TELNET 1</span>
<span class="cp">#define NETSRV_ENABLE_NAT 0</span>
<span class="cp">#define NETSRV_ENABLE_DHCPCLIENT 1</span>
<span class="cp">#define NETSRV_ENABLE_DHCPSERVER 1</span>
<span class="cp">#define NETSRV_ENABLE_DNSSERVER 1</span>
</pre></div>
</div>
<p>By setting any of the above to 0 and rebuilding the appropriate NETCTRL library, individual services can be purged from the executable.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="05_os-adaptation-layer.html" class="btn btn-neutral float-right" title="5 OS Adaptation Layer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="stack.html" class="btn btn-neutral float-left" title="3 Stack" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>