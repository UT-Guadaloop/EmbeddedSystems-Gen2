

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3 Stack &mdash; NDK Users Guide  documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4 Network Control Functions" href="04_network-control-functions.html" />
    <link rel="prev" title="2 Network Application Development" href="03_network-application-development.html" /> 
</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> NDK Users Guide
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="02_overview.html">1 Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_network-application-development.html">2 Network Application Development</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3 Stack</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#packet-buffer-manager-pbm-c">3.1 Packet Buffer Manager: PBM.C</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#packet-buffer-pool">3.1.1 Packet Buffer Pool</a></li>
<li class="toctree-l3"><a class="reference internal" href="#packet-buffer-allocation-method">3.1.2 Packet Buffer Allocation Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referenced-route-handles">3.1.3 Referenced Route Handles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#network-interface-manager-unit-nimu">3.2 Network Interface Manager Unit (NIMU)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nimu-device-table">3.2.1 NIMU Device Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nimu-driver-development">3.2.2 NIMU Driver Development</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="04_network-control-functions.html">4 Network Control Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_os-adaptation-layer.html">5 OS Adaptation Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="99_endmaterial.html">Related Documentation From Texas Instruments</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NDK Users Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>3 Stack</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="stack">
<h1>3 Stack<a class="headerlink" href="#stack" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the stack functions.</p>
<div class="section" id="packet-buffer-manager-pbm-c">
<h2>3.1 Packet Buffer Manager: PBM.C<a class="headerlink" href="#packet-buffer-manager-pbm-c" title="Permalink to this headline">¶</a></h2>
<p>The Packet Buffer Manager (PBM) is charged with managing all the packet buffers in the system. Packet buffers are used by the NDK and device drivers to carry networking packet data. The PBM programming abstraction is discussed in the <em>NDK Programmer’s Reference Guide</em>. This section discusses the implementation provided in the NDK.</p>
<div class="section" id="packet-buffer-pool">
<h3>3.1.1 Packet Buffer Pool<a class="headerlink" href="#packet-buffer-pool" title="Permalink to this headline">¶</a></h3>
<p>See the networking examples in your SDK for references on configuring PBM buffers in your system. In some SDKs this is done using SysConfig, in others it’s done by declaring static buffer arrays in a C source file. You can set the <strong>number of frames</strong>, the <strong>frame buffer size</strong>, and the <strong>memory section</strong> where the buffers will be created.</p>
<p>Note that for systems with cache, when the PBM memory is declared, it is placed on a cache aligned boundary. Also note that each packet buffer must be an even number of cache lines in size so that it can be reliably flushed without the risk of conflicting with other buffers.</p>
</div>
<div class="section" id="packet-buffer-allocation-method">
<h3>3.1.2 Packet Buffer Allocation Method<a class="headerlink" href="#packet-buffer-allocation-method" title="Permalink to this headline">¶</a></h3>
<p>The basic method of buffer allocation is the buffer pool. Buffers are allocated when the <code class="docutils literal notranslate"><span class="pre">PBM_alloc()</span></code> function is called. This function can be called at interrupt time, so you must ensure only non-blocking calls are made as a result. However, only device drivers can make calls from an ISR and device drivers never ask for a buffer larger than <code class="docutils literal notranslate"><span class="pre">PKT_SIZE_FRAMEBUF</span></code>. Therefore, the fallback method for allocating larger buffers can technically make blocking calls, although the implementation included in the NDK does not make blocking calls under any circumstance.</p>
<p>The basic method of allocation is to check the size. When the size is less than or equal to <code class="docutils literal notranslate"><span class="pre">PKT_SIZE_FRAMEBUF</span></code>, then the packet buffer is obtained off the free queue. If there are no free packet buffers on the queue, the function returns NULL. Note that the PBM module could be modified to grow the free pool or use memory allocation as a fallback, but any buffer supplied as a result of a request with the size less than or equal to <code class="docutils literal notranslate"><span class="pre">PKT_SIZE_FRAMEBUF</span></code>, must adhere to the cache line restrictions outlined in the previous section.</p>
<p>For packet buffers larger than <code class="docutils literal notranslate"><span class="pre">PKT_SIZE_FRAMEBUF</span></code>, standard memory can be used. These allocation requests are only made for re-assembling large IP packets. The resulting packet cannot be submitted to a hardware device without being fragmented. Therefore, the packet buffer does not need to be compatible for hardware transmission.</p>
</div>
<div class="section" id="referenced-route-handles">
<h3>3.1.3 Referenced Route Handles<a class="headerlink" href="#referenced-route-handles" title="Permalink to this headline">¶</a></h3>
<p>One of the fields in the PBM structure is a referenced handle to a route used to route a packet to its final destination. The PBM module must be aware of this handle when freeing a packet buffer or copying a packet buffer.</p>
<p>When packet buffer is freed by calling <code class="docutils literal notranslate"><span class="pre">PBM_free()</span></code>, the PBM module must check for a route handle held by the packet buffer, and dereference the handle if it exists. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span> <span class="n">pPkt</span><span class="o">-&gt;</span><span class="n">hRoute</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">RtDeRef</span><span class="p">(</span> <span class="n">pPkt</span><span class="o">-&gt;</span><span class="n">hRoute</span> <span class="p">);</span>
    <span class="n">pPkt</span><span class="o">-&gt;</span><span class="n">hRoute</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As noted in the source code to PBM.C, the function <code class="docutils literal notranslate"><span class="pre">RtDeRef()</span></code> can only be called from kernel mode. However, instead of defining two versions of the <code class="docutils literal notranslate"><span class="pre">PBM_free()</span></code> function, the PBM module relies on the fact that device drivers are never given packet buffers containing routes. Therefore, any call to <code class="docutils literal notranslate"><span class="pre">PBM_free()</span></code> where the buffer contains a route, must have been called from within kernel mode. It is, therefore, safe to call <code class="docutils literal notranslate"><span class="pre">RtDeRef()</span></code>.</p>
<p>When a packet buffer is copied with <code class="docutils literal notranslate"><span class="pre">PBM_copy()</span></code>, all the information about the packet is also copied. This information may include a referenced route handle. If the handle to a route is copied in the process of copying the packet buffer, then a reference to that handle must also be added by calling the <code class="docutils literal notranslate"><span class="pre">RtRef()</span></code> function. The PBM module does not need to worry about kernel mode for the same reason as it did not with <code class="docutils literal notranslate"><span class="pre">PBM_free()</span></code>.</p>
</div>
</div>
<div class="section" id="network-interface-manager-unit-nimu">
<h2>3.2 Network Interface Manager Unit (NIMU)<a class="headerlink" href="#network-interface-manager-unit-nimu" title="Permalink to this headline">¶</a></h2>
<p>The Network Interface Management Unit (NIMU) layer interfaces with the NDK core stack. It enables the stack to control the device at runtime. This layer is platform-independent and is portable across various platforms.</p>
<p>A network interface in this context is analogous to a linux network interface.</p>
<div class="section" id="nimu-device-table">
<h3>3.2.1 NIMU Device Table<a class="headerlink" href="#nimu-device-table" title="Permalink to this headline">¶</a></h3>
<p>The NIMU Device Table is a user defined table enumerating all the Network Interfaces to be used with the NDK. The user has to create this table in their application code or else the application will fail to link with the NDK stack library.</p>
<blockquote>
<div><p><strong>NOTE</strong>: If you configure the NDK using the SysConfig tool, the NIMU Device Table will be generated for you by the “NDK Interfaces” module.</p>
</div></blockquote>
<p>The declaration for the table can be found in <code class="docutils literal notranslate"><span class="pre">src/ti/ndk/inc/stack/inc/nimuif.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*********************************************************************</span>
<span class="cm"> * DESCRIPTION   :</span>
<span class="cm"> *  The NIMUDeviceTable is a NULL terminated array of driver</span>
<span class="cm"> *  initialization functions which is called by the NDK Network</span>
<span class="cm"> *  Interface Management functions during the NDK Core Initialization.</span>
<span class="cm"> *  The table needs to be populated by the driver authors for each</span>
<span class="cm"> *  platform to have a list of all driver initialization functions.</span>
<span class="cm"> *********************************************************************/</span>
<span class="k">extern</span> <span class="n">NIMU_DEVICE_TABLE_ENTRY</span>  <span class="n">NIMUDeviceTable</span><span class="p">[];</span>
</pre></div>
</div>
<p>An example of a NIMU Device Table is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NIMU_DEVICE_TABLE_ENTRY</span> <span class="n">NIMUDeviceTable</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">emac0_init</span>
<span class="p">},</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">emac1_init</span>
<span class="p">},</span>
<span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>
</pre></div>
</div>
<p>Each entry in the table defines the initialization function for a NIMU driver. This initialization function is called by the stack at stack startup time. The <code class="docutils literal notranslate"><span class="pre">.init</span></code> member is the only recognized member for NIMU Device Table entries.</p>
<p>Many NDK APIs need to reference a Network Interface by its Interface ID. This is the Interface’s index in the Device Table + 1. So the interface with the init function of <code class="docutils literal notranslate"><span class="pre">emac0_init</span></code> in the example above has the Interface ID of <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div>
<div class="section" id="nimu-driver-development">
<h3>3.2.2 NIMU Driver Development<a class="headerlink" href="#nimu-driver-development" title="Permalink to this headline">¶</a></h3>
<p>In most cases a NIMU driver will already be included in your sdk. If you are interested in writing your own NIMU driver then you can refer to the <a class="reference external" href="../../NDK_API_Reference.html#a.13-network-interface-management-unit-nimu">NIMU Section</a> in the NDK API Reference Guide or the <a class="reference external" href="../../NDK_Driver_Design_Guide.pdf">NDK Driver Design Guide</a></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="04_network-control-functions.html" class="btn btn-neutral float-right" title="4 Network Control Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="03_network-application-development.html" class="btn btn-neutral float-left" title="2 Network Application Development" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>