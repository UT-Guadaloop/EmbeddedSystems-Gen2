<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>UART2.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_a59555fa6928a28ba1fd94639418fed2.html">tidrivers_msp432e4</a></li><li class="navelem"><a class="el" href="dir_881bc3ea3e0b6773ef082a7a8f546747.html">source</a></li><li class="navelem"><a class="el" href="dir_d200e2eb2d76e462bf7bb2f8b0aadb1e.html">ti</a></li><li class="navelem"><a class="el" href="dir_c7c3caac9c05bea82305b87d191db62d.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">UART2.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>PRELIMINARY</b> UART driver interface </p>
<hr/>
<p><b>WARNING</b> These APIs are <b>PRELIMINARY</b>, and subject to change in the next few months.</p>
<p>To use the UART2 driver, ensure that the correct driver library for your device is linked in and include this header file as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t2_8h.html">ti/drivers/UART2.h</a>&gt;</span></div></div><!-- fragment --><p>This module serves as the main interface for applications. Its purpose is to redirect the UART2 APIs to specific driver implementations which are specified using a pointer to a <a class="el" href="struct_u_a_r_t2___fxn_table.html" title="The definition of a UART2 function table that contains the required set of functions to control a spe...">UART2_FxnTable</a>.</p>
<p><a class="anchor" id="ti_drivers_UART2_Overview"></a></p><h1>Overview</h1>
<p>A UART is used to translate data between the chip and a serial port. The UART2 driver simplifies reading and writing to any of the UART peripherals on the board, with multiple modes of operation and performance. These include blocking, non-blocking, and polling modes.</p>
<p>The UART2 driver interface provides device independent APIs, data types, and macros. The APIs in this driver serve as an interface to a typical RTOS application. The specific peripheral implementations are responsible for creating all the RTOS specific primitives to allow for thread-safe operation.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_UART2_Usage"></a></p><h1>Usage</h1>
<p>This documentation provides a basic <a class="el" href="_u_a_r_t2_8h.html#ti_drivers_UART2_Synopsis">usage summary</a> and a set of <a class="el" href="_u_a_r_t2_8h.html#ti_drivers_UART2_Examples">examples</a> in the form of commented code fragments. Detailed descriptions of the APIs are provided in subsequent sections.</p>
<p><a class="anchor" id="ti_drivers_UART2_Synopsis"></a></p><h2>Synopsis</h2>
<p><a class="anchor" id="ti_drivers_UART2_Synopsis_Code"></a></p><div class="fragment"><div class="line"><span class="comment">// Import the UART2 driver definitions</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_u_a_r_t2_8h.html">ti/drivers/UART2.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Initialize UART2 parameters</span></div><div class="line"><a class="code" href="struct_u_a_r_t2___params.html">UART2_Params</a> params;</div><div class="line"><a class="code" href="_u_a_r_t2_8h.html#a8fd27db3b9bcca2fc88f65b2d26895d5">UART2_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_u_a_r_t2___params.html#a52da516a384dd7b59d8570ac05562f9e">baudRate</a> = 9600;</div><div class="line">params.<a class="code" href="struct_u_a_r_t2___params.html#a6dd95ee323c2aabf14b1aa82e27bc7a3">readMode</a> = <a class="code" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>;</div><div class="line">params.<a class="code" href="struct_u_a_r_t2___params.html#a7ee665634b02989a5a506dce0b51d298">writeMode</a> = <a class="code" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>;</div><div class="line"></div><div class="line"><span class="comment">// Open the UART</span></div><div class="line"><a class="code" href="struct_u_a_r_t2___config__.html">UART2_Handle</a> uart;</div><div class="line">uart = <a class="code" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b">UART2_open</a>(CONFIG_UART0, &amp;params);</div><div class="line"></div><div class="line"><span class="comment">// Read from the UART.</span></div><div class="line"><span class="keywordtype">size_t</span>  bytesRead;</div><div class="line">uint8_t buffer[BUFSIZE];</div><div class="line">int32_t status;</div><div class="line">status = <a class="code" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d">UART2_read</a>(uart, buffer, BUFSIZE, &amp;bytesRead);</div><div class="line"></div><div class="line"><span class="comment">// Write to the UART</span></div><div class="line"><span class="keywordtype">size_t</span>  bytesWritten;</div><div class="line">status = <a class="code" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf">UART2_write</a>(uart, buffer, BUFSIZE, &amp;bytesWritten);</div><div class="line"></div><div class="line"><span class="comment">// Close the UART</span></div><div class="line"><a class="code" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde">UART2_close</a>(uart);</div></div><!-- fragment --><hr/>
<p> <a class="anchor" id="ti_drivers_UART2_Examples"></a></p><h1>Examples</h1>
<p>The following code example opens a UART instance, reads a byte from the UART, and then writes the byte back to the UART.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>        input;</div><div class="line"><a class="code" href="struct_u_a_r_t2___config__.html">UART2_Handle</a> uart;</div><div class="line"><a class="code" href="struct_u_a_r_t2___params.html">UART2_Params</a> uartParams;</div><div class="line"></div><div class="line"><span class="comment">// Open an instance of the UART2 driver</span></div><div class="line"><a class="code" href="_u_a_r_t2_8h.html#a8fd27db3b9bcca2fc88f65b2d26895d5">UART2_Params_init</a>(&amp;uartParams);</div><div class="line">uartParams.<a class="code" href="struct_u_a_r_t2___params.html#a52da516a384dd7b59d8570ac05562f9e">baudRate</a> = 115200;</div><div class="line">uart = <a class="code" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b">UART2_open</a>(CONFIG_UART0, &amp;uartParams);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (uart == NULL) {</div><div class="line">    <span class="comment">// UART2_open() failed</span></div><div class="line">    <span class="keywordflow">while</span> (1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Loop forever echoing</span></div><div class="line"><span class="keywordflow">while</span> (1) {</div><div class="line">    status = <a class="code" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d">UART2_read</a>(uart, &amp;input, 1, &amp;bytesRead);</div><div class="line">    status = <a class="code" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf">UART2_write</a>(uart, &amp;input, 1, &amp;bytesWritten);</div><div class="line">}</div></div><!-- fragment --><p>Details for the example code above are described in the following subsections.</p>
<h3>Opening the UART2 Driver</h3>
<p>Opening a UART requires four steps:</p><ol type="1">
<li>Create and initialize a <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> structure.</li>
<li>Fill in the desired parameters.</li>
<li>Call <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a>, passing the index of the UART in the UART2_config structure, and the address of the <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> structure. The UART2 instance is specified by the index in the UART2_config structure.</li>
<li>Check that the UART2 handle returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> is non-NULL, and save it. The handle will be used to read and write to the UART you just opened.</li>
</ol>
<p>Only one UART index can be used at a time; calling <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> a second time with the same index previosly passed to <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>. In the previous example code, CONFIG_UART0 is passed to <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a>. This macro is defined in the example's ti_drivers_config.h file.</p>
<h3>Modes of Operation</h3>
<p>The UART driver can operate in blocking, callback, or polling mode, by setting the writeMode and readMode parameters passed to <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a>. If these parameters are not set, as in the example code, the UART2 driver defaults to blocking mode. Options for the writeMode and readMode parameters are <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, and <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>:</p>
<ul>
<li><a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a> uses a semaphore to block while data is being sent. The context of calling <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> and <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> must be a Task when using <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>. The <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> or <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> call will block until all data is sent or received, or an error occurs (e.g., framing or FIFO overrun). In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, <a class="el" href="_u_a_r_t2_8h.html#a0f025f78353515c8b0050f9d41596969" title="Function that reads data from a UART, with a specified timeout for blocking mode. ...">UART2_readTimeout()</a> can be used to specify a timeout in system clock ticks, to wait for data. <a class="el" href="_u_a_r_t2_8h.html#a0f025f78353515c8b0050f9d41596969" title="Function that reads data from a UART, with a specified timeout for blocking mode. ...">UART2_readTimeout()</a> will return when all data is received, or the specified timeout expires, or an error occurs, whichever happens first.</li>
<li><a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> is non-blocking and <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> and <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> will return while data is being sent in the context of a hardware interrupt. When the read or write finishes, the UART2 driver will call the user's callback function. In some cases, the UART data transfer may have been cancelled, so the number of bytes sent/received are passed to the callback function. Your implementation of the callback function can use this information as needed. Since the user's callback may be called in the context of a hardware interrupt, the callback function must not make any RTOS blocking calls. The buffer passed to <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the tx callback has been called with a byte count equal to that passed to <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a>).</li>
</ul>
<h3>Reading and Writing data</h3>
<p>The example code reads one byte frome the UART instance, and then writes one byte back to the same instance:</p>
<div class="fragment"><div class="line">status = <a class="code" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d">UART2_read</a>(uart, &amp;input, 1, &amp;bytesRead);</div><div class="line">status = <a class="code" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf">UART2_write</a>(uart, &amp;input, 1, &amp;bytesWritten);</div></div><!-- fragment --><p>The UART2 driver allows full duplex data transfers. Therefore, it is possible to call <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> and <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> at the same time (for either blocking or callback modes). It is not possible, however, to issue multiple concurrent operations in the same direction. For example, if one thread calls UART2_read(uart0, buffer0...), any other thread attempting UART2_read(uart0, buffer1...) will result in an error of UART2_STATUS_EINUSE, until all the data from the first <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> has been transferred to buffer0. This applies to blocking, callback, and polling modes. So applications must either synchronize <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> (or <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a>) calls that use the same UART handle, or check for the UART2_STATUS_EINUSE return code indicating that a transfer is still ongoing.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_UART2_Configuration"></a></p><h1>Configuration</h1>
<p>Refer to the <a class="el" href="index.html#driver_configuration">Driver's Configuration</a> section for driver configuration information. </p><hr/>
 <hr/>
</div><div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for UART2.h:</div>
<div class="dyncontent">
<div class="center"><img src="_u_a_r_t2_8h__incl.png" border="0" usemap="#_u_a_r_t2_8h" alt=""/></div>
<map name="_u_a_r_t2_8h" id="_u_a_r_t2_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_u_a_r_t2_8h__dep__incl.png" border="0" usemap="#_u_a_r_t2_8hdep" alt=""/></div>
<map name="_u_a_r_t2_8hdep" id="_u_a_r_t2_8hdep">
<area shape="rect" id="node2" href="_u_a_r_t2_m_s_p432_e4_8h.html" title="UART driver implementation for a MSP432E4 UART controller. " alt="" coords="5,80,148,107"/>
<area shape="rect" id="node3" href="_display_uart2_8h.html" title="Display.h implementation for UART output. " alt="" coords="173,80,282,107"/>
</map>
</div>
</div>
<p><a href="_u_a_r_t2_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 Parameters.  <a href="struct_u_a_r_t2___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t2___fxn_table.html">UART2_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART2 function table that contains the required set of functions to control a specific UART2 driver implementation.  <a href="struct_u_a_r_t2___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t2___config__.html">UART2_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 Global configuration.  <a href="struct_u_a_r_t2___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga50f50c06775b7ee13f45fe80c93fb356"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356">UART2_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga50f50c06775b7ee13f45fe80c93fb356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by UART2 APIs.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356">More...</a><br /></td></tr>
<tr class="separator:ga50f50c06775b7ee13f45fe80c93fb356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eafae271234b3df03442a2f5b1b7270"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga2eafae271234b3df03442a2f5b1b7270">UART2_STATUS_SREADTIMEOUT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga2eafae271234b3df03442a2f5b1b7270"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read timeout occurred (not an error).  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga2eafae271234b3df03442a2f5b1b7270">More...</a><br /></td></tr>
<tr class="separator:ga2eafae271234b3df03442a2f5b1b7270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056a6acd9fc1a49cb30c8baabecc35df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga056a6acd9fc1a49cb30c8baabecc35df">UART2_STATUS_EFRAMING</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga056a6acd9fc1a49cb30c8baabecc35df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A framing error occurred.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga056a6acd9fc1a49cb30c8baabecc35df">More...</a><br /></td></tr>
<tr class="separator:ga056a6acd9fc1a49cb30c8baabecc35df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d362690c0ab4dd14e50f53737499a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaa3d362690c0ab4dd14e50f53737499a1">UART2_STATUS_EPARITY</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:gaa3d362690c0ab4dd14e50f53737499a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parity error occurred.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gaa3d362690c0ab4dd14e50f53737499a1">More...</a><br /></td></tr>
<tr class="separator:gaa3d362690c0ab4dd14e50f53737499a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4684c6671d256dc72b13ddb1eafd9971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4684c6671d256dc72b13ddb1eafd9971">UART2_STATUS_EBREAK</a>&#160;&#160;&#160;(-4)</td></tr>
<tr class="memdesc:ga4684c6671d256dc72b13ddb1eafd9971"><td class="mdescLeft">&#160;</td><td class="mdescRight">A break error occurred.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4684c6671d256dc72b13ddb1eafd9971">More...</a><br /></td></tr>
<tr class="separator:ga4684c6671d256dc72b13ddb1eafd9971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab410e4da00bc79fdbbe921e89a78ffeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gab410e4da00bc79fdbbe921e89a78ffeb">UART2_STATUS_EOVERRUN</a>&#160;&#160;&#160;(-8)</td></tr>
<tr class="memdesc:gab410e4da00bc79fdbbe921e89a78ffeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A FIFO overrun occurred.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gab410e4da00bc79fdbbe921e89a78ffeb">More...</a><br /></td></tr>
<tr class="separator:gab410e4da00bc79fdbbe921e89a78ffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec322208aa002ae4b058a410a387801"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801">UART2_STATUS_EINUSE</a>&#160;&#160;&#160;(-9)</td></tr>
<tr class="memdesc:ga0ec322208aa002ae4b058a410a387801"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UART is currently in use.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801">More...</a><br /></td></tr>
<tr class="separator:ga0ec322208aa002ae4b058a410a387801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a4b2002f04d6caaeee837aa662e7d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gac2a4b2002f04d6caaeee837aa662e7d4">UART2_STATUS_EINVALID</a>&#160;&#160;&#160;(-10)</td></tr>
<tr class="memdesc:gac2a4b2002f04d6caaeee837aa662e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid argument or <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> field was passed to UART2 API.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gac2a4b2002f04d6caaeee837aa662e7d4">More...</a><br /></td></tr>
<tr class="separator:gac2a4b2002f04d6caaeee837aa662e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e0d7738225ce8f423e32e0c90d883e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad3e0d7738225ce8f423e32e0c90d883e">UART2_STATUS_EFAIL</a>&#160;&#160;&#160;(-11)</td></tr>
<tr class="memdesc:gad3e0d7738225ce8f423e32e0c90d883e"><td class="mdescLeft">&#160;</td><td class="mdescRight">General failure status returned by UART2 API.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gad3e0d7738225ce8f423e32e0c90d883e">More...</a><br /></td></tr>
<tr class="separator:gad3e0d7738225ce8f423e32e0c90d883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cab16fd65127a1987a20caa0653476b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4cab16fd65127a1987a20caa0653476b">UART2_STATUS_EMEMORY</a>&#160;&#160;&#160;(-12)</td></tr>
<tr class="memdesc:ga4cab16fd65127a1987a20caa0653476b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory allocation failure occurred.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4cab16fd65127a1987a20caa0653476b">More...</a><br /></td></tr>
<tr class="separator:ga4cab16fd65127a1987a20caa0653476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb708c48cd2517f08660196f16d31a33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaeb708c48cd2517f08660196f16d31a33">UART2_STATUS_ETIMEOUT</a>&#160;&#160;&#160;(-13)</td></tr>
<tr class="memdesc:gaeb708c48cd2517f08660196f16d31a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timeout occurred for a blocking UART2_read or UART2_write call.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gaeb708c48cd2517f08660196f16d31a33">More...</a><br /></td></tr>
<tr class="separator:gaeb708c48cd2517f08660196f16d31a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad528e61ecc06c90d5824796ce547ecb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7">UART2_STATUS_ECANCELLED</a>&#160;&#160;&#160;(-14)</td></tr>
<tr class="memdesc:gad528e61ecc06c90d5824796ce547ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> or <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> operation was cancelled.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7">More...</a><br /></td></tr>
<tr class="separator:gad528e61ecc06c90d5824796ce547ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bfc05124702d98c0540896ead270a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga02bfc05124702d98c0540896ead270a0">UART2_STATUS_ENOTOPEN</a>&#160;&#160;&#160;(-15)</td></tr>
<tr class="memdesc:ga02bfc05124702d98c0540896ead270a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> or <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> called on a device not opened.  <a href="group___u_a_r_t2___s_t_a_t_u_s.html#ga02bfc05124702d98c0540896ead270a0">More...</a><br /></td></tr>
<tr class="separator:ga02bfc05124702d98c0540896ead270a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e3ea6008dfc427628433dc5ac6592"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#ad94e3ea6008dfc427628433dc5ac6592">UART2_WAIT_FOREVER</a>&#160;&#160;&#160;(~(0U))</td></tr>
<tr class="memdesc:ad94e3ea6008dfc427628433dc5ac6592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define.  <a href="#ad94e3ea6008dfc427628433dc5ac6592">More...</a><br /></td></tr>
<tr class="separator:ad94e3ea6008dfc427628433dc5ac6592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abbf55a000a1ce4c24c15c03fbb610b60"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t2___config__.html">UART2_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a></td></tr>
<tr class="memdesc:abbf55a000a1ce4c24c15c03fbb610b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> call.  <a href="#abbf55a000a1ce4c24c15c03fbb610b60">More...</a><br /></td></tr>
<tr class="separator:abbf55a000a1ce4c24c15c03fbb610b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d68ce47bb8b798f31c3338077d301a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a00d68ce47bb8b798f31c3338077d301a">UART2_Callback</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buf, size_t count, void *userArg, int_fast16_t status)</td></tr>
<tr class="memdesc:a00d68ce47bb8b798f31c3338077d301a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART2 driver when used in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> The callback can occur in task or interrupt context.  <a href="#a00d68ce47bb8b798f31c3338077d301a">More...</a><br /></td></tr>
<tr class="separator:a00d68ce47bb8b798f31c3338077d301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d8a9b5f17bcff4e45ead5f5cc7f840"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#af5d8a9b5f17bcff4e45ead5f5cc7f840">UART2_CloseFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:af5d8a9b5f17bcff4e45ead5f5cc7f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#af5d8a9b5f17bcff4e45ead5f5cc7f840" title="A function pointer to a driver specific implementation of UART2_CloseFxn(). ">UART2_CloseFxn()</a>.  <a href="#af5d8a9b5f17bcff4e45ead5f5cc7f840">More...</a><br /></td></tr>
<tr class="separator:af5d8a9b5f17bcff4e45ead5f5cc7f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa5891ee52a732cf856e7b252ad4c20"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a8fa5891ee52a732cf856e7b252ad4c20">UART2_FlushRxFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a8fa5891ee52a732cf856e7b252ad4c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to flush the RX data currently in the FIFO.  <a href="#a8fa5891ee52a732cf856e7b252ad4c20">More...</a><br /></td></tr>
<tr class="separator:a8fa5891ee52a732cf856e7b252ad4c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3127226f01c75bcec70428aae16f1a0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#ad3127226f01c75bcec70428aae16f1a0">UART2_OpenFxn</a>) (uint_least8_t index, <a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *params)</td></tr>
<tr class="memdesc:ad3127226f01c75bcec70428aae16f1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#ad3127226f01c75bcec70428aae16f1a0" title="A function pointer to a driver specific implementation of UART2_OpenFxn(). ">UART2_OpenFxn()</a>.  <a href="#ad3127226f01c75bcec70428aae16f1a0">More...</a><br /></td></tr>
<tr class="separator:ad3127226f01c75bcec70428aae16f1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d71293060697e153d50dd20ac28cfd4"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a0d71293060697e153d50dd20ac28cfd4">UART2_ReadFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buffer, size_t size, size_t *bytesRead, uint32_t timeout)</td></tr>
<tr class="memdesc:a0d71293060697e153d50dd20ac28cfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a0d71293060697e153d50dd20ac28cfd4" title="A function pointer to a driver specific implementation of UART2_ReadFxn(). ">UART2_ReadFxn()</a>.  <a href="#a0d71293060697e153d50dd20ac28cfd4">More...</a><br /></td></tr>
<tr class="separator:a0d71293060697e153d50dd20ac28cfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421e6f83dc5ad9f786277ed70c6e3e0c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a421e6f83dc5ad9f786277ed70c6e3e0c">UART2_ReadCancelFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a421e6f83dc5ad9f786277ed70c6e3e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a421e6f83dc5ad9f786277ed70c6e3e0c" title="A function pointer to a driver specific implementation of UART2_ReadCancelFxn(). ">UART2_ReadCancelFxn()</a>.  <a href="#a421e6f83dc5ad9f786277ed70c6e3e0c">More...</a><br /></td></tr>
<tr class="separator:a421e6f83dc5ad9f786277ed70c6e3e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dbaef8e8f6fd515a11c5fef172a927"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a08dbaef8e8f6fd515a11c5fef172a927">UART2_WriteFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, const void *buffer, size_t size, size_t *bytesWritten, uint32_t timeout)</td></tr>
<tr class="memdesc:a08dbaef8e8f6fd515a11c5fef172a927"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a08dbaef8e8f6fd515a11c5fef172a927" title="A function pointer to a driver specific implementation of UART2_WriteFxn(). ">UART2_WriteFxn()</a>.  <a href="#a08dbaef8e8f6fd515a11c5fef172a927">More...</a><br /></td></tr>
<tr class="separator:a08dbaef8e8f6fd515a11c5fef172a927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fe1832cd5a079387f38f86b33aec61"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a72fe1832cd5a079387f38f86b33aec61">UART2_WriteCancelFxn</a>) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a72fe1832cd5a079387f38f86b33aec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a72fe1832cd5a079387f38f86b33aec61" title="A function pointer to a driver specific implementation of UART2_WriteCancelFxn(). ...">UART2_WriteCancelFxn()</a>.  <a href="#a72fe1832cd5a079387f38f86b33aec61">More...</a><br /></td></tr>
<tr class="separator:a72fe1832cd5a079387f38f86b33aec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9ed8d3be24bf0ba355ec100f9eabbd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t2___config__.html">UART2_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a5a9ed8d3be24bf0ba355ec100f9eabbd">UART2_Config</a></td></tr>
<tr class="memdesc:a5a9ed8d3be24bf0ba355ec100f9eabbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 Global configuration.  <a href="#a5a9ed8d3be24bf0ba355ec100f9eabbd">More...</a><br /></td></tr>
<tr class="separator:a5a9ed8d3be24bf0ba355ec100f9eabbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5bfa1a3442db9943342497e519a08863"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863">UART2_Mode</a> { <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, 
<a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, 
<a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>
 }<tr class="memdesc:a5bfa1a3442db9943342497e519a08863"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 mode settings.  <a href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5bfa1a3442db9943342497e519a08863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab233d65776f6f909c674c5baae27637d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637d">UART2_ReadReturnMode</a> { <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a>, 
<a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a>
 }<tr class="memdesc:ab233d65776f6f909c674c5baae27637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 return mode settings.  <a href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab233d65776f6f909c674c5baae27637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c14675701ba732f156c2eea7e3f6515"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515">UART2_DataLen</a> { <a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515abf6427750460fb2f0d0cdfbd4a1dce9f">UART2_DataLen_5</a> = 0, 
<a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515ab53fa866e596d2ea28672962b30ea0d8">UART2_DataLen_6</a> = 1, 
<a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515ae669912970cfcd98fc5c5702f6256571">UART2_DataLen_7</a> = 2, 
<a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515abcb7ead4413215f0473c368f284ef729">UART2_DataLen_8</a> = 3
 }<tr class="memdesc:a6c14675701ba732f156c2eea7e3f6515"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 data length settings.  <a href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6c14675701ba732f156c2eea7e3f6515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d2d6413d7e338fd053569d848c239f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239f">UART2_StopBits</a> { <a class="el" href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239faa707a48589e67b81ac5a2f22342070e9">UART2_StopBits_1</a> = 0, 
<a class="el" href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239fa59f4de55d4d1844a50efc38f0e99bc84">UART2_StopBits_2</a> = 1
 }<tr class="memdesc:ae0d2d6413d7e338fd053569d848c239f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 stop bit settings.  <a href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae0d2d6413d7e338fd053569d848c239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb78d1b403c91619af5153a84994d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994d">UART2_Parity</a> { <br />
&#160;&#160;<a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994dafef829752e4d035a457dce76f23cec19">UART2_Parity_NONE</a> = 0, 
<a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994da7e4737a62b3bb4385542849b38a4c058">UART2_Parity_EVEN</a> = 1, 
<a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994da4a98084e16b8754a068fe9fb11c17ba5">UART2_Parity_ODD</a> = 2, 
<a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994dafc82a57ded8fec31003fe0b6520f1fa0">UART2_Parity_ZERO</a> = 3, 
<br />
&#160;&#160;<a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994dae95a66e405093bb4a4c4f071facfa1c9">UART2_Parity_ONE</a> = 4
<br />
 }<tr class="memdesc:a259cb78d1b403c91619af5153a84994d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 parity type settings.  <a href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a259cb78d1b403c91619af5153a84994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a82f370c2f15ececc5b03fbba65bcde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde">UART2_close</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a2a82f370c2f15ececc5b03fbba65bcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a UART peripheral specified by the UART2 handle.  <a href="#a2a82f370c2f15ececc5b03fbba65bcde">More...</a><br /></td></tr>
<tr class="separator:a2a82f370c2f15ececc5b03fbba65bcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc2eca3cffea172c99d152f7d4ebd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a63fc2eca3cffea172c99d152f7d4ebd9">UART2_flushRx</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a63fc2eca3cffea172c99d152f7d4ebd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to flush data in the UART RX FIFO.  <a href="#a63fc2eca3cffea172c99d152f7d4ebd9">More...</a><br /></td></tr>
<tr class="separator:a63fc2eca3cffea172c99d152f7d4ebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b76166f16518bc1cdf85fdf6aa206b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b">UART2_open</a> (uint_least8_t index, <a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *params)</td></tr>
<tr class="memdesc:a03b76166f16518bc1cdf85fdf6aa206b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral.  <a href="#a03b76166f16518bc1cdf85fdf6aa206b">More...</a><br /></td></tr>
<tr class="separator:a03b76166f16518bc1cdf85fdf6aa206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd27db3b9bcca2fc88f65b2d26895d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a8fd27db3b9bcca2fc88f65b2d26895d5">UART2_Params_init</a> (<a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *params)</td></tr>
<tr class="memdesc:a8fd27db3b9bcca2fc88f65b2d26895d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> struct to its defaults.  <a href="#a8fd27db3b9bcca2fc88f65b2d26895d5">More...</a><br /></td></tr>
<tr class="separator:a8fd27db3b9bcca2fc88f65b2d26895d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3406839adde44077da387c89fa9ddb0d"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d">UART2_read</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buffer, size_t size, size_t *bytesRead)</td></tr>
<tr class="memdesc:a3406839adde44077da387c89fa9ddb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART.  <a href="#a3406839adde44077da387c89fa9ddb0d">More...</a><br /></td></tr>
<tr class="separator:a3406839adde44077da387c89fa9ddb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f025f78353515c8b0050f9d41596969"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a0f025f78353515c8b0050f9d41596969">UART2_readTimeout</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buffer, size_t size, size_t *bytesRead, uint32_t timeout)</td></tr>
<tr class="memdesc:a0f025f78353515c8b0050f9d41596969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART, with a specified timeout for blocking mode.  <a href="#a0f025f78353515c8b0050f9d41596969">More...</a><br /></td></tr>
<tr class="separator:a0f025f78353515c8b0050f9d41596969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8302b9b2d54d3f8a428a9225e267a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#aa8302b9b2d54d3f8a428a9225e267a41">UART2_readCancel</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:aa8302b9b2d54d3f8a428a9225e267a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> function call.  <a href="#aa8302b9b2d54d3f8a428a9225e267a41">More...</a><br /></td></tr>
<tr class="separator:aa8302b9b2d54d3f8a428a9225e267a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec2c5906ad36adc14cddd011b3b7cf"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf">UART2_write</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, const void *buffer, size_t size, size_t *bytesWritten)</td></tr>
<tr class="memdesc:a85ec2c5906ad36adc14cddd011b3b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#a85ec2c5906ad36adc14cddd011b3b7cf">More...</a><br /></td></tr>
<tr class="separator:a85ec2c5906ad36adc14cddd011b3b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4b4c351fc4fb2663d6737a0cd4c7db"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db">UART2_writeTimeout</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, const void *buffer, size_t size, size_t *bytesWritten, uint32_t timeout)</td></tr>
<tr class="memdesc:adc4b4c351fc4fb2663d6737a0cd4c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART, with a specified timeout.  <a href="#adc4b4c351fc4fb2663d6737a0cd4c7db">More...</a><br /></td></tr>
<tr class="separator:adc4b4c351fc4fb2663d6737a0cd4c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7052ce61a02ae90920d11c9bacddbf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a7052ce61a02ae90920d11c9bacddbf1e">UART2_writeCancel</a> (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td></tr>
<tr class="memdesc:a7052ce61a02ae90920d11c9bacddbf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> function call.  <a href="#a7052ce61a02ae90920d11c9bacddbf1e">More...</a><br /></td></tr>
<tr class="separator:a7052ce61a02ae90920d11c9bacddbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a80d75291c42d2471b3c38dce6b6bdb0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_u_a_r_t2_8h.html#a5a9ed8d3be24bf0ba355ec100f9eabbd">UART2_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a80d75291c42d2471b3c38dce6b6bdb0a">UART2_config</a> []</td></tr>
<tr class="separator:a80d75291c42d2471b3c38dce6b6bdb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a11a7ad983146f408d8deb22b764710"><td class="memItemLeft" align="right" valign="top">const uint_least8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t2_8h.html#a9a11a7ad983146f408d8deb22b764710">UART2_count</a></td></tr>
<tr class="separator:a9a11a7ad983146f408d8deb22b764710"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad94e3ea6008dfc427628433dc5ac6592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e3ea6008dfc427628433dc5ac6592">&sect;&nbsp;</a></span>UART2_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART2_WAIT_FOREVER&#160;&#160;&#160;(~(0U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abbf55a000a1ce4c24c15c03fbb610b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf55a000a1ce4c24c15c03fbb610b60">&sect;&nbsp;</a></span>UART2_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t2___config__.html">UART2_Config_</a>* <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> call. </p>

</div>
</div>
<a id="a00d68ce47bb8b798f31c3338077d301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d68ce47bb8b798f31c3338077d301a">&sect;&nbsp;</a></span>UART2_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART2_Callback) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buf, size_t count, void *userArg, int_fast16_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART2 driver when used in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> The callback can occur in task or interrupt context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UART2_Handle</td><td>UART2_Handle</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to read/write buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements read/written</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userArg</td><td>A user supplied argument specified in <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A UART2_STATUS code indicating success or failure of the transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d8a9b5f17bcff4e45ead5f5cc7f840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d8a9b5f17bcff4e45ead5f5cc7f840">&sect;&nbsp;</a></span>UART2_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART2_CloseFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#af5d8a9b5f17bcff4e45ead5f5cc7f840" title="A function pointer to a driver specific implementation of UART2_CloseFxn(). ">UART2_CloseFxn()</a>. </p>

</div>
</div>
<a id="a8fa5891ee52a732cf856e7b252ad4c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa5891ee52a732cf856e7b252ad4c20">&sect;&nbsp;</a></span>UART2_FlushRxFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART2_FlushRxFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to flush the RX data currently in the FIFO. </p>

</div>
</div>
<a id="ad3127226f01c75bcec70428aae16f1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3127226f01c75bcec70428aae16f1a0">&sect;&nbsp;</a></span>UART2_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>(* UART2_OpenFxn) (uint_least8_t index, <a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#ad3127226f01c75bcec70428aae16f1a0" title="A function pointer to a driver specific implementation of UART2_OpenFxn(). ">UART2_OpenFxn()</a>. </p>

</div>
</div>
<a id="a0d71293060697e153d50dd20ac28cfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d71293060697e153d50dd20ac28cfd4">&sect;&nbsp;</a></span>UART2_ReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* UART2_ReadFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, void *buffer, size_t size, size_t *bytesRead, uint32_t timeout)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a0d71293060697e153d50dd20ac28cfd4" title="A function pointer to a driver specific implementation of UART2_ReadFxn(). ">UART2_ReadFxn()</a>. </p>

</div>
</div>
<a id="a421e6f83dc5ad9f786277ed70c6e3e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421e6f83dc5ad9f786277ed70c6e3e0c">&sect;&nbsp;</a></span>UART2_ReadCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART2_ReadCancelFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a421e6f83dc5ad9f786277ed70c6e3e0c" title="A function pointer to a driver specific implementation of UART2_ReadCancelFxn(). ">UART2_ReadCancelFxn()</a>. </p>

</div>
</div>
<a id="a08dbaef8e8f6fd515a11c5fef172a927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dbaef8e8f6fd515a11c5fef172a927">&sect;&nbsp;</a></span>UART2_WriteFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* UART2_WriteFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle, const void *buffer, size_t size, size_t *bytesWritten, uint32_t timeout)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a08dbaef8e8f6fd515a11c5fef172a927" title="A function pointer to a driver specific implementation of UART2_WriteFxn(). ">UART2_WriteFxn()</a>. </p>

</div>
</div>
<a id="a72fe1832cd5a079387f38f86b33aec61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fe1832cd5a079387f38f86b33aec61">&sect;&nbsp;</a></span>UART2_WriteCancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART2_WriteCancelFxn) (<a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t2_8h.html#a72fe1832cd5a079387f38f86b33aec61" title="A function pointer to a driver specific implementation of UART2_WriteCancelFxn(). ...">UART2_WriteCancelFxn()</a>. </p>

</div>
</div>
<a id="a5a9ed8d3be24bf0ba355ec100f9eabbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9ed8d3be24bf0ba355ec100f9eabbd">&sect;&nbsp;</a></span>UART2_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t2___config__.html">UART2_Config_</a>  <a class="el" href="_u_a_r_t2_8h.html#a5a9ed8d3be24bf0ba355ec100f9eabbd">UART2_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 Global configuration. </p>
<p>The UART2_Config structure contains a set of pointers used to characterize the UART2 driver implementation. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5bfa1a3442db9943342497e519a08863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfa1a3442db9943342497e519a08863">&sect;&nbsp;</a></span>UART2_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863">UART2_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c"></a>UART2_Mode_BLOCKING&#160;</td><td class="fielddoc"><p>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed"></a>UART2_Mode_CALLBACK&#160;</td><td class="fielddoc"><p>Non-blocking, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> or <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> will return immediately. When the transfer has finished, the callback function is called from either the caller's context or from an interrupt context. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04"></a>UART2_Mode_POLLING&#160;</td><td class="fielddoc"><p>UART is polled until all available data is received, or all data that can be sent without blocking is sent. Context of the call can be main(), Task, software interrupt, or hardware interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab233d65776f6f909c674c5baae27637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab233d65776f6f909c674c5baae27637d">&sect;&nbsp;</a></span>UART2_ReadReturnMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637d">UART2_ReadReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a>.</p>
<p><a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a> unblocks or performs a callback when the read buffer has been filled with the number of bytes passed to <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a>. <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a> unblocks or performs a callback whenever a read timeout error occurs on the UART peripheral. This timeout error is not the same as the blocking read timeout in the <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a>; the read timeout occurs if the read FIFO is non-empty and no new data has been received for a device/baudrate dependent number of clock cycles. This mode can be used when the exact number of bytes to be read is not known. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037"></a>UART2_ReadReturnMode_FULL&#160;</td><td class="fielddoc"><p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5"></a>UART2_ReadReturnMode_PARTIAL&#160;</td><td class="fielddoc"><p>Unblock/callback when no new data comes in. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6c14675701ba732f156c2eea7e3f6515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c14675701ba732f156c2eea7e3f6515">&sect;&nbsp;</a></span>UART2_DataLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515">UART2_DataLen</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c14675701ba732f156c2eea7e3f6515abf6427750460fb2f0d0cdfbd4a1dce9f"></a>UART2_DataLen_5&#160;</td><td class="fielddoc"><p>Data length is 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c14675701ba732f156c2eea7e3f6515ab53fa866e596d2ea28672962b30ea0d8"></a>UART2_DataLen_6&#160;</td><td class="fielddoc"><p>Data length is 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c14675701ba732f156c2eea7e3f6515ae669912970cfcd98fc5c5702f6256571"></a>UART2_DataLen_7&#160;</td><td class="fielddoc"><p>Data length is 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a id="a6c14675701ba732f156c2eea7e3f6515abcb7ead4413215f0473c368f284ef729"></a>UART2_DataLen_8&#160;</td><td class="fielddoc"><p>Data length is 8 bits </p>
</td></tr>
</table>

</div>
</div>
<a id="ae0d2d6413d7e338fd053569d848c239f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d2d6413d7e338fd053569d848c239f">&sect;&nbsp;</a></span>UART2_StopBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239f">UART2_StopBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 stop bit settings. </p>
<p>This enumeration defines the UART2 stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae0d2d6413d7e338fd053569d848c239faa707a48589e67b81ac5a2f22342070e9"></a>UART2_StopBits_1&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="ae0d2d6413d7e338fd053569d848c239fa59f4de55d4d1844a50efc38f0e99bc84"></a>UART2_StopBits_2&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="a259cb78d1b403c91619af5153a84994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb78d1b403c91619af5153a84994d">&sect;&nbsp;</a></span>UART2_Parity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t2_8h.html#a259cb78d1b403c91619af5153a84994d">UART2_Parity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 parity type settings. </p>
<p>This enumeration defines the UART2 parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a259cb78d1b403c91619af5153a84994dafef829752e4d035a457dce76f23cec19"></a>UART2_Parity_NONE&#160;</td><td class="fielddoc"><p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a id="a259cb78d1b403c91619af5153a84994da7e4737a62b3bb4385542849b38a4c058"></a>UART2_Parity_EVEN&#160;</td><td class="fielddoc"><p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a id="a259cb78d1b403c91619af5153a84994da4a98084e16b8754a068fe9fb11c17ba5"></a>UART2_Parity_ODD&#160;</td><td class="fielddoc"><p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a id="a259cb78d1b403c91619af5153a84994dafc82a57ded8fec31003fe0b6520f1fa0"></a>UART2_Parity_ZERO&#160;</td><td class="fielddoc"><p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a id="a259cb78d1b403c91619af5153a84994dae95a66e405093bb4a4c4f071facfa1c9"></a>UART2_Parity_ONE&#160;</td><td class="fielddoc"><p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2a82f370c2f15ececc5b03fbba65bcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a82f370c2f15ececc5b03fbba65bcde">&sect;&nbsp;</a></span>UART2_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a UART peripheral specified by the UART2 handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> has been called. </dd>
<dd>
There are no ongoing read or write calls. Any ongoing read or write calls can be cancelled with <a class="el" href="_u_a_r_t2_8h.html#aa8302b9b2d54d3f8a428a9225e267a41" title="Function that cancels a UART2_read() function call. ">UART2_readCancel()</a> or <a class="el" href="_u_a_r_t2_8h.html#a7052ce61a02ae90920d11c9bacddbf1e" title="Function that cancels a UART2_write() function call. ">UART2_writeCancel()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned from <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> </dd></dl>

</div>
</div>
<a id="a63fc2eca3cffea172c99d152f7d4ebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc2eca3cffea172c99d152f7d4ebd9">&sect;&nbsp;</a></span>UART2_flushRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_flushRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to flush data in the UART RX FIFO. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> has been called.</dd></dl>
<p>This function can be called to remove all data from the RX FIFO, for example, after a UART read error has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned from <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03b76166f16518bc1cdf85fdf6aa206b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b76166f16518bc1cdf85fdf6aa206b">&sect;&nbsp;</a></span>UART2_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a> UART2_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral. </p>
<p>Function to initialize a given UART peripheral specified by the particular index value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Logical peripheral number for the UART indexed into the UART2_config table</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a parameter block. If NULL, default parameter values will be used. All the fields in this structure are read-only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a> </dd></dl>

</div>
</div>
<a id="a8fd27db3b9bcca2fc88f65b2d26895d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd27db3b9bcca2fc88f65b2d26895d5">&sect;&nbsp;</a></span>UART2_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t2___params.html">UART2_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>A pointer to <a class="el" href="struct_u_a_r_t2___params.html" title="UART2 Parameters. ">UART2_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: readMode = UART2_Mode_BLOCKING; writeMode = UART2_Mode_BLOCKING; readCallback = NULL; writeCallback = NULL; readReturnMode = UART2_ReadReturnMode_FULL; baudRate = 115200; dataLength = UART2_DataLen_8; stopBits = UART2_StopBits_1; parityType = UART2_Parity_NONE; userArg = NULL; </p>

</div>
</div>
<a id="a3406839adde44077da387c89fa9ddb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3406839adde44077da387c89fa9ddb0d">&sect;&nbsp;</a></span>UART2_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART2_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART. </p>
<p>UART2_read() reads data from a UART controller. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, UART2_read() blocks task execution until all the data in buffer has been read, if the read return mode is <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a>. If the read return mode is <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a>, UART2_read() returns before all the data has been read, if some data has been received, but reception has been inactive sufficiently long for a hardware read timeout to occur (e.g., for a 32-bit period). If a receive error occurs (e.g., framing, fifo overrun), UART2_read() will return with the number of bytes read up to the occurance of the error.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, UART2_read() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t2___params.html#a72feec1f368666cc1d330400b0eec1c7">UART2_Params::readCallback</a> is called when the transfer is finished (<a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a>), or reception has become inactive (<a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a>). The callback function can occur in the caller's context or in SWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be cancelled using <a class="el" href="_u_a_r_t2_8h.html#aa8302b9b2d54d3f8a428a9225e267a41" title="Function that cancels a UART2_read() function call. ">UART2_readCancel()</a> before calling <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>, UART2_read() will return the minimum of size and the number of data in the RX FIFO. In this mode, <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> is non-blocking, but the application should check the number of bytes read in the bytesRead parameter. A status of success will be returned even if not all bytes requested were read, unless an error occured.</p>
<dl class="section note"><dt>Note</dt><dd>It is ok to call UART2_read() from its own callback function when in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to an empty buffer to which received data should be read</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to be read into buffer</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes read. In blocking mode, NULL can be passed, however, status should be checked in case the number of bytes requested was not received due to errors. In polling mode, it is not recommended to pass NULL for this parameter, as it would be impossible to determine the number of bytes actually read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356" title="Successful status code returned by UART2 APIs. ">UART2_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801" title="The UART is currently in use. ">UART2_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gab410e4da00bc79fdbbe921e89a78ffeb" title="A FIFO overrun occurred. ">UART2_STATUS_EOVERRUN</a></td><td>A fifo overrun occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga056a6acd9fc1a49cb30c8baabecc35df" title="A framing error occurred. ">UART2_STATUS_EFRAMING</a></td><td>A framinig error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4684c6671d256dc72b13ddb1eafd9971" title="A break error occurred. ">UART2_STATUS_EBREAK</a></td><td>A break error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaa3d362690c0ab4dd14e50f53737499a1" title="A parity error occurred. ">UART2_STATUS_EPARITY</a></td><td>A parity error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f025f78353515c8b0050f9d41596969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f025f78353515c8b0050f9d41596969">&sect;&nbsp;</a></span>UART2_readTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART2_readTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART, with a specified timeout for blocking mode. </p>
<p>UART2_readTimeout() reads data from a UART controller. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a> with <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a>, UART2_readTimeout() blocks task execution until all the data in buffer has been read, or the specified timeout has elapsed. In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a> with <a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a>, UART2_readTimeout() returns before all the data has been read, if some data has been received, but reception has been inactive sufficiently long for a hardware read timeout to occur (e.g., for a 32-bit period). UART2_readTimeout() will also return if the specified timeout parameter has elapsed. Note that the timeout parameter is different from the hardware read timeout.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, UART2_readTimeout() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t2___params.html#a72feec1f368666cc1d330400b0eec1c7">UART2_Params::readCallback</a> is called when the transfer is finished (<a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637da183a4bd9f538e511bbbd6d91e6889037">UART2_ReadReturnMode_FULL</a>), or reception has become inactive (<a class="el" href="_u_a_r_t2_8h.html#ab233d65776f6f909c674c5baae27637dae54481886c1c305f3f8fdf842bdb53c5">UART2_ReadReturnMode_PARTIAL</a>). The callback function can occur in the caller's context or in HWI context, depending on the device-specific implementation. An unfinished asynchronous read operation must always be cancelled using <a class="el" href="_u_a_r_t2_8h.html#aa8302b9b2d54d3f8a428a9225e267a41" title="Function that cancels a UART2_read() function call. ">UART2_readCancel()</a> before calling <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>. In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, the timeout parameter passed to UART2_readTimeout(), is ignored.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>, UART2_readTimeout() will return the minimum of size and the number of data in the RX FIFO. In this mode, <a class="el" href="_u_a_r_t2_8h.html#a0f025f78353515c8b0050f9d41596969" title="Function that reads data from a UART, with a specified timeout for blocking mode. ...">UART2_readTimeout()</a> is non-blocking, but the application should check the number of bytes read in the bytesRead parameter. A status of success will be returned even if not all bytes requested were read, unless an error occured. In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>, the timeout parameter passed to UART2_readTimeout(), is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>It is ok to call UART2_readTimeout() from its own callback function when in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to an empty buffer to which received data should be read</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to be read into buffer</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesRead</td><td>If non-NULL, the location to store the number of bytes actually read into the buffer. If NULL, this parameter will be ignored. In callback mode, NULL could be passed in for this parameter, since the callback function will be passed the number of bytes read. Similarly, in blocking mode with infinite timeout, NULL can be passed. However, status should be checked in case the number of bytes requested was not received due to errors. In polling mode, it is not recommended to pass NULL for this parameter, as it would be impossible to determine the number of bytes actually read.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The number of system clock ticks to wait until all data is received. If not all requested data was received within the timeout period, an error of UART2_STATUS_ETIMEOUT will be returned. This parameter is only applicable to <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the read.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356" title="Successful status code returned by UART2 APIs. ">UART2_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801" title="The UART is currently in use. ">UART2_STATUS_EINUSE</a></td><td>Another read from the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaeb708c48cd2517f08660196f16d31a33" title="A timeout occurred for a blocking UART2_read or UART2_write call. ">UART2_STATUS_ETIMEOUT</a></td><td>The read operation timed out. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gab410e4da00bc79fdbbe921e89a78ffeb" title="A FIFO overrun occurred. ">UART2_STATUS_EOVERRUN</a></td><td>A fifo overrun occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga056a6acd9fc1a49cb30c8baabecc35df" title="A framing error occurred. ">UART2_STATUS_EFRAMING</a></td><td>A framinig error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga4684c6671d256dc72b13ddb1eafd9971" title="A break error occurred. ">UART2_STATUS_EBREAK</a></td><td>A break error occurred. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaa3d362690c0ab4dd14e50f53737499a1" title="A parity error occurred. ">UART2_STATUS_EPARITY</a></td><td>A parity error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8302b9b2d54d3f8a428a9225e267a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8302b9b2d54d3f8a428a9225e267a41">&sect;&nbsp;</a></span>UART2_readCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> operation in in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, or unblocks a <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> call in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>. In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, <a class="el" href="_u_a_r_t2_8h.html#aa8302b9b2d54d3f8a428a9225e267a41" title="Function that cancels a UART2_read() function call. ">UART2_readCancel()</a> calls the registered read callback function with the number of bytes received so far. It is the application's responsibility to check the count argument in the callback function and handle the case where only a subset of the bytes were received. The callback function will be passed a status of <a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7" title="A UART2_write() or UART2_read() operation was cancelled. ">UART2_STATUS_ECANCELLED</a>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, <a class="el" href="_u_a_r_t2_8h.html#a3406839adde44077da387c89fa9ddb0d" title="Function that reads data from a UART. ">UART2_read()</a> will return <a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7" title="A UART2_write() or UART2_read() operation was cancelled. ">UART2_STATUS_ECANCELLED</a>, and the bytesRead parameter will be set to the number of bytes received so far.</p>
<p>This API has no affect in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85ec2c5906ad36adc14cddd011b3b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec2c5906ad36adc14cddd011b3b7cf">&sect;&nbsp;</a></span>UART2_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART2_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p>UART2_write() writes data from a memory buffer to the UART interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> blocks task execution until all the data in buffer has been written.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, UART2_write() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t2___params.html#aadcf916de5cdd5591997d289f03ccfdd">UART2_Params::writeCallback</a> is called when the transfer is finished. The buffer passed to <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the write callback has been called with a byte count equal to that passed to <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a>). The callback function can occur in the caller's task context or in a HWI or SWI context, depending on the device implementation. An unfinished asynchronous write operation must always be cancelled using <a class="el" href="_u_a_r_t2_8h.html#a7052ce61a02ae90920d11c9bacddbf1e" title="Function that cancels a UART2_write() function call. ">UART2_writeCancel()</a> before calling <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> will send out as many of the bytes in the buffer as possible, until the TX FIFO is full. In polling mode, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> is non-blocking and can be called from any context. The bytesWritten parameter should not be NULL so the application can determine the number of bytes actually written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A read-only pointer to buffer containing data to be written to the UART</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written to the UART in UART2_Mode_BLOCKING and UART2_Mode_POLLING. In UART2_Mode_CALLBACK, bytesWritten will be set to 0. If bytesWritten is NULL, this parameter will be ignored. In polling mode, it is not recommended to pass NULL for bytesWritten, as the application would have no way to determine the number of bytes actually written. In polling mode, a status of success will be returned even if not all the requested bytes could be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356" title="Successful status code returned by UART2 APIs. ">UART2_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801" title="The UART is currently in use. ">UART2_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc4b4c351fc4fb2663d6737a0cd4c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4b4c351fc4fb2663d6737a0cd4c7db">&sect;&nbsp;</a></span>UART2_writeTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t UART2_writeTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytesWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART, with a specified timeout. </p>
<p>UART2_writeTimeout() writes data from a memory buffer to the UART interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>. A timeout in system clock ticks specifies the maximum time to wait until all data is written (<a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a> only).</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a>, <a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db" title="Function that writes data to a UART, with a specified timeout. ">UART2_writeTimeout()</a> blocks task execution until all the data in buffer has been written, or the timeout expires.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, UART2_writeTimeout() does not block task execution. Instead, a callback function specified by <a class="el" href="struct_u_a_r_t2___params.html#aadcf916de5cdd5591997d289f03ccfdd">UART2_Params::writeCallback</a> is called when the transfer is finished. The buffer passed to <a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db" title="Function that writes data to a UART, with a specified timeout. ">UART2_writeTimeout()</a> in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a> is not copied. The buffer must remain coherent until all the characters have been sent (ie until the write callback has been called with a byte count equal to that passed to <a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db" title="Function that writes data to a UART, with a specified timeout. ">UART2_writeTimeout()</a>). The callback function can occur in the caller's task context or in interrupt context, depending on the device implementation. An unfinished asynchronous write operation must always be cancelled using <a class="el" href="_u_a_r_t2_8h.html#a7052ce61a02ae90920d11c9bacddbf1e" title="Function that cancels a UART2_write() function call. ">UART2_writeCancel()</a> before calling <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>.</p>
<p>In <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>, <a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db" title="Function that writes data to a UART, with a specified timeout. ">UART2_writeTimeout()</a> will send out as many of the bytes in the buffer as possible, until the TX FIFO is full. In polling mode, <a class="el" href="_u_a_r_t2_8h.html#adc4b4c351fc4fb2663d6737a0cd4c7db" title="Function that writes data to a UART, with a specified timeout. ">UART2_writeTimeout()</a> is non-blocking and can be called from any context. The bytesWritten parameter should not be NULL so the application can determine the number of bytes actually written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A read-only pointer to buffer containing data to be written to the UART</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the UART</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytesWritten</td><td>If non-NULL, the location to store the number of bytes actually written to the UART in UART2_Mode_BLOCKING and UART2_Mode_POLLING. In UART2_Mode_CALLBACK, bytesWritten will be set to 0. If bytesWritten is NULL, this parameter will be ignored. In polling mode, it is not recommended to pass NULL for bytesWritten, as the application would have no way to determine the number of bytes actually written. In polling mode, a status of success will be returned even if not all the requested bytes could be written.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The number of system clock ticks to wait for the write to complete (<a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a7d3f5d67bebb58f7ae475cce13779c8c">UART2_Mode_BLOCKING</a> only). If the timeout expires before all bytes are written, a status of UART2_STATUS_ETIMEOUT will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status indicating success or failure of the write.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga50f50c06775b7ee13f45fe80c93fb356" title="Successful status code returned by UART2 APIs. ">UART2_STATUS_SUCCESS</a></td><td>The call was successful. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#ga0ec322208aa002ae4b058a410a387801" title="The UART is currently in use. ">UART2_STATUS_EINUSE</a></td><td>Another write to the UART is currently ongoing. </td></tr>
    <tr><td class="paramname"><a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gaeb708c48cd2517f08660196f16d31a33" title="A timeout occurred for a blocking UART2_read or UART2_write call. ">UART2_STATUS_ETIMEOUT</a></td><td>The write operation timed out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7052ce61a02ae90920d11c9bacddbf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7052ce61a02ae90920d11c9bacddbf1e">&sect;&nbsp;</a></span>UART2_writeCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60">UART2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> function call. </p>
<p>This function cancels an asynchronous <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> operation when write mode is <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a2bf221b50ba7a639b06b592cfdccd5ed">UART2_Mode_CALLBACK</a>, or an ongoing <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> in <a class="el" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a0e91143b8d918f4b11435189cb310c04">UART2_Mode_POLLING</a>. In callback mode, <a class="el" href="_u_a_r_t2_8h.html#a7052ce61a02ae90920d11c9bacddbf1e" title="Function that cancels a UART2_write() function call. ">UART2_writeCancel()</a> calls the registered write callback function no matter how many bytes were sent. It is the application's responsibility to check the count argument in the callback function and handle cases where only a subset of the bytes were sent. The callback function will be passed a status of <a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7" title="A UART2_write() or UART2_read() operation was cancelled. ">UART2_STATUS_ECANCELLED</a>. In blocking mode, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> will return <a class="el" href="group___u_a_r_t2___s_t_a_t_u_s.html#gad528e61ecc06c90d5824796ce547ecb7" title="A UART2_write() or UART2_read() operation was cancelled. ">UART2_STATUS_ECANCELLED</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The above applies to UART2_writeTimeout() as well.</dd></dl>
<p>This API has no affect in polling mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_u_a_r_t2_8h.html#abbf55a000a1ce4c24c15c03fbb610b60" title="A handle that is returned from a UART2_open() call. ">UART2_Handle</a> returned by <a class="el" href="_u_a_r_t2_8h.html#a03b76166f16518bc1cdf85fdf6aa206b" title="Function to initialize a given UART peripheral. ">UART2_open()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a80d75291c42d2471b3c38dce6b6bdb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d75291c42d2471b3c38dce6b6bdb0a">&sect;&nbsp;</a></span>UART2_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_u_a_r_t2_8h.html#a5a9ed8d3be24bf0ba355ec100f9eabbd">UART2_Config</a> UART2_config[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a11a7ad983146f408d8deb22b764710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a11a7ad983146f408d8deb22b764710">&sect;&nbsp;</a></span>UART2_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint_least8_t UART2_count</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
