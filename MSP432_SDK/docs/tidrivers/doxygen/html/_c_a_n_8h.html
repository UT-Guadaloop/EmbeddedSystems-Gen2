<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>CAN.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_a59555fa6928a28ba1fd94639418fed2.html">tidrivers_msp432e4</a></li><li class="navelem"><a class="el" href="dir_881bc3ea3e0b6773ef082a7a8f546747.html">source</a></li><li class="navelem"><a class="el" href="dir_d200e2eb2d76e462bf7bb2f8b0aadb1e.html">ti</a></li><li class="navelem"><a class="el" href="dir_c7c3caac9c05bea82305b87d191db62d.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CAN.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>PRELIMINARY</b> CAN driver interface </p>
<hr/>
<p><b>WARNING</b> These APIs are <b>PRELIMINARY</b>, and subject to change in the next few months.</p>
<p>To use the CAN driver, ensure that the correct driver library for your device is linked in and include this header file as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_c_a_n_8h.html">ti/drivers/CAN.h</a>&gt;</span></div></div><!-- fragment --><p>This module serves as the main interface for applications. Its purpose is to redirect the CAN APIs to specific driver implementations which are specified using a pointer to a <a class="el" href="struct_c_a_n___fxn_table.html" title="The definition of a CAN function table that contains the required set of functions to control a speci...">CAN_FxnTable</a>.</p>
<p><a class="anchor" id="ti_drivers_CAN_Overview"></a></p><h1>Overview</h1>
<p>The Controller Area Network (CAN) driver is a generic driver that allows for communication on a CAN bus. It is a two-wire, half-duplex, LAN system that is collision free. The main method of transfer is by broadcasting. The CAN protocol defines the format of data transfer, and this CAN driver allows full functionality as a transmitting and receiving node on a bus. However, there can be higher-level software layers and stacks that use this driver to enable more advanced features. Functional modes available in this driver include blocking and non-blocking.</p>
<p>The APIs in this driver serve as an interface to a typical RTOS application. The specific peripheral implementations are responsible for creating all the RTOS specific primitives to allow for thread-safe operation.</p>
<p><a class="anchor" id="ti_drivers_CAN_Usage"></a></p><h1>Usage</h1>
<p>The CAN driver interface provides device independent APIs, data types, and macros.</p>
<p><a class="anchor" id="ti_drivers_CAN_Synopsis"></a></p><h2>Synopsis</h2>
<p>The following code example opens a CAN instance, creates an incrementing CAN frame, and continually writes them to the CAN bus. NOTE: a CAN receiver on this bus is needed, or else this transmitter will continually throw an error if it does not detect an ACK.</p>
<div class="fragment"><div class="line">uint8_t i;</div><div class="line"><span class="comment">// Initialize the CAN driver</span></div><div class="line"><a class="code" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a>();</div><div class="line"></div><div class="line"><a class="code" href="struct_c_a_n___config__.html">CAN_Handle</a> canHandle;</div><div class="line"><a class="code" href="struct_c_a_n___params.html">CAN_Params</a> canParams;</div><div class="line"><a class="code" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a>(&amp;canParams);</div><div class="line">canHandle = <a class="code" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a>(CONFIG_CAN0, &amp;canParams);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (canHandle == NULL) {</div><div class="line">    <span class="comment">// CAN_open() failed</span></div><div class="line">    <span class="keywordflow">while</span> (1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (i = 0; ; ++i) {</div><div class="line">    <a class="code" href="structcan__frame.html">CAN_Frame</a> canFrame[1];</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ac6aeb5fbc99596a37fe1519f3aa8410a">can_id</a> = i;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#a8831fc16e06232795c1c16597a8189f7">err</a> = 0;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#a5ca10890737c528f19c9b72c5063c15a">rtr</a> = 0;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#aef754ed5feee21c33124a6b3acb38ff2">eff</a> = 1;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#a014c42277e886906e6c761bc6f21fb47">dlc</a> = i % 9;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[0] = i;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[1] = i + 1;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[2] = i + 2;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[3] = i + 3;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[4] = i + 4;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[5] = i + 5;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[6] = i + 6;</div><div class="line">    canFrame[0].<a class="code" href="structcan__frame.html#ade6eedeba6cc24ef2f7a2aa2ed452291">data</a>[7] = i + 7;</div><div class="line"></div><div class="line">    <a class="code" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b">CAN_write</a>(canHandle, canFrame, <span class="keyword">sizeof</span>(canFrame));</div><div class="line">}</div></div><!-- fragment --><p>Details for the example code above are described in the following subsections.</p>
<p><a class="anchor" id="ti_drivers_CAN_Configuration"></a></p><h3>CAN Driver Configuration</h3>
<p>In order to use the CAN APIs, the application is required to provide device-specific CAN configuration in the ti_drivers_config.c file. The CAN driver interface defines a configuration data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <a class="code" href="struct_c_a_n___fxn_table.html">CAN_FxnTable</a>  <span class="keyword">const</span>    *fxnTablePtr;</div><div class="line">    <span class="keywordtype">void</span>                   *object;</div><div class="line">    <span class="keywordtype">void</span>          <span class="keyword">const</span>    *hwAttrs;</div><div class="line">    <a class="code" href="structcan__frame.html">CAN_Frame</a>              *rxBufPtr;</div><div class="line">    CAN_frame              *txBufPtr;</div><div class="line">    <span class="keywordtype">size_t</span>                  rxBufSize;</div><div class="line">    <span class="keywordtype">size_t</span>                  txBufSize;</div><div class="line">} <a class="code" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a>;</div></div><!-- fragment --><p>You will need to check the device-specific CAN driver implementation's header file for example configuration. Please also refer to the ti_drivers_config.c file to see the CAN configuration.</p>
<h3>Initializing the CAN Driver</h3>
<p><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="Function to initialize the CAN module. ">CAN_init()</a> must be called before any other CAN APIs. This function calls the device implementation's CAN initialization function, for each element of CAN_config[].</p>
<h3>Opening the CAN Driver</h3>
<p>Opening a CAN requires four steps:</p><ol type="1">
<li>Create and initialize a <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> structure.</li>
<li>Fill in the desired parameters.</li>
<li>Call <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a>, passing the index of the CAN in the CAN_config structure, and the address of the <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> structure. The CAN instance is specified by the index in the CAN_config structure.</li>
<li>Check that the CAN handle returned by <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> is non-NULL, and save it. The handle will be used to read and write to the CAN you just opened.</li>
</ol>
<p>Only one CAN index can be used at a time; calling <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> a second time with the same index previously passed to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Function to close a CAN peripheral specified by the CAN handle. ">CAN_close()</a>. In the example code, CONFIG_CAN0 is passed to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a>. This macro is defined in the applications "ti_drivers_config.h" file.</p>
<h3>Modes of Operation</h3>
<p>The CAN driver can operate in blocking mode or nonblocking mode, by setting the mode parameters passed to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a>. If these parameters are not set, as in the example code, the CAN driver defaults to blocking mode. Options for the mode parameter are <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a> and <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1">CAN_MODE_NONBLOCKING</a>:</p>
<ul>
<li><a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a> uses a semaphore to block while data is being sent or read. The context of calling <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> or <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> must be a Task when using <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a>. The <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> or <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> call will block until all data is sent or received, or the write timeout or read timeout expires, whichever happens first.</li>
<li><a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1">CAN_MODE_NONBLOCKING</a> is non-blocking and <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> and <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> will return either with the number of bytes successfully read/written, or a negative error number.</li>
</ul>
<h3>Reading and Writing data</h3>
<p>The example code reads one CAN frame from the CAN instance, and then writes one CAN frame back to the same instance:</p>
<div class="fragment"><div class="line"><a class="code" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551">CAN_read</a>(can, &amp;canFrame, <span class="keyword">sizeof</span>(canFrame));</div><div class="line"><a class="code" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b">CAN_write</a>(can, &amp;canFrame, <span class="keyword">sizeof</span>(canFrame));</div></div><!-- fragment --><p>The CAN driver allows <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> and <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> calls to happen for any node at any time from the CAN bus. Please see the CAN protocol for how it handles collisions. The ability to filter incoming messages are also available through <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a>.</p>
<h1>Implementation</h1>
<p>The CAN driver interface module is joined (at link time) to an array of CAN_Config data structures named <em>CAN_config</em>. CAN_config is implemented in the application with each entry being an instance of a CAN peripheral. Each entry in <em>CAN_config</em> contains a:</p><ul>
<li>(<a class="el" href="struct_c_a_n___fxn_table.html" title="The definition of a CAN function table that contains the required set of functions to control a speci...">CAN_FxnTable</a> *) to a set of functions that implement a CAN peripheral</li>
<li>(void *) data object that is associated with the <a class="el" href="struct_c_a_n___fxn_table.html" title="The definition of a CAN function table that contains the required set of functions to control a speci...">CAN_FxnTable</a></li>
<li>(void *) hardware attributes that are associated with the <a class="el" href="struct_c_a_n___fxn_table.html" title="The definition of a CAN function table that contains the required set of functions to control a speci...">CAN_FxnTable</a></li>
</ul>
<p>The CAN APIs are redirected to the device specific implementations using the <a class="el" href="struct_c_a_n___fxn_table.html" title="The definition of a CAN function table that contains the required set of functions to control a speci...">CAN_FxnTable</a> pointer of the CAN_config entry. In order to use device specific functions of the CAN driver directly, link in the correct driver library for your device and include the device specific CAN driver header file (which in turn includes <a class="el" href="_c_a_n_8h.html" title="PRELIMINARY CAN driver interface ">CAN.h</a>). For example, for the MSP432 family of devices, you would include the following header file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ti/drivers/can/CANMSP432.h&gt;</span></div></div><!-- fragment --> <hr/>
</div><div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="source_2ti_2drivers_2can_2types_8h_source.html">ti/drivers/can/types.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for CAN.h:</div>
<div class="dyncontent">
<div class="center"><img src="_c_a_n_8h__incl.png" border="0" usemap="#_c_a_n_8h" alt=""/></div>
<map name="_c_a_n_8h" id="_c_a_n_8h">
<area shape="rect" id="node4" href="source_2ti_2drivers_2can_2types_8h.html" title="ti/drivers/can/types.h" alt="" coords="22,80,166,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_c_a_n_8h__dep__incl.png" border="0" usemap="#_c_a_n_8hdep" alt=""/></div>
<map name="_c_a_n_8hdep" id="_c_a_n_8hdep">
<area shape="rect" id="node2" href="_c_a_n_m_s_p432_e4_8h.html" title="CAN driver implementation for a MSP432E4 CAN controller. " alt="" coords="5,80,133,107"/>
</map>
</div>
</div>
<p><a href="_c_a_n_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Parameters.  <a href="struct_c_a_n___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___fxn_table.html">CAN_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a CAN function table that contains the required set of functions to control a specific CAN driver implementation.  <a href="struct_c_a_n___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Global configuration.  <a href="struct_c_a_n___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad3aec7d0ff50fa7ecd46f41c46b1dd4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___c_o_n_t_r_o_l.html#gad3aec7d0ff50fa7ecd46f41c46b1dd4b">CAN_CMD_RESERVED</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:gad3aec7d0ff50fa7ecd46f41c46b1dd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ae91524e3e059c0b1f2ba091ed0794"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___c_o_n_t_r_o_l.html#ga03ae91524e3e059c0b1f2ba091ed0794">CAN_STATUS_RESERVED</a>&#160;&#160;&#160;(-32)</td></tr>
<tr class="separator:ga03ae91524e3e059c0b1f2ba091ed0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gaec519b2472a0cb3c778a1e2cffd7de5d">CAN_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_c_a_n_8h.html#a16c50386c49aa57fb2576a89ffa22a6b" title="Function performs implementation specific features on a given CAN_Handle. ">CAN_control()</a>.  <a href="group___c_a_n___s_t_a_t_u_s.html#gaec519b2472a0cb3c778a1e2cffd7de5d">More...</a><br /></td></tr>
<tr class="separator:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97bc85f9b1ce1bd427ab76347994217"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gaf97bc85f9b1ce1bd427ab76347994217">CAN_STATUS_ERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:gaf97bc85f9b1ce1bd427ab76347994217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_c_a_n_8h.html#a16c50386c49aa57fb2576a89ffa22a6b" title="Function performs implementation specific features on a given CAN_Handle. ">CAN_control()</a>.  <a href="group___c_a_n___s_t_a_t_u_s.html#gaf97bc85f9b1ce1bd427ab76347994217">More...</a><br /></td></tr>
<tr class="separator:gaf97bc85f9b1ce1bd427ab76347994217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b40d390fb347ceb930b54982e62e8c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#ga4b40d390fb347ceb930b54982e62e8c3">CAN_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga4b40d390fb347ceb930b54982e62e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_c_a_n_8h.html#a16c50386c49aa57fb2576a89ffa22a6b" title="Function performs implementation specific features on a given CAN_Handle. ">CAN_control()</a> for undefined command codes.  <a href="group___c_a_n___s_t_a_t_u_s.html#ga4b40d390fb347ceb930b54982e62e8c3">More...</a><br /></td></tr>
<tr class="separator:ga4b40d390fb347ceb930b54982e62e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7efefe615409e714f165d1fdcf00ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a9a7efefe615409e714f165d1fdcf00ae">CAN_WAIT_FOREVER</a>&#160;&#160;&#160;(~(0U))</td></tr>
<tr class="memdesc:a9a7efefe615409e714f165d1fdcf00ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define.  <a href="#a9a7efefe615409e714f165d1fdcf00ae">More...</a><br /></td></tr>
<tr class="separator:a9a7efefe615409e714f165d1fdcf00ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04c6849a36f49970a418d45e72c9b516"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a></td></tr>
<tr class="memdesc:a04c6849a36f49970a418d45e72c9b516"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> call.  <a href="#a04c6849a36f49970a418d45e72c9b516">More...</a><br /></td></tr>
<tr class="separator:a04c6849a36f49970a418d45e72c9b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d35abf30084ae3b17d47f1c3e2a17"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ae64d35abf30084ae3b17d47f1c3e2a17">CAN_Frame</a></td></tr>
<tr class="memdesc:ae64d35abf30084ae3b17d47f1c3e2a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN frame structure.  <a href="#ae64d35abf30084ae3b17d47f1c3e2a17">More...</a><br /></td></tr>
<tr class="separator:ae64d35abf30084ae3b17d47f1c3e2a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8897d6cde8780b2ea1c6ded3f1f549"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#acc8897d6cde8780b2ea1c6ded3f1f549">CAN_CloseFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:acc8897d6cde8780b2ea1c6ded3f1f549"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#acc8897d6cde8780b2ea1c6ded3f1f549" title="A function pointer to a driver specific implementation of CAN_CloseFxn(). ">CAN_CloseFxn()</a>.  <a href="#acc8897d6cde8780b2ea1c6ded3f1f549">More...</a><br /></td></tr>
<tr class="separator:acc8897d6cde8780b2ea1c6ded3f1f549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad949f7ebd426255b83a5abd990a609c0"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ad949f7ebd426255b83a5abd990a609c0">CAN_ControlFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint_fast16_t cmd, void *arg)</td></tr>
<tr class="memdesc:ad949f7ebd426255b83a5abd990a609c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#ad949f7ebd426255b83a5abd990a609c0" title="A function pointer to a driver specific implementation of CAN_ControlFxn(). ">CAN_ControlFxn()</a>.  <a href="#ad949f7ebd426255b83a5abd990a609c0">More...</a><br /></td></tr>
<tr class="separator:ad949f7ebd426255b83a5abd990a609c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6668a04da1b06d98709be9a2426cc7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a6f6668a04da1b06d98709be9a2426cc7">CAN_InitFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:a6f6668a04da1b06d98709be9a2426cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a6f6668a04da1b06d98709be9a2426cc7" title="A function pointer to a driver specific implementation of CAN_InitFxn(). ">CAN_InitFxn()</a>.  <a href="#a6f6668a04da1b06d98709be9a2426cc7">More...</a><br /></td></tr>
<tr class="separator:a6f6668a04da1b06d98709be9a2426cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b71b8ad224e01470b5c9ee34b3f95e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a51b71b8ad224e01470b5c9ee34b3f95e">CAN_OpenFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, <a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *params)</td></tr>
<tr class="memdesc:a51b71b8ad224e01470b5c9ee34b3f95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a51b71b8ad224e01470b5c9ee34b3f95e" title="A function pointer to a driver specific implementation of CAN_OpenFxn(). ">CAN_OpenFxn()</a>.  <a href="#a51b71b8ad224e01470b5c9ee34b3f95e">More...</a><br /></td></tr>
<tr class="separator:a51b71b8ad224e01470b5c9ee34b3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee976ab0f943a5efa7d15e70906b11d1"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#aee976ab0f943a5efa7d15e70906b11d1">CAN_ReadFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:aee976ab0f943a5efa7d15e70906b11d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#aee976ab0f943a5efa7d15e70906b11d1" title="A function pointer to a driver specific implementation of CAN_ReadFxn(). ">CAN_ReadFxn()</a>.  <a href="#aee976ab0f943a5efa7d15e70906b11d1">More...</a><br /></td></tr>
<tr class="separator:aee976ab0f943a5efa7d15e70906b11d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1f018c6ee8289264e184cac3b6f32"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a37e1f018c6ee8289264e184cac3b6f32">CAN_WriteFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:a37e1f018c6ee8289264e184cac3b6f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a37e1f018c6ee8289264e184cac3b6f32" title="A function pointer to a driver specific implementation of CAN_WriteFxn(). ">CAN_WriteFxn()</a>.  <a href="#a37e1f018c6ee8289264e184cac3b6f32">More...</a><br /></td></tr>
<tr class="separator:a37e1f018c6ee8289264e184cac3b6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191c1d511cada1b1d82c634c6859666b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a191c1d511cada1b1d82c634c6859666b">CAN_TxMsgFxn</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:a191c1d511cada1b1d82c634c6859666b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a191c1d511cada1b1d82c634c6859666b" title="A function pointer to a driver specific implementation of CAN_TxMsgFxn(). ">CAN_TxMsgFxn()</a>.  <a href="#a191c1d511cada1b1d82c634c6859666b">More...</a><br /></td></tr>
<tr class="separator:a191c1d511cada1b1d82c634c6859666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adcb3cde9a6e999f9434e4689a917b9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a></td></tr>
<tr class="memdesc:a2adcb3cde9a6e999f9434e4689a917b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Global configuration.  <a href="#a2adcb3cde9a6e999f9434e4689a917b9">More...</a><br /></td></tr>
<tr class="separator:a2adcb3cde9a6e999f9434e4689a917b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4d6db79b5847128a849ac24b3c281960"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960">CAN_Mode</a> { <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a>, 
<a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1">CAN_MODE_NONBLOCKING</a>
 }<tr class="memdesc:a4d6db79b5847128a849ac24b3c281960"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN mode settings.  <a href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4d6db79b5847128a849ac24b3c281960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e5130739e2ad4bdf3cbf3eccbdf83f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83f">CAN_Direction</a> { <a class="el" href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83fa41cd246c9c2837823376b22096157c7c">CAN_DIRECTION_READ</a> = 0x1, 
<a class="el" href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83fa62f442390bb202f9314368dbafc54adf">CAN_DIRECTION_WRITE</a> = 0x2, 
<a class="el" href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83fadb0f0d4c55d5e35112c2cba7aa697738">CAN_DIRECTION_READWRITE</a> = 0x3
 }<tr class="memdesc:a34e5130739e2ad4bdf3cbf3eccbdf83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN communication mode.  <a href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a34e5130739e2ad4bdf3cbf3eccbdf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf">CAN_close</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a CAN peripheral specified by the CAN handle.  <a href="#abfc2ccd7bffde7724a17ab6c7e69f5cf">More...</a><br /></td></tr>
<tr class="separator:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a> (void)</td></tr>
<tr class="memdesc:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the CAN module.  <a href="#ace7de72cc97ae2a35d63c3a4a4772a31">More...</a><br /></td></tr>
<tr class="separator:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c50386c49aa57fb2576a89ffa22a6b"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a16c50386c49aa57fb2576a89ffa22a6b">CAN_control</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint_fast16_t cmd, void *arg)</td></tr>
<tr class="memdesc:a16c50386c49aa57fb2576a89ffa22a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a>.  <a href="#a16c50386c49aa57fb2576a89ffa22a6b">More...</a><br /></td></tr>
<tr class="separator:a16c50386c49aa57fb2576a89ffa22a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac007ed113727f16540e8b8e5d4e88fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a> (uint_least8_t index, <a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *params)</td></tr>
<tr class="memdesc:ac007ed113727f16540e8b8e5d4e88fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given CAN peripheral.  <a href="#ac007ed113727f16540e8b8e5d4e88fe4">More...</a><br /></td></tr>
<tr class="separator:ac007ed113727f16540e8b8e5d4e88fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a> (<a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *params)</td></tr>
<tr class="memdesc:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> struct to its defaults.  <a href="#a9a7a7042e4948d4e04b9cb5205c50acf">More...</a><br /></td></tr>
<tr class="separator:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89a00428e47854c9881b4998f2464b"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b">CAN_write</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:afe89a00428e47854c9881b4998f2464b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a CAN with interrupts enabled.  <a href="#afe89a00428e47854c9881b4998f2464b">More...</a><br /></td></tr>
<tr class="separator:afe89a00428e47854c9881b4998f2464b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ffdf96e912ae6218ec3d3f52549551"><td class="memItemLeft" align="right" valign="top">int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551">CAN_read</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a24ffdf96e912ae6218ec3d3f52549551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a CAN with interrupt enabled.  <a href="#a24ffdf96e912ae6218ec3d3f52549551">More...</a><br /></td></tr>
<tr class="separator:a24ffdf96e912ae6218ec3d3f52549551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9a7efefe615409e714f165d1fdcf00ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7efefe615409e714f165d1fdcf00ae">&sect;&nbsp;</a></span>CAN_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_WAIT_FOREVER&#160;&#160;&#160;(~(0U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a04c6849a36f49970a418d45e72c9b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c6849a36f49970a418d45e72c9b516">&sect;&nbsp;</a></span>CAN_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>* <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> call. </p>

</div>
</div>
<a id="ae64d35abf30084ae3b17d47f1c3e2a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d35abf30084ae3b17d47f1c3e2a17">&sect;&nbsp;</a></span>CAN_Frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan__frame.html">can_frame</a> <a class="el" href="_c_a_n_8h.html#ae64d35abf30084ae3b17d47f1c3e2a17">CAN_Frame</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN frame structure. </p>
<p>The structure that makes up a CAN message. The unions are provided in order for there to be structural naming compatibility with SocketCAN while at the same time providing an alternative easier to use naming convention. We diverge a bit with TI structural naming convention of the struct in order to provide an option to be compatible with SocketCAN conventions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> </dd>
<dd>
<a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> </dd></dl>

</div>
</div>
<a id="acc8897d6cde8780b2ea1c6ded3f1f549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8897d6cde8780b2ea1c6ded3f1f549">&sect;&nbsp;</a></span>CAN_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CAN_CloseFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#acc8897d6cde8780b2ea1c6ded3f1f549" title="A function pointer to a driver specific implementation of CAN_CloseFxn(). ">CAN_CloseFxn()</a>. </p>

</div>
</div>
<a id="ad949f7ebd426255b83a5abd990a609c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad949f7ebd426255b83a5abd990a609c0">&sect;&nbsp;</a></span>CAN_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* CAN_ControlFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint_fast16_t cmd, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#ad949f7ebd426255b83a5abd990a609c0" title="A function pointer to a driver specific implementation of CAN_ControlFxn(). ">CAN_ControlFxn()</a>. </p>

</div>
</div>
<a id="a6f6668a04da1b06d98709be9a2426cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6668a04da1b06d98709be9a2426cc7">&sect;&nbsp;</a></span>CAN_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CAN_InitFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a6f6668a04da1b06d98709be9a2426cc7" title="A function pointer to a driver specific implementation of CAN_InitFxn(). ">CAN_InitFxn()</a>. </p>

</div>
</div>
<a id="a51b71b8ad224e01470b5c9ee34b3f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b71b8ad224e01470b5c9ee34b3f95e">&sect;&nbsp;</a></span>CAN_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>(* CAN_OpenFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, <a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a51b71b8ad224e01470b5c9ee34b3f95e" title="A function pointer to a driver specific implementation of CAN_OpenFxn(). ">CAN_OpenFxn()</a>. </p>

</div>
</div>
<a id="aee976ab0f943a5efa7d15e70906b11d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee976ab0f943a5efa7d15e70906b11d1">&sect;&nbsp;</a></span>CAN_ReadFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* CAN_ReadFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#aee976ab0f943a5efa7d15e70906b11d1" title="A function pointer to a driver specific implementation of CAN_ReadFxn(). ">CAN_ReadFxn()</a>. </p>

</div>
</div>
<a id="a37e1f018c6ee8289264e184cac3b6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e1f018c6ee8289264e184cac3b6f32">&sect;&nbsp;</a></span>CAN_WriteFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t(* CAN_WriteFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a37e1f018c6ee8289264e184cac3b6f32" title="A function pointer to a driver specific implementation of CAN_WriteFxn(). ">CAN_WriteFxn()</a>. </p>

</div>
</div>
<a id="a191c1d511cada1b1d82c634c6859666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191c1d511cada1b1d82c634c6859666b">&sect;&nbsp;</a></span>CAN_TxMsgFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CAN_TxMsgFxn) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver specific implementation of <a class="el" href="_c_a_n_8h.html#a191c1d511cada1b1d82c634c6859666b" title="A function pointer to a driver specific implementation of CAN_TxMsgFxn(). ">CAN_TxMsgFxn()</a>. </p>

</div>
</div>
<a id="a2adcb3cde9a6e999f9434e4689a917b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adcb3cde9a6e999f9434e4689a917b9">&sect;&nbsp;</a></span>CAN_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>  <a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN Global configuration. </p>
<p>The CAN_Config structure contains a set of pointers used to characterize the CAN driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="Function to initialize the CAN module. ">CAN_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="Function to initialize the CAN module. ">CAN_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4d6db79b5847128a849ac24b3c281960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6db79b5847128a849ac24b3c281960">&sect;&nbsp;</a></span>CAN_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960">CAN_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN mode settings. </p>
<p>This enum defines the read, write, and blocking modes for the configured CAN. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6"></a>CAN_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>Blocking and will return only when at least one CAN frame has been processed by <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> or <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> data, or if the optional timeout occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1"></a>CAN_MODE_NONBLOCKING&#160;</td><td class="fielddoc"><p>Non-blocking and will return immediately with or without write or read data. Error flags could be thrown if invalid <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> or <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a34e5130739e2ad4bdf3cbf3eccbdf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e5130739e2ad4bdf3cbf3eccbdf83f">&sect;&nbsp;</a></span>CAN_Direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_c_a_n_8h.html#a34e5130739e2ad4bdf3cbf3eccbdf83f">CAN_Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN communication mode. </p>
<p>This enum defines read or write communication direction for the configured CAN. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34e5130739e2ad4bdf3cbf3eccbdf83fa41cd246c9c2837823376b22096157c7c"></a>CAN_DIRECTION_READ&#160;</td><td class="fielddoc"><p>Read only mode, a transmit object is not used </p>
</td></tr>
<tr><td class="fieldname"><a id="a34e5130739e2ad4bdf3cbf3eccbdf83fa62f442390bb202f9314368dbafc54adf"></a>CAN_DIRECTION_WRITE&#160;</td><td class="fielddoc"><p>Write only mode, a receive object is not used </p>
</td></tr>
<tr><td class="fieldname"><a id="a34e5130739e2ad4bdf3cbf3eccbdf83fadb0f0d4c55d5e35112c2cba7aa697738"></a>CAN_DIRECTION_READWRITE&#160;</td><td class="fielddoc"><p>Read and write mode. A single transmit object is used and at least one receive object is used. NOTE: enum value must be logical OR of CAN_DIRECTION_READ and CAN_DIRECTION_WRITE </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abfc2ccd7bffde7724a17ab6c7e69f5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc2ccd7bffde7724a17ab6c7e69f5cf">&sect;&nbsp;</a></span>CAN_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a CAN peripheral specified by the CAN handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> has been called. </dd>
<dd>
No active <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> or <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> </dd></dl>

</div>
</div>
<a id="ace7de72cc97ae2a35d63c3a4a4772a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7de72cc97ae2a35d63c3a4a4772a31">&sect;&nbsp;</a></span>CAN_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the CAN module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The CAN_config structure must exist and be persistent before this function can be called. This function must also be called before any other CAN driver APIs. </dd></dl>

</div>
</div>
<a id="a16c50386c49aa57fb2576a89ffa22a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c50386c49aa57fb2576a89ffa22a6b">&sect;&nbsp;</a></span>CAN_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a>. </p>
<p>Commands for CAN_control() can originate from <a class="el" href="_c_a_n_8h.html" title="PRELIMINARY CAN driver interface ">CAN.h</a> or from implementation specific CAN*.h (<em>CANTCAN2550.h</em>, <em>CANMSP432.h</em>, etc.. ) files. While commands from <a class="el" href="_c_a_n_8h.html" title="PRELIMINARY CAN driver interface ">CAN.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific CAN*.h files add unique driver capabilities but are not API portable across all CAN driver implementations.</p>
<p>Commands supported by <a class="el" href="_c_a_n_8h.html" title="PRELIMINARY CAN driver interface ">CAN.h</a> follow a CAN_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by CAN*.h follow a CAN*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> has to be called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A CAN handle returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_c_a_n_8h.html" title="PRELIMINARY CAN driver interface ">CAN.h</a> or CAN*.h commands.</td></tr>
    <tr><td class="paramname">arg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a> </dd></dl>

</div>
</div>
<a id="ac007ed113727f16540e8b8e5d4e88fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac007ed113727f16540e8b8e5d4e88fe4">&sect;&nbsp;</a></span>CAN_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> CAN_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given CAN peripheral. </p>
<p>Function to initialize a given CAN peripheral specified by the particular index value.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="Function to initialize the CAN module. ">CAN_init()</a> has been called</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the CAN indexed into the CAN_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. If NULL, default parameter values will be used. All the fields in this structure are RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> upon success. NULL if an error occurs, or if the indexed CAN peripheral is already opened.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="Function to initialize the CAN module. ">CAN_init()</a> </dd>
<dd>
<a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Function to close a CAN peripheral specified by the CAN handle. ">CAN_close()</a> </dd></dl>

</div>
</div>
<a id="a9a7a7042e4948d4e04b9cb5205c50acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7a7042e4948d4e04b9cb5205c50acf">&sect;&nbsp;</a></span>CAN_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: mode = CAN_MODE_BLOCKING; direction = CAN_DIRECTION_READWRITE; readTimeout = CAN_WAIT_FOREVER; writeTimeout = CAN_WAIT_FOREVER; baudRate = 125000; </p>

</div>
</div>
<a id="afe89a00428e47854c9881b4998f2464b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe89a00428e47854c9881b4998f2464b">&sect;&nbsp;</a></span>CAN_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t CAN_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a CAN with interrupts enabled. </p>
<p>CAN_write() writes data from a memory buffer to the CAN interface. The source is specified by <em>buffer</em> and the number of bytes to write is given by <em>size</em>.</p>
<p>In <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a>, <a class="el" href="_c_a_n_8h.html#afe89a00428e47854c9881b4998f2464b" title="Function that writes data to a CAN with interrupts enabled. ">CAN_write()</a> blocks task execution until at least one CAN frame data in buffer has been written.</p>
<p>In <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1">CAN_MODE_NONBLOCKING</a>, CAN_write() returns immediately with the number of bytes (in frame size chunks) that were able to be immediately written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned by <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A read-only pointer to buffer containing CAN frames to be written to the CAN interface (<a class="el" href="_c_a_n_8h.html#ae64d35abf30084ae3b17d47f1c3e2a17" title="CAN frame structure. ">CAN_Frame</a>, struct <a class="el" href="structcan__frame.html" title="CAN frame structure. ">can_frame</a>)</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that should be written to the CAN interface, sizeof(CAN_frame)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the CAN interface. If an error occurs, a negative error number is returned. If in non-blocking mode, and if there is no more room for write data, then -EAGAIN is return. If in blocking mode and a timeout occurs, then -ETIMEDOUT is returned. </dd></dl>

</div>
</div>
<a id="a24ffdf96e912ae6218ec3d3f52549551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ffdf96e912ae6218ec3d3f52549551">&sect;&nbsp;</a></span>CAN_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast32_t CAN_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a CAN with interrupt enabled. </p>
<p>CAN_read() reads data into a memory buffer from the CAN interface. The destination is specified by <em>buffer</em> and the number of bytes to read is given by <em>size</em>.</p>
<p>In <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960a6298c2511f40500c7124649998f4d3d6">CAN_MODE_BLOCKING</a>, <a class="el" href="_c_a_n_8h.html#a24ffdf96e912ae6218ec3d3f52549551" title="Function that reads data from a CAN with interrupt enabled. ">CAN_read()</a> blocks task execution until at least one CAN frame data can be received.</p>
<p>In <a class="el" href="_c_a_n_8h.html#a4d6db79b5847128a849ac24b3c281960ac8985ce218669592d8b94f1c796113e1">CAN_MODE_NONBLOCKING</a>, CAN_write() returns immediately with the number of bytes (in frame size chunks) that were able to be immediately received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned by <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Function to initialize a given CAN peripheral. ">CAN_open()</a></td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to buffer containing space for CAN frames to be read into from the CAN interface (<a class="el" href="_c_a_n_8h.html#ae64d35abf30084ae3b17d47f1c3e2a17" title="CAN frame structure. ">CAN_Frame</a>, struct <a class="el" href="structcan__frame.html" title="CAN frame structure. ">can_frame</a>)</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in the buffer that can be filled with receive data from the CAN interface, sizeof(CAN_frame)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the CAN interface. If an error occurs, a negative error number is returned. If in non-blocking mode, and if there is no data to be read then -EAGAIN is returned. If in blocking mode and a timeout occurs, then -ETIMEDOUT is returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
