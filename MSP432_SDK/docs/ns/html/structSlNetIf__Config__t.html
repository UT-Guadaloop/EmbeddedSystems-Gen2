<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>Network Services API: SlNetIf_Config_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Network Services API
   &#160;<span id="projectnumber">2.75.00.17</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SlNetIf_Config_t Struct Reference<div class="ingroups"><a class="el" href="group__SlNetIf.html">SlNetIf group</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structSlNetIf__Config__t.html" title="SlNetIf_Config_t structure contains all the function callbacks that are expected to be filled by the ...">SlNetIf_Config_t</a> structure contains all the function callbacks that are expected to be filled by the relevant network stack interface <br />
 Each interface has different capabilities, so not all the API's must be supported therefore an API's can be defined as:  
 <a href="structSlNetIf__Config__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="slnetif_8h_source.html">ti/net/slnetif.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for SlNetIf_Config_t:</div>
<div class="dyncontent">
<div class="center"><img src="structSlNetIf__Config__t__coll__graph.png" border="0" usemap="#SlNetIf__Config__t_coll__map" alt="Collaboration graph"/></div>
<map name="SlNetIf__Config__t_coll__map" id="SlNetIf__Config__t_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a083ed3e60745fc6b48617fcdd6e86927"><td class="memItemLeft" align="right" valign="top">int16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a083ed3e60745fc6b48617fcdd6e86927">sockCreate</a> )(void *ifContext, int16_t domain, int16_t type, int16_t protocol, void **sdContext)</td></tr>
<tr class="separator:a083ed3e60745fc6b48617fcdd6e86927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4555e74fd1e05a071e8c20b5fe91422"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#ab4555e74fd1e05a071e8c20b5fe91422">sockClose</a> )(int16_t sd, void *sdContext)</td></tr>
<tr class="separator:ab4555e74fd1e05a071e8c20b5fe91422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba0bc23b129509b36c756cff838e41e"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a9ba0bc23b129509b36c756cff838e41e">sockShutdown</a> )(int16_t sd, void *sdContext, int16_t how)</td></tr>
<tr class="separator:a9ba0bc23b129509b36c756cff838e41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a809b7e3637fd1510e1d9c384c06e8"><td class="memItemLeft" align="right" valign="top">int16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a76a809b7e3637fd1510e1d9c384c06e8">sockAccept</a> )(int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen, uint8_t flags, void **acceptedSdContext)</td></tr>
<tr class="separator:a76a809b7e3637fd1510e1d9c384c06e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13290e3f0d2b134c0b9b4c6369a9f409"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a13290e3f0d2b134c0b9b4c6369a9f409">sockBind</a> )(int16_t sd, void *sdContext, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, int16_t addrlen)</td></tr>
<tr class="separator:a13290e3f0d2b134c0b9b4c6369a9f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6f5cbdd5834267bbae22b3db53d5b4"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#abd6f5cbdd5834267bbae22b3db53d5b4">sockListen</a> )(int16_t sd, void *sdContext, int16_t backlog)</td></tr>
<tr class="separator:abd6f5cbdd5834267bbae22b3db53d5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c97fe12153360098b450fcc0ae7e68a"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a3c97fe12153360098b450fcc0ae7e68a">sockConnect</a> )(int16_t sd, void *sdContext, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> addrlen, uint8_t flags)</td></tr>
<tr class="separator:a3c97fe12153360098b450fcc0ae7e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99d1b259e79ae43184a82fd0d32157d"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#ae99d1b259e79ae43184a82fd0d32157d">sockGetPeerName</a> )(int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen)</td></tr>
<tr class="separator:ae99d1b259e79ae43184a82fd0d32157d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d2259a0347e21bdb463e6efa5590a8"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#ad4d2259a0347e21bdb463e6efa5590a8">sockGetLocalName</a> )(int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen)</td></tr>
<tr class="separator:ad4d2259a0347e21bdb463e6efa5590a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab85869481ba5e0b55b43fc0b9462a"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a12ab85869481ba5e0b55b43fc0b9462a">sockSelect</a> )(void *ifContext, int16_t nsds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *readsds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *writesds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *exceptsds, <a class="el" href="group__SlNetSock.html#gabe4a9f6015bc289d3342f2e3df8ecbe7">SlNetSock_Timeval_t</a> *timeout)</td></tr>
<tr class="separator:a12ab85869481ba5e0b55b43fc0b9462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f3f207a12c44108892d01bea874c45"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a88f3f207a12c44108892d01bea874c45">sockSetOpt</a> )(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> optlen)</td></tr>
<tr class="separator:a88f3f207a12c44108892d01bea874c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7141241ab611f6a6f7470a0f1a7e15b3"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a7141241ab611f6a6f7470a0f1a7e15b3">sockGetOpt</a> )(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *optlen)</td></tr>
<tr class="separator:a7141241ab611f6a6f7470a0f1a7e15b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9da688f25e8c4818281861a88b7db7"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a8e9da688f25e8c4818281861a88b7db7">sockRecv</a> )(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags)</td></tr>
<tr class="separator:a8e9da688f25e8c4818281861a88b7db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ecf6ce8dc83603ffedcf6b8d2bf2cc"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a55ecf6ce8dc83603ffedcf6b8d2bf2cc">sockRecvFrom</a> )(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *from, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *fromlen)</td></tr>
<tr class="separator:a55ecf6ce8dc83603ffedcf6b8d2bf2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb57d54ee329c5063b3967dd9afd8710"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#afb57d54ee329c5063b3967dd9afd8710">sockSend</a> )(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags)</td></tr>
<tr class="separator:afb57d54ee329c5063b3967dd9afd8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016a512efd66579ab7507b7ba0f6d01"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a2016a512efd66579ab7507b7ba0f6d01">sockSendTo</a> )(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *to, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> tolen)</td></tr>
<tr class="separator:a2016a512efd66579ab7507b7ba0f6d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3287ee2b76f780731123c55d4381eaf"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#af3287ee2b76f780731123c55d4381eaf">sockstartSec</a> )(int16_t sd, void *sdContext, <a class="el" href="group__SlNetSock.html#gab0a8884e32b47aca0215b6083dad9489">SlNetSockSecAttrib_t</a> *secAttrib, uint8_t flags)</td></tr>
<tr class="separator:af3287ee2b76f780731123c55d4381eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc08dd8a97a3533cc33de148792ab3"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a9ddc08dd8a97a3533cc33de148792ab3">utilGetHostByName</a> )(void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family)</td></tr>
<tr class="separator:a9ddc08dd8a97a3533cc33de148792ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c4298be3f63bb789809e897a282c2"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a524c4298be3f63bb789809e897a282c2">ifGetIPAddr</a> )(void *ifContext, <a class="el" href="group__SlNetIf.html#ga5b4ae97f88b0f06e47174562a25b35ff">SlNetIfAddressType_e</a> addrType, uint16_t *addrConfig, uint32_t *ipAddr)</td></tr>
<tr class="separator:a524c4298be3f63bb789809e897a282c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e232a515f0d73a3841c8563c34e42c3"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a6e232a515f0d73a3841c8563c34e42c3">ifGetConnectionStatus</a> )(void *ifContext)</td></tr>
<tr class="separator:a6e232a515f0d73a3841c8563c34e42c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572bebd884bbd14dd7d32ac4bb9d7672"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#a572bebd884bbd14dd7d32ac4bb9d7672">ifLoadSecObj</a> )(void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen)</td></tr>
<tr class="separator:a572bebd884bbd14dd7d32ac4bb9d7672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15a0a975df1c02cb6728bdf31c3403a"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlNetIf__Config__t.html#ac15a0a975df1c02cb6728bdf31c3403a">ifCreateContext</a> )(uint16_t ifID, const char *ifName, void **ifContext)</td></tr>
<tr class="separator:ac15a0a975df1c02cb6728bdf31c3403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structSlNetIf__Config__t.html" title="SlNetIf_Config_t structure contains all the function callbacks that are expected to be filled by the ...">SlNetIf_Config_t</a> structure contains all the function callbacks that are expected to be filled by the relevant network stack interface <br />
 Each interface has different capabilities, so not all the API's must be supported therefore an API's can be defined as: </p>
<ul>
<li><b>Mandatory API's</b> - must be supported by the interface in order to be part of SlNetSock layer</li>
<li><b>Non-Mandatory API's</b> - can be supported, but not mandatory for basic SlNetSock proper operation</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Interface that is not supporting a non-mandatory API should set it to <b>NULL</b> in its function list</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSlNetIf__Config__t.html" title="SlNetIf_Config_t structure contains all the function callbacks that are expected to be filled by the ...">SlNetIf_Config_t</a> </dd></dl>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a083ed3e60745fc6b48617fcdd6e86927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083ed3e60745fc6b48617fcdd6e86927">&sect;&nbsp;</a></span>sockCreate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t(* SlNetIf_Config_t::sockCreate) (void *ifContext, int16_t domain, int16_t type, int16_t protocol, void **sdContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga9ea71381f0f81003ca777c06d0bfdf0f" title="Create an endpoint for communication. ">SlNetSock_create</a> </p>

</div>
</div>
<a id="ab4555e74fd1e05a071e8c20b5fe91422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4555e74fd1e05a071e8c20b5fe91422">&sect;&nbsp;</a></span>sockClose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockClose) (int16_t sd, void *sdContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gac10928928d0984392fa31f6ef8c5fad8" title="Gracefully close socket. ">SlNetSock_close</a> </p>

</div>
</div>
<a id="a9ba0bc23b129509b36c756cff838e41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba0bc23b129509b36c756cff838e41e">&sect;&nbsp;</a></span>sockShutdown</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockShutdown) (int16_t sd, void *sdContext, int16_t how)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga770906a5e5d3ed14184e51f830346b19" title="Shutting down parts of a full-duplex connection. ">SlNetSock_shutdown</a> </p>

</div>
</div>
<a id="a76a809b7e3637fd1510e1d9c384c06e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a809b7e3637fd1510e1d9c384c06e8">&sect;&nbsp;</a></span>sockAccept</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t(* SlNetIf_Config_t::sockAccept) (int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen, uint8_t flags, void **acceptedSdContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga45fd9b22c489184590f54120f13dbcd6" title="Accept a connection on a socket. ">SlNetSock_accept</a> </p>

</div>
</div>
<a id="a13290e3f0d2b134c0b9b4c6369a9f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13290e3f0d2b134c0b9b4c6369a9f409">&sect;&nbsp;</a></span>sockBind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockBind) (int16_t sd, void *sdContext, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, int16_t addrlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga8c6a39689f45df13e97afcea7c21adbb" title="Assign a name to a socket. ">SlNetSock_bind</a> </p>

</div>
</div>
<a id="abd6f5cbdd5834267bbae22b3db53d5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6f5cbdd5834267bbae22b3db53d5b4">&sect;&nbsp;</a></span>sockListen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockListen) (int16_t sd, void *sdContext, int16_t backlog)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gafa59ce16fc62997cf08ae88cdd358fd0" title="Listen for connections on a socket. ">SlNetSock_listen</a> </p>

</div>
</div>
<a id="a3c97fe12153360098b450fcc0ae7e68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c97fe12153360098b450fcc0ae7e68a">&sect;&nbsp;</a></span>sockConnect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockConnect) (int16_t sd, void *sdContext, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> addrlen, uint8_t flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gaea4662ca93793562d216cb307977d3b5" title="Initiate a connection on a socket. ">SlNetSock_connect</a> </p>

</div>
</div>
<a id="ae99d1b259e79ae43184a82fd0d32157d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99d1b259e79ae43184a82fd0d32157d">&sect;&nbsp;</a></span>sockGetPeerName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockGetPeerName) (int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga3eac25e5c6ec5865c89e07b0dce09000" title="Return address info about the remote side of the connection. ">SlNetSock_getPeerName</a> </p>

</div>
</div>
<a id="ad4d2259a0347e21bdb463e6efa5590a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d2259a0347e21bdb463e6efa5590a8">&sect;&nbsp;</a></span>sockGetLocalName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockGetLocalName) (int16_t sd, void *sdContext, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *addr, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *addrlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gab4101ff3e249219f95ef7134b1ce8199" title="Get local address info by socket descriptor. ">SlNetSock_getSockName</a> </p>

</div>
</div>
<a id="a12ab85869481ba5e0b55b43fc0b9462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ab85869481ba5e0b55b43fc0b9462a">&sect;&nbsp;</a></span>sockSelect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockSelect) (void *ifContext, int16_t nsds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *readsds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *writesds, <a class="el" href="structSlNetSock__SdSet__t.html">SlNetSock_SdSet_t</a> *exceptsds, <a class="el" href="group__SlNetSock.html#gabe4a9f6015bc289d3342f2e3df8ecbe7">SlNetSock_Timeval_t</a> *timeout)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga6fb99109fb8ca927a6e0bb663feb40d8" title="Monitor socket activity. ">SlNetSock_select</a> </p>

</div>
</div>
<a id="a88f3f207a12c44108892d01bea874c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f3f207a12c44108892d01bea874c45">&sect;&nbsp;</a></span>sockSetOpt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockSetOpt) (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> optlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga39840c28417c98670d82e347e5c1093b" title="Set socket options. ">SlNetSock_setOpt</a> </p>

</div>
</div>
<a id="a7141241ab611f6a6f7470a0f1a7e15b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7141241ab611f6a6f7470a0f1a7e15b3">&sect;&nbsp;</a></span>sockGetOpt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockGetOpt) (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *optlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga4e94ea51cc019d104ca181cba2d6bf50" title="Get socket options. ">SlNetSock_getOpt</a> </p>

</div>
</div>
<a id="a8e9da688f25e8c4818281861a88b7db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9da688f25e8c4818281861a88b7db7">&sect;&nbsp;</a></span>sockRecv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockRecv) (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga1349ee33126ca01de47104aa61253908" title="Read data from TCP socket. ">SlNetSock_recv</a> </p>

</div>
</div>
<a id="a55ecf6ce8dc83603ffedcf6b8d2bf2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ecf6ce8dc83603ffedcf6b8d2bf2cc">&sect;&nbsp;</a></span>sockRecvFrom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockRecvFrom) (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *from, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> *fromlen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gacb20dca59da74cd843213a8094302257" title="Read data from socket. ">SlNetSock_recvFrom</a> </p>

</div>
</div>
<a id="afb57d54ee329c5063b3967dd9afd8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb57d54ee329c5063b3967dd9afd8710">&sect;&nbsp;</a></span>sockSend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockSend) (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga46bc70ae63ecd3fc15bfb2c99dda85db" title="Write data to TCP socket. ">SlNetSock_send</a> </p>

</div>
</div>
<a id="a2016a512efd66579ab7507b7ba0f6d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2016a512efd66579ab7507b7ba0f6d01">&sect;&nbsp;</a></span>sockSendTo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockSendTo) (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const <a class="el" href="structSlNetSock__Addr__t.html">SlNetSock_Addr_t</a> *to, <a class="el" href="group__SlNetSock.html#ga89b698aee92814448d4bd15a2b874fd5">SlNetSocklen_t</a> tolen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#ga785993d541a91b99c5a4e29e7fb9318c" title="Write data to socket. ">SlNetSock_sendTo</a> </p>

</div>
</div>
<a id="af3287ee2b76f780731123c55d4381eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3287ee2b76f780731123c55d4381eaf">&sect;&nbsp;</a></span>sockstartSec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::sockstartSec) (int16_t sd, void *sdContext, <a class="el" href="group__SlNetSock.html#gab0a8884e32b47aca0215b6083dad9489">SlNetSockSecAttrib_t</a> *secAttrib, uint8_t flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetSock.html#gac601a0009777c2dd84b476a7fbd09ed5" title="Start a security session on an opened socket. ">SlNetSock_startSec</a> </p>

</div>
</div>
<a id="a9ddc08dd8a97a3533cc33de148792ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddc08dd8a97a3533cc33de148792ab3">&sect;&nbsp;</a></span>utilGetHostByName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::utilGetHostByName) (void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetUtils.html#gab9f23f3dae293a3867c989a30a0e5e43" title="Get host IP by name Obtain the IP Address of machine on network, by machine name. ...">SlNetUtil_getHostByName</a> </p>

</div>
</div>
<a id="a524c4298be3f63bb789809e897a282c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524c4298be3f63bb789809e897a282c2">&sect;&nbsp;</a></span>ifGetIPAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::ifGetIPAddr) (void *ifContext, <a class="el" href="group__SlNetIf.html#ga5b4ae97f88b0f06e47174562a25b35ff">SlNetIfAddressType_e</a> addrType, uint16_t *addrConfig, uint32_t *ipAddr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetIf.html#gac2fbe1c788dfcabb94e465448e2632a2" title="Get IP Address of specific interface. ">SlNetIf_getIPAddr</a> </p>

</div>
</div>
<a id="a6e232a515f0d73a3841c8563c34e42c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e232a515f0d73a3841c8563c34e42c3">&sect;&nbsp;</a></span>ifGetConnectionStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::ifGetConnectionStatus) (void *ifContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetIf.html#gac47597b573607194c63d42a82d5953db" title="Get the connection status of an interface. ">SlNetIf_getConnectionStatus</a> </p>

</div>
</div>
<a id="a572bebd884bbd14dd7d32ac4bb9d7672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572bebd884bbd14dd7d32ac4bb9d7672">&sect;&nbsp;</a></span>ifLoadSecObj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::ifLoadSecObj) (void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetIf.html#ga72f32689df9255833f05af282ae3639b" title="Load/unload/replace a secure object into a network interface/stack. ">SlNetIf_loadSecObj</a> </p>

</div>
</div>
<a id="ac15a0a975df1c02cb6728bdf31c3403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15a0a975df1c02cb6728bdf31c3403a">&sect;&nbsp;</a></span>ifCreateContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* SlNetIf_Config_t::ifCreateContext) (uint16_t ifID, const char *ifName, void **ifContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Non-Mandatory</b> API <br />
 The actual implementation of the interface for <a class="el" href="group__SlNetIf.html#gae09651b941726526788a932498d2d250" title="Add a new SlNetIf-compatible interface to the system. ">SlNetIf_add</a> </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>ti/net/<a class="el" href="slnetif_8h_source.html">slnetif.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
