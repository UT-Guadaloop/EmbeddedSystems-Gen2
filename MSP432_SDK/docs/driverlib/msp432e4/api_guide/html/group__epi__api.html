<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Epi_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Epi_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga96755362386f5ced366f5ae9a46ea513"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a></td></tr>
<tr class="separator:ga96755362386f5ced366f5ae9a46ea513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfec815ec7fa028f90a39b1a4d315ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9dfec815ec7fa028f90a39b1a4d315ca">EPI_HB16_CS_MASK</a>&#160;&#160;&#160;(<a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a> | <a class="el" href="epi_8h.html#a130064adefdd390094f5c1d4d2296b77">EPI_HB16_BURST_TRAFFIC</a>)</td></tr>
<tr class="separator:ga9dfec815ec7fa028f90a39b1a4d315ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf954738021f0632426c67962aedf8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaaf954738021f0632426c67962aedf8e7">EPIWorkaroundWordWrite</a> (uint32_t *pui32Addr, uint32_t ui32Value)</td></tr>
<tr class="separator:gaaf954738021f0632426c67962aedf8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dd18169c4f1dd367fc7ac6d0256c98"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga47dd18169c4f1dd367fc7ac6d0256c98">EPIWorkaroundWordRead</a> (uint32_t *pui32Addr)</td></tr>
<tr class="separator:ga47dd18169c4f1dd367fc7ac6d0256c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a50bfa91729092980cca2ec63ec84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae0a50bfa91729092980cca2ec63ec84f">EPIWorkaroundHWordWrite</a> (uint16_t *pui16Addr, uint16_t ui16Value)</td></tr>
<tr class="separator:gae0a50bfa91729092980cca2ec63ec84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71f8ad921035840a193e61195043f19"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad71f8ad921035840a193e61195043f19">EPIWorkaroundHWordRead</a> (uint16_t *pui16Addr)</td></tr>
<tr class="separator:gad71f8ad921035840a193e61195043f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ba9dc9e83289991e8f14761c878700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga77ba9dc9e83289991e8f14761c878700">EPIWorkaroundByteWrite</a> (uint8_t *pui8Addr, uint8_t ui8Value)</td></tr>
<tr class="separator:ga77ba9dc9e83289991e8f14761c878700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fdafd7c230548f932c7c97bf10edede"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga5fdafd7c230548f932c7c97bf10edede">EPIWorkaroundByteRead</a> (uint8_t *pui8Addr)</td></tr>
<tr class="separator:ga5fdafd7c230548f932c7c97bf10edede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bb056cd29fa04275e955323ab18239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet</a> (uint32_t ui32Base, uint32_t ui32Mode)</td></tr>
<tr class="separator:ga68bb056cd29fa04275e955323ab18239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5bc021fe841f7910b9c441c9e645e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet</a> (uint32_t ui32Base, uint32_t ui32Divider)</td></tr>
<tr class="separator:ga5b5bc021fe841f7910b9c441c9e645e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0477da26c8bbb3746ecdc2f4329cb71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Divider)</td></tr>
<tr class="separator:gad0477da26c8bbb3746ecdc2f4329cb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb1dc9e6eed9bfcf5565cd930b0f22b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7bb1dc9e6eed9bfcf5565cd930b0f22b">EPIDMATxCount</a> (uint32_t ui32Base, uint32_t ui32Count)</td></tr>
<tr class="separator:ga7bb1dc9e6eed9bfcf5565cd930b0f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab51fb7dee81c5e5dfc6a3cce5f8711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">EPIConfigSDRAMSet</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32Refresh)</td></tr>
<tr class="separator:ga7ab51fb7dee81c5e5dfc6a3cce5f8711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6637f518ffb554224100f386f0c13936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)</td></tr>
<tr class="separator:ga6637f518ffb554224100f386f0c13936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d612e5b8a15f344097625817a2a415a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)</td></tr>
<tr class="separator:ga7d612e5b8a15f344097625817a2a415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8d1ad6326357040fa3a8805cfeeb0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr class="separator:ga0c8d1ad6326357040fa3a8805cfeeb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6d88d2589bd63fd23fbfa403dc688a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr class="separator:gae6d88d2589bd63fd23fbfa403dc688a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2bf596b8c09862989df76bc781c2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga1a2bf596b8c09862989df76bc781c2e3">EPIConfigHB8TimingSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr class="separator:ga1a2bf596b8c09862989df76bc781c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404cc115292a3c173d64ed6c38e793f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga404cc115292a3c173d64ed6c38e793f3">EPIConfigHB16TimingSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr class="separator:ga404cc115292a3c173d64ed6c38e793f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcbbd4afec4caf570bc1dbfdd0169c99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gabcbbd4afec4caf570bc1dbfdd0169c99">EPIPSRAMConfigRegSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32CR)</td></tr>
<tr class="separator:gabcbbd4afec4caf570bc1dbfdd0169c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52fb7f5686e6c29a42ded8694ea8accb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead</a> (uint32_t ui32Base, uint32_t ui32CS)</td></tr>
<tr class="separator:ga52fb7f5686e6c29a42ded8694ea8accb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7028e21f0e37f8f79e94855c56ce0d8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7028e21f0e37f8f79e94855c56ce0d8c">EPIPSRAMConfigRegGetNonBlocking</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t *pui32CR)</td></tr>
<tr class="separator:ga7028e21f0e37f8f79e94855c56ce0d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac078ff4e388a21abdd0e63aae2d96960"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac078ff4e388a21abdd0e63aae2d96960">EPIPSRAMConfigRegGet</a> (uint32_t ui32Base, uint32_t ui32CS)</td></tr>
<tr class="separator:gac078ff4e388a21abdd0e63aae2d96960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9544feee05f3e0342a8092ff87f9bad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9544feee05f3e0342a8092ff87f9bad2">EPIConfigGPModeSet</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32FrameCount, uint32_t ui32MaxWait)</td></tr>
<tr class="separator:ga9544feee05f3e0342a8092ff87f9bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae781a5be3fc69203242a16f34feae2cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet</a> (uint32_t ui32Base, uint32_t ui32Map)</td></tr>
<tr class="separator:gae781a5be3fc69203242a16f34feae2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d3a1b329d16480537f5afbbd54a547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure</a> (uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32DataSize, uint32_t ui32Address)</td></tr>
<tr class="separator:ga09d3a1b329d16480537f5afbbd54a547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd38827e4a7a2c21cad1f58e61dd4053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart</a> (uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32Count)</td></tr>
<tr class="separator:gabd38827e4a7a2c21cad1f58e61dd4053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fa0e80a591d62a6b84f09f47a71afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaa5fa0e80a591d62a6b84f09f47a71afa">EPINonBlockingReadStop</a> (uint32_t ui32Base, uint32_t ui32Channel)</td></tr>
<tr class="separator:gaa5fa0e80a591d62a6b84f09f47a71afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3decd0254b5104255b9dbe1e02936ff6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga3decd0254b5104255b9dbe1e02936ff6">EPINonBlockingReadCount</a> (uint32_t ui32Base, uint32_t ui32Channel)</td></tr>
<tr class="separator:ga3decd0254b5104255b9dbe1e02936ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfc47bee6a379ced21c9ecf984f2888"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaecfc47bee6a379ced21c9ecf984f2888">EPINonBlockingReadAvail</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaecfc47bee6a379ced21c9ecf984f2888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a09fac58328065e92a61fdd31cdcc0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac8a09fac58328065e92a61fdd31cdcc0">EPINonBlockingReadGet32</a> (uint32_t ui32Base, uint32_t ui32Count, uint32_t *pui32Buf)</td></tr>
<tr class="separator:gac8a09fac58328065e92a61fdd31cdcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac0645c23368a2e768a27010e714e7cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaac0645c23368a2e768a27010e714e7cf">EPINonBlockingReadGet16</a> (uint32_t ui32Base, uint32_t ui32Count, uint16_t *pui16Buf)</td></tr>
<tr class="separator:gaac0645c23368a2e768a27010e714e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7df76c4aa477ec5f48e682d9a420903"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaf7df76c4aa477ec5f48e682d9a420903">EPINonBlockingReadGet8</a> (uint32_t ui32Base, uint32_t ui32Count, uint8_t *pui8Buf)</td></tr>
<tr class="separator:gaf7df76c4aa477ec5f48e682d9a420903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c11b58182855b534e42cf0357b4db72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9c11b58182855b534e42cf0357b4db72">EPIFIFOConfig</a> (uint32_t ui32Base, uint32_t ui32Config)</td></tr>
<tr class="separator:ga9c11b58182855b534e42cf0357b4db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9983fa4529a274cd1b09f5a10cbbdd0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gab9983fa4529a274cd1b09f5a10cbbdd0">EPIWriteFIFOCountGet</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gab9983fa4529a274cd1b09f5a10cbbdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0231d902fde7ee8a0bd73d43cee6d636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga0231d902fde7ee8a0bd73d43cee6d636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac477f3e293ed8e771fc05450cd6c28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac477f3e293ed8e771fc05450cd6c28d5">EPIIntDisable</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:gac477f3e293ed8e771fc05450cd6c28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198a1b608d1cf1565e96ce27d967aea4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:ga198a1b608d1cf1565e96ce27d967aea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6fcb9023d51da8af50f924dd64e9e72"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad6fcb9023d51da8af50f924dd64e9e72">EPIIntErrorStatus</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gad6fcb9023d51da8af50f924dd64e9e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14adf0b4a609b3635ef98c2223ada115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga14adf0b4a609b3635ef98c2223ada115">EPIIntErrorClear</a> (uint32_t ui32Base, uint32_t ui32ErrFlags)</td></tr>
<tr class="separator:ga14adf0b4a609b3635ef98c2223ada115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2d512849c4f92fc15196d62ff30bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga4b2d512849c4f92fc15196d62ff30bd2">EPIIntRegister</a> (uint32_t ui32Base, void(*pfnHandler)(void))</td></tr>
<tr class="separator:ga4b2d512849c4f92fc15196d62ff30bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9375b854f9a595e2b0b0a712829cf8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9375b854f9a595e2b0b0a712829cf8aa">EPIIntUnregister</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga9375b854f9a595e2b0b0a712829cf8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="epi_intro"></a>
Introduction</h1>
<p>The EPI API provides functions to use the EPI module available in the MSP432E4 microcontroller. The EPI module provides a physical interface for external peripherals and memories. The EPI can be configured to support several types of external interfaces and different sized address and data buses.</p>
<p>Some features of the EPI module are:</p>
<ul>
<li>configurable interface modes including SDRAM, HostBus, and simple read/write protocols</li>
<li>configurable address and data sizes</li>
<li>configurable bus cycle timing</li>
<li>blocking and non-blocking reads and writes</li>
<li>FIFO for streaming reads</li>
<li>interrupt and uDMA support</li>
</ul>
<h1><a class="anchor" id="epi_api_functions"></a>
API Functions</h1>
<p>The function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a> is used to select the interface mode. The clock divider is set with the <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> function which determines the speed of the external bus. The external device is mapped into the processor memory or peripheral space using the <a class="el" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet()</a> function.</p>
<p>Once the mode is selected, the interface is configured with one of the configuration functions. If SDRAM mode is chosen, then the function <a class="el" href="group__epi__api.html#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">EPIConfigSDRAMSet()</a> is used to configure the SDRAM interface. If Host-Bus 8 mode is chosen, then <a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set()</a> is used. If Host-Bus 16 mode is chosen, then <a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set()</a> is used. If General-Purpose mode is chosen, then EPIConfigGPMode() is used.</p>
<p>After the mode has been selected and configured, then the device can be accessed by reading and writing to the memory or peripheral address space that was programmed with <a class="el" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet()</a>.</p>
<p>There are more sophisticated ways to use the read/write interface. When an application is writing to the mapped memory or peripheral space, the writes stall the processor until the write to the external interface is completed. However, the EPI contains an internal transaction FIFO and can buffer up to 4 pending writes without stalling the processor. Prior to writing, the application can test to see if the EPI can take more write operations without stalling the processor by using the function EPINonBlockingWriteCount(), which returns the number of non-blocking writes that can be made.</p>
<p>For efficient reads from the external device, the EPI contains a programmable read FIFO. After setting a starting address and a count, data from sequential reads from the device can be stored in the FIFO. The application can then periodically drain the FIFO by polling or by interrupts, optionally using the uDMA controller. A non-blocking read is configured by using the function <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure()</a>. The read operation is started with <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart()</a> and can be stopped by calling <a class="el" href="group__epi__api.html#gaa5fa0e80a591d62a6b84f09f47a71afa">EPINonBlockingReadStop()</a>. The function <a class="el" href="group__epi__api.html#ga3decd0254b5104255b9dbe1e02936ff6">EPINonBlockingReadCount()</a> can be used to determine the number of items remaining to be read, while the function <a class="el" href="group__epi__api.html#gaecfc47bee6a379ced21c9ecf984f2888">EPINonBlockingReadAvail()</a> returns the number of items in the FIFO that can be read immediately without stalling. There are 3 functions available for reading data from the FIFO and into a buffer provided by the application. These functions are <a class="el" href="group__epi__api.html#gac8a09fac58328065e92a61fdd31cdcc0">EPINonBlockingReadGet32()</a>, <a class="el" href="group__epi__api.html#gaac0645c23368a2e768a27010e714e7cf">EPINonBlockingReadGet16()</a>, <a class="el" href="group__epi__api.html#gaf7df76c4aa477ec5f48e682d9a420903">EPINonBlockingReadGet8()</a>, to read the data from the FIFO as 32-bit, 16-bit, or 8-bit data items.</p>
<p>The read FIFO and write transaction FIFO can be configured with the function <a class="el" href="group__epi__api.html#ga9c11b58182855b534e42cf0357b4db72">EPIFIFOConfig()</a>. This function is used to set the FIFO trigger levels and to enable error interrupts to be generated when a read or write is stalled.</p>
<p>Interrupts are enabled or disabled with the functions <a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable()</a> and <a class="el" href="group__epi__api.html#gac477f3e293ed8e771fc05450cd6c28d5">EPIIntDisable()</a>. The interrupt status can be read by calling <a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus()</a>. If there is an error interrupt pending, the cause of the error can be determined with the function <a class="el" href="group__epi__api.html#gad6fcb9023d51da8af50f924dd64e9e72">EPIIntErrorStatus()</a>. The error can then be cleared with <a class="el" href="group__epi__api.html#ga14adf0b4a609b3635ef98c2223ada115">EPIIntErrorClear()</a>.</p>
<p>If dynamic interrupt registration is being used by the application, then an EPI interrupt handler can be registered by calling <a class="el" href="group__epi__api.html#ga4b2d512849c4f92fc15196d62ff30bd2">EPIIntRegister()</a>. This function loads the interrupt handler's address into the vector table. The handler can be removed with <a class="el" href="group__epi__api.html#ga9375b854f9a595e2b0b0a712829cf8aa">EPIIntUnregister()</a>.</p>
<h1><a class="anchor" id="epi_example"></a>
Programming Example</h1>
<p>This example illustrates the setup steps required to initialize the EPI to access an SDRAM when the system clock is running at 50MHz.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable the EPI module.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a>(<a class="code" href="sysctl_8h.html#a441d64ecd5a31f56f40ad107c7ef3363">SYSCTL_PERIPH_EPI0</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Wait for the EPI module to be ready.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordflow">while</span>(!<a class="code" href="group__sysctl__api.html#ga7ddf1f06376894c31e5596f562c299ac">SysCtlPeripheralReady</a>(<a class="code" href="sysctl_8h.html#a441d64ecd5a31f56f40ad107c7ef3363">SYSCTL_PERIPH_EPI0</a>))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set the EPI divider.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet</a>(EPI0_BASE, 0);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Select SDRAM mode.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet</a>(EPI0_BASE, <a class="code" href="epi_8h.html#ae30aaee9658b57e352f3aeac2bfa3ad2">EPI_MODE_SDRAM</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Configure SDRAM mode.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__epi__api.html#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">EPIConfigSDRAMSet</a>(EPI0_BASE, (<a class="code" href="epi_8h.html#aee3a4902da2c4bb865cecbff830b8c6d">EPI_SDRAM_CORE_FREQ_50_100</a> |</div><div class="line">                  <a class="code" href="epi_8h.html#a4669b1ce8e8195ab39c9d5bf29462645">EPI_SDRAM_FULL_POWER</a> | <a class="code" href="epi_8h.html#a6ad76ca17839b1bbc46acdcce3890838">EPI_SDRAM_SIZE_64MBIT</a>), 1024);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set the address map.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet</a>(EPI0_BASE, <a class="code" href="epi_8h.html#ada77758ec15f9f7a8b6decb8c5cce9f2">EPI_ADDR_RAM_SIZE_256MB</a> | <a class="code" href="epi_8h.html#a9f1a4583aa762f744e225e0e971f3f05">EPI_ADDR_RAM_BASE_6</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Wait for the EPI initialization to complete.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordflow">while</span>(<a class="code" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(EPI0_BASE + <a class="code" href="hw__epi_8h.html#a635bf1757e7aa5544a08e37e1567743e">EPI_O_STAT</a>) &amp;  <a class="code" href="hw__epi_8h.html#a129db371ec65cde1dad5c406d9c16578">EPI_STAT_INITSEQ</a>)</div><div class="line">{</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Wait for SDRAM initialization to complete.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// At this point, the SDRAM is accessible and available for use.</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga96755362386f5ced366f5ae9a46ea513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96755362386f5ced366f5ae9a46ea513">&sect;&nbsp;</a></span>EPI_HB8_CS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPI_HB8_CS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="epi_8h.html#aa1b5d4fe0d20aa8ec95b5326a75fa616">EPI_HB8_MODE_FIFO</a> | <a class="code" href="epi_8h.html#a39f59d28f3d23a19df186562d4f41702">EPI_HB8_RDWAIT_3</a> |       \</div><div class="line">                                 EPI_HB8_WRWAIT_3 | <a class="code" href="epi_8h.html#ade4a1b8e90598bde97094372c5863293">EPI_HB8_RDHIGH</a> |          \</div><div class="line">                                 EPI_HB8_WRHIGH | <a class="code" href="epi_8h.html#a75c20f10ed8d6b18a809453cd106b995">EPI_HB8_ALE_HIGH</a>)</div><div class="ttc" id="epi_8h_html_ade4a1b8e90598bde97094372c5863293"><div class="ttname"><a href="epi_8h.html#ade4a1b8e90598bde97094372c5863293">EPI_HB8_RDHIGH</a></div><div class="ttdeci">#define EPI_HB8_RDHIGH</div><div class="ttdef"><b>Definition:</b> epi.h:112</div></div>
<div class="ttc" id="epi_8h_html_aa1b5d4fe0d20aa8ec95b5326a75fa616"><div class="ttname"><a href="epi_8h.html#aa1b5d4fe0d20aa8ec95b5326a75fa616">EPI_HB8_MODE_FIFO</a></div><div class="ttdeci">#define EPI_HB8_MODE_FIFO</div><div class="ttdef"><b>Definition:</b> epi.h:126</div></div>
<div class="ttc" id="epi_8h_html_a75c20f10ed8d6b18a809453cd106b995"><div class="ttname"><a href="epi_8h.html#a75c20f10ed8d6b18a809453cd106b995">EPI_HB8_ALE_HIGH</a></div><div class="ttdeci">#define EPI_HB8_ALE_HIGH</div><div class="ttdef"><b>Definition:</b> epi.h:113</div></div>
<div class="ttc" id="epi_8h_html_a39f59d28f3d23a19df186562d4f41702"><div class="ttname"><a href="epi_8h.html#a39f59d28f3d23a19df186562d4f41702">EPI_HB8_RDWAIT_3</a></div><div class="ttdeci">#define EPI_HB8_RDWAIT_3</div><div class="ttdef"><b>Definition:</b> epi.h:122</div></div>
</div><!-- fragment -->
<p>Referenced by <a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet()</a>.</p>

</div>
</div>
<a id="ga9dfec815ec7fa028f90a39b1a4d315ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dfec815ec7fa028f90a39b1a4d315ca">&sect;&nbsp;</a></span>EPI_HB16_CS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPI_HB16_CS_MASK&#160;&#160;&#160;(<a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a> | <a class="el" href="epi_8h.html#a130064adefdd390094f5c1d4d2296b77">EPI_HB16_BURST_TRAFFIC</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf954738021f0632426c67962aedf8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf954738021f0632426c67962aedf8e7">&sect;&nbsp;</a></span>EPIWorkaroundWordWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIWorkaroundWordWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely writes a word to the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui32Value</td><td>is the 32-bit word to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing words to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga47dd18169c4f1dd367fc7ac6d0256c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47dd18169c4f1dd367fc7ac6d0256c98">&sect;&nbsp;</a></span>EPIWorkaroundWordRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPIWorkaroundWordRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely reads a word from the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading words from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit word stored at address <em>pui32Addr</em>. </dd></dl>

</div>
</div>
<a id="gae0a50bfa91729092980cca2ec63ec84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a50bfa91729092980cca2ec63ec84f">&sect;&nbsp;</a></span>EPIWorkaroundHWordWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIWorkaroundHWordWrite </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely writes a half-word to the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui16Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui16Value</td><td>is the 16-bit half-word to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing half-words to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gad71f8ad921035840a193e61195043f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71f8ad921035840a193e61195043f19">&sect;&nbsp;</a></span>EPIWorkaroundHWordRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t EPIWorkaroundHWordRead </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely reads a half-word from the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui16Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading half-words from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit word stored at address <em>pui16Addr</em>. </dd></dl>

</div>
</div>
<a id="ga77ba9dc9e83289991e8f14761c878700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ba9dc9e83289991e8f14761c878700">&sect;&nbsp;</a></span>EPIWorkaroundByteWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIWorkaroundByteWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely writes a byte to the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui8Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui8Value</td><td>is the 8-bit byte to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing bytes to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga5fdafd7c230548f932c7c97bf10edede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fdafd7c230548f932c7c97bf10edede">&sect;&nbsp;</a></span>EPIWorkaroundByteRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t EPIWorkaroundByteRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely reads a byte from the EPI 0x10000000 address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui8Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading bytes from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The 8-bit byte stored at address <em>pui8Addr</em>. </dd></dl>

</div>
</div>
<a id="ga68bb056cd29fa04275e955323ab18239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68bb056cd29fa04275e955323ab18239">&sect;&nbsp;</a></span>EPIModeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the usage mode of the EPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>is the usage mode of the EPI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions sets the operating mode of the EPI module. The parameter <em>ui32Mode</em> must be one of the following:</p>
<ul>
<li><b>EPI_MODE_GENERAL</b> - use for general-purpose mode operation</li>
<li><b>EPI_MODE_SDRAM</b> - use with SDRAM device</li>
<li><b>EPI_MODE_HB8</b> - use with host-bus 8-bit interface</li>
<li><b>EPI_MODE_HB16</b> - use with host-bus 16-bit interface</li>
<li><b>EPI_MODE_DISABLE</b> - disable the EPI module</li>
</ul>
<p>Selection of any of the above modes enables the EPI module, except for <b>EPI_MODE_DISABLE</b>, which is used to disable the module.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="epi_8h.html#af43bd43bff8a405a63626ea423a3b0fb">EPI_MODE_DISABLE</a>, <a class="el" href="epi_8h.html#a729eeab60066a39337793c3f363649b1">EPI_MODE_GENERAL</a>, <a class="el" href="epi_8h.html#ada4b2e48b1e178591ff3dca7eddb96b9">EPI_MODE_HB16</a>, <a class="el" href="epi_8h.html#aa0ccd99a1265d2880c7c0942fe39dfab">EPI_MODE_HB8</a>, <a class="el" href="epi_8h.html#ae30aaee9658b57e352f3aeac2bfa3ad2">EPI_MODE_SDRAM</a>, <a class="el" href="hw__epi_8h.html#a9063d1bfdc05bf936500da72ca429798">EPI_O_CFG</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga5b5bc021fe841f7910b9c441c9e645e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5bc021fe841f7910b9c441c9e645e4">&sect;&nbsp;</a></span>EPIDividerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIDividerSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clock divider for the EPI module's CS0n/CS1n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Divider</td><td>is the value of the clock divider to be applied to the external interface (0-65535).</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the clock divider(s) that is used to determine the clock rate of the external interface. The <em>ui32Divider</em> value is used to derive the EPI clock rate from the system clock based on the following formula.</p>
<p>EPIClk = (Divider == 0) ? SysClk : (SysClk / (((Divider / 2) + 1) * 2))</p>
<p>For example, a divider value of 1 results in an EPI clock rate of half the system clock, value of 2 or 3 yields one quarter of the system clock and a value of 4 results in one sixth of the system clock rate.</p>
<p>In cases where a dual chip select mode is in use and different clock rates are required for each chip select, the <em>ui32Divider</em> parameter must contain two dividers. The lower 16 bits define the divider to be used with CS0n and the upper 16 bits define the divider for CS1n.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a04b8f6a26cd70596ea1a031d1bc128a5">EPI_O_BAUD</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gad0477da26c8bbb3746ecdc2f4329cb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0477da26c8bbb3746ecdc2f4329cb71">&sect;&nbsp;</a></span>EPIDividerCSSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIDividerCSSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clock divider for the specified CS in the EPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select to modify and has a valid range of 0-3. </td></tr>
    <tr><td class="paramname">ui32Divider</td><td>is the value of the clock divider to be applied to the external interface (0-65535).</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the clock divider(s) for the specified CS that is used to determine the clock rate of the external interface. The <em>ui32Divider</em> value is used to derive the EPI clock rate from the system clock based on the following formula.</p>
<p>EPIClk = (Divider == 0) ? SysClk : (SysClk / (((Divider / 2) + 1) * 2))</p>
<p>For example, a divider value of 1 results in an EPI clock rate of half the system clock, value of 2 or 3 yields one quarter of the system clock and a value of 4 results in one sixth of the system clock rate.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a04b8f6a26cd70596ea1a031d1bc128a5">EPI_O_BAUD</a>, <a class="el" href="hw__epi_8h.html#a98b93188bd9f702e166aee2dceb396db">EPI_O_BAUD2</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga7bb1dc9e6eed9bfcf5565cd930b0f22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb1dc9e6eed9bfcf5565cd930b0f22b">&sect;&nbsp;</a></span>EPIDMATxCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIDMATxCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transfer count for uDMA transmit operations on EPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of units to transmit by uDMA to WRFIFO.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to help configure the EPI uDMA transmit operations. A non-zero transmit count in combination with a FIFO threshold trigger asserts an EPI uDMA transmit.</p>
<p>Note that, although the EPI peripheral can handle counts of up to 65535, a single uDMA transfer has a maximum length of 1024 units so <em>ui32Count</em> should be set to values less than or equal to 1024.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a358faa9a598fa6661b2957bfedd7e407">EPI_O_DMATXCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga7ab51fb7dee81c5e5dfc6a3cce5f8711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">&sect;&nbsp;</a></span>EPIConfigSDRAMSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigSDRAMSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Refresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the SDRAM mode of operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the SDRAM interface configuration. </td></tr>
    <tr><td class="paramname">ui32Refresh</td><td>is the refresh count in core clocks (0-2047).</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the SDRAM interface, when the SDRAM mode is chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of several sets of choices:</p>
<p>The processor core frequency must be specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_CORE_FREQ_0_15</b> defines core clock as 0 MHz &lt; clk &lt;= 15 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_15_30</b> defines core clock as 15 MHz &lt; clk &lt;= 30 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_30_50</b> defines core clock as 30 MHz &lt; clk &lt;= 50 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_50_100</b> defines core clock as 50 MHz &lt; clk &lt;= 100 MHz</li>
</ul>
<p>The low power mode is specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_LOW_POWER</b> enter low power, self-refresh state.</li>
<li><b>EPI_SDRAM_FULL_POWER</b> normal operating state.</li>
</ul>
<p>The SDRAM device size is specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_SIZE_64MBIT</b> size is a 64 Mbit device (8 MB).</li>
<li><b>EPI_SDRAM_SIZE_128MBIT</b> size is a 128 Mbit device (16 MB).</li>
<li><b>EPI_SDRAM_SIZE_256MBIT</b> size is a 256 Mbit device (32 MB).</li>
<li><b>EPI_SDRAM_SIZE_512MBIT</b> size is a 512 Mbit device (64 MB).</li>
</ul>
<p>The parameter <em>ui16Refresh</em> sets the refresh counter in units of core clock ticks. It is an 11-bit value with a range of 0 - 2047 counts.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a9803b49f1186c9ec6e906eec62ca6306">EPI_O_SDRAMCFG</a>, <a class="el" href="hw__epi_8h.html#a3f92e058bce0738d303009917d8f21b5">EPI_SDRAMCFG_RFSH_M</a>, <a class="el" href="hw__epi_8h.html#a036dc7e81b774736d3f8c8a9b9c78871">EPI_SDRAMCFG_RFSH_S</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga6637f518ffb554224100f386f0c13936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6637f518ffb554224100f386f0c13936">&sect;&nbsp;</a></span>EPIConfigHB8Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB8Set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the interface for Host-bus 8 operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is the maximum number of external clocks to wait if a FIFO ready signal is holding off the transaction, 0-255.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in host-bus 8 operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Host-bus 8 submode, select one of:<ul>
<li><b>EPI_HB8_MODE_ADMUX</b> sets data and address muxed, AD[7:0]</li>
<li><b>EPI_HB8_MODE_ADDEMUX</b> sets up data and address separate, D[7:0]</li>
<li><b>EPI_HB8_MODE_SRAM</b> as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[7:0]</li>
<li><b>EPI_HB8_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[7:0]</li>
</ul>
</li>
<li><b>EPI_HB8_USE_TXEMPTY</b> enables TXEMPTY signal with FIFO</li>
<li><b>EPI_HB8_USE_RXFULL</b> enables RXFULL signal with FIFO</li>
<li><b>EPI_HB8_WRHIGH</b> sets active high write strobe, otherwise it is active low</li>
<li><b>EPI_HB8_RDHIGH</b> sets active high read strobe, otherwise it is active low</li>
<li>Write wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default)</li>
<li><b>EPI_HB8_WRWAIT_1</b> sets write wait state to 4 EPI clocks</li>
<li><b>EPI_HB8_WRWAIT_2</b> sets write wait state to 6 EPI clocks</li>
<li><b>EPI_HB8_WRWAIT_3</b> sets write wait state to 8 EPI clocks</li>
</ul>
</li>
<li>Read wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default)</li>
<li><b>EPI_HB8_RDWAIT_1</b> sets read wait state to 4 EPI clocks</li>
<li><b>EPI_HB8_RDWAIT_2</b> sets read wait state to 6 EPI clocks</li>
<li><b>EPI_HB8_RDWAIT_3</b> sets read wait state to 8 EPI clocks</li>
</ul>
</li>
<li><b>EPI_HB8_CLOCK_GATE_IDLE</b> sets the EPI clock to be held low when no data is available to read or write</li>
<li><b>EPI_HB8_CLOCK_INVERT</b> inverts the EPI clock</li>
<li><b>EPI_HB8_IN_READY_EN</b> sets EPIS032 as a ready/stall signal, active high</li>
<li><b>EPI_HB8_IN_READY_EN_INVERT</b> sets EPIS032 as ready/stall signal, active low</li>
<li><b>EPI_HB8_ALE_HIGH</b> sets the address latch active high (default)</li>
<li><b>EPI_HB8_ALE_LOW</b> sets address latch active low</li>
<li><b>EPI_HB8_CSBAUD</b> use different baud rates when accessing devices on each chip select. CS0n uses the baud rate specified by the lower 16 bits of the divider passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> and CS1n uses the divider passed in the upper 16 bits. If this option is absent, both chip selects use the baud rate resulting from the divider in the lower 16 bits of the parameter passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a>.</li>
</ul>
<p>If <b>EPI_HB8_CSBAUD</b> is configured, <a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet()</a> should be used to to configure the divider for CS2n and CS3n. They both also use the lower 16 bits passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> if this option is absent.</p>
<p>The use of <b>EPI_HB8_CSBAUD</b> also allows for unique chip select configurations. CS0n, CS1n, CS2n, and CS3n can each be configured by calling <a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet()</a> if <b>EPI_HB8_CSBAUD</b> is used. Otherwise, the configuration provided in <em>ui32Config</em> is used for all chip selects enabled.</p>
<ul>
<li>Chip select configuration, select one of:<ul>
<li><b>EPI_HB8_CSCFG_CS</b> sets EPIS030 to operate as a chip select signal.</li>
<li><b>EPI_HB8_CSCFG_ALE</b> sets EPIS030 to operate as an address latch (ALE).</li>
<li><b>EPI_HB8_CSCFG_DUAL_CS</b> sets EPIS030 to operate as CS0n and EPIS027 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB8_CSCFG_ALE_DUAL_CS</b> sets EPIS030 as an address latch (ALE), EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB8_CSCFG_ALE_SINGLE_CS</b> sets EPIS030 to operate as an address latch (ALE) and EPIS027 is used as a chip select.</li>
<li><b>EPI_HB8_CSCFG_QUAD_CS</b> sets EPIS030 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n.</li>
<li><b>EPI_HB8_CSCFG_ALE_QUAD_CS</b> sets EPIS030 as an address latch (ALE), EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n. <dl class="section note"><dt>Note</dt><dd>Dual or quad chip select configurations cannot be used with EPI_HB8_MODE_SRAM.</dd></dl>
The parameter <em>ui32MaxWait</em> is used if the FIFO mode is chosen. If a FIFO is used aint32_t with RXFULL or TXEMPTY ready signals, then this parameter determines the maximum number of clocks to wait when the transaction is being held off by by the FIFO using one of these ready signals. A value of 0 means to wait forever.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="epi_8h.html#a2646dcc71e26d1a67d8a9385977f571f">EPI_HB8_CSBAUD</a>, <a class="el" href="epi_8h.html#adcaad25b802e5ff5be31d78494020bb3">EPI_HB8_CSCFG_MASK</a>, <a class="el" href="hw__epi_8h.html#ae2405bc6dcf30c3fd894760eaae87538">EPI_HB8CFG2_CSBAUD</a>, <a class="el" href="hw__epi_8h.html#a33d4bd8b3216d3b7640594224fe49d0a">EPI_HB8CFG_MAXWAIT_M</a>, <a class="el" href="hw__epi_8h.html#a409426476729a4e122c8052fd7b1fc8a">EPI_HB8CFG_MAXWAIT_S</a>, <a class="el" href="hw__epi_8h.html#a8e07c362c8fb4f71625b707f509bfd7f">EPI_O_HB8CFG</a>, <a class="el" href="hw__epi_8h.html#a994c0867fe83905f0ed75203221415a8">EPI_O_HB8CFG2</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga7d612e5b8a15f344097625817a2a415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d612e5b8a15f344097625817a2a415a">&sect;&nbsp;</a></span>EPIConfigHB16Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB16Set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the interface for Host-bus 16 operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is the maximum number of external clocks to wait if a FIFO ready signal is holding off the transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in Host-bus 16 operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p><ul>
<li>Host-bus 16 submode, select one of:<ul>
<li><b>EPI_HB16_MODE_ADMUX</b> sets data and address muxed, AD[15:0].</li>
<li><b>EPI_HB16_MODE_ADDEMUX</b> sets up data and address as separate, D[15:0].</li>
<li><b>EPI_HB16_MODE_SRAM</b> sets as <b>EPI_HB16_MODE_ADDEMUX</b> but uses address switch for multiple reads instead of OEn strobing, D[15:0].</li>
<li><b>EPI_HB16_MODE_FIFO</b> addes XFIFO controls with sense of XFIFO full and XFIFO empty, D[15:0]. This submode uses no address or ALE.</li>
</ul>
</li>
<li><b>EPI_HB16_USE_TXEMPTY</b> enables TXEMPTY signal with FIFO.</li>
<li><b>EPI_HB16_USE_RXFULL</b> enables RXFULL signal with FIFO.</li>
<li><b>EPI_HB16_WRHIGH</b> use active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB16_RDHIGH</b> use active high read strobe, otherwise it is active low.</li>
<li>Write wait state, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_0</b> sets write wait state to 2 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
<li>Read wait state, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_0</b> sets read wait state to 2 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB16_CLOCK_GATE_IDLE</b> holds the EPI clock low when no data is available to read or write.</li>
<li><b>EPI_HB16_CLOCK_INVERT</b> inverts the EPI clock.</li>
<li><b>EPI_HB16_IN_READY_EN</b> sets EPIS032 as a ready/stall signal, active high.</li>
<li><b>EPI_HB16_IN_READY_EN_INVERTED</b> sets EPIS032 as ready/stall signal, active low.</li>
<li>Address latch logic, select one of:<ul>
<li><b>EPI_HB16_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB16_ALE_LOW</b> sets address latch active low.</li>
</ul>
</li>
<li><b>EPI_HB16_BURST_TRAFFIC</b> enables burst traffic. Only valid with <b>EPI_HB16_MODE_ADMUX</b> and a chip select configuration that utilizes an ALE.</li>
<li><b>EPI_HB16_BSEL</b> enables byte selects. In this mode, two EPI signals operate as byte selects allowing 8-bit transfers. If this flag is not specified, data must be read and written using only 16-bit transfers.</li>
<li><b>EPI_HB16_CSBAUD</b> use different baud rates when accessing devices on each chip select. CS0n uses the baud rate specified by the lower 16 bits of the divider passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> and CS1n uses the divider passed in the upper 16 bits. If this option is absent, both chip selects use the baud rate resulting from the divider in the lower 16 bits of the parameter passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a>.</li>
</ul>
<p>If <b>EPI_HB16_CSBAUD</b> is configured, <a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet()</a> should be used to to configure the divider for CS2n and CS3n. They both also use the lower 16 bits passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> if this option is absent.</p>
<p>The use of <b>EPI_HB16_CSBAUD</b> also allows for unique chip select configurations. CS0n, CS1n, CS2n, and CS3n can each be configured by calling <a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet()</a> if <b>EPI_HB16_CSBAUD</b> is used. Otherwise, the configuration provided in <em>ui32Config</em> is used for all chip selects.</p>
<ul>
<li>Chip select configuration, select one of:<ul>
<li><b>EPI_HB16_CSCFG_CS</b> sets EPIS030 to operate as a chip select signal.</li>
<li><b>EPI_HB16_CSCFG_ALE</b> sets EPIS030 to operate as an address latch (ALE).</li>
<li><b>EPI_HB16_CSCFG_DUAL_CS</b> sets EPIS030 to operate as CS0n and EPIS027 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB16_CSCFG_ALE_DUAL_CS</b> sets EPIS030 as an address latch (ALE), EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB16_CSCFG_ALE_SINGLE_CS</b> sets EPIS030 to operate as an address latch (ALE) and EPIS027 is used as a chip select.</li>
<li><b>EPI_HB16_CSCFG_QUAD_CS</b> sets EPIS030 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n.</li>
<li><b>EPI_HB16_CSCFG_ALE_QUAD_CS</b> sets EPIS030 as an address latch (ALE), EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n. <dl class="section note"><dt>Note</dt><dd>Dual or quad chip select configurations cannot be used with EPI_HB16_MODE_SRAM.</dd></dl>
The parameter <em>ui32MaxWait</em> is used if the FIFO mode is chosen. If a FIFO is used along with RXFULL or TXEMPTY ready signals, then this parameter determines the maximum number of clocks to wait when the transaction is being held off by by the FIFO using one of these ready signals. A value of 0 means to wait forever.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="epi_8h.html#a8f7cd9ae5ee9915f5860c4e7e1330328">EPI_HB16_CSBAUD</a>, <a class="el" href="epi_8h.html#abd20b23cde603b9ba132ff7487e11edc">EPI_HB16_CSCFG_MASK</a>, <a class="el" href="hw__epi_8h.html#afd34e71027e0baf18036bdef3d38caee">EPI_HB16CFG2_CSBAUD</a>, <a class="el" href="hw__epi_8h.html#a145f460d460294ab5664032d54b89a89">EPI_HB16CFG_MAXWAIT_M</a>, <a class="el" href="hw__epi_8h.html#ae847c419bb220ebecac6392fb17dd4b6">EPI_HB16CFG_MAXWAIT_S</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a15d6738e007ab347b7bba814df49a580">EPI_O_HB16CFG2</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga0c8d1ad6326357040fa3a8805cfeeb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8d1ad6326357040fa3a8805cfeeb0d">&sect;&nbsp;</a></span>EPIConfigHB8CSSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB8CSSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individual chip select configuration for the Host-bus 8 interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure individual chip select settings for the Host-bus 8 interface mode. <a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set()</a> must have been setup with the <b>EPI_HB8_CSBAUD</b> flag for the individual chip select configuration option to be available.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Host-bus 8 submode, select one of:<ul>
<li><b>EPI_HB8_MODE_ADMUX</b> sets data and address muxed, AD[7:0].</li>
<li><b>EPI_HB8_MODE_ADDEMUX</b> sets up data and address separate, D[7:0].</li>
<li><b>EPI_HB8_MODE_SRAM</b> as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[7:0].</li>
<li><b>EPI_HB8_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[7:0]. This is only available for CS0n and CS1n.</li>
</ul>
</li>
<li><b>EPI_HB8_WRHIGH</b> sets active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB8_RDHIGH</b> sets active high read strobe, otherwise it is active low.</li>
<li>Write wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB8_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB8_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB8_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
<li>Read wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB8_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB8_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB8_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB8_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB8_ALE_LOW</b> sets address latch active low.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a>, <a class="el" href="hw__epi_8h.html#a8e07c362c8fb4f71625b707f509bfd7f">EPI_O_HB8CFG</a>, <a class="el" href="hw__epi_8h.html#a7ddce2750424b23a00b3e85da89c5e29">EPI_O_HB8CFG3</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gae6d88d2589bd63fd23fbfa403dc688a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6d88d2589bd63fd23fbfa403dc688a5">&sect;&nbsp;</a></span>EPIConfigHB16CSSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB16CSSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individual chip select configuration for the Host-bus 16 interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure individual chip select settings for the Host-bus 16 interface mode. <a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set()</a> must have been set up with the <b>EPI_HB16_CSBAUD</b> flag for the individual chip select configuration option to be available.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR the following:</p>
<ul>
<li>Host-bus 16 submode, select one of:<ul>
<li><b>EPI_HB16_MODE_ADMUX</b> sets data and address muxed, AD[15:0].</li>
<li><b>EPI_HB16_MODE_ADDEMUX</b> sets up data and address separate, D[15:0].</li>
<li><b>EPI_HB16_MODE_SRAM</b> same as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[15:0].</li>
<li><b>EPI_HB16_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[15:0]. This feature is only available on CS0n and CS1n.</li>
</ul>
</li>
<li><b>EPI_HB16_WRHIGH</b> sets active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB16_RDHIGH</b> sets active high read strobe, otherwise it is active low.</li>
<li>Write wait state when <b>EPI_HB16_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB16_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
<li>Read wait state when <b>EPI_HB16_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB16_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB16_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB16_ALE_LOW</b> sets address latch active low.</li>
<li><b>EPI_HB16_BURST_TRAFFIC</b> enables burst traffic. Only valid with <b>EPI_HB16_MODE_ADMUX</b> and a chip select configuration that utilizes an ALE.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="group__epi__api.html#ga9dfec815ec7fa028f90a39b1a4d315ca">EPI_HB16_CS_MASK</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga1a2bf596b8c09862989df76bc781c2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2bf596b8c09862989df76bc781c2e3">&sect;&nbsp;</a></span>EPIConfigHB8TimingSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB8TimingSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individual chip select timing settings for the Host-bus 8 interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set individual chip select timings for the Host-bus 8 interface mode.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Input ready stall delay, select one of:<ul>
<li><b>EPI_HB8_IN_READY_DELAY_1</b> sets the stall on input ready (EPIS032) to start 1 EPI clock after signaled.</li>
<li><b>EPI_HB8_IN_READY_DELAY_2</b> sets the stall on input ready (EPIS032) to start 2 EPI clocks after signaled.</li>
<li><b>EPI_HB8_IN_READY_DELAY_3</b> sets the stall on input ready (EPIS032) to start 3 EPI clocks after signaled.</li>
</ul>
</li>
<li>Host bus transfer delay, select one of:<ul>
<li><b>EPI_HB8_CAP_WIDTH_1</b> defines the inter-transfer capture width to create a delay of 1 EPI clock.</li>
<li><b>EPI_HB8_CAP_WIDTH_2</b> defines the inter-transfer capture width to create a delay of 2 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB8_WRWAIT_MINUS_DISABLE</b> disables the additional write wait state reduction.</li>
<li><b>EPI_HB8_WRWAIT_MINUS_ENABLE</b> enables a 1 EPI clock write wait state reduction.</li>
<li><b>EPI_HB8_RDWAIT_MINUS_DISABLE</b> disables the additional read wait state reduction.</li>
<li><b>EPI_HB8_RDWAIT_MINUS_ENABLE</b> enables a 1 EPI clock read wait state reduction.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a8fe4aaaa853881272cd4ca85f8b4f475">EPI_O_HB8TIME</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga404cc115292a3c173d64ed6c38e793f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404cc115292a3c173d64ed6c38e793f3">&sect;&nbsp;</a></span>EPIConfigHB16TimingSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigHB16TimingSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individual chip select timing settings for the Host-bus 16 interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set individual chip select timings for the Host-bus 16 interface mode.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Input ready stall delay, select one of:<ul>
<li><b>EPI_HB16_IN_READY_DELAY_1</b> sets the stall on input ready (EPIS032) to start 1 EPI clock after signaled.</li>
<li><b>EPI_HB16_IN_READY_DELAY_2</b> sets the stall on input ready (EPIS032) to start 2 EPI clocks after signaled.</li>
<li><b>EPI_HB16_IN_READY_DELAY_3</b> sets the stall on input ready (EPIS032) to start 3 EPI clocks after signaled.</li>
</ul>
</li>
<li>PSRAM size limitation, select one of:<ul>
<li><b>EPI_HB16_PSRAM_NO_LIMIT</b> defines no row size limitation.</li>
<li><b>EPI_HB16_PSRAM_128</b> defines the PSRAM row size to 128 bytes.</li>
<li><b>EPI_HB16_PSRAM_256</b> defines the PSRAM row size to 256 bytes.</li>
<li><b>EPI_HB16_PSRAM_512</b> defines the PSRAM row size to 512 bytes.</li>
<li><b>EPI_HB16_PSRAM_1024</b> defines the PSRAM row size to 1024 bytes.</li>
<li><b>EPI_HB16_PSRAM_2048</b> defines the PSRAM row size to 2048 bytes.</li>
<li><b>EPI_HB16_PSRAM_4096</b> defines the PSRAM row size to 4096 bytes.</li>
<li><b>EPI_HB16_PSRAM_8192</b> defines the PSRAM row size to 8192 bytes.</li>
</ul>
</li>
<li>Host bus transfer delay, select one of:<ul>
<li><b>EPI_HB16_CAP_WIDTH_1</b> defines the inter-transfer capture width to create a delay of 1 EPI clock</li>
<li><b>EPI_HB16_CAP_WIDTH_2</b> defines the inter-transfer capture width to create a delay of 2 EPI clocks.</li>
</ul>
</li>
<li>Write wait state timing reduction, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_MINUS_DISABLE</b> disables the additional write wait state reduction.</li>
<li><b>EPI_HB16_WRWAIT_MINUS_ENABLE</b> enables a 1 EPI clock write wait state reduction.</li>
</ul>
</li>
<li>Read wait state timing reduction, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_MINUS_DISABLE</b> disables the additional read wait state reduction.</li>
<li><b>EPI_HB16_RDWAIT_MINUS_ENABLE</b> enables a 1 EPI clock read wait state reduction.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a1084ac391f2ae3e54d2afd9ab5037fb9">EPI_O_HB16TIME</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gabcbbd4afec4caf570bc1dbfdd0169c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcbbd4afec4caf570bc1dbfdd0169c99">&sect;&nbsp;</a></span>EPIPSRAMConfigRegSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIPSRAMConfigRegSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PSRAM configuration register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target. </td></tr>
    <tr><td class="paramname">ui32CR</td><td>is the PSRAM configuration register value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PSRAM's configuration register by using the PSRAM configuration register enable signal. The Host-bus 16 interface mode should be configured prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32CR</em> value is determined by consulting the PSRAM's data sheet.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#abf137f9a17f0640dd8bc7b84c1f6e5e3">EPI_HB16CFG_WRCRE</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga52fb7f5686e6c29a42ded8694ea8accb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52fb7f5686e6c29a42ded8694ea8accb">&sect;&nbsp;</a></span>EPIPSRAMConfigRegRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIPSRAMConfigRegRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests a configuration register read from the PSRAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target.</td></tr>
  </table>
  </dd>
</dl>
<p>This function requests a read of the PSRAM's configuration register. The Host-bus 16 interface mode should be configured prior to calling this function. The <a class="el" href="group__epi__api.html#gac078ff4e388a21abdd0e63aae2d96960">EPIPSRAMConfigRegGet()</a> and <a class="el" href="group__epi__api.html#ga7028e21f0e37f8f79e94855c56ce0d8c">EPIPSRAMConfigRegGetNonBlocking()</a> can be used to retrieve the configuration register value.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3.</p>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga7028e21f0e37f8f79e94855c56ce0d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7028e21f0e37f8f79e94855c56ce0d8c">&sect;&nbsp;</a></span>EPIPSRAMConfigRegGetNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EPIPSRAMConfigRegGetNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32CR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the contents of the EPI PSRAM configuration register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target. </td></tr>
    <tr><td class="paramname">pui32CR</td><td>is the provided storage used to hold the register value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies the contents of the EPI PSRAM configuration register to the provided storage if the PSRAM read configuration register enable is no longer asserted. Otherwise the provided storage is not modified.</p>
<p>The Host-bus 16 interface mode should be set up and <a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead()</a> should be called prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The <em>pui32CR</em> parameter is a pointer to provided storage used to hold the register value.</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the value was copied to the provided storage and <b>false</b> if it was not. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gac078ff4e388a21abdd0e63aae2d96960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac078ff4e388a21abdd0e63aae2d96960">&sect;&nbsp;</a></span>EPIPSRAMConfigRegGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPIPSRAMConfigRegGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the contents of the EPI PSRAM configuration register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves the EPI PSRAM configuration register. The register is read once the EPI PSRAM configuration register read enable signal is de-asserted.</p>
<p>The Host-bus 16 interface mode should be set up and <a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead()</a> should be called prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3.</p>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga9544feee05f3e0342a8092ff87f9bad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9544feee05f3e0342a8092ff87f9bad2">&sect;&nbsp;</a></span>EPIConfigGPModeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIConfigGPModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FrameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the interface for general-purpose mode operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32FrameCount</td><td>is the frame size in clocks, if the frame signal is used (0-15). </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is currently not used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in general-purpose operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li><b>EPI_GPMODE_CLKPIN</b> interface clock as output on a pin.</li>
<li><b>EPI_GPMODE_CLKGATE</b> clock is stopped when there is no transaction, otherwise it is free-running.</li>
<li><b>EPI_GPMODE_FRAME50</b> framing signal is 50/50 duty cycle, otherwise it is a pulse.</li>
<li><b>EPI_GPMODE_WRITE2CYCLE</b> a two-cycle write is used, otherwise a single-cycle write is used.</li>
<li>Address bus size, select one of:<ul>
<li><b>EPI_GPMODE_ASIZE_NONE</b> sets no address bus.</li>
<li><b>EPI_GPMODE_ASIZE_4</b> sets an address bus size of 4 bits.</li>
<li><b>EPI_GPMODE_ASIZE_12</b> sets an address bus size of 12 bits.</li>
<li><b>EPI_GPMODE_ASIZE_20</b> sets an address bus size of 20 bits.</li>
</ul>
</li>
<li>Data bus size, select one of:<ul>
<li><b>EPI_GPMODE_DSIZE_8</b> sets a data bus size of 8 bits.</li>
<li><b>EPI_GPMODE_DSIZE_16</b> sets a data bus size of 16 bits.</li>
<li><b>EPI_GPMODE_DSIZE_24</b> sets a data bus size of 24 bits.</li>
<li><b>EPI_GPMODE_DSIZE_32</b> sets a data bus size of 32 bits.</li>
</ul>
</li>
</ul>
<p>The parameter <em>ui32FrameCount</em> is the number of clocks used to form the framing signal, if the framing signal is used. The behavior depends on whether the frame signal is a pulse or a 50/50 duty cycle.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#ab6c41669f6a6d6a1c3aec3b53e605f62">EPI_GPCFG_FRMCNT_M</a>, <a class="el" href="hw__epi_8h.html#a69cdb65b7c0d9d61a6f6c22c68f12df6">EPI_GPCFG_FRMCNT_S</a>, <a class="el" href="hw__epi_8h.html#a6a75ead6054642f400ec9d11b9011508">EPI_O_GPCFG</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gae781a5be3fc69203242a16f34feae2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae781a5be3fc69203242a16f34feae2cf">&sect;&nbsp;</a></span>EPIAddressMapSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIAddressMapSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the address map for the external interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Map</td><td>is the address mapping configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the address mapping for the external interface, which then determines the base address of the external memory or device within the processor peripheral and/or memory space.</p>
<p>The parameter <em>ui32Map</em> is the logical OR of the following:</p>
<ul>
<li>Peripheral address space size, select one of:<ul>
<li><b>EPI_ADDR_PER_SIZE_256B</b> sets the peripheral address space to 256 bytes.</li>
<li><b>EPI_ADDR_PER_SIZE_64KB</b> sets the peripheral address space to 64 Kbytes.</li>
<li><b>EPI_ADDR_PER_SIZE_16MB</b> sets the peripheral address space to 16 Mbytes.</li>
<li><b>EPI_ADDR_PER_SIZE_256MB</b> sets the peripheral address space to 256 Mbytes.</li>
</ul>
</li>
<li>Peripheral base address, select one of:<ul>
<li><b>EPI_ADDR_PER_BASE_NONE</b> sets the peripheral base address to none.</li>
<li><b>EPI_ADDR_PER_BASE_A</b> sets the peripheral base address to 0xA0000000.</li>
<li><b>EPI_ADDR_PER_BASE_C</b> sets the peripheral base address to 0xC0000000.</li>
</ul>
</li>
<li>RAM address space, select one of:<ul>
<li><b>EPI_ADDR_RAM_SIZE_256B</b> sets the RAM address space to 256 bytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_64KB</b> sets the RAM address space to 64 Kbytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_16MB</b> sets the RAM address space to 16 Mbytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_256MB</b> sets the RAM address space to 256 Mbytes.</li>
</ul>
</li>
<li>RAM base address, select one of:<ul>
<li><b>EPI_ADDR_RAM_BASE_NONE</b> sets the RAM space address to none.</li>
<li><b>EPI_ADDR_RAM_BASE_6</b> sets the RAM space address to 0x60000000.</li>
<li><b>EPI_ADDR_RAM_BASE_8</b> sets the RAM space address to 0x80000000.</li>
</ul>
</li>
<li><b>EPI_ADDR_QUAD_MODE</b> maps CS0n to 0x60000000, CS1n to 0x80000000, CS2n to 0xA0000000, and CS3n to 0xC0000000.</li>
<li><b>EPI_ADDR_CODE_SIZE_256B</b> sets an external code size of 256 bytes, range 0x00 to 0xFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_64KB</b> sets an external code size of 64 Kbytes, range 0x0000 to 0xFFFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_16MB</b> sets an external code size of 16 Mbytes, range 0x000000 to 0xFFFFFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_256MB</b> sets an external code size of 256 Mbytes, range 0x0000000 to 0xFFFFFFF.</li>
<li><b>EPI_ADDR_CODE_BASE_NONE</b> sets external code base to not mapped.</li>
<li><b>EPI_ADDR_CODE_BASE_1</b> sets external code base to 0x10000000.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a6e502121ee45669b1fb6f6c7d4355cf2">EPI_O_ADDRMAP</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga09d3a1b329d16480537f5afbbd54a547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d3a1b329d16480537f5afbbd54a547">&sect;&nbsp;</a></span>EPINonBlockingReadConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPINonBlockingReadConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a non-blocking read transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1). </td></tr>
    <tr><td class="paramname">ui32DataSize</td><td>is the size of the data items to read. </td></tr>
    <tr><td class="paramname">ui32Address</td><td>is the starting address to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure a non-blocking read channel for a transaction. Two channels are available that can be used in a ping-pong method for continuous reading. It is not necessary to use both channels to perform a non-blocking read.</p>
<p>The parameter <em>ui8DataSize</em> is one of <b>EPI_NBCONFIG_SIZE_8</b>, <b>EPI_NBCONFIG_SIZE_16</b>, or <b>EPI_NBCONFIG_SIZE_32</b> for 8-bit, 16-bit, or 32-bit sized data transfers.</p>
<p>The parameter <em>ui32Address</em> is the starting address for the read, relative to the external device. The start of the device is address 0.</p>
<p>Once configured, the non-blocking read is started by calling <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart()</a>. If the addresses to be read from the device are in a sequence, it is not necessary to call this function multiple times. Until it is changed, the EPI module stores the last address that was used for a non-blocking read (per channel).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a36b844ff2593d7da3cfa8edcb534fa81">EPI_O_RADDR0</a>, <a class="el" href="hw__epi_8h.html#aceaa6ba4ce9c8b72d16e789d034e97dc">EPI_O_RSIZE0</a>, <a class="el" href="hw__epi_8h.html#a752d331b65b48399db43d293b81123f6">EPI_O_RSIZE1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gabd38827e4a7a2c21cad1f58e61dd4053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd38827e4a7a2c21cad1f58e61dd4053">&sect;&nbsp;</a></span>EPINonBlockingReadStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPINonBlockingReadStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a non-blocking read transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1). </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of items to read (1-4095).</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts a non-blocking read that was previously configured with the function <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure()</a>. Once this function is called, the EPI module begins reading data from the external device into the read FIFO. The EPI stops reading when the FIFO fills up and resumes reading when the application drains the FIFO, until the total specified count of data items has been read.</p>
<p>Once a read transaction is completed and the FIFO drained, another transaction can be started from the next address by calling this function again.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gaa5fa0e80a591d62a6b84f09f47a71afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5fa0e80a591d62a6b84f09f47a71afa">&sect;&nbsp;</a></span>EPINonBlockingReadStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPINonBlockingReadStop </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops a non-blocking read transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1).</td></tr>
  </table>
  </dd>
</dl>
<p>This function cancels a non-blocking read transaction that is already in progress.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga3decd0254b5104255b9dbe1e02936ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3decd0254b5104255b9dbe1e02936ff6">&sect;&nbsp;</a></span>EPINonBlockingReadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPINonBlockingReadCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the count remaining for a non-blocking transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1).</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the remaining count of items for a non-blocking read transaction.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of items remaining in the non-blocking read transaction. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gaecfc47bee6a379ced21c9ecf984f2888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfc47bee6a379ced21c9ecf984f2888">&sect;&nbsp;</a></span>EPINonBlockingReadAvail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPINonBlockingReadAvail </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the count of items available in the read FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the number of items that are available to read in the read FIFO. The read FIFO is filled by a non-blocking read transaction which is configured by the functions <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure()</a> and <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of items available to read in the read FIFO. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gac8a09fac58328065e92a61fdd31cdcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a09fac58328065e92a61fdd31cdcc0">&sect;&nbsp;</a></span>EPINonBlockingReadGet32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPINonBlockingReadGet32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read available data from the read FIFO, as 32-bit data items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui32Buf</td><td>is the caller supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 32-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of items read from the FIFO. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gaac0645c23368a2e768a27010e714e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac0645c23368a2e768a27010e714e7cf">&sect;&nbsp;</a></span>EPINonBlockingReadGet16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPINonBlockingReadGet16 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read available data from the read FIFO, as 16-bit data items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui16Buf</td><td>is the caller-supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 16-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of items read from the FIFO. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gaf7df76c4aa477ec5f48e682d9a420903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7df76c4aa477ec5f48e682d9a420903">&sect;&nbsp;</a></span>EPINonBlockingReadGet8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPINonBlockingReadGet8 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read available data from the read FIFO, as 8-bit data items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui8Buf</td><td>is the caller-supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 8-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of items read from the FIFO. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga9c11b58182855b534e42cf0357b4db72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c11b58182855b534e42cf0357b4db72">&sect;&nbsp;</a></span>EPIFIFOConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIFIFOConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the read FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the FIFO configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FIFO trigger levels and error generation. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li><b>EPI_FIFO_CONFIG_WTFULLERR</b> enables an error interrupt when a write is attempted and the write FIFO is full</li>
<li><b>EPI_FIFO_CONFIG_RSTALLERR</b> enables an error interrupt when a read is stalled due to an interleaved write or other reason</li>
<li>FIFO TX trigger level, select one of:<ul>
<li><b>EPI_FIFO_CONFIG_TX_EMPTY</b> sets the FIFO TX trigger level to empty.</li>
<li><b>EPI_FIFO_CONFIG_TX_1_4</b> sets the FIFO TX trigger level to 1/4.</li>
<li><b>EPI_FIFO_CONFIG_TX_1_2</b> sets the FIFO TX trigger level to 1/2.</li>
<li><b>EPI_FIFO_CONFIG_TX_3_4</b> sets the FIFO TX trigger level to 3/4.</li>
</ul>
</li>
<li>FIFO RX trigger level, select one of:<ul>
<li><b>EPI_FIFO_CONFIG_RX_1_8</b> sets the FIFO RX trigger level to 1/8.</li>
<li><b>EPI_FIFO_CONFIG_RX_1_4</b> sets the FIFO RX trigger level to 1/4.</li>
<li><b>EPI_FIFO_CONFIG_RX_1_2</b> sets the FIFO RX trigger level to 1/2.</li>
<li><b>EPI_FIFO_CONFIG_RX_3_4</b> sets the FIFO RX trigger level to 3/4.</li>
<li><b>EPI_FIFO_CONFIG_RX_7_8</b> sets the FIFO RX trigger level to 7/8.</li>
<li><b>EPI_FIFO_CONFIG_RX_FULL</b> sets the FIFO RX trigger level to full.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#aaf0bcc8fff757a5543bfd81005dab502">EPI_O_FIFOLVL</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gab9983fa4529a274cd1b09f5a10cbbdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9983fa4529a274cd1b09f5a10cbbdd0">&sect;&nbsp;</a></span>EPIWriteFIFOCountGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPIWriteFIFOCountGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the number of empty slots in the write transaction FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of slots available in the transaction FIFO. It can be used in a polling method to avoid attempting a write that would stall.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of empty slots in the transaction FIFO. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a4d5028cd2b406879600cb46047a9deb0">EPI_O_WFIFOCNT</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga0231d902fde7ee8a0bd73d43cee6d636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0231d902fde7ee8a0bd73d43cee6d636">&sect;&nbsp;</a></span>EPIIntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables EPI interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the specified EPI sources to generate interrupts. The <em>ui32IntFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a6031a185f1291b951d4f358565a13dac">EPI_O_IM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gac477f3e293ed8e771fc05450cd6c28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac477f3e293ed8e771fc05450cd6c28d5">&sect;&nbsp;</a></span>EPIIntDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables EPI interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the specified EPI sources for interrupt generation. The <em>ui32IntFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a6031a185f1291b951d4f358565a13dac">EPI_O_IM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga198a1b608d1cf1565e96ce27d967aea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga198a1b608d1cf1565e96ce27d967aea4">&sect;&nbsp;</a></span>EPIIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPIIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the EPI interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is set <b>true</b> to get the masked interrupt status, or <b>false</b> to get the raw interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the EPI interrupt status. It can return either the raw or masked interrupt status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the masked or raw EPI interrupt status, as a bit field of any of the following values:</dd></dl>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes. </li>
</ul>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a3a1e714eb3024d262f45084d473ecb7f">EPI_O_MIS</a>, <a class="el" href="hw__epi_8h.html#a65abd7f445f99b9887cd3547426cc16e">EPI_O_RIS</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gad6fcb9023d51da8af50f924dd64e9e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6fcb9023d51da8af50f924dd64e9e72">&sect;&nbsp;</a></span>EPIIntErrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EPIIntErrorStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the EPI error interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the error status of the EPI. If the return value of the function <a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus()</a> has the flag <b>EPI_INT_ERR</b> set, then this function can be used to determine the cause of the error.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a bit mask of error flags, which can be the logical OR of any of the following:</dd></dl>
<ul>
<li><b>EPI_INT_ERR_WTFULL</b> occurs when a write stalled when the transaction FIFO was full</li>
<li><b>EPI_INT_ERR_RSTALL</b> occurs when a read stalled</li>
<li><b>EPI_INT_ERR_TIMEOUT</b> occurs when the external clock enable held off a transaction longer than the configured maximum wait time </li>
</ul>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a8289cddbe9fa2e2d2fcd93eb1dac9ff7">EPI_O_EISC</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga14adf0b4a609b3635ef98c2223ada115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14adf0b4a609b3635ef98c2223ada115">&sect;&nbsp;</a></span>EPIIntErrorClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIIntErrorClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ErrFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears pending EPI error sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32ErrFlags</td><td>is a bit mask of the error sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified pending EPI errors. The <em>ui32ErrFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_ERR_DMAWRIC</b> clears the EPI_INT_DMA_TX_DONE as an interrupt source</li>
<li><b>EPI_INT_ERR_DMARDIC</b> clears the EPI_INT_DMA_RX_DONE as an interrupt source</li>
<li><b>EPI_INT_ERR_WTFULL</b> occurs when a write stalled when the transaction FIFO was full</li>
<li><b>EPI_INT_ERR_RSTALL</b> occurs when a read stalled</li>
<li><b>EPI_INT_ERR_TIMEOUT</b> occurs when the external clock enable held off a transaction longer than the configured maximum wait time</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__epi_8h.html#a8289cddbe9fa2e2d2fcd93eb1dac9ff7">EPI_O_EISC</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga4b2d512849c4f92fc15196d62ff30bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b2d512849c4f92fc15196d62ff30bd2">&sect;&nbsp;</a></span>EPIIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIIntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the EPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the interrupt is activated.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets and enables the handler to be called when the EPI module generates an interrupt. Specific EPI interrupts must still be enabled with the <a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable()</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>.</p>

</div>
</div>
<a id="ga9375b854f9a595e2b0b0a712829cf8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9375b854f9a595e2b0b0a712829cf8aa">&sect;&nbsp;</a></span>EPIIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPIIntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a registered interrupt handler for the EPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables and clears the handler to be called when the EPI interrupt occurs.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
