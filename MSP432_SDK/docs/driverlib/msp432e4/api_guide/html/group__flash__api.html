<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Flash_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c07699981eca56d83bc5a7d11e13848"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga7c07699981eca56d83bc5a7d11e13848">FlashErase</a> (uint32_t ui32Address)</td></tr>
<tr class="separator:ga7c07699981eca56d83bc5a7d11e13848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d41b1adc1919998b7c446663af663a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga12d41b1adc1919998b7c446663af663a">FlashProgram</a> (uint32_t *pui32Data, uint32_t ui32Address, uint32_t ui32Count)</td></tr>
<tr class="separator:ga12d41b1adc1919998b7c446663af663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d899fb5ae2c044eeaa025c254375fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69">tFlashProtection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga86d899fb5ae2c044eeaa025c254375fa">FlashProtectGet</a> (uint32_t ui32Address)</td></tr>
<tr class="separator:ga86d899fb5ae2c044eeaa025c254375fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dca804ebcefe3819eb4178efa4ac294"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga3dca804ebcefe3819eb4178efa4ac294">FlashProtectSet</a> (uint32_t ui32Address, <a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69">tFlashProtection</a> eProtect)</td></tr>
<tr class="separator:ga3dca804ebcefe3819eb4178efa4ac294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67df27554b4d45e10cf2ea5ce58bccf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gad67df27554b4d45e10cf2ea5ce58bccf">FlashProtectSave</a> (void)</td></tr>
<tr class="separator:gad67df27554b4d45e10cf2ea5ce58bccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a8e8c1032a58ce2cc79954b26c274e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga78a8e8c1032a58ce2cc79954b26c274e">FlashUserGet</a> (uint32_t *pui32User0, uint32_t *pui32User1)</td></tr>
<tr class="separator:ga78a8e8c1032a58ce2cc79954b26c274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105d8abeae98272161e563f146f13075"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga105d8abeae98272161e563f146f13075">FlashUserSet</a> (uint32_t ui32User0, uint32_t ui32User1)</td></tr>
<tr class="separator:ga105d8abeae98272161e563f146f13075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99be37a55b47302622bfd9387464462"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaa99be37a55b47302622bfd9387464462">FlashAllUserRegisterGet</a> (uint32_t *pui32User0, uint32_t *pui32User1, uint32_t *pui32User2, uint32_t *pui32User3)</td></tr>
<tr class="separator:gaa99be37a55b47302622bfd9387464462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c04ea0fd563e1301f12932de1f91ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga46c04ea0fd563e1301f12932de1f91ea">FlashAllUserRegisterSet</a> (uint32_t ui32User0, uint32_t ui32User1, uint32_t ui32User2, uint32_t ui32User3)</td></tr>
<tr class="separator:ga46c04ea0fd563e1301f12932de1f91ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e168d8745037e9b2554100f433509de"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga8e168d8745037e9b2554100f433509de">FlashUserSave</a> (void)</td></tr>
<tr class="separator:ga8e168d8745037e9b2554100f433509de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada01a33fde506fa892c0426c9aa44c54"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gada01a33fde506fa892c0426c9aa44c54">FlashAllUserRegisterSave</a> (void)</td></tr>
<tr class="separator:gada01a33fde506fa892c0426c9aa44c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9618455a71ab80e02dd0139a30767b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gadc9618455a71ab80e02dd0139a30767b">FlashIntRegister</a> (void(*pfnHandler)(void))</td></tr>
<tr class="separator:gadc9618455a71ab80e02dd0139a30767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeef7616c7db14cc8f1b21de1a777e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gaeeef7616c7db14cc8f1b21de1a777e10">FlashIntUnregister</a> (void)</td></tr>
<tr class="separator:gaeeef7616c7db14cc8f1b21de1a777e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5777e193e6335c845c5dc06813874e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gabe5777e193e6335c845c5dc06813874e">FlashIntEnable</a> (uint32_t ui32IntFlags)</td></tr>
<tr class="separator:gabe5777e193e6335c845c5dc06813874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f4d44ace218739be6d9e94ba7543cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gae6f4d44ace218739be6d9e94ba7543cf">FlashIntDisable</a> (uint32_t ui32IntFlags)</td></tr>
<tr class="separator:gae6f4d44ace218739be6d9e94ba7543cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddc4964bed58c1c14358c5b4e3a5fa4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#gacddc4964bed58c1c14358c5b4e3a5fa4">FlashIntStatus</a> (bool bMasked)</td></tr>
<tr class="separator:gacddc4964bed58c1c14358c5b4e3a5fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dcee673e2dad8d5a8a2bbb4e3553be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__api.html#ga2dcee673e2dad8d5a8a2bbb4e3553be6">FlashIntClear</a> (uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga2dcee673e2dad8d5a8a2bbb4e3553be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="flash_intro"></a>
Introduction</h1>
<p>The flash API provides a set of functions for dealing with the on-chip flash. Functions are provided to program and erase the flash, configure the flash protection, and handle the flash interrupt.</p>
<p>The flash is organized as a set of blocks that can be individually erased. See the device data sheet to determine the size of the flash blocks on an MCU. Erasing a block causes the entire contents of the block to be reset to all ones. The blocks can be marked as read-only or execute-only, providing differing levels of code protection. Read-only blocks cannot be erased or programmed, protecting the contents of those blocks from being modified. Execute-only blocks cannot be erased or programmed, and can only be read by the processor instruction fetch mechanism, protecting the contents of those blocks from being read by either the processor or by debuggers. Refer to the device data sheet to determine the size of flash blocks that can be configured as read-only or execute-only.</p>
<p>The flash can be programmed on a word-by-word basis. Programming causes 1 bits to become 0 bits (where appropriate); because of this, a word can be repeatedly programmed so long as each programming operation only requires changing 1 bits to 0 bits.</p>
<p>The timing for the flash is automatically handled by the flash controller. On some devices, flash timing depends on the PLL frequency that is specified. For these devices, the <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a> function properly configures the flash timing.</p>
<p>The flash controller has the ability to generate an interrupt when an invalid access is attempted (such as reading from execute-only flash). This capability can be used to validate the operation of a program as the interrupt ensures that invalid accesses are not silently ignored, hiding potential bugs. The flash protection can be applied without being permanently enabled, which allows the program to be debugged before the flash protection is permanently applied to the device (which is a non-reversible operation on some devices). An interrupt can also be generated when an erase or programming operation has completed.</p>
<p>Depending upon the member of the MSP432E4 family used, the amount of available flash is 8 KB, 16 KB, 32 KB, 64 KB, 96 KB, 128 KB, 256 KB, 512 KB, or 1 MB.</p>
<h1><a class="anchor" id="flash_api_functions"></a>
API Functions</h1>
<p>The flash API is broken into three groups of functions: those that deal with programming the flash, those that deal with flash protection, and those that deal with interrupt handling.</p>
<p>Flash programming is managed with <a class="el" href="group__flash__api.html#ga7c07699981eca56d83bc5a7d11e13848">FlashErase()</a>, <a class="el" href="group__flash__api.html#ga12d41b1adc1919998b7c446663af663a">FlashProgram()</a>, FlashUsecGet(), and FlashUsecSet().</p>
<p>Flash protection is managed with <a class="el" href="group__flash__api.html#ga86d899fb5ae2c044eeaa025c254375fa">FlashProtectGet()</a>, <a class="el" href="group__flash__api.html#ga3dca804ebcefe3819eb4178efa4ac294">FlashProtectSet()</a>, and <a class="el" href="group__flash__api.html#gad67df27554b4d45e10cf2ea5ce58bccf">FlashProtectSave()</a>.</p>
<p>Interrupt handling is managed with <a class="el" href="group__flash__api.html#gadc9618455a71ab80e02dd0139a30767b">FlashIntRegister()</a>, <a class="el" href="group__flash__api.html#gaeeef7616c7db14cc8f1b21de1a777e10">FlashIntUnregister()</a>, <a class="el" href="group__flash__api.html#gabe5777e193e6335c845c5dc06813874e">FlashIntEnable()</a>, <a class="el" href="group__flash__api.html#gae6f4d44ace218739be6d9e94ba7543cf">FlashIntDisable()</a>, FlashIntGetStatus(), and <a class="el" href="group__flash__api.html#ga2dcee673e2dad8d5a8a2bbb4e3553be6">FlashIntClear()</a>.</p>
<h1><a class="anchor" id="flash_example"></a>
Programming Example</h1>
<p>The following example shows how to use the flash API to erase a block of the flash and program a few words on a TM4C123x device.</p>
<div class="fragment"><div class="line">uint32_t pui32Data[2];</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Erase a block of the flash.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__flash__api.html#ga7c07699981eca56d83bc5a7d11e13848">FlashErase</a>(0x800);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Program some data into the newly erased block of the flash.</span></div><div class="line"><span class="comment">//</span></div><div class="line">pui32Data[0] = 0x12345678;</div><div class="line">pui32Data[1] = 0x56789abc;</div><div class="line"><a class="code" href="group__flash__api.html#ga12d41b1adc1919998b7c446663af663a">FlashProgram</a>(pui32Data, 0x800, <span class="keyword">sizeof</span>(pui32Data));</div></div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga7c07699981eca56d83bc5a7d11e13848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c07699981eca56d83bc5a7d11e13848">&sect;&nbsp;</a></span>FlashErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashErase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases a block of flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Address</td><td>is the start address of the flash block to be erased.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a block of the on-chip flash. After erasing, the block is filled with 0xFF bytes. Read-only and execute-only blocks cannot be erased.</p>
<p>The flash block size is 16-KB.</p>
<p>This function does not return until the block has been erased.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an invalid block address was specified or the block is write-protected. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#a7407d0bb0053b539b8144477b446978a">FLASH_ERASE_SIZE</a>, <a class="el" href="hw__flash_8h.html#a452957750decad802205504cd6760b28">FLASH_FCMISC</a>, <a class="el" href="hw__flash_8h.html#ad93ec424487167f9ff9e603c5b7bbea3">FLASH_FCMISC_AMISC</a>, <a class="el" href="hw__flash_8h.html#a5971da07bbccd52896cffe0cf9d00c42">FLASH_FCMISC_ERMISC</a>, <a class="el" href="hw__flash_8h.html#a221dab551cd1c8c2c20b52597d3490ae">FLASH_FCMISC_VOLTMISC</a>, <a class="el" href="hw__flash_8h.html#ac03d9a7d333a980b958c3d0a4ebdb5f2">FLASH_FCRIS</a>, <a class="el" href="hw__flash_8h.html#a09d50b5c6779f705a495c165914d1bd1">FLASH_FCRIS_ARIS</a>, <a class="el" href="hw__flash_8h.html#a0ed8621b4617b19532f18e0e4b63a19f">FLASH_FCRIS_ERRIS</a>, <a class="el" href="hw__flash_8h.html#a5d083252492ed45f95e8d7fc351319ad">FLASH_FCRIS_VOLTRIS</a>, <a class="el" href="hw__flash_8h.html#acec37e62cb88a0d40af83c466d03151f">FLASH_FMA</a>, <a class="el" href="hw__flash_8h.html#a89c6418eced607811aec6c584f004215">FLASH_FMC</a>, <a class="el" href="hw__flash_8h.html#a4467d81c06e58e0058ba9bd7ce9a1fa8">FLASH_FMC_ERASE</a>, <a class="el" href="hw__flash_8h.html#ad459e0bf007541fd064f4a6f85651ede">FLASH_FMC_WRKEY</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga12d41b1adc1919998b7c446663af663a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12d41b1adc1919998b7c446663af663a">&sect;&nbsp;</a></span>FlashProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashProgram </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Programs flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Data</td><td>is a pointer to the data to be programmed. </td></tr>
    <tr><td class="paramname">ui32Address</td><td>is the starting address in flash to be programmed. Must be a multiple of four. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to be programmed. Must be a multiple of four.</td></tr>
  </table>
  </dd>
</dl>
<p>This function programs a sequence of words into the on-chip flash. Because the flash is programmed one word at a time, the starting address and byte count must both be multiples of four. It is up to the caller to verify the programmed contents, if such verification is required.</p>
<p>This function does not return until the data has been programmed.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a programming error is encountered. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#a452957750decad802205504cd6760b28">FLASH_FCMISC</a>, <a class="el" href="hw__flash_8h.html#ad93ec424487167f9ff9e603c5b7bbea3">FLASH_FCMISC_AMISC</a>, <a class="el" href="hw__flash_8h.html#add6b9efaed181828f6d85c2f0359895f">FLASH_FCMISC_INVDMISC</a>, <a class="el" href="hw__flash_8h.html#ac3caebbaeb5be18fda4cff44199bf928">FLASH_FCMISC_PROGMISC</a>, <a class="el" href="hw__flash_8h.html#a221dab551cd1c8c2c20b52597d3490ae">FLASH_FCMISC_VOLTMISC</a>, <a class="el" href="hw__flash_8h.html#ac03d9a7d333a980b958c3d0a4ebdb5f2">FLASH_FCRIS</a>, <a class="el" href="hw__flash_8h.html#a09d50b5c6779f705a495c165914d1bd1">FLASH_FCRIS_ARIS</a>, <a class="el" href="hw__flash_8h.html#aa5ee1b730a711807d68624ceeb0cfd9d">FLASH_FCRIS_INVDRIS</a>, <a class="el" href="hw__flash_8h.html#ad40d08bc39c563b2a51a41379d760dcc">FLASH_FCRIS_PROGRIS</a>, <a class="el" href="hw__flash_8h.html#a5d083252492ed45f95e8d7fc351319ad">FLASH_FCRIS_VOLTRIS</a>, <a class="el" href="hw__flash_8h.html#acec37e62cb88a0d40af83c466d03151f">FLASH_FMA</a>, <a class="el" href="hw__flash_8h.html#ae67ab1d1ac27281f9572824f025f84d8">FLASH_FMC2</a>, <a class="el" href="hw__flash_8h.html#a3420da5261a77ac75ff954616425cc25">FLASH_FMC2_WRBUF</a>, <a class="el" href="hw__flash_8h.html#afe36cd218f8480b756c69aafb3902aba">FLASH_FMC2_WRKEY</a>, <a class="el" href="hw__flash_8h.html#a9aa76192495a3123083fb9484ed21060">FLASH_FWBN</a>, <a class="el" href="hw__flash_8h.html#a44d47ae7430f7d86209ea2af145dc8bd">FLASH_FWBVAL</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga86d899fb5ae2c044eeaa025c254375fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d899fb5ae2c044eeaa025c254375fa">&sect;&nbsp;</a></span>FlashProtectGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69">tFlashProtection</a> FlashProtectGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the protection setting for a block of flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Address</td><td>is the start address of the flash block to be queried.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the current protection for the specified block of flash. A block can be read/write, read-only, or execute-only. Read/write blocks can be read, executed, erased, and programmed. Read-only blocks can be read and executed. Execute-only blocks can only be executed; processor and debugger data reads are not allowed.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the protection setting for this block. See <a class="el" href="group__flash__api.html#ga3dca804ebcefe3819eb4178efa4ac294">FlashProtectSet()</a> for possible values. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#a178f3c3c39141eafece59ee5e74dae51">FLASH_PROTECT_SIZE</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga3dca804ebcefe3819eb4178efa4ac294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dca804ebcefe3819eb4178efa4ac294">&sect;&nbsp;</a></span>FlashProtectSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashProtectSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69">tFlashProtection</a>&#160;</td>
          <td class="paramname"><em>eProtect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the protection setting for a block of flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Address</td><td>is the start address of the flash block to be protected. </td></tr>
    <tr><td class="paramname">eProtect</td><td>is the protection to be applied to the block. Can be one of <b>FlashReadWrite</b>, <b>FlashReadOnly</b>, or <b>FlashExecuteOnly</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the protection for the specified block of flash. Blocks that are read/write can be made read-only or execute-only. Blocks that are read-only can be made execute-only. Blocks that are execute-only cannot have their protection modified. Attempts to make the block protection less stringent (that is, read-only to read/write) result in a failure (and are prevented by the hardware).</p>
<p>Changes to the flash protection are maintained only until the next reset. This protocol allows the application to be executed in the desired flash protection environment to check for inappropriate flash access (via the flash interrupt). To make the flash protection permanent, use the <a class="el" href="group__flash__api.html#gad67df27554b4d45e10cf2ea5ce58bccf">FlashProtectSave()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an invalid address or an invalid protection was specified. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#a178f3c3c39141eafece59ee5e74dae51">FLASH_PROTECT_SIZE</a>, <a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69a89688aa46f7fbe896237cd1ae93378d6">FlashExecuteOnly</a>, <a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69ad97d8551ef6a697d415040f23547f879">FlashReadOnly</a>, <a class="el" href="flash_8h.html#adc37523740e95a78e9c797cef3913d69a5bf698d8f7f06bc2fba40bedee6267ac">FlashReadWrite</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gad67df27554b4d45e10cf2ea5ce58bccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67df27554b4d45e10cf2ea5ce58bccf">&sect;&nbsp;</a></span>FlashProtectSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashProtectSave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the flash protection settings.</p>
<p>This function makes the currently programmed flash protection settings permanent. This operation is non-reversible; a chip reset or power cycle does not change the flash protection.</p>
<p>This function does not return until the protection has been saved.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#acec37e62cb88a0d40af83c466d03151f">FLASH_FMA</a>, <a class="el" href="hw__flash_8h.html#a89c6418eced607811aec6c584f004215">FLASH_FMC</a>, <a class="el" href="hw__flash_8h.html#a9c7c67a4856820820fe1843e2507774f">FLASH_FMC_COMT</a>, <a class="el" href="hw__flash_8h.html#ad459e0bf007541fd064f4a6f85651ede">FLASH_FMC_WRKEY</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga78a8e8c1032a58ce2cc79954b26c274e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a8e8c1032a58ce2cc79954b26c274e">&sect;&nbsp;</a></span>FlashUserGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashUserGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the user registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32User0</td><td>is a pointer to the location to store USER Register 0. </td></tr>
    <tr><td class="paramname">pui32User1</td><td>is a pointer to the location to store USER Register 1.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the contents of user registers 0 and 1, and stores them in the specified locations.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#afe6509e88317f4227d1d42bf84cadbe0">FLASH_USERREG0</a>, <a class="el" href="hw__flash_8h.html#a68cc8da960af2919e813794ea5121073">FLASH_USERREG1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga105d8abeae98272161e563f146f13075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga105d8abeae98272161e563f146f13075">&sect;&nbsp;</a></span>FlashUserSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashUserSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32User0</td><td>is the value to store in USER Register 0. </td></tr>
    <tr><td class="paramname">ui32User1</td><td>is the value to store in USER Register 1.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the contents of the user registers 0 and 1 to the specified values.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#afe6509e88317f4227d1d42bf84cadbe0">FLASH_USERREG0</a>, <a class="el" href="hw__flash_8h.html#a68cc8da960af2919e813794ea5121073">FLASH_USERREG1</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gaa99be37a55b47302622bfd9387464462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa99be37a55b47302622bfd9387464462">&sect;&nbsp;</a></span>FlashAllUserRegisterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashAllUserRegisterGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32User3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all the user registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32User0</td><td>is a pointer to the location to store USER Register 0. </td></tr>
    <tr><td class="paramname">pui32User1</td><td>is a pointer to the location to store USER Register 1. </td></tr>
    <tr><td class="paramname">pui32User2</td><td>is a pointer to the location to store USER Register 2. </td></tr>
    <tr><td class="paramname">pui32User3</td><td>is a pointer to the location to store USER Register 3.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the contents of user registers 0, 1, 2 and 3, and stores them in the specified locations.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__flash_8h.html#afe6509e88317f4227d1d42bf84cadbe0">FLASH_USERREG0</a>, <a class="el" href="hw__flash_8h.html#a68cc8da960af2919e813794ea5121073">FLASH_USERREG1</a>, <a class="el" href="hw__flash_8h.html#af227a70a99447a59e209dbdc424c41c9">FLASH_USERREG2</a>, <a class="el" href="hw__flash_8h.html#a05dd536e259e8a91c42b06ef7d6cb6ef">FLASH_USERREG3</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga46c04ea0fd563e1301f12932de1f91ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c04ea0fd563e1301f12932de1f91ea">&sect;&nbsp;</a></span>FlashAllUserRegisterSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashAllUserRegisterSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32User3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user registers 0 to 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32User0</td><td>is the value to store in USER Register 0. </td></tr>
    <tr><td class="paramname">ui32User1</td><td>is the value to store in USER Register 1. </td></tr>
    <tr><td class="paramname">ui32User2</td><td>is the value to store in USER Register 2. </td></tr>
    <tr><td class="paramname">ui32User3</td><td>is the value to store in USER Register 3.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the contents of the user registers 0, 1, 2 and 3 to the specified values.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#afe6509e88317f4227d1d42bf84cadbe0">FLASH_USERREG0</a>, <a class="el" href="hw__flash_8h.html#a68cc8da960af2919e813794ea5121073">FLASH_USERREG1</a>, <a class="el" href="hw__flash_8h.html#af227a70a99447a59e209dbdc424c41c9">FLASH_USERREG2</a>, <a class="el" href="hw__flash_8h.html#a05dd536e259e8a91c42b06ef7d6cb6ef">FLASH_USERREG3</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga8e168d8745037e9b2554100f433509de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e168d8745037e9b2554100f433509de">&sect;&nbsp;</a></span>FlashUserSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashUserSave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the user registers 0 and 1.</p>
<p>This function makes the currently programmed user register 0 and 1 settings permanent. This operation is non-reversible; a chip reset or power cycle does not change the flash protection.</p>
<p>This function does not return until the protection has been saved.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#acec37e62cb88a0d40af83c466d03151f">FLASH_FMA</a>, <a class="el" href="hw__flash_8h.html#a89c6418eced607811aec6c584f004215">FLASH_FMC</a>, <a class="el" href="hw__flash_8h.html#a9c7c67a4856820820fe1843e2507774f">FLASH_FMC_COMT</a>, <a class="el" href="hw__flash_8h.html#ad459e0bf007541fd064f4a6f85651ede">FLASH_FMC_WRKEY</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gada01a33fde506fa892c0426c9aa44c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada01a33fde506fa892c0426c9aa44c54">&sect;&nbsp;</a></span>FlashAllUserRegisterSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FlashAllUserRegisterSave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the user registers.</p>
<p>This function makes the currently programmed user register 0, 1, 2 and 3 settings permanent. This operation is non-reversible; a chip reset or power cycle does not change the flash protection.</p>
<p>This function does not return until the protection has been saved.</p>
<dl class="section note"><dt>Note</dt><dd>To ensure data integrity of the user registers, the commits should not be interrupted with a power loss.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if a hardware error is encountered. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#acec37e62cb88a0d40af83c466d03151f">FLASH_FMA</a>, <a class="el" href="hw__flash_8h.html#a89c6418eced607811aec6c584f004215">FLASH_FMC</a>, <a class="el" href="hw__flash_8h.html#a9c7c67a4856820820fe1843e2507774f">FLASH_FMC_COMT</a>, <a class="el" href="hw__flash_8h.html#ad459e0bf007541fd064f4a6f85651ede">FLASH_FMC_WRKEY</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gadc9618455a71ab80e02dd0139a30767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9618455a71ab80e02dd0139a30767b">&sect;&nbsp;</a></span>FlashIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashIntRegister </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the flash interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the flash interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the handler to be called when the flash interrupt occurs. The flash controller can generate an interrupt when an invalid flash access occurs, such as trying to program or erase a read-only block, or trying to read from an execute-only block. It can also generate an interrupt when a program or erase operation has completed. The interrupt is automatically enabled when the handler is registered.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="interrupt_8h.html#a757c4f6c62c9dc236389ac3a6854eca0">INT_FLASH</a>, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>, and <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>.</p>

</div>
</div>
<a id="gaeeef7616c7db14cc8f1b21de1a777e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeef7616c7db14cc8f1b21de1a777e10">&sect;&nbsp;</a></span>FlashIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashIntUnregister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the flash interrupt.</p>
<p>This function clears the handler to be called when the flash interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler is no longer called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="interrupt_8h.html#a757c4f6c62c9dc236389ac3a6854eca0">INT_FLASH</a>, <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>, and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>

</div>
</div>
<a id="gabe5777e193e6335c845c5dc06813874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe5777e193e6335c845c5dc06813874e">&sect;&nbsp;</a></span>FlashIntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual flash controller interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be enabled. The ui32IntFlags parameter can be the logical OR of any of the following values:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>FLASH_INT_ACCESS</b> occurs when a program or erase action was attempted on a block of flash that is marked as read-only or execute-only.</li>
<li><b>FLASH_INT_PROGRAM</b> occurs when a programming or erase cycle completes.</li>
<li><b>FLASH_INT_EEPROM</b> occurs when an EEPROM interrupt occurs. The source of the EEPROM interrupt can be determined by reading the EEDONE register.</li>
<li><b>FLASH_INT_VOLTAGE_ERR</b> occurs when the voltage was out of spec during the flash operation and the operation was terminated.</li>
<li><b>FLASH_INT_DATA_ERR</b> occurs when an operation attempts to program a bit that contains a 0 to a 1.</li>
<li><b>FLASH_INT_ERASE_ERR</b> occurs when an erase operation fails.</li>
<li><b>FLASH_INT_PROGRAM_ERR</b> occurs when a program operation fails.</li>
</ul>
<p>This function enables the indicated flash controller interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#ad7637004a1d9ba1cc8d8bb35a8cb1dd6">FLASH_FCIM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gae6f4d44ace218739be6d9e94ba7543cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6f4d44ace218739be6d9e94ba7543cf">&sect;&nbsp;</a></span>FlashIntDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual flash controller interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be disabled. The ui32IntFlags parameter can be the logical OR of any of the following values:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>FLASH_INT_ACCESS</b> occurs when a program or erase action was attempted on a block of flash that is marked as read-only or execute-only.</li>
<li><b>FLASH_INT_PROGRAM</b> occurs when a programming or erase cycle completes.</li>
<li><b>FLASH_INT_EEPROM</b> occurs when an EEPROM interrupt occurs. The source of the EEPROM interrupt can be determined by reading the EEDONE register.</li>
<li><b>FLASH_INT_VOLTAGE_ERR</b> occurs when the voltage was out of spec during the flash operation and the operation was terminated.</li>
<li><b>FLASH_INT_DATA_ERR</b> occurs when an operation attempts to program a bit that contains a 0 to a 1.</li>
<li><b>FLASH_INT_ERASE_ERR</b> occurs when an erase operation fails.</li>
<li><b>FLASH_INT_PROGRAM_ERR</b> occurs when a program operation fails.</li>
</ul>
<p>This function disables the indicated flash controller interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#ad7637004a1d9ba1cc8d8bb35a8cb1dd6">FLASH_FCIM</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gacddc4964bed58c1c14358c5b4e3a5fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddc4964bed58c1c14358c5b4e3a5fa4">&sect;&nbsp;</a></span>FlashIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FlashIntStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is required and true if the masked interrupt status is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the flash controller. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of <b>FLASH_INT_ACCESS</b>, <b>FLASH_INT_PROGRAM</b>, <b>FLASH_INT_EEPROM</b>, FLASH_INT_VOLTAGE_ERR, FLASH_INT_DATA_ERR, FLASH_INT_ERASE_ERR, and FLASH_INT_PROGRAM_ERR. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#a452957750decad802205504cd6760b28">FLASH_FCMISC</a>, <a class="el" href="hw__flash_8h.html#ac03d9a7d333a980b958c3d0a4ebdb5f2">FLASH_FCRIS</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga2dcee673e2dad8d5a8a2bbb4e3553be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dcee673e2dad8d5a8a2bbb4e3553be6">&sect;&nbsp;</a></span>FlashIntClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears flash controller interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32IntFlags</td><td>is the bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified flash controller interrupt sources are cleared, so that they no longer assert. The ui32IntFlags parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>FLASH_INT_ACCESS</b> occurs when a program or erase action was attempted on a block of flash that is marked as read-only or execute-only.</li>
<li><b>FLASH_INT_PROGRAM</b> occurs when a programming or erase cycle completes.</li>
<li><b>FLASH_INT_EEPROM</b> occurs when an EEPROM interrupt occurs. The source of the EEPROM interrupt can be determined by reading the EEDONE register.</li>
<li><b>FLASH_INT_VOLTAGE_ERR</b> occurs when the voltage was out of spec during the flash operation and the operation was terminated.</li>
<li><b>FLASH_INT_DATA_ERR</b> occurs when an operation attempts to program a bit that contains a 0 to a 1.</li>
<li><b>FLASH_INT_ERASE_ERR</b> occurs when an erase operation fails.</li>
<li><b>FLASH_INT_PROGRAM_ERR</b> occurs when a program operation fails.</li>
</ul>
<p>This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#a452957750decad802205504cd6760b28">FLASH_FCMISC</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
