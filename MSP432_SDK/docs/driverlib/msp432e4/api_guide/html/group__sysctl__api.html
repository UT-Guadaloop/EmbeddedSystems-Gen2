<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Sysctl_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sysctl_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac5fbff938556da80415fb3e72a9a408f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac5fbff938556da80415fb3e72a9a408f">FLASH_PP_MAINSS_S</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:gac5fbff938556da80415fb3e72a9a408f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368eb5ebc0c5267aef73cd1caf7d873c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga368eb5ebc0c5267aef73cd1caf7d873c">SysCtlXtalCfgToIndex</a>(a)&#160;&#160;&#160;((a &amp; 0x7c0) &gt;&gt; 6)</td></tr>
<tr class="separator:ga368eb5ebc0c5267aef73cd1caf7d873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2b8dc5aca3e1b9faffeacd6bb92b4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gadb2b8dc5aca3e1b9faffeacd6bb92b4c">MAX_VCO_ENTRIES</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gadb2b8dc5aca3e1b9faffeacd6bb92b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c8da9dcb738f8815705a3c72c25615"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga60c8da9dcb738f8815705a3c72c25615">MAX_XTAL_ENTRIES</a>&#160;&#160;&#160;18</td></tr>
<tr class="separator:ga60c8da9dcb738f8815705a3c72c25615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982496fe979d7ce71dffea3669c6fa79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga982496fe979d7ce71dffea3669c6fa79">PLL_M_TO_REG</a>(mi,  mf)&#160;&#160;&#160;((uint32_t)mi | (uint32_t)(mf &lt;&lt; <a class="el" href="hw__sysctl_8h.html#a74a0cb30677d19f64ab7e3f34b093759">SYSCTL_PLLFREQ0_MFRAC_S</a>))</td></tr>
<tr class="separator:ga982496fe979d7ce71dffea3669c6fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580daaf281b1d0669c00489b538c4b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga580daaf281b1d0669c00489b538c4b9e">PLL_N_TO_REG</a>(n)&#160;&#160;&#160;((uint32_t)(n - 1) &lt;&lt; <a class="el" href="hw__sysctl_8h.html#ab0b5adbda9a48cfb7702d281fbcbd833">SYSCTL_PLLFREQ1_N_S</a>)</td></tr>
<tr class="separator:ga580daaf281b1d0669c00489b538c4b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550468a1446c55ff1a6c328496ebb218"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga550468a1446c55ff1a6c328496ebb218">PLL_Q_TO_REG</a>(q)&#160;&#160;&#160;((uint32_t)(q - 1) &lt;&lt; <a class="el" href="hw__sysctl_8h.html#ace8575577d0a4037333a38f97adb9f7b">SYSCTL_PLLFREQ1_Q_S</a>)</td></tr>
<tr class="separator:ga550468a1446c55ff1a6c328496ebb218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964a824e22039a7b4191aac3a785c26d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga964a824e22039a7b4191aac3a785c26d">SYSCTL_PPBASE</a>&#160;&#160;&#160;0x400fe300</td></tr>
<tr class="separator:ga964a824e22039a7b4191aac3a785c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728149fdb5d71e5ad29f79fa143beeaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga728149fdb5d71e5ad29f79fa143beeaa">SYSCTL_SRBASE</a>&#160;&#160;&#160;0x400fe500</td></tr>
<tr class="separator:ga728149fdb5d71e5ad29f79fa143beeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ebceaf21699c2734ece677f50757bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga06ebceaf21699c2734ece677f50757bb">SYSCTL_RCGCBASE</a>&#160;&#160;&#160;0x400fe600</td></tr>
<tr class="separator:ga06ebceaf21699c2734ece677f50757bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1107dc41d3c5c0ab71df0a55ebbcb3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa1107dc41d3c5c0ab71df0a55ebbcb3a">SYSCTL_SCGCBASE</a>&#160;&#160;&#160;0x400fe700</td></tr>
<tr class="separator:gaa1107dc41d3c5c0ab71df0a55ebbcb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fef5e82d99e1417797cf570cc8574f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga66fef5e82d99e1417797cf570cc8574f">SYSCTL_DCGCBASE</a>&#160;&#160;&#160;0x400fe800</td></tr>
<tr class="separator:ga66fef5e82d99e1417797cf570cc8574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a193fd8d66ec461b8a67e0604d99f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga82a193fd8d66ec461b8a67e0604d99f1">SYSCTL_PCBASE</a>&#160;&#160;&#160;0x400fe900</td></tr>
<tr class="separator:ga82a193fd8d66ec461b8a67e0604d99f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab339add73c43f8b19bfa850e0fc999ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab339add73c43f8b19bfa850e0fc999ec">SYSCTL_PRBASE</a>&#160;&#160;&#160;0x400fea00</td></tr>
<tr class="separator:gab339add73c43f8b19bfa850e0fc999ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae9d9e3eec4d4b8d8c87720c767f4f36f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gae9d9e3eec4d4b8d8c87720c767f4f36f">SysCtlSRAMSizeGet</a> (void)</td></tr>
<tr class="separator:gae9d9e3eec4d4b8d8c87720c767f4f36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2e0ff17f85017c043a3a318806d428"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gadd2e0ff17f85017c043a3a318806d428">SysCtlFlashSizeGet</a> (void)</td></tr>
<tr class="separator:gadd2e0ff17f85017c043a3a318806d428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12b8bc7c66e7ee2f2c49913ea2910e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac12b8bc7c66e7ee2f2c49913ea2910e1">SysCtlFlashSectorSizeGet</a> (void)</td></tr>
<tr class="separator:gac12b8bc7c66e7ee2f2c49913ea2910e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1d6a1177370abf4bdda1bdf49236c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga8b1d6a1177370abf4bdda1bdf49236c6">SysCtlPeripheralPresent</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga8b1d6a1177370abf4bdda1bdf49236c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddf1f06376894c31e5596f562c299ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7ddf1f06376894c31e5596f562c299ac">SysCtlPeripheralReady</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga7ddf1f06376894c31e5596f562c299ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf69aace5f096e92b7908fbe5e7fdc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga0cf69aace5f096e92b7908fbe5e7fdc5">SysCtlPeripheralPowerOn</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga0cf69aace5f096e92b7908fbe5e7fdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c4cbb616f0b37b806914543e2a09b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga18c4cbb616f0b37b806914543e2a09b4">SysCtlPeripheralPowerOff</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga18c4cbb616f0b37b806914543e2a09b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c537abe40caacd5dfa7ffdedefb6b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab8c537abe40caacd5dfa7ffdedefb6b9">SysCtlPeripheralReset</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:gab8c537abe40caacd5dfa7ffdedefb6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fbae61db465e1d861a62785d28e3ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga2fbae61db465e1d861a62785d28e3ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41000fce023961157e6031ac94ff1f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga41000fce023961157e6031ac94ff1f3a">SysCtlPeripheralDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga41000fce023961157e6031ac94ff1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88db79b809decde9d228ee2c3e58a727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga88db79b809decde9d228ee2c3e58a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1131a3d12965af7cdaa02f0649dc237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:gaa1131a3d12965af7cdaa02f0649dc237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad412f63e83618b3085f324778b1fd606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:gad412f63e83618b3085f324778b1fd606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f46fff4f83f6e6771b9839fe58d209a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="separator:ga8f46fff4f83f6e6771b9839fe58d209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad7b6dcec84339f2bbb8663551cc7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating</a> (bool bEnable)</td></tr>
<tr class="separator:ga0ad7b6dcec84339f2bbb8663551cc7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3caf3c0e7eddea266b7dc2fcb121c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaad3caf3c0e7eddea266b7dc2fcb121c4">SysCtlIntRegister</a> (void(*pfnHandler)(void))</td></tr>
<tr class="separator:gaad3caf3c0e7eddea266b7dc2fcb121c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fa0579c653617672244b6a280d9897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga96fa0579c653617672244b6a280d9897">SysCtlIntUnregister</a> (void)</td></tr>
<tr class="separator:ga96fa0579c653617672244b6a280d9897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d75a6ab7e4a0d8fb88d7ef9359b2adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable</a> (uint32_t ui32Ints)</td></tr>
<tr class="separator:ga4d75a6ab7e4a0d8fb88d7ef9359b2adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3131c668931a976c6005d17135693b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaae3131c668931a976c6005d17135693b">SysCtlIntDisable</a> (uint32_t ui32Ints)</td></tr>
<tr class="separator:gaae3131c668931a976c6005d17135693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c94773880c951cdfe70b387626d081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear</a> (uint32_t ui32Ints)</td></tr>
<tr class="separator:gad6c94773880c951cdfe70b387626d081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10bfca29c2ba2a5ad80f8c57192ef7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab10bfca29c2ba2a5ad80f8c57192ef7d">SysCtlIntStatus</a> (bool bMasked)</td></tr>
<tr class="separator:gab10bfca29c2ba2a5ad80f8c57192ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3647a438a01f95e022cbada36e3ef90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gae3647a438a01f95e022cbada36e3ef90">SysCtlLDODeepSleepSet</a> (uint32_t ui32Voltage)</td></tr>
<tr class="separator:gae3647a438a01f95e022cbada36e3ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42bfcfe02f41590d06d6f58f6486357e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga42bfcfe02f41590d06d6f58f6486357e">SysCtlLDODeepSleepGet</a> (void)</td></tr>
<tr class="separator:ga42bfcfe02f41590d06d6f58f6486357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e05e98db611a541c28f2c218952282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab2e05e98db611a541c28f2c218952282">SysCtlSleepPowerSet</a> (uint32_t ui32Config)</td></tr>
<tr class="separator:gab2e05e98db611a541c28f2c218952282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2db971f213bf6250c763840a2b44585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab2db971f213bf6250c763840a2b44585">SysCtlDeepSleepPowerSet</a> (uint32_t ui32Config)</td></tr>
<tr class="separator:gab2db971f213bf6250c763840a2b44585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7eaf3273efa935f7bedfd3760d11b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7e7eaf3273efa935f7bedfd3760d11b8">SysCtlReset</a> (void)</td></tr>
<tr class="separator:ga7e7eaf3273efa935f7bedfd3760d11b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90efcbaddc41095b9567cae626aaeb2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga90efcbaddc41095b9567cae626aaeb2c">SysCtlSleep</a> (void)</td></tr>
<tr class="separator:ga90efcbaddc41095b9567cae626aaeb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54fcca75df0066bd2b2ecdf92c0eda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac54fcca75df0066bd2b2ecdf92c0eda2">SysCtlDeepSleep</a> (void)</td></tr>
<tr class="separator:gac54fcca75df0066bd2b2ecdf92c0eda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afa3bfa9b77ae24b8acdb0147496f5a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga1afa3bfa9b77ae24b8acdb0147496f5a">SysCtlResetCauseGet</a> (void)</td></tr>
<tr class="separator:ga1afa3bfa9b77ae24b8acdb0147496f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9735274e5c9468bb55ecde9ca07bfb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab9735274e5c9468bb55ecde9ca07bfb1">SysCtlResetCauseClear</a> (uint32_t ui32Causes)</td></tr>
<tr class="separator:gab9735274e5c9468bb55ecde9ca07bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ea49a00d023774f052fc53a2ccb953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa5ea49a00d023774f052fc53a2ccb953">SysCtlMOSCConfigSet</a> (uint32_t ui32Config)</td></tr>
<tr class="separator:gaa5ea49a00d023774f052fc53a2ccb953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5bd79f60945f405c34c89005b0eb50d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf5bd79f60945f405c34c89005b0eb50d">SysCtlPIOSCCalibrate</a> (uint32_t ui32Type)</td></tr>
<tr class="separator:gaf5bd79f60945f405c34c89005b0eb50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga109ad31fa3c2d1957454c8e73a8bbae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga109ad31fa3c2d1957454c8e73a8bbae6">SysCtlResetBehaviorSet</a> (uint32_t ui32Behavior)</td></tr>
<tr class="separator:ga109ad31fa3c2d1957454c8e73a8bbae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42211457f456c2c2b68b490acc320177"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga42211457f456c2c2b68b490acc320177">SysCtlResetBehaviorGet</a> (void)</td></tr>
<tr class="separator:ga42211457f456c2c2b68b490acc320177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21032362a556673829fb41e4f057ec5a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet</a> (uint32_t ui32Config, uint32_t ui32SysClock)</td></tr>
<tr class="separator:ga21032362a556673829fb41e4f057ec5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a32f72f5bad65b43795069a68ac2a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac1a32f72f5bad65b43795069a68ac2a6">SysCtlDeepSleepClockConfigSet</a> (uint32_t ui32Div, uint32_t ui32Config)</td></tr>
<tr class="separator:gac1a32f72f5bad65b43795069a68ac2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab556872df7db77f97c62502f99ee30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga5ab556872df7db77f97c62502f99ee30">SysCtlVoltageEventConfig</a> (uint32_t ui32Config)</td></tr>
<tr class="separator:ga5ab556872df7db77f97c62502f99ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477377a31fd24fa238e9235392d69e68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga477377a31fd24fa238e9235392d69e68">SysCtlVoltageEventStatus</a> (void)</td></tr>
<tr class="separator:ga477377a31fd24fa238e9235392d69e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62659875c2673c4f6da90ed38e6e230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf62659875c2673c4f6da90ed38e6e230">SysCtlVoltageEventClear</a> (uint32_t ui32Status)</td></tr>
<tr class="separator:gaf62659875c2673c4f6da90ed38e6e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4d3c5fc6dd5af6dbd8ef55713bf46c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga6e4d3c5fc6dd5af6dbd8ef55713bf46c">SysCtlVCOGet</a> (uint32_t ui32Crystal, uint32_t *pui32VCOFrequency)</td></tr>
<tr class="separator:ga6e4d3c5fc6dd5af6dbd8ef55713bf46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628248ad7d1558ec4f3a4070068422a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga628248ad7d1558ec4f3a4070068422a6">SysCtlNMIStatus</a> (void)</td></tr>
<tr class="separator:ga628248ad7d1558ec4f3a4070068422a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa88f58928e04ae7a3b35355664d4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga1fa88f58928e04ae7a3b35355664d4d9">SysCtlNMIClear</a> (uint32_t ui32Ints)</td></tr>
<tr class="separator:ga1fa88f58928e04ae7a3b35355664d4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d891ebea267f6236f5192b9f09f657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga57d891ebea267f6236f5192b9f09f657">SysCtlClockOutConfig</a> (uint32_t ui32Config, uint32_t ui32Div)</td></tr>
<tr class="separator:ga57d891ebea267f6236f5192b9f09f657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf719a6614c2febdea012870765a7d06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf719a6614c2febdea012870765a7d06c">SysCtlAltClkConfig</a> (uint32_t ui32Config)</td></tr>
<tr class="separator:gaf719a6614c2febdea012870765a7d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="sysctl_intro"></a>
Introduction</h1>
<p>System control determines the overall operation of the device. It controls the clocking of the device, the set of peripherals that are enabled, configuration of the device and its resets, and provides information about the device.</p>
<p>The members of the MSP432E4 family have a varying peripheral set and memory sizes. The device has a set of read-only registers that indicate the size of the memories, the peripherals that are present, and the pins that are present for peripherals that have a varying number of pins. This information can be used to write adaptive software that can run on more than one member of the MSP432E4 family.</p>
<p>The device can be clocked from several sources: an external oscillator, the main oscillator, the internal oscillator, the precision internal oscillator (PIOSC) or the PLL. The PLL can use any of the oscillators as its input. Because the internal oscillator has a very wide error range (+/- 50%), it cannot be used for applications that require specific timing; its real use is for detecting failures of the main oscillator and the PLL, and for applications that strictly respond to external events and do not use time-based peripherals (such as a UART). When using the PLL, the input clock frequency is constrained to specific frequencies that are specified in the device data sheet. When direct clocking with an external oscillator or the main oscillator, the frequency is constrained to between 0 Hz and 50 MHz (depending on the part). The frequency of the internal oscillator varies by device, with voltage, and with temperature. The internal oscillator provides no tuning or frequency measurement mechanism; its frequency is not adjustable.</p>
<p>Almost the entire device operates from a single clock. See the device data sheet for more information on how clocking for the various periphersals is configured.</p>
<p>Three modes of operation are supported by the MSP432E4 family: run mode, sleep mode, and deep-sleep mode. In run mode, the processor is actively executing code. In sleep mode, the clocking of the device is unchanged but the processor no longer executes code (and is no longer clocked). In deep-sleep mode, the clocking of the device may change (depending upon the run mode clock configuration) and the processor no longer executes code (and is no longer clocked). An interrupt returns the device to run mode from one of the sleep modes; the sleep modes are entered upon request from the code.</p>
<p>The device has an internal LDO for generating the core power supply. On some devices, the output voltage of the LDO can be adjusted between 2.25 V and 2.75 V. Depending upon the application, lower voltage may be advantageous for its power savings, or higher voltage may be advantageous for its improved performance. The default setting of 2.5 V is a good compromise between the two, and should not be changed without careful consideration and evaluation.</p>
<p>There are several system events that, when detected, cause system control to reset the device. These events are a power-on, the input voltage dropping too low, an external reset, a software reset request, waking from hibernation, a watchdog timeout, a hardware system service request, and a main oscillator failure. The properties of some of these events can be configured, and the reason for a reset can be determined from system control. Not all of these reset causes are on all devices, see the device data sheet for more details.</p>
<p>Each peripheral in the device can be individually enabled, disabled, or reset. Additionally, the set of peripherals that remain enabled during sleep mode and deep-sleep mode can be configured, allowing custom sleep and deep-sleep modes to be defined. Care must be taken with deep-sleep mode, though, because in this mode, the PLL is no longer used and the system is clocked by the input crystal. Peripherals that depend on a particular input clock rate (such as a UART) require special consideration in deep-sleep mode due to a clock rate change; these peripherals must either be reconfigured upon entry to and exit from deep-sleep mode, or simply not enabled in deep-sleep mode. Some devices provide the option to clock some peripherals with the PIOSC, even while in deep-sleep mode so the peripheral clocking does not have to be reconfigured upon entry and exit.</p>
<p>There are various system events that, when detected, cause system control to generate a processor interrupt. These events are the PLL achieving lock, the internal LDO current limit being exceeded, the internal oscillator failing, the main oscillator failing, the input voltage dropping too low, the internal LDO voltage dropping too low, and the PLL failing. Not all of these interrupts are available on all MSP432E4 devices, see the device data sheet for more details. Each of these interrupts can be individually enabled or disabled, and the sources must be cleared by the interrupt handler when they occur.</p>
<h1><a class="anchor" id="sysctl_api"></a>
API Functions</h1>
<p>The SysCtl API is broken up into eight groups of functions: those that provide device information, those that deal with device clocking, those that provide peripheral control, those that deal with the SysCtl interrupt, those that deal with the LDO, those that deal with sleep modes, those that deal with reset reasons, those that deal with the brown-out reset, and those that deal with clock verification timers.</p>
<p>Information about the device is provided by <a class="el" href="group__sysctl__api.html#gae9d9e3eec4d4b8d8c87720c767f4f36f">SysCtlSRAMSizeGet()</a>, <a class="el" href="group__sysctl__api.html#gadd2e0ff17f85017c043a3a318806d428">SysCtlFlashSizeGet()</a>, and <a class="el" href="group__sysctl__api.html#ga8b1d6a1177370abf4bdda1bdf49236c6">SysCtlPeripheralPresent()</a>.</p>
<p>Clocking of the device is configured with SysCtlClockSet() and SysCtlPWMClockSet(). Information about device clocking is provided by SysCtlClockGet() and SysCtlPWMClockGet().</p>
<p>The clocking of the main processor is configured by calling the SysCtlClockSet() or the <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a> functions depending on part class. The SysCtlClockSet() is called for Blizzard-class devices and the <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a> is called on all other devices. The SysCtlClockGet() function can only be called on Blizzard-class devices and all other devices must use the value returned from the <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a> to determine the operating frequency of the device.</p>
<p>Peripheral enabling and reset are controlled with <a class="el" href="group__sysctl__api.html#gab8c537abe40caacd5dfa7ffdedefb6b9">SysCtlPeripheralReset()</a>, <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>, <a class="el" href="group__sysctl__api.html#ga41000fce023961157e6031ac94ff1f3a">SysCtlPeripheralDisable()</a>, <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a>, <a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable()</a>, <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a>, <a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable()</a>, and <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>.</p>
<p>The system control interrupt is managed with <a class="el" href="group__sysctl__api.html#gaad3caf3c0e7eddea266b7dc2fcb121c4">SysCtlIntRegister()</a>, <a class="el" href="group__sysctl__api.html#ga96fa0579c653617672244b6a280d9897">SysCtlIntUnregister()</a>, <a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable()</a>, <a class="el" href="group__sysctl__api.html#gaae3131c668931a976c6005d17135693b">SysCtlIntDisable()</a>, <a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear()</a>, <a class="el" href="group__sysctl__api.html#gab10bfca29c2ba2a5ad80f8c57192ef7d">SysCtlIntStatus()</a>.</p>
<p>The LDO is controlled with SysCtlLDOSet() and SysCtlLDOConfigSet(). Its status is provided by SysCtlLDOGet().</p>
<p>The device is put into sleep modes with <a class="el" href="group__sysctl__api.html#ga90efcbaddc41095b9567cae626aaeb2c">SysCtlSleep()</a> and <a class="el" href="group__sysctl__api.html#gac54fcca75df0066bd2b2ecdf92c0eda2">SysCtlDeepSleep()</a>.</p>
<p>The reset reason is managed with <a class="el" href="group__sysctl__api.html#ga1afa3bfa9b77ae24b8acdb0147496f5a">SysCtlResetCauseGet()</a> and <a class="el" href="group__sysctl__api.html#gab9735274e5c9468bb55ecde9ca07bfb1">SysCtlResetCauseClear()</a>. A software reset is performed with <a class="el" href="group__sysctl__api.html#ga7e7eaf3273efa935f7bedfd3760d11b8">SysCtlReset()</a>.</p>
<p>The brown-out reset is configured with <a class="el" href="sysctl_8h.html#aeb74907ed3fa6dee7ece46f69fbba9e5">SysCtlBrownOutConfigSet()</a>.</p>
<p>The clock verification timers are managed with SysCtlIOSCVerificationSet(), SysCtlMOSCVerificationSet(), SysCtlPLLVerificationSet(), and SysCtlClkVerificationClear().</p>
<h1><a class="anchor" id="sysctl_example"></a>
Programming Example</h1>
<p>The following example shows how to use the SysCtl API to configure the device for normal operation on a TM4C123x device.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Configure the device to run at 20 MHz from the PLL using a 4 MHz crystal</span></div><div class="line"><span class="comment">// as the input.</span></div><div class="line"><span class="comment">//</span></div><div class="line">SysCtlClockSet(SYSCTL_SYSDIV_10 | <a class="code" href="sysctl_8h.html#a403d221759494417f175f6b78730cfcf">SYSCTL_USE_PLL</a> | SYSCTL_XTAL_4MHZ |</div><div class="line">               <a class="code" href="sysctl_8h.html#a8c78f8e9ba8e9829e93824ec5dc90cc9">SYSCTL_OSC_MAIN</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable the GPIO blocks and the SSI.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a>(<a class="code" href="sysctl_8h.html#aea621e9fcb42501468c5d42aa08972c8">SYSCTL_PERIPH_GPIOA</a>);</div><div class="line"><a class="code" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a>(<a class="code" href="sysctl_8h.html#aacde21f07d16b073bf84d6b7eac72af7">SYSCTL_PERIPH_GPIOB</a>);</div><div class="line"><a class="code" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a>(SYSCTL_PERIPH_SSI);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable the GPIO blocks and the SSI in sleep mode.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable</a>(<a class="code" href="sysctl_8h.html#aea621e9fcb42501468c5d42aa08972c8">SYSCTL_PERIPH_GPIOA</a>);</div><div class="line"><a class="code" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable</a>(<a class="code" href="sysctl_8h.html#aacde21f07d16b073bf84d6b7eac72af7">SYSCTL_PERIPH_GPIOB</a>);</div><div class="line"><a class="code" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable</a>(SYSCTL_PERIPH_SSI);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable peripheral clock gating.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating</a>(<span class="keyword">true</span>);</div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac5fbff938556da80415fb3e72a9a408f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5fbff938556da80415fb3e72a9a408f">&sect;&nbsp;</a></span>FLASH_PP_MAINSS_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_PP_MAINSS_S&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#gac12b8bc7c66e7ee2f2c49913ea2910e1">SysCtlFlashSectorSizeGet()</a>.</p>

</div>
</div>
<a id="ga368eb5ebc0c5267aef73cd1caf7d873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga368eb5ebc0c5267aef73cd1caf7d873c">&sect;&nbsp;</a></span>SysCtlXtalCfgToIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SysCtlXtalCfgToIndex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;((a &amp; 0x7c0) &gt;&gt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a>, and <a class="el" href="group__sysctl__api.html#ga6e4d3c5fc6dd5af6dbd8ef55713bf46c">SysCtlVCOGet()</a>.</p>

</div>
</div>
<a id="gadb2b8dc5aca3e1b9faffeacd6bb92b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2b8dc5aca3e1b9faffeacd6bb92b4c">&sect;&nbsp;</a></span>MAX_VCO_ENTRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_VCO_ENTRIES&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga60c8da9dcb738f8815705a3c72c25615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60c8da9dcb738f8815705a3c72c25615">&sect;&nbsp;</a></span>MAX_XTAL_ENTRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_XTAL_ENTRIES&#160;&#160;&#160;18</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga982496fe979d7ce71dffea3669c6fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982496fe979d7ce71dffea3669c6fa79">&sect;&nbsp;</a></span>PLL_M_TO_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLL_M_TO_REG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mf&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((uint32_t)mi | (uint32_t)(mf &lt;&lt; <a class="el" href="hw__sysctl_8h.html#a74a0cb30677d19f64ab7e3f34b093759">SYSCTL_PLLFREQ0_MFRAC_S</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga580daaf281b1d0669c00489b538c4b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga580daaf281b1d0669c00489b538c4b9e">&sect;&nbsp;</a></span>PLL_N_TO_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLL_N_TO_REG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;((uint32_t)(n - 1) &lt;&lt; <a class="el" href="hw__sysctl_8h.html#ab0b5adbda9a48cfb7702d281fbcbd833">SYSCTL_PLLFREQ1_N_S</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga550468a1446c55ff1a6c328496ebb218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550468a1446c55ff1a6c328496ebb218">&sect;&nbsp;</a></span>PLL_Q_TO_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLL_Q_TO_REG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">q</td><td>)</td>
          <td>&#160;&#160;&#160;((uint32_t)(q - 1) &lt;&lt; <a class="el" href="hw__sysctl_8h.html#ace8575577d0a4037333a38f97adb9f7b">SYSCTL_PLLFREQ1_Q_S</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga964a824e22039a7b4191aac3a785c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964a824e22039a7b4191aac3a785c26d">&sect;&nbsp;</a></span>SYSCTL_PPBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_PPBASE&#160;&#160;&#160;0x400fe300</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga8b1d6a1177370abf4bdda1bdf49236c6">SysCtlPeripheralPresent()</a>.</p>

</div>
</div>
<a id="ga728149fdb5d71e5ad29f79fa143beeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728149fdb5d71e5ad29f79fa143beeaa">&sect;&nbsp;</a></span>SYSCTL_SRBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_SRBASE&#160;&#160;&#160;0x400fe500</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#gab8c537abe40caacd5dfa7ffdedefb6b9">SysCtlPeripheralReset()</a>.</p>

</div>
</div>
<a id="ga06ebceaf21699c2734ece677f50757bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06ebceaf21699c2734ece677f50757bb">&sect;&nbsp;</a></span>SYSCTL_RCGCBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_RCGCBASE&#160;&#160;&#160;0x400fe600</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga41000fce023961157e6031ac94ff1f3a">SysCtlPeripheralDisable()</a>, and <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>.</p>

</div>
</div>
<a id="gaa1107dc41d3c5c0ab71df0a55ebbcb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1107dc41d3c5c0ab71df0a55ebbcb3a">&sect;&nbsp;</a></span>SYSCTL_SCGCBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_SCGCBASE&#160;&#160;&#160;0x400fe700</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable()</a>, and <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a>.</p>

</div>
</div>
<a id="ga66fef5e82d99e1417797cf570cc8574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66fef5e82d99e1417797cf570cc8574f">&sect;&nbsp;</a></span>SYSCTL_DCGCBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_DCGCBASE&#160;&#160;&#160;0x400fe800</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable()</a>, and <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a>.</p>

</div>
</div>
<a id="ga82a193fd8d66ec461b8a67e0604d99f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82a193fd8d66ec461b8a67e0604d99f1">&sect;&nbsp;</a></span>SYSCTL_PCBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_PCBASE&#160;&#160;&#160;0x400fe900</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga18c4cbb616f0b37b806914543e2a09b4">SysCtlPeripheralPowerOff()</a>, and <a class="el" href="group__sysctl__api.html#ga0cf69aace5f096e92b7908fbe5e7fdc5">SysCtlPeripheralPowerOn()</a>.</p>

</div>
</div>
<a id="gab339add73c43f8b19bfa850e0fc999ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab339add73c43f8b19bfa850e0fc999ec">&sect;&nbsp;</a></span>SYSCTL_PRBASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCTL_PRBASE&#160;&#160;&#160;0x400fea00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__sysctl__api.html#ga7ddf1f06376894c31e5596f562c299ac">SysCtlPeripheralReady()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae9d9e3eec4d4b8d8c87720c767f4f36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9d9e3eec4d4b8d8c87720c767f4f36f">&sect;&nbsp;</a></span>SysCtlSRAMSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlSRAMSizeGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the SRAM.</p>
<p>This function determines the size of the SRAM on the device.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of SRAM. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#aa2a71cbfefd2c08f483f0bedaeb5365c">FLASH_SSIZE</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gadd2e0ff17f85017c043a3a318806d428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd2e0ff17f85017c043a3a318806d428">&sect;&nbsp;</a></span>SysCtlFlashSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlFlashSizeGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the flash.</p>
<p>This function determines the size of the flash on the device.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of flash. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#a660a7d823e7ceddfbb1ba354423e597e">FLASH_PP</a>, <a class="el" href="hw__flash_8h.html#a6cd314491cb6935247613deeab3fbc4b">FLASH_PP_SIZE_M</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="gac12b8bc7c66e7ee2f2c49913ea2910e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12b8bc7c66e7ee2f2c49913ea2910e1">&sect;&nbsp;</a></span>SysCtlFlashSectorSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlFlashSectorSizeGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of a single eraseable sector of flash.</p>
<p>This function determines the flash sector size on the device. This size determines the erase granularity of the device flash.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in a single flash sector. </dd></dl>

<p>References <a class="el" href="hw__flash_8h.html#a660a7d823e7ceddfbb1ba354423e597e">FLASH_PP</a>, <a class="el" href="hw__flash_8h.html#a76bf6e9e2dafb46042e459fd4306a2ee">FLASH_PP_MAINSS_M</a>, <a class="el" href="group__sysctl__api.html#gac5fbff938556da80415fb3e72a9a408f">FLASH_PP_MAINSS_S</a>, and <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a id="ga8b1d6a1177370abf4bdda1bdf49236c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1d6a1177370abf4bdda1bdf49236c6">&sect;&nbsp;</a></span>SysCtlPeripheralPresent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SysCtlPeripheralPresent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is present in the device.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the specified peripheral is present and <b>false</b> if it is not. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga964a824e22039a7b4191aac3a785c26d">SYSCTL_PPBASE</a>.</p>

</div>
</div>
<a id="ga7ddf1f06376894c31e5596f562c299ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ddf1f06376894c31e5596f562c299ac">&sect;&nbsp;</a></span>SysCtlPeripheralReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SysCtlPeripheralReady </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is ready to be accessed. The peripheral may be in a non-ready state if it is not enabled, is being held in reset, or is in the process of becoming ready after being enabled or taken out of reset.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the specified peripheral is ready and <b>false</b> if it is not. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#gab339add73c43f8b19bfa850e0fc999ec">SYSCTL_PRBASE</a>.</p>

<p>Referenced by <a class="el" href="group__emac__api.html#ga6f369bdbe2e8ea108ef1398242030198">EMACPHYConfigSet()</a>.</p>

</div>
</div>
<a id="ga0cf69aace5f096e92b7908fbe5e7fdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf69aace5f096e92b7908fbe5e7fdc5">&sect;&nbsp;</a></span>SysCtlPeripheralPowerOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers on a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to be powered on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function turns on the power to a peripheral. The peripheral continues to receive power even when its clock is not enabled.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_CAN0</b>,<b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_USB0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga82a193fd8d66ec461b8a67e0604d99f1">SYSCTL_PCBASE</a>.</p>

</div>
</div>
<a id="ga18c4cbb616f0b37b806914543e2a09b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c4cbb616f0b37b806914543e2a09b4">&sect;&nbsp;</a></span>SysCtlPeripheralPowerOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOff </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers off a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to be powered off.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the power to a peripheral to be turned off. The peripheral continues to receive power when its clock is enabled, but the power is removed when its clock is disabled.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_CAN0</b>,<b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_USB0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga82a193fd8d66ec461b8a67e0604d99f1">SYSCTL_PCBASE</a>.</p>

</div>
</div>
<a id="gab8c537abe40caacd5dfa7ffdedefb6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8c537abe40caacd5dfa7ffdedefb6b9">&sect;&nbsp;</a></span>SysCtlPeripheralReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a software reset of a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a software reset of the specified peripheral. An individual peripheral reset signal is asserted for a brief period and then de-asserted, returning the internal state of the peripheral to its reset condition.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga728149fdb5d71e5ad29f79fa143beeaa">SYSCTL_SRBASE</a>.</p>

<p>Referenced by <a class="el" href="group__emac__api.html#ga6f369bdbe2e8ea108ef1398242030198">EMACPHYConfigSet()</a>.</p>

</div>
</div>
<a id="ga2fbae61db465e1d861a62785d28e3ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fbae61db465e1d861a62785d28e3ad6">&sect;&nbsp;</a></span>SysCtlPeripheralEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables a peripheral. At power-up, all peripherals are disabled; they must be enabled in order to operate or respond to register reads/writes.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section note"><dt>Note</dt><dd>It takes five clock cycles after the write to enable a peripheral before the the peripheral is actually enabled. During this time, attempts to access the peripheral result in a bus fault. Care should be taken to ensure that the peripheral is not accessed during this brief time period.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga06ebceaf21699c2734ece677f50757bb">SYSCTL_RCGCBASE</a>.</p>

</div>
</div>
<a id="ga41000fce023961157e6031ac94ff1f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41000fce023961157e6031ac94ff1f3a">&sect;&nbsp;</a></span>SysCtlPeripheralDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables a peripheral. Once disabled, they do not operate or respond to register reads/writes.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga06ebceaf21699c2734ece677f50757bb">SYSCTL_RCGCBASE</a>.</p>

</div>
</div>
<a id="ga88db79b809decde9d228ee2c3e58a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88db79b809decde9d228ee2c3e58a727">&sect;&nbsp;</a></span>SysCtlPeripheralSleepEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into sleep mode. Because the clocking configuration of the device does not change, any peripheral can safely continue operating while the processor is in sleep mode and can therefore wake the processor from sleep mode.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#gaa1107dc41d3c5c0ab71df0a55ebbcb3a">SYSCTL_SCGCBASE</a>.</p>

</div>
</div>
<a id="gaa1131a3d12965af7cdaa02f0649dc237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1131a3d12965af7cdaa02f0649dc237">&sect;&nbsp;</a></span>SysCtlPeripheralSleepDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into sleep mode. Disabling peripherals while in sleep mode helps to lower the current draw of the device. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves sleep mode, maintaining its entire state from before sleep mode was entered.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#gaa1107dc41d3c5c0ab71df0a55ebbcb3a">SYSCTL_SCGCBASE</a>.</p>

</div>
</div>
<a id="gad412f63e83618b3085f324778b1fd606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad412f63e83618b3085f324778b1fd606">&sect;&nbsp;</a></span>SysCtlPeripheralDeepSleepEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into deep-sleep mode. Because the clocking configuration of the device may change, not all peripherals can safely continue operating while the processor is in deep-sleep mode. Those that must run at a particular frequency (such as a UART) do not work as expected if the clock changes. It is the responsibility of the caller to make sensible choices.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga66fef5e82d99e1417797cf570cc8574f">SYSCTL_DCGCBASE</a>.</p>

</div>
</div>
<a id="ga8f46fff4f83f6e6771b9839fe58d209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f46fff4f83f6e6771b9839fe58d209a">&sect;&nbsp;</a></span>SysCtlPeripheralDeepSleepDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into deep-sleep mode. Disabling peripherals while in deep-sleep mode helps to lower the current draw of the device, and can keep peripherals that require a particular clock frequency from operating when the clock changes as a result of entering deep-sleep mode. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves deep-sleep mode, maintaining its entire state from before deep-sleep mode was entered.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CCM0</b>,<b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EMAC</b>, <b>SYSCTL_PERIPH_EPHY</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_GPIOR</b>, <b>SYSCTL_PERIPH_GPIOS</b>, <b>SYSCTL_PERIPH_GPIOT</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2C6</b>, <b>SYSCTL_PERIPH_I2C7</b>, <b>SYSCTL_PERIPH_I2C8</b>, <b>SYSCTL_PERIPH_I2C9</b>, <b>SYSCTL_PERIPH_LCD0</b>, <b>SYSCTL_PERIPH_ONEWIRE0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_TIMER6</b>, <b>SYSCTL_PERIPH_TIMER7</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, or <b>SYSCTL_PERIPH_WDOG1</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#afc61bb0c136a7acdb99ebaf93799c7be">HWREGBITW</a>, and <a class="el" href="group__sysctl__api.html#ga66fef5e82d99e1417797cf570cc8574f">SYSCTL_DCGCBASE</a>.</p>

</div>
</div>
<a id="ga0ad7b6dcec84339f2bbb8663551cc7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad7b6dcec84339f2bbb8663551cc7d8">&sect;&nbsp;</a></span>SysCtlPeripheralClockGating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralClockGating </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls peripheral clock gating in sleep and deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the sleep and deep-sleep peripheral configuration should be used and <b>false</b> if not.</td></tr>
  </table>
  </dd>
</dl>
<p>This function controls how peripherals are clocked when the processor goes into sleep or deep-sleep mode. By default, the peripherals are clocked the same as in run mode; if peripheral clock gating is enabled, they are clocked according to the configuration set by <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a>, <a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable()</a>, <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a>, and <a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#a0a46cac92f10630390e04ad38d1400db">SYSCTL_RSCLKCFG</a>, and <a class="el" href="hw__sysctl_8h.html#addd1e308ba0e77bf8bdbac43086bb55a">SYSCTL_RSCLKCFG_ACG</a>.</p>

</div>
</div>
<a id="gaad3caf3c0e7eddea266b7dc2fcb121c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad3caf3c0e7eddea266b7dc2fcb121c4">&sect;&nbsp;</a></span>SysCtlIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntRegister </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the system control interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the system control interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a system control interrupt occurs. This function enables the global interrupt in the interrupt controller; specific system control interrupts must be enabled via <a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear()</a>.</p>
<p>System control can generate interrupts when the PLL achieves lock, if the internal LDO current limit is exceeded, if the internal oscillator fails, if the main oscillator fails, if the internal LDO output voltage droops too much, if the external voltage droops too much, or if the PLL fails.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="interrupt_8h.html#a5092b94a3089191f11d735a5c9219007">INT_SYSCTL</a>, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>, and <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>.</p>

</div>
</div>
<a id="ga96fa0579c653617672244b6a280d9897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96fa0579c653617672244b6a280d9897">&sect;&nbsp;</a></span>SysCtlIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntUnregister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the system control interrupt.</p>
<p>This function unregisters the handler to be called when a system control interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="interrupt_8h.html#a5092b94a3089191f11d735a5c9219007">INT_SYSCTL</a>, <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>, and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>

</div>
</div>
<a id="ga4d75a6ab7e4a0d8fb88d7ef9359b2adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">&sect;&nbsp;</a></span>SysCtlIntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of <b>SYSCTL_INT_BOR0</b>, <b>SYSCTL_INT_VDDA_OK</b>, <b>SYSCTL_INT_MOSC_PUP</b>, <b>SYSCTL_INT_USBPLL_LOCK</b>, <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_BOR1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a846407f0f364f2507891553773c77d19">SYSCTL_IMC</a>.</p>

</div>
</div>
<a id="gaae3131c668931a976c6005d17135693b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae3131c668931a976c6005d17135693b">&sect;&nbsp;</a></span>SysCtlIntDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be disabled. Must be a logical OR of <b>SYSCTL_INT_BOR0</b>, <b>SYSCTL_INT_VDDA_OK</b>, <b>SYSCTL_INT_MOSC_PUP</b>, <b>SYSCTL_INT_USBPLL_LOCK</b>, <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_BOR1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a846407f0f364f2507891553773c77d19">SYSCTL_IMC</a>.</p>

</div>
</div>
<a id="gad6c94773880c951cdfe70b387626d081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c94773880c951cdfe70b387626d081">&sect;&nbsp;</a></span>SysCtlIntClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears system control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of <b>SYSCTL_INT_BOR0</b>, <b>SYSCTL_INT_VDDA_OK</b>, <b>SYSCTL_INT_MOSC_PUP</b>, <b>SYSCTL_INT_USBPLL_LOCK</b>, <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_BOR1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified system control interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately on exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a4f9f87f9381b3da165a82bde242d5e61">SYSCTL_MISC</a>.</p>

</div>
</div>
<a id="gab10bfca29c2ba2a5ad80f8c57192ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10bfca29c2ba2a5ad80f8c57192ef7d">&sect;&nbsp;</a></span>SysCtlIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlIntStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is required and true if the masked interrupt status is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the system controller. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of <b>SYSCTL_INT_BOR0</b>, <b>SYSCTL_INT_VDDA_OK</b>, <b>SYSCTL_INT_MOSC_PUP</b>, <b>SYSCTL_INT_USBPLL_LOCK</b>, <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_BOR1</b>. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#a4f9f87f9381b3da165a82bde242d5e61">SYSCTL_MISC</a>, and <a class="el" href="hw__sysctl_8h.html#a1c81f0f10746ec3948b6f46b4d06583f">SYSCTL_RIS</a>.</p>

</div>
</div>
<a id="gae3647a438a01f95e022cbada36e3ef90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3647a438a01f95e022cbada36e3ef90">&sect;&nbsp;</a></span>SysCtlLDODeepSleepSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlLDODeepSleepSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Voltage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the output voltage of the LDO when the device enters deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Voltage</td><td>is the required output voltage from the LDO while in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the output voltage of the LDO while in deep-sleep mode. The <em>ui32Voltage</em> parameter specifies the output voltage of the LDO and must be one of the following values: <b>SYSCTL_LDO_0_90V</b>, <b>SYSCTL_LDO_0_95V</b>, <b>SYSCTL_LDO_1_00V</b>, <b>SYSCTL_LDO_1_05V</b>, <b>SYSCTL_LDO_1_10V</b>, <b>SYSCTL_LDO_1_15V</b>, or <b>SYSCTL_LDO_1_20V</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="sysctl_8h.html#ad4dba90f599e473cd8672b03c2074374">SYSCTL_LDO_0_90V</a>, <a class="el" href="sysctl_8h.html#a9cd605449d3ef10ce137d15b6af3030d">SYSCTL_LDO_0_95V</a>, <a class="el" href="sysctl_8h.html#ad7f1e108d4a398ce2eb6319f03fee705">SYSCTL_LDO_1_00V</a>, <a class="el" href="sysctl_8h.html#aa77ea22048837f836a82622de6cddc13">SYSCTL_LDO_1_05V</a>, <a class="el" href="sysctl_8h.html#a09c0ed06c3edb8f42ba1a7929d502b0d">SYSCTL_LDO_1_10V</a>, <a class="el" href="sysctl_8h.html#a252d5491b269181d654c67adb09cfacf">SYSCTL_LDO_1_15V</a>, <a class="el" href="sysctl_8h.html#a13f159c9abeea69a8c1f5a5e3dd06bae">SYSCTL_LDO_1_20V</a>, and <a class="el" href="hw__sysctl_8h.html#af8e591fe4a8479f685feffa427bcc9ad">SYSCTL_LDODPCTL</a>.</p>

</div>
</div>
<a id="ga42bfcfe02f41590d06d6f58f6486357e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42bfcfe02f41590d06d6f58f6486357e">&sect;&nbsp;</a></span>SysCtlLDODeepSleepGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlLDODeepSleepGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the output voltage of the LDO when the device enters deep-sleep mode.</p>
<p>This function returns the output voltage of the LDO when the device is in deep-sleep mode, as specified by the control register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the deep-sleep-mode voltage of the LDO; is one of <b>SYSCTL_LDO_0_90V</b>, <b>SYSCTL_LDO_0_95V</b>, <b>SYSCTL_LDO_1_00V</b>, <b>SYSCTL_LDO_1_05V</b>, <b>SYSCTL_LDO_1_10V</b>, <b>SYSCTL_LDO_1_15V</b>, or <b>SYSCTL_LDO_1_20V</b>. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#af8e591fe4a8479f685feffa427bcc9ad">SYSCTL_LDODPCTL</a>.</p>

</div>
</div>
<a id="gab2e05e98db611a541c28f2c218952282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2e05e98db611a541c28f2c218952282">&sect;&nbsp;</a></span>SysCtlSleepPowerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlSleepPowerSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the power to the flash and SRAM while in sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required flash and SRAM power configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the power configuration of the flash and SRAM while in sleep mode to be set. The <em>ui32Config</em> parameter is the logical OR of the flash power configuration and the SRAM power configuration.</p>
<p>The flash power configuration is specified as either:</p>
<ul>
<li><b>SYSCTL_FLASH_NORMAL</b> - The flash is left in fully powered mode, providing fast wake-up time but higher power consumption.</li>
<li><b>SYSCTL_FLASH_LOW_POWER</b> - The flash is in low power mode, providing reduced power consumption but longer wake-up time.</li>
</ul>
<p>The SRAM power configuration is specified as one of:</p>
<ul>
<li><b>SYSCTL_SRAM_NORMAL</b> - The SRAM is left in fully powered mode, providing fast wake-up time but higher power consumption.</li>
<li><b>SYSCTL_SRAM_STANDBY</b> - The SRAM is placed into a lower power mode, providing reduced power consumption but longer wake-up time.</li>
<li><b>SYSCTL_SRAM_LOW_POWER</b> - The SRAM is placed into lowest power mode, providing further reduced power consumption but longer wake-up time.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#aac24e047d3d3e2d2a69c522910ba1bb2">SYSCTL_SLPPWRCFG</a>.</p>

</div>
</div>
<a id="gab2db971f213bf6250c763840a2b44585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2db971f213bf6250c763840a2b44585">&sect;&nbsp;</a></span>SysCtlDeepSleepPowerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleepPowerSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the power to the flash and SRAM while in deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required flash and SRAM power configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the power configuration of the flash and SRAM while in deep-sleep mode to be set. The <em>ui32Config</em> parameter is the logical OR of the flash power configuration and the SRAM power configuration.</p>
<p>The flash power configuration is specified as either:</p>
<ul>
<li><b>SYSCTL_FLASH_NORMAL</b> - The flash is left in fully powered mode, providing fast wake-up time but higher power consumption.</li>
<li><b>SYSCTL_FLASH_LOW_POWER</b> - The flash is in low power mode, providing reduced power consumption but longer wake-up time.</li>
</ul>
<p>The SRAM power configuration is specified as one of:</p>
<ul>
<li><b>SYSCTL_LDO_SLEEP</b> - The LDO is in sleep mode.</li>
<li><b>SYSCTL_TEMP_LOW_POWER</b> - The temperature sensor in low power mode.</li>
<li><b>SYSCTL_SRAM_NORMAL</b> - The SRAM is left in fully powered mode, providing fast wake-up time but higher power consumption.</li>
<li><b>SYSCTL_SRAM_STANDBY</b> - The SRAM is placed into a lower power mode, providing reduced power consumption but longer wake-up time.</li>
<li><b>SYSCTL_SRAM_LOW_POWER</b> - The SRAM is placed into lowest power mode, providing further reduced power consumption but longer wake-up time.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a1e21c2b8e869e86658fcc4b44c81ac7b">SYSCTL_DSLPPWRCFG</a>.</p>

</div>
</div>
<a id="ga7e7eaf3273efa935f7bedfd3760d11b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7eaf3273efa935f7bedfd3760d11b8">&sect;&nbsp;</a></span>SysCtlReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the device.</p>
<p>This function performs a software reset of the entire device. The processor and all peripherals are reset and all device registers are returned to their default values (with the exception of the reset cause register, which maintains its current value but has the software reset bit set as well).</p>
<dl class="section return"><dt>Returns</dt><dd>This function does not return. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a4b8063473ed37bbc7f9a41da65b9c2ad">NVIC_APINT</a>, <a class="el" href="hw__nvic_8h.html#a2622822940e2c6c4783085c6b4717213">NVIC_APINT_SYSRESETREQ</a>, and <a class="el" href="hw__nvic_8h.html#ab4aac1a401683ddc647b4bd27d6c1e07">NVIC_APINT_VECTKEY</a>.</p>

</div>
</div>
<a id="ga90efcbaddc41095b9567cae626aaeb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90efcbaddc41095b9567cae626aaeb2c">&sect;&nbsp;</a></span>SysCtlSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the processor into sleep mode.</p>
<p>This function places the processor into sleep mode; it does not return until the processor returns to run mode. The peripherals that are enabled via <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a> continue to operate and can wake up the processor (if automatic clock gating is enabled with <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>, otherwise all peripherals continue to operate).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="cpu_8h.html#ad86bb26882bba3e9be5cea3b92a9e02f">CPUwfi()</a>.</p>

</div>
</div>
<a id="gac54fcca75df0066bd2b2ecdf92c0eda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54fcca75df0066bd2b2ecdf92c0eda2">&sect;&nbsp;</a></span>SysCtlDeepSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the processor into deep-sleep mode.</p>
<p>This function places the processor into deep-sleep mode; it does not return until the processor returns to run mode. The peripherals that are enabled via <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a> continue to operate and can wake up the processor (if automatic clock gating is enabled with <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>, otherwise all peripherals continue to operate).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="cpu_8h.html#ad86bb26882bba3e9be5cea3b92a9e02f">CPUwfi()</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a15f41c2b54e21dc9abb03e5d0a7c719d">NVIC_SYS_CTRL</a>, and <a class="el" href="hw__nvic_8h.html#a903c1896b1acfbe0738b762c985dc62a">NVIC_SYS_CTRL_SLEEPDEEP</a>.</p>

</div>
</div>
<a id="ga1afa3bfa9b77ae24b8acdb0147496f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1afa3bfa9b77ae24b8acdb0147496f5a">&sect;&nbsp;</a></span>SysCtlResetCauseGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlResetCauseGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the reason for a reset.</p>
<p>This function returns the reason(s) for a reset. Because the reset reasons are sticky until either cleared by software or a power-on reset, multiple reset reasons may be returned if multiple resets have occurred. The reset reason is a logical OR of <b>SYSCTL_CAUSE_HSRVREQ</b>, <b>SYSCTL_CAUSE_HIB</b>, <b>SYSCTL_CAUSE_WDOG1</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG0</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the reason(s) for a reset. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#ab6b8c95db38367853b060f1c7fa53121">SYSCTL_RESC</a>.</p>

</div>
</div>
<a id="gab9735274e5c9468bb55ecde9ca07bfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9735274e5c9468bb55ecde9ca07bfb1">&sect;&nbsp;</a></span>SysCtlResetCauseClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlResetCauseClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Causes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears reset reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Causes</td><td>are the reset causes to be cleared; must be a logical OR of <b>SYSCTL_CAUSE_HSRVREQ</b>, <b>SYSCTL_CAUSE_HIB</b>, <b>SYSCTL_CAUSE_WDOG1</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG0</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified sticky reset reasons. Once cleared, another reset for the same reason can be detected, and a reset for a different reason can be distinguished (instead of having two reset causes set). If the reset reason is used by an application, all reset causes should be cleared after they are retrieved with <a class="el" href="group__sysctl__api.html#ga1afa3bfa9b77ae24b8acdb0147496f5a">SysCtlResetCauseGet()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#ab6b8c95db38367853b060f1c7fa53121">SYSCTL_RESC</a>, and <a class="el" href="sysctl_8h.html#a992a7493f587384e949178cdc4063042">SysCtlDelay()</a>.</p>

</div>
</div>
<a id="gaa5ea49a00d023774f052fc53a2ccb953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ea49a00d023774f052fc53a2ccb953">&sect;&nbsp;</a></span>SysCtlMOSCConfigSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlMOSCConfigSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a small delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Count</td><td>is the number of delay loop iterations to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides a means of generating a delay by executing a simple 3 instruction cycle loop a given number of times. It is written in assembly to keep the loop instruction count consistent across tool chains.</p>
<p>It is important to note that this function does NOT provide an accurate timing mechanism. Although the delay loop is 3 instruction cycles long, the execution time of the loop will vary dramatically depending upon the application's interrupt environment (the loop will be interrupted unless run with interrupts disabled and this is generally an unwise thing to do) and also the current system clock rate and flash timings (wait states and the operation of the prefetch buffer affect the timing).</p>
<p>For better accuracy, the ROM version of this function may be used. This version will not suffer from flash- and prefect buffer-related timing variability but will still be delayed by interrupt service routines.</p>
<p>For best accuracy, a system timer should be used with code either polling for a particular timer value being exceeded or processing the timer interrupt to determine when a particular time period has elapsed.</p>
<dl class="section return"><dt>Returns</dt><dd>None. Sets the configuration of the main oscillator (MOSC) control.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required configuration of the MOSC control.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the control of the main oscillator. The <em>ui32Config</em> is specified as the logical OR of the following values:</p>
<ul>
<li><b>SYSCTL_MOSC_VALIDATE</b> enables the MOSC verification circuit that detects a failure of the main oscillator (such as a loss of the clock).</li>
<li><b>SYSCTL_MOSC_INTERRUPT</b> indicates that a MOSC failure should generate an interrupt instead of resetting the processor.</li>
<li><b>SYSCTL_MOSC_NO_XTAL</b> indicates that there is no crystal or oscillator connected to the OSC0/OSC1 pins, allowing power consumption to be reduced.</li>
<li><b>SYSCTL_MOSC_PWR_DIS</b> disable power to the main oscillator. If this parameter is not specified, the MOSC input remains powered.</li>
<li><b>SYSCTL_MOSC_LOWFREQ</b> MOSC is less than 10 MHz.</li>
<li><b>SYSCTL_MOSC_HIGHFREQ</b> MOSC is greater than 10 MHz.</li>
<li><b>SYSCTL_MOSC_SESRC</b> specifies that the MOSC is a single-ended oscillator connected to OSC0. If this parameter is not specified, the input is assumed to be a crystal.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a25e07d3c958f6bac10d5a290d57bfae8">SYSCTL_MOSCCTL</a>.</p>

</div>
</div>
<a id="gaf5bd79f60945f405c34c89005b0eb50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5bd79f60945f405c34c89005b0eb50d">&sect;&nbsp;</a></span>SysCtlPIOSCCalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlPIOSCCalibrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calibrates the precision internal oscillator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Type</td><td>is the type of calibration to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a calibration of the PIOSC. There are three types of calibration available; the desired calibration type as specified in <em>ui32Type</em> is one of:</p>
<ul>
<li><b>SYSCTL_PIOSC_CAL_AUTO</b> to perform automatic calibration using the 32-kHz clock from the hibernate module as a reference. This type is only possible if the hibernate module is enabled, a 32.768-kHz clock source is attached to the XOSC0/1 pins and the hibernate module's RTC is also enabled.</li>
<li><b>SYSCTL_PIOSC_CAL_FACT</b> to reset the PIOSC calibration to the factory provided calibration.</li>
<li><b>SYSCTL_PIOSC_CAL_USER</b> to set the PIOSC calibration to a user-supplied value. The value to be used is ORed into the lower 7-bits of this value, with 0x40 being the ``nominal'' value (in other words, if everything were perfect, 0x40 provides exactly 16 MHz). Values larger than 0x40 slow down PIOSC, and values smaller than 0x40 speed up PIOSC.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the calibration was successful and 0 if it failed. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#a250323d022f46409e1d0f58a3e953f8a">SYSCTL_PIOSCCAL</a>, <a class="el" href="hw__sysctl_8h.html#a4b7490f14b79ecf8591ed125410c3b91">SYSCTL_PIOSCCAL_CAL</a>, <a class="el" href="hw__sysctl_8h.html#a5cae7d8761f0d7acde6a1a5ca285d3e5">SYSCTL_PIOSCCAL_UPDATE</a>, <a class="el" href="hw__sysctl_8h.html#a90a55644ee915ecbec011e27cd7811ba">SYSCTL_PIOSCCAL_UT_M</a>, <a class="el" href="hw__sysctl_8h.html#abe8883f93985822cf049113037a37158">SYSCTL_PIOSCCAL_UTEN</a>, <a class="el" href="hw__sysctl_8h.html#accae2718c49e898e670929411106fddc">SYSCTL_PIOSCSTAT</a>, <a class="el" href="hw__sysctl_8h.html#a44ca577d83c7d3ab213c6d167b72fcfd">SYSCTL_PIOSCSTAT_CR_M</a>, and <a class="el" href="hw__sysctl_8h.html#a21ba5d553e4388eca1e6f889afd5adf6">SYSCTL_PIOSCSTAT_CRPASS</a>.</p>

</div>
</div>
<a id="ga109ad31fa3c2d1957454c8e73a8bbae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga109ad31fa3c2d1957454c8e73a8bbae6">&sect;&nbsp;</a></span>SysCtlResetBehaviorSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlResetBehaviorSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Behavior</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the type of reset issued due to certain reset events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Behavior</td><td>specifies the types of resets for each of the configurable reset events.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the types of reset issued when a configurable reset event occurs. The reset events that are configurable are: Watchdog 0 or 1, a brown out and the external RSTn pin. The valid actions are either a system reset or a full POR sequence. See the technical reference manual for more information on the differences between a full POR and a system reset. All reset behaviors can be configured with a single call using the logical OR of the values defined below. Any reset option that is not specifically set remains configured for its default behavior. Either POR or system reset can be selected for each reset cause.</p>
<p>Valid values are logical combinations of the following:</p>
<ul>
<li><b>SYSCTL_ONRST_WDOG0_POR</b> configures a Watchdog 0 reset to perform a full POR.</li>
<li><b>SYSCTL_ONRST_WDOG0_SYS</b> configures a Watchdog 0 reset to perform a system reset.</li>
<li><b>SYSCTL_ONRST_WDOG1_POR</b> configures a Watchdog 1 reset to perform a full POR.</li>
<li><b>SYSCTL_ONRST_WDOG1_SYS</b> configures a Watchdog 1 reset to perform a system reset.</li>
<li><b>SYSCTL_ONRST_BOR_POR</b> configures a brown-out reset to perform a full POR.</li>
<li><b>SYSCTL_ONRST_BOR_SYS</b> configures a brown-out reset to perform a system reset.</li>
<li><b>SYSCTL_ONRST_EXT_POR</b> configures an external pin reset to perform a full POR.</li>
<li><b>SYSCTL_ONRST_EXT_SYS</b> configures an external pin reset to perform a system reset.</li>
</ul>
<p><b>Example:</b> Set Watchdog 0 reset to trigger a POR and a brown-out reset to trigger a system reset while leaving the remaining resets with their default behaviors.</p>
<pre class="fragment">//! SysCtlResetBehaviorSet(SYSCTL_ONRST_WDOG0_POR | SYSCTL_ONRST_BOR_SYS);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a90b98f564be713b6c62f163f94bc357c">SYSCTL_RESBEHAVCTL</a>.</p>

</div>
</div>
<a id="ga42211457f456c2c2b68b490acc320177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42211457f456c2c2b68b490acc320177">&sect;&nbsp;</a></span>SysCtlResetBehaviorGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlResetBehaviorGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current types of reset issued due to reset events.</p>
<p>This function returns the types of resets issued when a configurable reset occurs. The value returned is a logical OR combination of the valid values that are described in the documentation for the <em>ui32Behavior</em> parameter of the <a class="el" href="group__sysctl__api.html#ga109ad31fa3c2d1957454c8e73a8bbae6">SysCtlResetBehaviorSet()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>The reset behaviors for all configurable resets. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a90b98f564be713b6c62f163f94bc357c">SYSCTL_RESBEHAVCTL</a>.</p>

</div>
</div>
<a id="ga21032362a556673829fb41e4f057ec5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21032362a556673829fb41e4f057ec5a">&sect;&nbsp;</a></span>SysCtlClockFreqSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlClockFreqSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32SysClock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the system clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required configuration of the device clocking. </td></tr>
    <tr><td class="paramname">ui32SysClock</td><td>is the requested processor frequency.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the main system clocking for the device. The input frequency, oscillator source, whether or not to enable the PLL, and the system clock divider are all configured with this function. This function configures the system frequency to the closest available divisor of one of the fixed PLL VCO settings provided in the <em>ui32Config</em> parameter. The caller sets the <em>ui32SysClock</em> parameter to request the system clock frequency, and this function then attempts to match this using the values provided in the <em>ui32Config</em> parameter. If this function cannot exactly match the requested frequency, it picks the closest frequency that is lower than the requested frequency. The <em>ui32Config</em> parameter provides the remaining configuration options using a set of defines that are a logical OR of several different values, many of which are grouped into sets where only one of the set can be chosen. This function returns the current system frequency which may not match the requested frequency.</p>
<p>If the application is using an external crystal then the frequency is set by using one of the following values: <b>SYSCTL_XTAL_5MHZ</b>, <b>SYSCTL_XTAL_6MHZ</b>, <b>SYSCTL_XTAL_8MHZ</b>, <b>SYSCTL_XTAL_10MHZ</b>, <b>SYSCTL_XTAL_12MHZ</b>, <b>SYSCTL_XTAL_16MHZ</b>, <b>SYSCTL_XTAL_18MHZ</b>, <b>SYSCTL_XTAL_20MHZ</b>, <b>SYSCTL_XTAL_24MHZ</b>, or <b>SYSCTL_XTAL_25MHz</b>.</p>
<p>The oscillator source is chosen with one of the following values:</p>
<ul>
<li><b>SYSCTL_OSC_MAIN</b> to use an external crystal or oscillator.</li>
<li><b>SYSCTL_OSC_INT</b> to use the 16-MHz precision internal oscillator.</li>
<li><b>SYSCTL_OSC_INT30</b> to use the internal low frequency oscillator.</li>
<li><b>SYSCTL_OSC_EXT32</b> to use the hibernate modules 32.786-kHz oscillator.</li>
</ul>
<p>The system clock source is chosen with one of the following values:</p>
<ul>
<li><b>SYSCTL_USE_PLL</b> is used to select the PLL output as the system clock.</li>
<li><b>SYSCTL_USE_OSC</b> is used to choose one of the oscillators as the system clock.</li>
</ul>
<p>The PLL VCO frequency is chosen with one of the the following values:</p>
<ul>
<li><b>SYSCTL_CFG_VCO_480</b> to set the PLL VCO output to 480-MHz</li>
<li><b>SYSCTL_CFG_VCO_320</b> to set the PLL VCO output to 320-MHz</li>
</ul>
<p>Example: Configure the system clocking to be 40 MHz with a 320-MHz PLL setting using the 16-MHz internal oscillator.</p>
<pre class="fragment">//! SysCtlClockFreqSet(SYSCTL_OSC_INT | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_320,
//!                    40000000);
//! </pre> <pre class="fragment">\return The actual configured system clock frequency in Hz or zero if the
value could not be changed due to a parameter error or PLL lock failure.  </pre> 
<p>References <a class="el" href="sysctl_8h.html#a378ad2f17176867836a92c3a18d725bd">SYSCTL_OSC_EXT32</a>, <a class="el" href="sysctl_8h.html#aaac267b7fe1a5a16f3e23845ed004634">SYSCTL_OSC_INT</a>, <a class="el" href="sysctl_8h.html#a0bfa7f9a23c526e81a784d8184f34585">SYSCTL_OSC_INT30</a>, <a class="el" href="sysctl_8h.html#a8c78f8e9ba8e9829e93824ec5dc90cc9">SYSCTL_OSC_MAIN</a>, <a class="el" href="hw__sysctl_8h.html#aac42648f3999f5c1544920a2a1bde84e">SYSCTL_RSCLKCFG_OSCSRC_LFIOSC</a>, <a class="el" href="hw__sysctl_8h.html#a81df0865eb6a0cd2505356ebed046c7d">SYSCTL_RSCLKCFG_OSCSRC_PIOSC</a>, <a class="el" href="hw__sysctl_8h.html#aa86a34dfecf1a7dfece6c36161563f15">SYSCTL_RSCLKCFG_OSCSRC_RTC</a>, <a class="el" href="hw__sysctl_8h.html#ae305421a2d99204a6b53a355b4e315b7">SYSCTL_RSCLKCFG_PLLSRC_PIOSC</a>, <a class="el" href="sysctl_8h.html#aa28940746d2ba2b251b11043dd8bc2fe">SYSCTL_XTAL_16MHZ</a>, <a class="el" href="sysctl_8h.html#af059fbe6af6b3a69daeaf2e98243b26e">SYSCTL_XTAL_25MHZ</a>, <a class="el" href="sysctl_8h.html#a06524c0e03c2638fdc962921ce46c4ec">SYSCTL_XTAL_5MHZ</a>, and <a class="el" href="group__sysctl__api.html#ga368eb5ebc0c5267aef73cd1caf7d873c">SysCtlXtalCfgToIndex</a>.</p>

</div>
</div>
<a id="gac1a32f72f5bad65b43795069a68ac2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a32f72f5bad65b43795069a68ac2a6">&sect;&nbsp;</a></span>SysCtlDeepSleepClockConfigSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleepClockConfigSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clock configuration of the device while in deep-sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Div</td><td>is the clock divider when in deep-sleep mode. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration of the device clocking while in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the clocking of the device while in deep-sleep mode. The <em>ui32Config</em> parameter selects the oscillator and the <em>ui32Div</em> parameter sets the clock divider used in deep-sleep mode. The valid values for the <em>ui32Div</em> parameter range from 1 to 1024.</p>
<p>The oscillator source is chosen from one of the following values: <b>SYSCTL_DSLP_OSC_MAIN</b>, <b>SYSCTL_DSLP_OSC_INT</b>, <b>SYSCTL_DSLP_OSC_INT30</b>, or <b>SYSCTL_DSLP_OSC_EXT32</b>. The <b>SYSCTL_DSLP_OSC_EXT32</b> option is only available when the hibernation module is enabled.</p>
<p>The precision internal oscillator can be powered down in deep-sleep mode by specifying <b>SYSCTL_DSLP_PIOSC_PD</b>. The precision internal oscillator is not powered down if it is required for operation while in deep-sleep (based on other configuration settings).</p>
<p>The main oscillator can be powered down in deep-sleep mode by specifying <b>SYSCTL_DSLP_MOSC_PD</b>. The main oscillator is not powered down if it is required for operation while in deep-sleep (based on other configuration settings).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#a1b9b05995b84bd6156d34d9e4383ab19">SYSCTL_DSCLKCFG</a>, <a class="el" href="hw__sysctl_8h.html#a96e8e7aa23434a123b688ef9bfc81b99">SYSCTL_DSCLKCFG_DSOSCSRC_LFIOSC</a>, <a class="el" href="hw__sysctl_8h.html#a9815df36bb0974b960bb6a2ab79460e5">SYSCTL_DSCLKCFG_DSOSCSRC_M</a>, <a class="el" href="hw__sysctl_8h.html#a1eabec8dd7a5a36122afa04f059c22c4">SYSCTL_DSCLKCFG_DSOSCSRC_MOSC</a>, <a class="el" href="hw__sysctl_8h.html#a959b46bd1cdf3a5ffb8c7028a018079e">SYSCTL_DSCLKCFG_DSOSCSRC_RTC</a>, <a class="el" href="hw__sysctl_8h.html#a81a85a9c8f0c88d18e6279b9409572ab">SYSCTL_DSCLKCFG_MOSCDPD</a>, <a class="el" href="hw__sysctl_8h.html#abe3637fe8f54d98207e7f304b77c142f">SYSCTL_DSCLKCFG_PIOSCPD</a>, <a class="el" href="sysctl_8h.html#a0aa31ddf74a8688b7df40a4dec1db35c">SYSCTL_DSLP_MOSC_DPD</a>, <a class="el" href="sysctl_8h.html#a10da3db9e4299201a0e011eeb0c6a3f5">SYSCTL_DSLP_OSC_EXT32</a>, <a class="el" href="sysctl_8h.html#a944c129796e21c1bf4d908004231d8ed">SYSCTL_DSLP_OSC_INT</a>, <a class="el" href="sysctl_8h.html#a0b2c093ccea186a3f309a4c2afd35f58">SYSCTL_DSLP_OSC_INT30</a>, <a class="el" href="sysctl_8h.html#ae22fd83f008cdaad12219f93aa846a0e">SYSCTL_DSLP_OSC_MAIN</a>, and <a class="el" href="sysctl_8h.html#ad9571b2166170f673777a875ab3dfc66">SYSCTL_DSLP_PIOSC_PD</a>.</p>

</div>
</div>
<a id="ga5ab556872df7db77f97c62502f99ee30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ab556872df7db77f97c62502f99ee30">&sect;&nbsp;</a></span>SysCtlVoltageEventConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlVoltageEventConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the response to system voltage events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>holds the configuration options for the voltage events.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the response to voltage-related events. These events are triggered when the voltage rails drop below certain levels. The <em>ui32Config</em> parameter provides the configuration for the voltage events and is a combination of the <b>SYSCTL_VEVENT_*</b> values.</p>
<p>The response to a brown out on the VDDA rail is set by using one of the following values:</p><ul>
<li><b>SYSCTL_VEVENT_VDDABO_NONE</b> - There is no action taken on a VDDA brown out.</li>
<li><b>SYSCTL_VEVENT_VDDABO_INT</b> - A system interrupt is generated when a VDDA brown out occurs.</li>
<li><b>SYSCTL_VEVENT_VDDABO_NMI</b> - An NMI is generated when a VDDA brown out occurs.</li>
<li><b>SYSCTL_VEVENT_VDDABO_RST</b> - A reset is generated when a VDDA brown out occurs. The type of reset that is generated is controller by the <b>SYSCTL_ONRST_BOR_*</b> setting passed into the <a class="el" href="group__sysctl__api.html#ga109ad31fa3c2d1957454c8e73a8bbae6">SysCtlResetBehaviorSet()</a> function.</li>
</ul>
<p>The response to a brown out on the VDD rail is set by using one of the following values:</p><ul>
<li><b>SYSCTL_VEVENT_VDDBO_NONE</b> - There is no action taken on a VDD brown out.</li>
<li><b>SYSCTL_VEVENT_VDDBO_INT</b> - A system interrupt is generated when a VDD brown out occurs.</li>
<li><b>SYSCTL_VEVENT_VDDBO_NMI</b> - An NMI is generated when a VDD brown out occurs.</li>
<li><b>SYSCTL_VEVENT_VDDBO_RST</b> - A reset is generated when a VDD brown out occurs. The type of reset that is generated is controller by the <b>SYSCTL_ONRST_BOR_*</b> setting passed into the <a class="el" href="group__sysctl__api.html#ga109ad31fa3c2d1957454c8e73a8bbae6">SysCtlResetBehaviorSet()</a> function.</li>
</ul>
<p><b>Example:</b> Configure the voltage events to trigger an interrupt on a VDDA brown out, an NMI on a VDDC brown out and a reset on a VDD brown out.</p>
<pre class="fragment">//!
//! //
//! // Configure the BOR rest to trigger a full POR.  This is needed because
//! // the SysCtlVoltageEventConfig() call is triggering a reset so the type
//! // of reset is specified by this call.
//! //
//! SysCtlResetBehaviorSet(SYSCTL_ONRST_BOR_POR);
//!
//! //
//! // Trigger an interrupt on a VDDA brown out and a reset on a VDD brown out.
//! //
//! SysCtlVoltageEventConfig(SYSCTL_VEVENT_VDDABO_INT |
//!                          SYSCTL_VEVENT_VDDBO_RST);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a3fd602f9f4366b7cd066c89f56403052">SYSCTL_PTBOCTL</a>.</p>

</div>
</div>
<a id="ga477377a31fd24fa238e9235392d69e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477377a31fd24fa238e9235392d69e68">&sect;&nbsp;</a></span>SysCtlVoltageEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlVoltageEventStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the voltage event status.</p>
<p>This function returns the voltage event status for the system controller. The value returned is a logical OR of the following values:</p><ul>
<li><b>SYSCTL_VESTAT_VDDBOR</b> a brown-out event occurred on the VDD rail.</li>
<li><b>SYSCTL_VESTAT_VDDABOR</b> a brown-out event occurred on the VDDA rail.</li>
</ul>
<p>The values returned from this function can be passed to the <a class="el" href="group__sysctl__api.html#gaf62659875c2673c4f6da90ed38e6e230">SysCtlVoltageEventClear()</a> to clear the current voltage event status. Because voltage events are not cleared due to a reset, the voltage event status must be cleared by calling <a class="el" href="group__sysctl__api.html#gaf62659875c2673c4f6da90ed38e6e230">SysCtlVoltageEventClear()</a>.</p>
<p><b>Example:</b> Clear the current voltage event status.</p>
<pre class="fragment">//! uint32_t ui32VoltageEvents;
//!
//! //
//! // Read the current voltage event status.
//! //
//! ui32VoltageEvents = SysCtlVoltageEventStatus();
//!
//! //
//! // Clear all the current voltage events.
//! //
//! SysCtlVoltageEventClear(ui32VoltageEvents);
//! </pre> <pre class="fragment">\return The current voltage event status.</pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#affb5c3022c06d0f2f14188eb6c819548">SYSCTL_PWRTC</a>.</p>

</div>
</div>
<a id="gaf62659875c2673c4f6da90ed38e6e230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf62659875c2673c4f6da90ed38e6e230">&sect;&nbsp;</a></span>SysCtlVoltageEventClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlVoltageEventClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the voltage event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Status</td><td>is a bit mask of the voltage events to clear.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the current voltage events status for the values specified in the <em>ui32Status</em> parameter. The <em>ui32Status</em> value must be a logical OR of the following values:</p><ul>
<li><b>SYSCTL_VESTAT_VDDBOR</b> a brown-out event occurred on the VDD rail.</li>
<li><b>SYSCTL_VESTAT_VDDABOR</b> a brown-out event occurred on the VDDA rail.</li>
</ul>
<p><b>Example:</b> Clear the current voltage event status.</p>
<pre class="fragment">//! //
//! // Clear all the current voltage events.
//! //
//! SysCtlVoltageEventClear(SysCtlVoltageEventStatus());
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#affb5c3022c06d0f2f14188eb6c819548">SYSCTL_PWRTC</a>.</p>

</div>
</div>
<a id="ga6e4d3c5fc6dd5af6dbd8ef55713bf46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e4d3c5fc6dd5af6dbd8ef55713bf46c">&sect;&nbsp;</a></span>SysCtlVCOGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SysCtlVCOGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Crystal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32VCOFrequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the effective VCO frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Crystal</td><td>holds the crystal value used for the PLL. </td></tr>
    <tr><td class="paramname">pui32VCOFrequency</td><td>is a pointer to the storage location which holds value of the VCO computed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the VCO of the PLL before the system divider is applied</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the PLL is configured correctly and a VCO is valid or <b>false</b> if the PLL is not used </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__sysctl_8h.html#a0a46cac92f10630390e04ad38d1400db">SYSCTL_RSCLKCFG</a>, <a class="el" href="hw__sysctl_8h.html#a8a4cd2f1b8e43126380b44f569321236">SYSCTL_RSCLKCFG_USEPLL</a>, and <a class="el" href="group__sysctl__api.html#ga368eb5ebc0c5267aef73cd1caf7d873c">SysCtlXtalCfgToIndex</a>.</p>

</div>
</div>
<a id="ga628248ad7d1558ec4f3a4070068422a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628248ad7d1558ec4f3a4070068422a6">&sect;&nbsp;</a></span>SysCtlNMIStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlNMIStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current NMI status.</p>
<p>This function returns the NMI status for the system controller. The valid values for the <em>ui32Ints</em> parameter are a logical OR of the following values:</p><ul>
<li><b>SYSCTL_NMI_MOSCFAIL</b> the main oscillator is not present or did not start.</li>
<li><b>SYSCTL_NMI_TAMPER</b> a tamper event has been detected.</li>
<li><b>SYSCTL_NMI_WDT0</b> watchdog 0 generated a timeout.</li>
<li><b>SYSCTL_NMI_WDT1</b> watchdog 1 generated a timeout.</li>
<li><b>SYSCTL_NMI_POWER</b> a power event occurred.</li>
<li><b>SYSCTL_NMI_EXTERNAL</b> an external NMI pin asserted.</li>
</ul>
<p><b>Example:</b> Clear all current NMI status flags.</p>
<pre class="fragment">//!
//! //
//! // Clear all the current NMI sources.
//! //
//! SysCtlNMIClear(SysCtlNMIStatus());
//! </pre> <pre class="fragment">\return The current NMI status.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a2edf1bf1842cd39e6df633710485d1b6">SYSCTL_NMIC</a>.</p>

</div>
</div>
<a id="ga1fa88f58928e04ae7a3b35355664d4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa88f58928e04ae7a3b35355664d4d9">&sect;&nbsp;</a></span>SysCtlNMIClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlNMIClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears NMI sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the non-maskable interrupt sources.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the current NMI status specified in the <em>ui32Ints</em> parameter. The valid values for the <em>ui32Ints</em> parameter are a logical OR of the following values:</p><ul>
<li><b>SYSCTL_NMI_MOSCFAIL</b> the main oscillator is not present or did not start.</li>
<li><b>SYSCTL_NMI_TAMPER</b> a tamper event has been detected.</li>
<li><b>SYSCTL_NMI_WDT0</b> watchdog 0 generated a timeout.</li>
<li><b>SYSCTL_NMI_WDT1</b> watchdog 1 generated a timeout.</li>
<li><b>SYSCTL_NMI_POWER</b> a power event occurred.</li>
<li><b>SYSCTL_NMI_EXTERNAL</b> an external NMI pin asserted.</li>
</ul>
<p><b>Example:</b> Clear all current NMI status flags.</p>
<pre class="fragment">//!
//! //
//! // Clear all the current NMI sources.
//! //
//! SysCtlNMIClear(SysCtlNMIStatus());
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a2edf1bf1842cd39e6df633710485d1b6">SYSCTL_NMIC</a>.</p>

</div>
</div>
<a id="ga57d891ebea267f6236f5192b9f09f657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d891ebea267f6236f5192b9f09f657">&sect;&nbsp;</a></span>SysCtlClockOutConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlClockOutConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures and enables or disables the clock output on the DIVSCLK pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>holds the configuration options including enabling or disabling the clock output on the DIVSCLK pin. </td></tr>
    <tr><td class="paramname">ui32Div</td><td>is the divisor for the clock selected in the <em>ui32Config</em> parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the source for the DIVSCLK, enables or disables the clock output and provides an output divider value. The <em>ui32Div</em> parameter specifies the divider for the selected clock source and has a valid range of 1-256. The <em>ui32Config</em> parameter configures the DIVSCLK output based on the following settings:</p>
<p>The first setting allows the output to be enabled or disabled.</p><ul>
<li><b>SYSCTL_CLKOUT_EN</b> - enable the DIVSCLK output.</li>
<li><b>SYSCTL_CLKOUT_DIS</b> - disable the DIVSCLK output (default).</li>
</ul>
<p>The next group of settings selects the source for the DIVSCLK.</p><ul>
<li><b>SYSCTL_CLKOUT_SYSCLK</b> - use the current system clock as the source (default).</li>
<li><b>SYSCTL_CLKOUT_PIOSC</b> - use the PIOSC as the source.</li>
<li><b>SYSCTL_CLKOUT_MOSC</b> - use the MOSC as the source.</li>
</ul>
<p><b>Example:</b> Enable the PIOSC divided by 4 as the DIVSCLK output.</p>
<pre class="fragment">//!
//! //
//! // Enable the PIOSC divided by 4 as the DIVSCLK output.
//! //
//! SysCtlClockOutConfig(SYSCTL_DIVSCLK_EN | SYSCTL_DIVSCLK_SRC_PIOSC, 4);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="sysctl_8h.html#a54cf9ff06eac8184447f7296c790b076">SYSCTL_CLKOUT_DIS</a>, <a class="el" href="sysctl_8h.html#ae2000c83d70954237d5981a0c172adf4">SYSCTL_CLKOUT_EN</a>, <a class="el" href="sysctl_8h.html#ad9d2acd289ba757a7d741d9b2c8fbf7e">SYSCTL_CLKOUT_MOSC</a>, <a class="el" href="sysctl_8h.html#af10516a9ba4862bddbfbc0de762b6bca">SYSCTL_CLKOUT_PIOSC</a>, <a class="el" href="sysctl_8h.html#a5b890de65910f0dfd2dee15a94ba678f">SYSCTL_CLKOUT_SYSCLK</a>, <a class="el" href="hw__sysctl_8h.html#a0477a1b414c4e90b5e8cc98e7fd5bb20">SYSCTL_DIVSCLK</a>, and <a class="el" href="hw__sysctl_8h.html#a8e9b7b332d5568683c37bcb8067e6c57">SYSCTL_DIVSCLK_DIV_M</a>.</p>

</div>
</div>
<a id="gaf719a6614c2febdea012870765a7d06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf719a6614c2febdea012870765a7d06c">&sect;&nbsp;</a></span>SysCtlAltClkConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlAltClkConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the alternate peripheral clock source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>holds the configuration options for the alternate peripheral clock.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the alternate peripheral clock. The alternate peripheral clock is used to provide a known clock in all operating modes to peripherals that support using the alternate peripheral clock as an input clock. The <em>ui32Config</em> parameter value provides the clock input source using one of the following values:</p><ul>
<li><b>SYSCTL_ALTCLK_PIOSC</b> - use the PIOSC as the alternate clock source (default).</li>
<li><b>SYSCTL_ALTCLK_RTCOSC</b> - use the Hibernate module RTC clock as the alternate clock source.</li>
<li><b>SYSCTL_ALTCLK_LFIOSC</b> - use the low-frequency internal oscillator as the alternate clock source.</li>
</ul>
<p><b>Example:</b> Select the Hibernate module RTC clock as the alternate clock source.</p>
<pre class="fragment">//!
//! //
//! // Select the Hibernate module RTC clock as the alternate clock source.
//! //
//! SysCtlAltClkConfig(SYSCTL_ALTCLK_RTCOSC);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__sysctl_8h.html#a51c1ad20cdc6c1eded606b1d42b4ab6c">SYSCTL_ALTCLKCFG</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gabf87c454179e3c6b9971b9715369341a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf87c454179e3c6b9971b9715369341a">&sect;&nbsp;</a></span>ui32Frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t { ... } ui32Frequency</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga53648ff7740d9626b659bf59dda94525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53648ff7740d9626b659bf59dda94525">&sect;&nbsp;</a></span>ui32MemTiming</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t { ... } ui32MemTiming</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
