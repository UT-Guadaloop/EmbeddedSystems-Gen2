<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Interrupt_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interrupt_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8b9ae71d2ea53a231841b41414acf1ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>&#160;&#160;&#160;155</td></tr>
<tr class="separator:ga8b9ae71d2ea53a231841b41414acf1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae3724c6b65b8461cf0441f09b13fadf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#gae3724c6b65b8461cf0441f09b13fadf5">IntMasterDisable</a> (void)</td></tr>
<tr class="separator:gae3724c6b65b8461cf0441f09b13fadf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a32aafea7f4904d2a64ee18b45f96c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister</a> (uint32_t ui32Interrupt, void(*pfnHandler)(void))</td></tr>
<tr class="separator:ga0a32aafea7f4904d2a64ee18b45f96c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dffc81c27c005f83e9bfc30f775982a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:ga5dffc81c27c005f83e9bfc30f775982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341c2244311b2c8c84b0a5546fc3dff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga341c2244311b2c8c84b0a5546fc3dff1">IntPriorityGroupingSet</a> (uint32_t ui32Bits)</td></tr>
<tr class="separator:ga341c2244311b2c8c84b0a5546fc3dff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86595146bc7ea51280d5abbb45fcf02a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga86595146bc7ea51280d5abbb45fcf02a">IntPriorityGroupingGet</a> (void)</td></tr>
<tr class="separator:ga86595146bc7ea51280d5abbb45fcf02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0432ddf52557352ac987f7dd211c2017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga0432ddf52557352ac987f7dd211c2017">IntPrioritySet</a> (uint32_t ui32Interrupt, uint8_t ui8Priority)</td></tr>
<tr class="separator:ga0432ddf52557352ac987f7dd211c2017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a7849e23f4a84c1bcaad2e9bcc27b2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#gac6a7849e23f4a84c1bcaad2e9bcc27b2">IntPriorityGet</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:gac6a7849e23f4a84c1bcaad2e9bcc27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49fc9c3d1a0f8c42a20249f8c5d360ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:ga49fc9c3d1a0f8c42a20249f8c5d360ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af6b00884dc44e92b3d05ff821b5334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:ga9af6b00884dc44e92b3d05ff821b5334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8b044169061f80ea2a2d11af591d18"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga2c8b044169061f80ea2a2d11af591d18">IntIsEnabled</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:ga2c8b044169061f80ea2a2d11af591d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe17b56764bff1bcb95bd53acde4ac98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#gafe17b56764bff1bcb95bd53acde4ac98">IntPendSet</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:gafe17b56764bff1bcb95bd53acde4ac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab708e168ca0f1f554bb141e5b0fd1bdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#gab708e168ca0f1f554bb141e5b0fd1bdc">IntPendClear</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:gab708e168ca0f1f554bb141e5b0fd1bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b8f34d64c588f632509406b50e4f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga61b8f34d64c588f632509406b50e4f68">IntPriorityMaskSet</a> (uint32_t ui32PriorityMask)</td></tr>
<tr class="separator:ga61b8f34d64c588f632509406b50e4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39b7d4927274abf42c57767218af279"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#gad39b7d4927274abf42c57767218af279">IntPriorityMaskGet</a> (void)</td></tr>
<tr class="separator:gad39b7d4927274abf42c57767218af279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374a8725d31b31ed8f10b1609fe05f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt__api.html#ga374a8725d31b31ed8f10b1609fe05f64">IntTrigger</a> (uint32_t ui32Interrupt)</td></tr>
<tr class="separator:ga374a8725d31b31ed8f10b1609fe05f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="interrupt_intro"></a>
Introduction</h1>
<p>The interrupt controller API provides a set of functions for dealing with the Nested Vectored Interrupt Controller (NVIC). Functions are provided to enable and disable interrupts, register interrupt handlers, and set the priority of interrupts.</p>
<p>The NVIC provides global interrupt masking, prioritization, and handler dispatching. Devices within the MSP432E4 family support up to 154 interrupt sources and eight priority levels. Individual interrupt sources can be masked, and the processor interrupt can be globally masked as well (without affecting the individual source masks).</p>
<p>The NVIC is tightly coupled with the Cortex-M microprocessor. When the processor responds to an interrupt, the NVIC supplies the address of the function to handle the interrupt directly to the processor. This action eliminates the need for a global interrupt handler that queries the interrupt controller to determine the cause of the interrupt and branch to the appropriate handler, reducing interrupt response time.</p>
<p>The interrupt prioritization in the NVIC allows higher priority interrupts to be handled before lower priority interrupts, as well as allowing preemption of lower priority interrupt handlers by higher priority interrupts. Again, this helps reduce interrupt response time (for example, a 1 ms system control interrupt is not held off by the execution of a lower priority 1 second housekeeping interrupt handler).</p>
<p>Sub-prioritization is also possible; instead of having N bits of preemptable prioritization, the NVIC can be configured (via software) for N - M bits of preemptable prioritization and M bits of sub-priority. In this scheme, two interrupts with the same preemptable prioritization but different sub-priorities do not cause a preemption; tail chaining is used instead to process the two interrupts back-to-back.</p>
<p>If two interrupts with the same priority (and sub-priority if so configured) are asserted at the same time, the one with the lower interrupt number is processed first. The NVIC keeps track of the nesting of interrupt handlers, allowing the processor to return from interrupt context only once all nested and pending interrupts have been handled.</p>
<p>Interrupt handlers can be configured in one of two ways; statically at compile time or dynamically at run time. Static configuration of interrupt handlers is accomplished by editing the interrupt handler table in the application's startup code. When statically configured, the interrupts must be explicitly enabled in the NVIC via <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a> before the processor can respond to the interrupt (in addition to any interrupt enabling required within the peripheral itself). Statically configuring the interrupt table provides the fastest interrupt response time because the stacking operation (a write to SRAM) can be performed in parallel with the interrupt handler table fetch (a read from Flash), as well as the prefetch of the interrupt handler itself (assuming it is also in Flash).</p>
<p>Alternatively, interrupts can be configured at run-time using <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> (or the analog in each individual driver). When using <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>, the interrupt must also be enabled as before; when using the analogue in each individual driver, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a> is called by the driver and does not need to be called by the application. Run-time configuration of interrupts adds a small latency to the interrupt response time because the stacking operation (a write to SRAM) and the interrupt handler table fetch (a read from SRAM) must be performed sequentially.</p>
<p>Run-time configuration of interrupt handlers requires that the interrupt handler table be placed on a 1-kB boundary in SRAM (typically this is at the beginning of SRAM). Failure to do so results in an incorrect vector address being fetched in response to an interrupt. The vector table is in a section called ``vtable'' and must be placed appropriately with a linker script.</p>
<h1><a class="anchor" id="interrupt_api_functions"></a>
API Functions</h1>
<p>The primary function of the interrupt controller API is to manage the interrupt vector table used by the NVIC to dispatch interrupt requests. Registering an interrupt handler is a simple matter of inserting the handler address into the table. By default, the table is filled with pointers to an internal handler that loops forever; it is an error for an interrupt to occur when there is no interrupt handler registered to process it. Therefore, interrupt sources must not be enabled before a handler has been registered, and interrupt sources must be disabled before a handler is unregistered. Interrupt handlers are managed with <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>
<p>Each interrupt source can be individually enabled and disabled via <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a> and <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>. The processor interrupt can be enabled and disabled via <a class="el" href="interrupt_8h.html#a8321cf21088e200350d36827ecc6dad3">IntMasterEnable()</a> and <a class="el" href="group__interrupt__api.html#gae3724c6b65b8461cf0441f09b13fadf5">IntMasterDisable()</a>; this does not affect the individual interrupt enable states. Masking of the processor interrupt can be used as a simple critical section (only an NMI can interrupt the processor while the processor interrupt is disabled), although masking the processor interrupt can have adverse effects on the interrupt response time.</p>
<p>The priority of each interrupt source can be set and examined via <a class="el" href="group__interrupt__api.html#ga0432ddf52557352ac987f7dd211c2017">IntPrioritySet()</a> and <a class="el" href="group__interrupt__api.html#gac6a7849e23f4a84c1bcaad2e9bcc27b2">IntPriorityGet()</a>. The priority assignments are defined by the hardware; the upper N bits of the 8-bit priority are examined to determine the priority of an interrupt (for the MSP432E4 family, N is 3). This protocol allows priorities to be defined without knowledge of the exact number of supported priorities; moving to a device with more or fewer priority bits is made easier as the interrupt source continues to have a similar level of priority. Smaller priority numbers correspond to higher interrupt priority, so 0 is the highest priority.</p>
<h2><a class="anchor" id="interrupt_mapping"></a>
Interrupt Mapping</h2>
<p>The TM4C123 and TM4C129 devices have different interrupt mapping for the same peripheral interrupts. This requires that the application have a way to control the mapping of interrupts so that the correct interrupt number is used. For example the same interrupt name <b>INT_USB0</b> has interrupt number 60 on TM4C123 devices and 58 on TM4C129 devices. All of the interrupt number macros start with <b>INT_*</b> and there are two defines that an application uses to allow the correct interrupt number to be mapped to these <b>INT_*</b> macros. The first set of macros that are the <b>TARGET_IS_TM4C*</b> which are used to define the class of part in use by the application. The second option is to specify the exact part that the application is using by defining one of the <b>PART_&lt;partno&gt;</b> values. For example, for a board using a TM4C129XNCZAD device the application would define the <b>PART_TM4C129XNCZAD</b> and/or one of the <b>TARGET_IS_TM4C129_*</b> macros depending on the revision of the device that is in use by the application. This conditional mapping of the interrupts allows applications to use a common name for the interrupt numbers without having to look up the actual interrupt number. </p><dl class="section note"><dt>Note</dt><dd>The <b>TARGET_IS_TM4C*</b> and <b>PART_&lt;partno&gt;</b> macros also control ROM and pin mapping functions as well. See the rom_direct and the <a class="el" href="group__gpio__api.html#gpio_pin_mapping">GPIO Pin Configuration</a> sections of this document for more details on how these defines are used by these modules.</dd></dl>
<p>The valid interrupt for the interrupt API functions are the following: <b><b>INT_ADC0SS0</b>,</b> <b><b>INT_ADC0SS1</b>,</b> <b>INT_ADC0SS2</b>, <b>INT_ADC0SS3</b>, <b>INT_ADC1SS0</b>, <b>INT_ADC1SS1</b>, <b>INT_ADC1SS2</b>, <b>INT_ADC1SS3</b>, <b>INT_AES0</b>, <b>INT_CAN0</b>, <b>INT_CAN1</b>, <b>INT_CIR0</b>, <b>INT_COMP0</b>, <b>INT_COMP1</b>, <b>INT_COMP2</b>, <b>INT_DES0</b>, <b>INT_EMAC0</b>, <b>INT_EPI0</b>, <b>INT_FAN0</b>, <b>INT_FAN1</b>, <b>INT_FLASH</b>, <b>INT_GPIOA</b>, <b>INT_GPIOB</b>, <b>INT_GPIOC</b>, <b>INT_GPIOD</b>, <b>INT_GPIOE</b>, <b>INT_GPIOF</b>, <b>INT_GPIOG</b>, <b>INT_GPIOH</b>, <b>INT_GPIOJ</b>, <b>INT_GPIOK</b>, <b>INT_GPIOL</b>, <b>INT_GPIOM</b>, <b>INT_GPION</b>, <b>INT_GPIOP0</b>, <b>INT_GPIOP1</b>, <b>INT_GPIOP2</b>, <b>INT_GPIOP3</b>, <b>INT_GPIOP4</b>, <b>INT_GPIOP5</b>, <b>INT_GPIOP6</b>, <b>INT_GPIOP7</b>, <b>INT_GPIOQ0</b>, <b>INT_GPIOQ1</b>, <b>INT_GPIOQ2</b>, <b>INT_GPIOQ3</b>, <b>INT_GPIOQ4</b>, <b>INT_GPIOQ5</b>, <b>INT_GPIOQ6</b>, <b>INT_GPIOQ7</b>, <b>INT_GPIOR</b>, <b>INT_GPIOS</b>, <b>INT_GPIOT</b>, <b>INT_HIBERNATE</b>, <b>INT_I2C0</b>, <b>INT_I2C1</b>, <b>INT_I2C2</b>, <b>INT_I2C3</b>, <b>INT_I2C4</b>, <b>INT_I2C5</b>, <b>INT_I2C6</b>, <b>INT_I2C7</b>, <b>INT_I2C8</b>, <b>INT_I2C9</b>, <b>INT_KBSCAN0</b>, <b>INT_LCD0</b>, <b>INT_LED0</b>, <b>INT_LPC0</b>, <b>INT_ONEWIRE0</b>, <b>INT_PECI0</b>, <b>INT_PRB0</b>, <b>INT_PS20</b>, <b>INT_PWM0_0</b>, <b>INT_PWM0_1</b>, <b>INT_PWM0_2</b>, <b>INT_PWM0_3</b>, <b>INT_PWM0_FAULT</b>, <b>INT_PWM1_0</b>, <b>INT_PWM1_1</b>, <b>INT_PWM1_2</b>, <b>INT_PWM1_3</b>, <b>INT_PWM1_FAULT</b>, <b>INT_QEI0</b>, <b>INT_QEI1</b>, <b>INT_RTS0</b>, <b>INT_SHA0</b>, <b>INT_SSI0</b>, <b>INT_SSI1</b>, <b>INT_SSI2</b>, <b>INT_SSI3</b>, <b>INT_SYSCTL</b>, <b>INT_SYSEXC</b>, <b>INT_TAMPER0</b>, <b>INT_TIMER0A</b>, <b>INT_TIMER0B</b>, <b>INT_TIMER1A</b>, <b>INT_TIMER1B</b>, <b>INT_TIMER2A</b>, <b>INT_TIMER2B</b>, <b>INT_TIMER3A</b>, <b>INT_TIMER3B</b>, <b>INT_TIMER4A</b>, <b>INT_TIMER4B</b>, <b>INT_TIMER5A</b>, <b>INT_TIMER5B</b>, <b>INT_TIMER6A</b>, <b>INT_TIMER6B</b>, <b>INT_TIMER7A</b>, <b>INT_TIMER7B</b>, <b>INT_UART0</b>, <b>INT_UART1</b>, <b>INT_UART2</b>, <b>INT_UART3</b>, <b>INT_UART4</b>, <b>INT_UART5</b>, <b>INT_UART6</b>, <b>INT_UART7</b>, <b>INT_UDMA</b>, <b>INT_UDMAERR</b>, <b>INT_USB0</b>, <b>INT_WATCHDOG</b>, <b>INT_WTIMER0A</b>, <b>INT_WTIMER0B</b>, <b>INT_WTIMER1A</b>, <b>INT_WTIMER1B</b>, <b>INT_WTIMER2A</b>, <b>INT_WTIMER2B</b>, <b>INT_WTIMER3A</b>, <b>INT_WTIMER3B</b>, <b>INT_WTIMER4A</b>, <b>INT_WTIMER4B</b>, <b>INT_WTIMER5A</b>, <b>INT_WTIMER5B</b> </p>
<h1><a class="anchor" id="interrupt_example"></a>
Programming Example</h1>
<p>The following example shows how to use the Interrupt Controller API to register an interrupt handler for UART 0 and enable the interrupt.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The interrupt handler function.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> IntHandler(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Register the interrupt handler function for UART 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister</a>(<a class="code" href="interrupt_8h.html#a8625252972b3e98e500d36c67df3dbd2">INT_UART0</a>, IntHandler);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable the interrupt for UART 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a>(<a class="code" href="interrupt_8h.html#a8625252972b3e98e500d36c67df3dbd2">INT_UART0</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable UART 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="interrupt_8h.html#a8321cf21088e200350d36827ecc6dad3">IntMasterEnable</a>();</div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8b9ae71d2ea53a231841b41414acf1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b9ae71d2ea53a231841b41414acf1ec">&sect;&nbsp;</a></span>NUM_INTERRUPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_INTERRUPTS&#160;&#160;&#160;155</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>, <a class="el" href="group__interrupt__api.html#ga2c8b044169061f80ea2a2d11af591d18">IntIsEnabled()</a>, <a class="el" href="group__interrupt__api.html#gab708e168ca0f1f554bb141e5b0fd1bdc">IntPendClear()</a>, <a class="el" href="group__interrupt__api.html#gafe17b56764bff1bcb95bd53acde4ac98">IntPendSet()</a>, <a class="el" href="group__interrupt__api.html#gac6a7849e23f4a84c1bcaad2e9bcc27b2">IntPriorityGet()</a>, <a class="el" href="group__interrupt__api.html#ga0432ddf52557352ac987f7dd211c2017">IntPrioritySet()</a>, <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>, <a class="el" href="group__interrupt__api.html#ga374a8725d31b31ed8f10b1609fe05f64">IntTrigger()</a>, and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae3724c6b65b8461cf0441f09b13fadf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3724c6b65b8461cf0441f09b13fadf5">&sect;&nbsp;</a></span>IntMasterDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IntMasterDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the processor interrupt.</p>
<p>This function prevents the processor from receiving interrupts. This function does not affect the set of interrupts enabled in the interrupt controller; it just gates the single interrupt from the controller to the processor.</p>
<dl class="section note"><dt>Note</dt><dd>Previously, this function had no return value. As such, it was possible to include <code><a class="el" href="interrupt_8h.html">interrupt.h</a></code> and call this function without having included <code><a class="el" href="types_8h.html">types.h</a></code>. Now that the return is a <code>bool</code>, a compiler error occurs in this case. The solution is to include <code><a class="el" href="types_8h.html">types.h</a></code> before including <code><a class="el" href="interrupt_8h.html">interrupt.h</a></code>.</dd></dl>
<p><b>Example:</b> Disable interrupts to the processor.</p>
<pre class="fragment">//! //
//! // Disable interrupts to the processor.
//! //
//! IntMasterDisable();
//!
//! </pre> <pre class="fragment">\return Returns \b true if interrupts were already disabled when the
function was called or \b false if they were initially enabled.  </pre> 
<p>References <a class="el" href="cpu_8h.html#a491d851c4f7fff1f9f66aa778b0671b0">CPUcpsid()</a>.</p>

</div>
</div>
<a id="ga0a32aafea7f4904d2a64ee18b45f96c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a32aafea7f4904d2a64ee18b45f96c9">&sect;&nbsp;</a></span>IntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a function to be called when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to specify the handler function to be called when the given interrupt is asserted to the processor. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h header file. When the interrupt occurs, if it is enabled (via <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>), the handler function is called in interrupt context. Because the handler function can preempt other code, care must be taken to protect memory or peripherals that are accessed by the handler and other non-handler code.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this function (directly or indirectly via a peripheral driver interrupt register function) moves the interrupt vector table from flash to SRAM. Therefore, care must be taken when linking the application to ensure that the SRAM vector table is located at the beginning of SRAM; otherwise the NVIC does not look in the correct portion of memory for the vector table (it requires the vector table be on a 1 kB memory alignment). Normally, the SRAM vector table is so placed via the use of linker scripts. See the discussion of compile-time versus run-time interrupt handler registration in the introduction to this chapter.</dd></dl>
<p><b>Example:</b> Set the UART 0 interrupt handler.</p>
<pre class="fragment">//!
//! //
//! // UART 0 interrupt handler.
//! //
//! void
//! UART0Handler(void)
//! {
//!     //
//!     // Handle interrupt.
//!     //
//! }
//!
//! //
//! // Set the UART 0 interrupt handler.
//! //
//! IntRegister(INT_UART0, UART0Handler);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, and <a class="el" href="hw__nvic_8h.html#a8028743cd542dca6de67524512f015b0">NVIC_VTABLE</a>.</p>

<p>Referenced by <a class="el" href="group__aes__api.html#ga99b80df7ba8623ba6203ff8d034dedbf">AESIntRegister()</a>, <a class="el" href="group__comp__api.html#gafcdc39f74f8e19ad43a7538610658052">ComparatorIntRegister()</a>, <a class="el" href="group__des__api.html#ga6e60ca0b3f52903602f68d0cb6f11a9d">DESIntRegister()</a>, <a class="el" href="group__emac__api.html#gac81628900772eda30e2865a84e09cdf6">EMACIntRegister()</a>, <a class="el" href="group__flash__api.html#gadc9618455a71ab80e02dd0139a30767b">FlashIntRegister()</a>, <a class="el" href="group__lcd__api.html#gae412fc5b3e3629aa802702a03f4832ab">LCDIntRegister()</a>, <a class="el" href="group__mpu__api.html#ga5f391e2bed9919c3e98ee744d76a5a03">MPUIntRegister()</a>, <a class="el" href="group__shamd5__api.html#ga8ee0bdcd3aa789319379904cad13696e">SHAMD5IntRegister()</a>, <a class="el" href="group__sysctl__api.html#gaad3caf3c0e7eddea266b7dc2fcb121c4">SysCtlIntRegister()</a>, <a class="el" href="group__systick__api.html#ga4921bef366ee31ca37ef271abecedcb5">SysTickIntRegister()</a>, <a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister()</a>, and <a class="el" href="group__watchdog__api.html#gad743a6df21f37bbea0e338cc8875f374">WatchdogIntRegister()</a>.</p>

</div>
</div>
<a id="ga5dffc81c27c005f83e9bfc30f775982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dffc81c27c005f83e9bfc30f775982a">&sect;&nbsp;</a></span>IntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the function to be called when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to indicate that no handler is called when the given interrupt is asserted to the processor. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h header file. The interrupt source is automatically disabled (via <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>) if necessary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<p><b>Example:</b> Reset the UART 0 interrupt handler to the default handler.</p>
<pre class="fragment">//! //
//! // Reset the UART 0 interrupt handler to the default handler.
//! //
//! IntUnregister(INT_UART0);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>.</p>

<p>Referenced by <a class="el" href="group__aes__api.html#ga7a007590d2a9f0230b5359688b993121">AESIntUnregister()</a>, <a class="el" href="group__comp__api.html#ga2f09273a900189fba243cab582314298">ComparatorIntUnregister()</a>, <a class="el" href="group__des__api.html#ga77f532e796549d09d96d7be8d7c71e37">DESIntUnregister()</a>, <a class="el" href="group__emac__api.html#ga9d5cb58f12b3cb787e6d796f47bb6f30">EMACIntUnregister()</a>, <a class="el" href="group__flash__api.html#gaeeef7616c7db14cc8f1b21de1a777e10">FlashIntUnregister()</a>, <a class="el" href="group__lcd__api.html#gac698e23988f25c86d9062665c4b94324">LCDIntUnregister()</a>, <a class="el" href="group__mpu__api.html#ga8bd36f9796c8a112476a11f381cd5c90">MPUIntUnregister()</a>, <a class="el" href="group__shamd5__api.html#ga08724045a2ee9a0faf622073c00eb936">SHAMD5IntUnregister()</a>, <a class="el" href="group__sysctl__api.html#ga96fa0579c653617672244b6a280d9897">SysCtlIntUnregister()</a>, <a class="el" href="group__systick__api.html#ga606359e78b226889129995cf4f59ce09">SysTickIntUnregister()</a>, <a class="el" href="group__udma__api.html#ga8728732286c8948fd715e58ca04dbd84">uDMAIntUnregister()</a>, and <a class="el" href="group__watchdog__api.html#ga8a198841d216eaa089a484366d602cc7">WatchdogIntUnregister()</a>.</p>

</div>
</div>
<a id="ga341c2244311b2c8c84b0a5546fc3dff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga341c2244311b2c8c84b0a5546fc3dff1">&sect;&nbsp;</a></span>IntPriorityGroupingSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntPriorityGroupingSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority grouping of the interrupt controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Bits</td><td>specifies the number of bits of preemptable priority.</td></tr>
  </table>
  </dd>
</dl>
<p>This function specifies the split between preemptable priority levels and sub-priority levels in the interrupt priority specification. Three bits are available for hardware interrupt prioritization and therefore priority grouping values of three through seven have the same effect.</p>
<p><b>Example:</b> Set the priority grouping for the interrupt controller.</p>
<pre class="fragment">//! //
//! // Set the priority grouping for the interrupt controller to 2 bits.
//! //
//! IntPriorityGroupingSet(2);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="interrupt_8h.html#ac0a9734579ab6ac9baa33177ea0abbcd">NUM_PRIORITY</a>, <a class="el" href="hw__nvic_8h.html#a4b8063473ed37bbc7f9a41da65b9c2ad">NVIC_APINT</a>, and <a class="el" href="hw__nvic_8h.html#ab4aac1a401683ddc647b4bd27d6c1e07">NVIC_APINT_VECTKEY</a>.</p>

</div>
</div>
<a id="ga86595146bc7ea51280d5abbb45fcf02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86595146bc7ea51280d5abbb45fcf02a">&sect;&nbsp;</a></span>IntPriorityGroupingGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntPriorityGroupingGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the priority grouping of the interrupt controller.</p>
<p>This function returns the split between preemptable priority levels and sub-priority levels in the interrupt priority specification.</p>
<p><b>Example:</b> Get the priority grouping for the interrupt controller.</p>
<pre class="fragment">//! //
//! // Get the priority grouping for the interrupt controller.
//! //
//! IntPriorityGroupingGet();
//!
//! </pre> <pre class="fragment">\return The number of bits of preemptable priority.  </pre> 
<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="interrupt_8h.html#ac0a9734579ab6ac9baa33177ea0abbcd">NUM_PRIORITY</a>, <a class="el" href="hw__nvic_8h.html#a4b8063473ed37bbc7f9a41da65b9c2ad">NVIC_APINT</a>, and <a class="el" href="hw__nvic_8h.html#a4970dfbcacaf8173985203c951f60288">NVIC_APINT_PRIGROUP_M</a>.</p>

</div>
</div>
<a id="ga0432ddf52557352ac987f7dd211c2017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0432ddf52557352ac987f7dd211c2017">&sect;&nbsp;</a></span>IntPrioritySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntPrioritySet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">ui8Priority</td><td>specifies the priority of the interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set the priority of an interrupt. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h header file. The <em>ui8Priority</em> parameter specifies the interrupts hardware priority level of the interrupt in the interrupt controller. When multiple interrupts are asserted simultaneously, the ones with the highest priority are processed before the lower priority interrupts. Smaller numbers correspond to higher interrupt priorities; priority 0 is the highest interrupt priority.</p>
<dl class="section note"><dt>Note</dt><dd>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits. The remaining bits can be used to sub-prioritize the interrupt sources, and may be used by the hardware priority mechanism. This arrangement allows priorities to migrate to different NVIC implementations without changing the gross prioritization of the interrupts.</dd></dl>
<p><b>Example:</b> Set priorities for UART 0 and USB interrupts.</p>
<pre class="fragment">//! //
//! // Set the UART 0 interrupt priority to the lowest priority.
//! //
//! IntPrioritySet(INT_UART0, 0xE0);
//!
//! //
//! // Set the USB 0 interrupt priority to the highest priority.
//! //
//! IntPrioritySet(INT_USB0, 0);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>.</p>

</div>
</div>
<a id="gac6a7849e23f4a84c1bcaad2e9bcc27b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a7849e23f4a84c1bcaad2e9bcc27b2">&sect;&nbsp;</a></span>IntPriorityGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IntPriorityGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the priority of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the priority of an interrupt. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h header file. See <a class="el" href="group__interrupt__api.html#ga0432ddf52557352ac987f7dd211c2017">IntPrioritySet()</a> for a full definition of the priority value.</p>
<p><b>Example:</b> Get the current UART 0 interrupt priority.</p>
<pre class="fragment">//! //
//! // Get the current UART 0 interrupt priority.
//! //
//! IntPriorityGet(INT_UART0);
//!
//! </pre> <pre class="fragment">\return Returns the interrupt priority for the given interrupt.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>.</p>

</div>
</div>
<a id="ga49fc9c3d1a0f8c42a20249f8c5d360ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49fc9c3d1a0f8c42a20249f8c5d360ce">&sect;&nbsp;</a></span>IntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is enabled in the interrupt controller. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h header file. Other enables for the interrupt (such as at the peripheral level) are unaffected by this function.</p>
<p><b>Example:</b> Enable the UART 0 interrupt.</p>
<pre class="fragment">//! //
//! // Enable the UART 0 interrupt in the interrupt controller.
//! //
//! IntEnable(INT_UART0);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#a7a1eb1756e8cb3daef28e32700dc1af8">FAULT_BUS</a>, <a class="el" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>, <a class="el" href="interrupt_8h.html#a1e5182e81ff1f65efe91eb68228944df">FAULT_SYSTICK</a>, <a class="el" href="interrupt_8h.html#a5c057879273f43117ddfab32e2d38362">FAULT_USAGE</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, <a class="el" href="hw__nvic_8h.html#a767bbd2f329184ac62b26b3882a4590b">NVIC_ST_CTRL</a>, <a class="el" href="hw__nvic_8h.html#aff514c40eb9dcd7438077ec36b184b32">NVIC_ST_CTRL_INTEN</a>, <a class="el" href="hw__nvic_8h.html#a529f8f0eef63e12214fdd2c723a3d155">NVIC_SYS_HND_CTRL</a>, <a class="el" href="hw__nvic_8h.html#ab0a76135c843e96d0a0046fc38f4b135">NVIC_SYS_HND_CTRL_BUS</a>, <a class="el" href="hw__nvic_8h.html#a5a4d437f8a73736037b35f2a26ae31a7">NVIC_SYS_HND_CTRL_MEM</a>, and <a class="el" href="hw__nvic_8h.html#a4404ef076d28cc5184330ff925aed0fe">NVIC_SYS_HND_CTRL_USAGE</a>.</p>

<p>Referenced by <a class="el" href="group__aes__api.html#ga99b80df7ba8623ba6203ff8d034dedbf">AESIntRegister()</a>, <a class="el" href="group__comp__api.html#gafcdc39f74f8e19ad43a7538610658052">ComparatorIntRegister()</a>, <a class="el" href="group__des__api.html#ga6e60ca0b3f52903602f68d0cb6f11a9d">DESIntRegister()</a>, <a class="el" href="group__emac__api.html#gac81628900772eda30e2865a84e09cdf6">EMACIntRegister()</a>, <a class="el" href="group__flash__api.html#gadc9618455a71ab80e02dd0139a30767b">FlashIntRegister()</a>, <a class="el" href="group__lcd__api.html#gae412fc5b3e3629aa802702a03f4832ab">LCDIntRegister()</a>, <a class="el" href="group__mpu__api.html#ga5f391e2bed9919c3e98ee744d76a5a03">MPUIntRegister()</a>, <a class="el" href="group__shamd5__api.html#ga8ee0bdcd3aa789319379904cad13696e">SHAMD5IntRegister()</a>, <a class="el" href="group__sysctl__api.html#gaad3caf3c0e7eddea266b7dc2fcb121c4">SysCtlIntRegister()</a>, <a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister()</a>, and <a class="el" href="group__watchdog__api.html#gad743a6df21f37bbea0e338cc8875f374">WatchdogIntRegister()</a>.</p>

</div>
</div>
<a id="ga9af6b00884dc44e92b3d05ff821b5334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9af6b00884dc44e92b3d05ff821b5334">&sect;&nbsp;</a></span>IntDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is disabled in the interrupt controller. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in <a class="el" href="interrupt_8h.html">interrupt.h</a>. Other enables for the interrupt (such as at the peripheral level) are unaffected by this function.</p>
<p><b>Example:</b> Disable the UART 0 interrupt.</p>
<pre class="fragment">//! //
//! // Disable the UART 0 interrupt in the interrupt controller.
//! //
//! IntDisable(INT_UART0);
//!
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#a7a1eb1756e8cb3daef28e32700dc1af8">FAULT_BUS</a>, <a class="el" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>, <a class="el" href="interrupt_8h.html#a1e5182e81ff1f65efe91eb68228944df">FAULT_SYSTICK</a>, <a class="el" href="interrupt_8h.html#a5c057879273f43117ddfab32e2d38362">FAULT_USAGE</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, <a class="el" href="hw__nvic_8h.html#a767bbd2f329184ac62b26b3882a4590b">NVIC_ST_CTRL</a>, <a class="el" href="hw__nvic_8h.html#aff514c40eb9dcd7438077ec36b184b32">NVIC_ST_CTRL_INTEN</a>, <a class="el" href="hw__nvic_8h.html#a529f8f0eef63e12214fdd2c723a3d155">NVIC_SYS_HND_CTRL</a>, <a class="el" href="hw__nvic_8h.html#ab0a76135c843e96d0a0046fc38f4b135">NVIC_SYS_HND_CTRL_BUS</a>, <a class="el" href="hw__nvic_8h.html#a5a4d437f8a73736037b35f2a26ae31a7">NVIC_SYS_HND_CTRL_MEM</a>, and <a class="el" href="hw__nvic_8h.html#a4404ef076d28cc5184330ff925aed0fe">NVIC_SYS_HND_CTRL_USAGE</a>.</p>

<p>Referenced by <a class="el" href="group__aes__api.html#ga7a007590d2a9f0230b5359688b993121">AESIntUnregister()</a>, <a class="el" href="group__comp__api.html#ga2f09273a900189fba243cab582314298">ComparatorIntUnregister()</a>, <a class="el" href="group__des__api.html#ga77f532e796549d09d96d7be8d7c71e37">DESIntUnregister()</a>, <a class="el" href="group__emac__api.html#ga9d5cb58f12b3cb787e6d796f47bb6f30">EMACIntUnregister()</a>, <a class="el" href="group__flash__api.html#gaeeef7616c7db14cc8f1b21de1a777e10">FlashIntUnregister()</a>, <a class="el" href="group__lcd__api.html#gac698e23988f25c86d9062665c4b94324">LCDIntUnregister()</a>, <a class="el" href="group__mpu__api.html#ga8bd36f9796c8a112476a11f381cd5c90">MPUIntUnregister()</a>, <a class="el" href="group__shamd5__api.html#ga08724045a2ee9a0faf622073c00eb936">SHAMD5IntUnregister()</a>, <a class="el" href="group__sysctl__api.html#ga96fa0579c653617672244b6a280d9897">SysCtlIntUnregister()</a>, <a class="el" href="group__udma__api.html#ga8728732286c8948fd715e58ca04dbd84">uDMAIntUnregister()</a>, and <a class="el" href="group__watchdog__api.html#ga8a198841d216eaa089a484366d602cc7">WatchdogIntUnregister()</a>.</p>

</div>
</div>
<a id="ga2c8b044169061f80ea2a2d11af591d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8b044169061f80ea2a2d11af591d18">&sect;&nbsp;</a></span>IntIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if a peripheral interrupt is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks if the specified interrupt is enabled in the interrupt controller. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in <a class="el" href="interrupt_8h.html">interrupt.h</a>.</p>
<p><b>Example:</b> Disable the UART 0 interrupt if it is enabled.</p>
<pre class="fragment">//! //
//! // Disable the UART 0 interrupt if it is enabled.
//! //
//! if(IntIsEnabled(INT_UART0))
//! {
//!     IntDisable(INT_UART0);
//! }
//! </pre> <pre class="fragment">\return A non-zero value if the interrupt is enabled.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#a7a1eb1756e8cb3daef28e32700dc1af8">FAULT_BUS</a>, <a class="el" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>, <a class="el" href="interrupt_8h.html#a1e5182e81ff1f65efe91eb68228944df">FAULT_SYSTICK</a>, <a class="el" href="interrupt_8h.html#a5c057879273f43117ddfab32e2d38362">FAULT_USAGE</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, <a class="el" href="hw__nvic_8h.html#a767bbd2f329184ac62b26b3882a4590b">NVIC_ST_CTRL</a>, <a class="el" href="hw__nvic_8h.html#aff514c40eb9dcd7438077ec36b184b32">NVIC_ST_CTRL_INTEN</a>, <a class="el" href="hw__nvic_8h.html#a529f8f0eef63e12214fdd2c723a3d155">NVIC_SYS_HND_CTRL</a>, <a class="el" href="hw__nvic_8h.html#ab0a76135c843e96d0a0046fc38f4b135">NVIC_SYS_HND_CTRL_BUS</a>, <a class="el" href="hw__nvic_8h.html#a5a4d437f8a73736037b35f2a26ae31a7">NVIC_SYS_HND_CTRL_MEM</a>, and <a class="el" href="hw__nvic_8h.html#a4404ef076d28cc5184330ff925aed0fe">NVIC_SYS_HND_CTRL_USAGE</a>.</p>

</div>
</div>
<a id="gafe17b56764bff1bcb95bd53acde4ac98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe17b56764bff1bcb95bd53acde4ac98">&sect;&nbsp;</a></span>IntPendSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntPendSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pends an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to be pended.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is pended in the interrupt controller. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in <a class="el" href="interrupt_8h.html">interrupt.h</a>. Pending an interrupt causes the interrupt controller to execute the corresponding interrupt handler at the next available time, based on the current interrupt state priorities. For example, if called by a higher priority interrupt handler, the specified interrupt handler is not called until after the current interrupt handler has completed execution. The interrupt must have been enabled for it to be called.</p>
<p><b>Example:</b> Pend a UART 0 interrupt.</p>
<pre class="fragment">//! //
//! // Pend a UART 0 interrupt.
//! //
//! IntPendSet(INT_UART0);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#a430fa0c657a0d4550c893bf9a4f32e85">FAULT_NMI</a>, <a class="el" href="interrupt_8h.html#ae25ed9ac134da15fc8622911d0ac1905">FAULT_PENDSV</a>, <a class="el" href="interrupt_8h.html#a1e5182e81ff1f65efe91eb68228944df">FAULT_SYSTICK</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, <a class="el" href="hw__nvic_8h.html#afa1ca44ad548bf5bfa2f19d7438c722a">NVIC_INT_CTRL</a>, <a class="el" href="hw__nvic_8h.html#aea4f67673295ceba8609abe489788bef">NVIC_INT_CTRL_NMI_SET</a>, <a class="el" href="hw__nvic_8h.html#adc34fec0a6c793ea5aca1b48068f1c52">NVIC_INT_CTRL_PEND_SV</a>, and <a class="el" href="hw__nvic_8h.html#a0c3615140497bf7fd853e4d16be4abe1">NVIC_INT_CTRL_PENDSTSET</a>.</p>

</div>
</div>
<a id="gab708e168ca0f1f554bb141e5b0fd1bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab708e168ca0f1f554bb141e5b0fd1bdc">&sect;&nbsp;</a></span>IntPendClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntPendClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Un-pends an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to be un-pended. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in <a class="el" href="interrupt_8h.html">interrupt.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is un-pended in the interrupt controller. This causes any previously generated interrupts that have not been handled yet (due to higher priority interrupts or the interrupt not having been enabled yet) to be discarded.</p>
<p><b>Example:</b> Un-pend a UART 0 interrupt.</p>
<pre class="fragment">//! //
//! // Un-pend a UART 0 interrupt.
//! //
//! IntPendClear(INT_UART0);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#ae25ed9ac134da15fc8622911d0ac1905">FAULT_PENDSV</a>, <a class="el" href="interrupt_8h.html#a1e5182e81ff1f65efe91eb68228944df">FAULT_SYSTICK</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, <a class="el" href="hw__nvic_8h.html#afa1ca44ad548bf5bfa2f19d7438c722a">NVIC_INT_CTRL</a>, <a class="el" href="hw__nvic_8h.html#a4a5cc3e098ba46d4ab4715e8be3a6526">NVIC_INT_CTRL_PENDSTCLR</a>, and <a class="el" href="hw__nvic_8h.html#a3482a7e3189d5c4d133935045c9a9150">NVIC_INT_CTRL_UNPEND_SV</a>.</p>

</div>
</div>
<a id="ga61b8f34d64c588f632509406b50e4f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b8f34d64c588f632509406b50e4f68">&sect;&nbsp;</a></span>IntPriorityMaskSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntPriorityMaskSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PriorityMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority masking level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32PriorityMask</td><td>is the priority level that is masked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the interrupt priority masking level so that all interrupts at the specified or lesser priority level are masked. Masking interrupts can be used to globally disable a set of interrupts with priority below a predetermined threshold. A value of 0 disables priority masking.</p>
<p>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.</p>
<dl class="section note"><dt>Note</dt><dd>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</dd></dl>
<p><b>Example:</b> Mask of interrupt priorities greater than or equal to 0x80.</p>
<pre class="fragment">//! //
//! // Mask of interrupt priorities greater than or equal to 0x80.
//! //
//! IntPriorityMaskSet(0x80);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="cpu_8h.html#a9168443ccbf784e3f1280615440d8cac">CPUbasepriSet()</a>.</p>

</div>
</div>
<a id="gad39b7d4927274abf42c57767218af279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39b7d4927274abf42c57767218af279">&sect;&nbsp;</a></span>IntPriorityMaskGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntPriorityMaskGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the priority masking level</p>
<p>This function gets the current setting of the interrupt priority masking level. The value returned is the priority level such that all interrupts of that and lesser priority are masked. A value of 0 means that priority masking is disabled.</p>
<p>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.</p>
<p>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</p>
<p><b>Example:</b> Get the current interrupt priority mask.</p>
<pre class="fragment">//! //
//! // Get the current interrupt priority mask.
//! //
//! IntPriorityMaskGet();
//! </pre> <pre class="fragment">\return Returns the value of the interrupt priority level mask.  </pre> 
<p>References <a class="el" href="cpu_8h.html#a31fd39ee16277d1a44ab2b0e57afa958">CPUbasepriGet()</a>.</p>

</div>
</div>
<a id="ga374a8725d31b31ed8f10b1609fe05f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374a8725d31b31ed8f10b1609fe05f64">&sect;&nbsp;</a></span>IntTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Interrupt</td><td>specifies the interrupt to be triggered.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a software trigger of an interrupt. The <em>ui32Interrupt</em> parameter must be one of the valid <b>INT_*</b> values listed in <a class="el" href="interrupt_8h.html">interrupt.h</a>. The interrupt controller behaves as if the corresponding interrupt line was asserted, and the interrupt is handled in the same manner (meaning that it must be enabled in order to be processed, and the processing is based on its priority with respect to other unhandled interrupts).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="group__interrupt__api.html#ga8b9ae71d2ea53a231841b41414acf1ec">NUM_INTERRUPTS</a>, and <a class="el" href="hw__nvic_8h.html#aff93a807f44930ad5cc13c5d9cf58b82">NVIC_SW_TRIG</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
