<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Mpu_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mpu_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16c52787707bbfe428269741396cd79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga16c52787707bbfe428269741396cd79d">MPUEnable</a> (uint32_t ui32MPUConfig)</td></tr>
<tr class="separator:ga16c52787707bbfe428269741396cd79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98f222992a05f9a0feae96f933dd69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#gae98f222992a05f9a0feae96f933dd69d">MPUDisable</a> (void)</td></tr>
<tr class="separator:gae98f222992a05f9a0feae96f933dd69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga682b0d081b78b73e14fa4d540291fb7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga682b0d081b78b73e14fa4d540291fb7e">MPURegionCountGet</a> (void)</td></tr>
<tr class="separator:ga682b0d081b78b73e14fa4d540291fb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17918fcd1ac15cb5456d7ae3ad388aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga17918fcd1ac15cb5456d7ae3ad388aaa">MPURegionEnable</a> (uint32_t ui32Region)</td></tr>
<tr class="separator:ga17918fcd1ac15cb5456d7ae3ad388aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b1830b3d7ee909ee8a21a267df5164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga36b1830b3d7ee909ee8a21a267df5164">MPURegionDisable</a> (uint32_t ui32Region)</td></tr>
<tr class="separator:ga36b1830b3d7ee909ee8a21a267df5164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6134864a66eb0a110320fc98a49c8c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a> (uint32_t ui32Region, uint32_t ui32Addr, uint32_t ui32Flags)</td></tr>
<tr class="separator:ga6134864a66eb0a110320fc98a49c8c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197e3c9b41e6f05cf91ee618678dea89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga197e3c9b41e6f05cf91ee618678dea89">MPURegionGet</a> (uint32_t ui32Region, uint32_t *pui32Addr, uint32_t *pui32Flags)</td></tr>
<tr class="separator:ga197e3c9b41e6f05cf91ee618678dea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f391e2bed9919c3e98ee744d76a5a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga5f391e2bed9919c3e98ee744d76a5a03">MPUIntRegister</a> (void(*pfnHandler)(void))</td></tr>
<tr class="separator:ga5f391e2bed9919c3e98ee744d76a5a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd36f9796c8a112476a11f381cd5c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpu__api.html#ga8bd36f9796c8a112476a11f381cd5c90">MPUIntUnregister</a> (void)</td></tr>
<tr class="separator:ga8bd36f9796c8a112476a11f381cd5c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="mpu_intro"></a>
Introduction</h1>
<p>The Memory Protection Unit (MPU) API provides functions to configure the MPU. The MPU is tightly coupled to the Cortex-M processor core and provides a means to establish access permissions on regions of memory.</p>
<p>Up to eight memory regions can be defined. Each region has a base address and a size. The size is specified as a power of 2 between 32 bytes and 4 GB, inclusive. The region's base address must be aligned to the size of the region. Each region also has access permissions. Code execution can be allowed or disallowed for a region. A region can be configured for read-only access, read/write access, or no access for both privileged and user modes. Access permissions can be used to create an environment where only kernel or system code can access certain hardware registers or sections of code.</p>
<p>The MPU creates 8 sub-regions within each region. Any sub-region or combination of sub-regions can be disabled, allowing creation of ``holes'' or complex overlaying regions with different permissions. The sub-regions can also be used to create an unaligned beginning or ending of a region by disabling one or more of the leading or trailing sub-regions.</p>
<p>Once the regions are defined and the MPU is enabled, any access violation of a region causes a memory management fault, and the fault handler is activated.</p>
<h1><a class="anchor" id="mpu_api_functions"></a>
API Functions</h1>
<p>The MPU APIs provide a means to enable and configure the MPU and memory protection regions.</p>
<p>Generally, the memory protection regions should be defined before enabling the MPU. The regions can be configured by calling <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> once for each region to be configured.</p>
<p>A region that is defined by <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> can be initially enabled or disabled. If the region is not initially enabled, it can be enabled later by calling <a class="el" href="group__mpu__api.html#ga17918fcd1ac15cb5456d7ae3ad388aaa">MPURegionEnable()</a>. An enabled region can be disabled by calling <a class="el" href="group__mpu__api.html#ga36b1830b3d7ee909ee8a21a267df5164">MPURegionDisable()</a>. When a region is disabled, its configuration is preserved as long as it is not overwritten. In this case, it can be enabled again with <a class="el" href="group__mpu__api.html#ga17918fcd1ac15cb5456d7ae3ad388aaa">MPURegionEnable()</a> without the need to reconfigure the region.</p>
<p>Care must be taken when setting up a protection region using <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a>. The function writes to multiple registers and is not protected from interrupts. Therefore, it is possible that an interrupt which accesses a region may occur while that region is in the process of being changed. The safest way to protect against this is to make sure that a region is always disabled before making any changes. Otherwise, it is up to the caller to ensure that <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> is always called from within code that cannot be interrupted, or from code that is not be affected if an interrupt occurs while the region attributes are being changed.</p>
<p>The attributes of a region that have already been programmed can be retrieved and saved using the <a class="el" href="group__mpu__api.html#ga197e3c9b41e6f05cf91ee618678dea89">MPURegionGet()</a> function. This function is intended to save the attributes in a format that can be used later to reload the region using the <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> function. Note that the enable state of the region is saved with the attributes and takes effect when the region is reloaded.</p>
<p>When one or more regions are defined, the MPU can be enabled by calling <a class="el" href="group__mpu__api.html#ga16c52787707bbfe428269741396cd79d">MPUEnable()</a>. This function turns on the MPU and also defines the behavior in privileged mode and in the Hard Fault and NMI fault handlers. The MPU can be configured so that when in privileged mode and no regions are enabled, a default memory map is applied. If this feature is not enabled, then a memory management fault is generated if the MPU is enabled and no regions are configured and enabled. The MPU can also be set to use a default memory map when in the Hard Fault or NMI handlers, instead of using the configured regions. All of these features are selected when calling <a class="el" href="group__mpu__api.html#ga16c52787707bbfe428269741396cd79d">MPUEnable()</a>. When the MPU is enabled, it can be disabled by calling <a class="el" href="group__mpu__api.html#gae98f222992a05f9a0feae96f933dd69d">MPUDisable()</a>.</p>
<p>Finally, if the application is using run-time interrupt registration (see <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>), then the function <a class="el" href="group__mpu__api.html#ga5f391e2bed9919c3e98ee744d76a5a03">MPUIntRegister()</a> can be used to install the fault handler which is called whenever a memory protection violation occurs. This function also enables the fault handler. If compile-time interrupt registration is used, then the <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a> function with the parameter <b>FAULT_MPU</b> must be used to enable the memory management fault handler. When the memory management fault handler has been installed with <a class="el" href="group__mpu__api.html#ga5f391e2bed9919c3e98ee744d76a5a03">MPUIntRegister()</a>, it can be removed by calling <a class="el" href="group__mpu__api.html#ga8bd36f9796c8a112476a11f381cd5c90">MPUIntUnregister()</a>.</p>
<h1><a class="anchor" id="mpu_example"></a>
Programming Example</h1>
<p>The following example sets up a basic set of protection regions to provide the following:</p>
<ul>
<li>a 28-KB region in flash for read-only code execution</li>
<li>32 KB of RAM for read-write access in privileged and user modes</li>
<li>an additional 8 KB of RAM for use only in privileged mode</li>
<li>1 MB of peripheral space for access only in privileged mode, except for a 128-KB hole that is not accessible at all, and another 128-KB region that is accessible from user mode</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Define a 28-KB region of flash from 0x00000000 to 0x00007000.  The</span></div><div class="line"><span class="comment">// region is executable, and read-only for both privileged and user</span></div><div class="line"><span class="comment">// modes.  To set up the region, a 32-KB region (#0) is defined</span></div><div class="line"><span class="comment">// starting at address 0, and then a 4 KB hole removed at the end by</span></div><div class="line"><span class="comment">// disabling the last sub-region.  The region is initially enabled.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(0, 0,</div><div class="line">             <a class="code" href="mpu_8h.html#ab59a3e82a7b2f06c6ab50864a73b595e">MPU_RGN_SIZE_32K</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#ae2896afe5f7feefe85651b51d4d69944">MPU_RGN_PERM_EXEC</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a427631e2c24e1d3649215eec1021cf99">MPU_RGN_PERM_PRV_RO_USR_RO</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a9c13383d8ec5ac8650b57d1627072f7d">MPU_SUB_RGN_DISABLE_7</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#aabd353655cb3c7cccaf9737e4148b93e">MPU_RGN_ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Define a 32-KB region (#1) of RAM from 0x20000000 to 0x20008000.  The</span></div><div class="line"><span class="comment">// region is not executable, and is read/write access for</span></div><div class="line"><span class="comment">// privileged and user modes.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(1, 0x20000000,</div><div class="line">             <a class="code" href="mpu_8h.html#ab59a3e82a7b2f06c6ab50864a73b595e">MPU_RGN_SIZE_32K</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a06cf9eafa1fd23006277ae6d07ee7fab">MPU_RGN_PERM_NOEXEC</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#ac944ec4ccba8fd84465b7eccab0ebc2c">MPU_RGN_PERM_PRV_RW_USR_RW</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#aabd353655cb3c7cccaf9737e4148b93e">MPU_RGN_ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Define an additional 8-KB region (#2) in RAM from 0x20008000 to</span></div><div class="line"><span class="comment">// 0x2000A000 that is read/write accessible only from privileged</span></div><div class="line"><span class="comment">// mode.  This region is initially disabled, to be enabled later.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(2, 0x20008000,</div><div class="line">             <a class="code" href="mpu_8h.html#a6ba0a77fc8fc7cc5cb84c0f4cc768f41">MPU_RGN_SIZE_8K</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a06cf9eafa1fd23006277ae6d07ee7fab">MPU_RGN_PERM_NOEXEC</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a04bfe4704e37f7ccf06ab731ccb9b47f">MPU_RGN_PERM_PRV_RW_USR_NO</a>|</div><div class="line">             <a class="code" href="mpu_8h.html#ab8c953720ad67fb7ce33dcdc45b59008">MPU_RGN_DISABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Define a region (#3) in peripheral space from 0x40000000 to 0x40100000</span></div><div class="line"><span class="comment">// (1 MB).  This region is accessible only in privileged mode.  There is</span></div><div class="line"><span class="comment">// an area from 0x40020000 to 0x40040000 that has no peripherals and is not</span></div><div class="line"><span class="comment">// accessible at all.  This inaccessible region is created by disabling the</span></div><div class="line"><span class="comment">// second sub-region(1) and creating a hole.  Further, there is an area</span></div><div class="line"><span class="comment">// from 0x40080000 to 0x400A0000 that should be accessible from user mode</span></div><div class="line"><span class="comment">// as well.  This area is created by disabling the fifth sub-region (4),</span></div><div class="line"><span class="comment">// and overlaying an additional region (#4) in that space with the</span></div><div class="line"><span class="comment">// appropriate permissions.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(3, 0x40000000,</div><div class="line">             <a class="code" href="mpu_8h.html#aef5e1e48090041b770126095906b436c">MPU_RGN_SIZE_1M</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a06cf9eafa1fd23006277ae6d07ee7fab">MPU_RGN_PERM_NOEXEC</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a04bfe4704e37f7ccf06ab731ccb9b47f">MPU_RGN_PERM_PRV_RW_USR_NO</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#af9430b3276f63a8857bd208cf45903ba">MPU_SUB_RGN_DISABLE_1</a> | <a class="code" href="mpu_8h.html#a239088e42d22b57f3e027395dbb815a4">MPU_SUB_RGN_DISABLE_4</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#aabd353655cb3c7cccaf9737e4148b93e">MPU_RGN_ENABLE</a>);</div><div class="line"><a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(4, 0x40080000,</div><div class="line">             <a class="code" href="mpu_8h.html#ab6fe5a71af0a0163afe227209d450e64">MPU_RGN_SIZE_128K</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#a06cf9eafa1fd23006277ae6d07ee7fab">MPU_RGN_PERM_NOEXEC</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#ac944ec4ccba8fd84465b7eccab0ebc2c">MPU_RGN_PERM_PRV_RW_USR_RW</a> |</div><div class="line">             <a class="code" href="mpu_8h.html#aabd353655cb3c7cccaf9737e4148b93e">MPU_RGN_ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// In this example, compile-time registration of interrupts is used, so the</span></div><div class="line"><span class="comment">// handler does not have to be registered.  However, it must be enabled.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a>(<a class="code" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// When setting up the regions, region 2 was initially disabled for some</span></div><div class="line"><span class="comment">// reason.  At some point it must be enabled.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga17918fcd1ac15cb5456d7ae3ad388aaa">MPURegionEnable</a>(2);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Now the MPU is enabled.  It is configured so that a default</span></div><div class="line"><span class="comment">// map is available in privileged mode if no regions are defined.  The MPU</span></div><div class="line"><span class="comment">// is not enabled for the hard fault and NMI handlers, meaning that a</span></div><div class="line"><span class="comment">// default is not used whenever these handlers are active, effectively</span></div><div class="line"><span class="comment">// giving the fault handlers access to all of memory without any</span></div><div class="line"><span class="comment">// protection.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__mpu__api.html#ga16c52787707bbfe428269741396cd79d">MPUEnable</a>(<a class="code" href="mpu_8h.html#a360a7bc66885fa499128e66678531a62">MPU_CONFIG_PRIV_DEFAULT</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// At this point, the MPU is configured and enabled and if any code causes</span></div><div class="line"><span class="comment">// an access violation, the memory management fault occurs.</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>The following example shows how to save and restore region configurations.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The following arrays provide space for saving the address and</span></div><div class="line"><span class="comment">// attributes for 4 region configurations.</span></div><div class="line"><span class="comment">//</span></div><div class="line">uint32_t ui32RegionAddr[4];</div><div class="line">uint32_t ui32RegionAttr[4];</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// At some point in the system code, we want to save the state of 4 regions</span></div><div class="line"><span class="comment">// (0-3).</span></div><div class="line"><span class="comment">//</span></div><div class="line">for(ui8Idx = 0; ui8Idx &lt; 4; ui8Idx++)</div><div class="line">{</div><div class="line">    <a class="code" href="group__mpu__api.html#ga197e3c9b41e6f05cf91ee618678dea89">MPURegionGet</a>(ui8Idx, &amp;ui32RegionAddr[ui8Idx], &amp;ui32RegionAttr[ui8Idx]);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// At some other point, the previously saved regions should be restored.</span></div><div class="line"><span class="comment">//</span></div><div class="line">for(ui8Idx = 0; ui8Idx &lt; 4; ui8Idx++)</div><div class="line">{</div><div class="line">    <a class="code" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet</a>(ui8Idx, ui32RegionAddr[ui8Idx], ui32RegionAttr[ui8Idx]);</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga16c52787707bbfe428269741396cd79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c52787707bbfe428269741396cd79d">&sect;&nbsp;</a></span>MPUEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPUEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MPUConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables and configures the MPU for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32MPUConfig</td><td>is the logical OR of the possible configurations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the Cortex-M memory protection unit. It also configures the default behavior when in privileged mode and while handling a hard fault or NMI. Prior to enabling the MPU, at least one region must be set by calling <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> or else by enabling the default region for privileged mode by passing the <b>MPU_CONFIG_PRIV_DEFAULT</b> flag to <a class="el" href="group__mpu__api.html#ga16c52787707bbfe428269741396cd79d">MPUEnable()</a>. Once the MPU is enabled, a memory management fault is generated for memory access violations.</p>
<p>The <em>ui32MPUConfig</em> parameter should be the logical OR of any of the following:</p>
<ul>
<li><b>MPU_CONFIG_PRIV_DEFAULT</b> enables the default memory map when in privileged mode and when no other regions are defined. If this option is not enabled, then there must be at least one valid region already defined when the MPU is enabled.</li>
<li><b>MPU_CONFIG_HARDFLT_NMI</b> enables the MPU while in a hard fault or NMI exception handler. If this option is not enabled, then the MPU is disabled while in one of these exception handlers and the default memory map is applied.</li>
<li><b>MPU_CONFIG_NONE</b> chooses none of the above options. In this case, no default memory map is provided in privileged mode, and the MPU is not enabled in the fault handlers.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="mpu_8h.html#aecd48948da5ff4d30a1b669bd52575f5">MPU_CONFIG_HARDFLT_NMI</a>, <a class="el" href="mpu_8h.html#a360a7bc66885fa499128e66678531a62">MPU_CONFIG_PRIV_DEFAULT</a>, <a class="el" href="hw__nvic_8h.html#a3ddc77a4059aa9dcb20fbd9f543363a0">NVIC_MPU_CTRL</a>, and <a class="el" href="hw__nvic_8h.html#a22b49b0b74754a9bc96ac110f95b2f45">NVIC_MPU_CTRL_ENABLE</a>.</p>

</div>
</div>
<a id="gae98f222992a05f9a0feae96f933dd69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98f222992a05f9a0feae96f933dd69d">&sect;&nbsp;</a></span>MPUDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPUDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the MPU for use.</p>
<p>This function disables the Cortex-M memory protection unit. When the MPU is disabled, the default memory map is used and memory management faults are not generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a3ddc77a4059aa9dcb20fbd9f543363a0">NVIC_MPU_CTRL</a>, and <a class="el" href="hw__nvic_8h.html#a22b49b0b74754a9bc96ac110f95b2f45">NVIC_MPU_CTRL_ENABLE</a>.</p>

</div>
</div>
<a id="ga682b0d081b78b73e14fa4d540291fb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga682b0d081b78b73e14fa4d540291fb7e">&sect;&nbsp;</a></span>MPURegionCountGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MPURegionCountGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the count of regions supported by the MPU.</p>
<p>This function is used to get the total number of regions that are supported by the MPU, including regions that are already programmed.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of memory protection regions that are available for programming using <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a>. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a7be75ffdc159ad15d871dc79b12a6675">NVIC_MPU_TYPE</a>, <a class="el" href="hw__nvic_8h.html#adf9d1b6341d4d1328a37c0cdc78d160a">NVIC_MPU_TYPE_DREGION_M</a>, and <a class="el" href="hw__nvic_8h.html#a68af7d0238520f4f2fe971bdc91e566b">NVIC_MPU_TYPE_DREGION_S</a>.</p>

</div>
</div>
<a id="ga17918fcd1ac15cb5456d7ae3ad388aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17918fcd1ac15cb5456d7ae3ad388aaa">&sect;&nbsp;</a></span>MPURegionEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPURegionEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a specific region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Region</td><td>is the region number to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to enable a memory protection region. The region should already be configured with the <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> function. Once enabled, the memory protection rules of the region are applied and access violations cause a memory management fault.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a27fcd26de5ff56333143e9d4e48c2198">NVIC_MPU_ATTR</a>, <a class="el" href="hw__nvic_8h.html#aeda7a9221dedae07f1b41a94e5db8d76">NVIC_MPU_ATTR_ENABLE</a>, and <a class="el" href="hw__nvic_8h.html#ade051e0e6b4c898e3488eb39bfaae129">NVIC_MPU_NUMBER</a>.</p>

</div>
</div>
<a id="ga36b1830b3d7ee909ee8a21a267df5164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36b1830b3d7ee909ee8a21a267df5164">&sect;&nbsp;</a></span>MPURegionDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPURegionDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a specific region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Region</td><td>is the region number to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to disable a previously enabled memory protection region. The region remains configured if it is not overwritten with another call to <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a>, and can be enabled again by calling <a class="el" href="group__mpu__api.html#ga17918fcd1ac15cb5456d7ae3ad388aaa">MPURegionEnable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a27fcd26de5ff56333143e9d4e48c2198">NVIC_MPU_ATTR</a>, <a class="el" href="hw__nvic_8h.html#aeda7a9221dedae07f1b41a94e5db8d76">NVIC_MPU_ATTR_ENABLE</a>, and <a class="el" href="hw__nvic_8h.html#ade051e0e6b4c898e3488eb39bfaae129">NVIC_MPU_NUMBER</a>.</p>

</div>
</div>
<a id="ga6134864a66eb0a110320fc98a49c8c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6134864a66eb0a110320fc98a49c8c57">&sect;&nbsp;</a></span>MPURegionSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPURegionSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets up the access rules for a specific region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Region</td><td>is the region number to set up. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the base address of the region. It must be aligned according to the size of the region specified in ui32Flags. </td></tr>
    <tr><td class="paramname">ui32Flags</td><td>is a set of flags to define the attributes of the region.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the protection rules for a region. The region has a base address and a set of attributes including the size. The base address parameter, <em>ui32Addr</em>, must be aligned according to the size, and the size must be a power of 2.</p>
<p>The <em>ui32Flags</em> parameter is the logical OR of all of the attributes of the region. It is a combination of choices for region size, execute permission, read/write permissions, disabled sub-regions, and a flag to determine if the region is enabled.</p>
<p>The size flag determines the size of a region and must be one of the following:</p>
<ul>
<li><b>MPU_RGN_SIZE_32B</b> </li>
<li><b>MPU_RGN_SIZE_64B</b> </li>
<li><b>MPU_RGN_SIZE_128B</b> </li>
<li><b>MPU_RGN_SIZE_256B</b> </li>
<li><b>MPU_RGN_SIZE_512B</b> </li>
<li><b>MPU_RGN_SIZE_1K</b> </li>
<li><b>MPU_RGN_SIZE_2K</b> </li>
<li><b>MPU_RGN_SIZE_4K</b> </li>
<li><b>MPU_RGN_SIZE_8K</b> </li>
<li><b>MPU_RGN_SIZE_16K</b> </li>
<li><b>MPU_RGN_SIZE_32K</b> </li>
<li><b>MPU_RGN_SIZE_64K</b> </li>
<li><b>MPU_RGN_SIZE_128K</b> </li>
<li><b>MPU_RGN_SIZE_256K</b> </li>
<li><b>MPU_RGN_SIZE_512K</b> </li>
<li><b>MPU_RGN_SIZE_1M</b> </li>
<li><b>MPU_RGN_SIZE_2M</b> </li>
<li><b>MPU_RGN_SIZE_4M</b> </li>
<li><b>MPU_RGN_SIZE_8M</b> </li>
<li><b>MPU_RGN_SIZE_16M</b> </li>
<li><b>MPU_RGN_SIZE_32M</b> </li>
<li><b>MPU_RGN_SIZE_64M</b> </li>
<li><b>MPU_RGN_SIZE_128M</b> </li>
<li><b>MPU_RGN_SIZE_256M</b> </li>
<li><b>MPU_RGN_SIZE_512M</b> </li>
<li><b>MPU_RGN_SIZE_1G</b> </li>
<li><b>MPU_RGN_SIZE_2G</b> </li>
<li><b>MPU_RGN_SIZE_4G</b> </li>
</ul>
<p>The execute permission flag must be one of the following:</p>
<ul>
<li><b>MPU_RGN_PERM_EXEC</b> enables the region for execution of code</li>
<li><b>MPU_RGN_PERM_NOEXEC</b> disables the region for execution of code</li>
</ul>
<p>The read/write access permissions are applied separately for the privileged and user modes. The read/write access flags must be one of the following:</p>
<ul>
<li><b>MPU_RGN_PERM_PRV_NO_USR_NO</b> - no access in privileged or user mode</li>
<li><b>MPU_RGN_PERM_PRV_RW_USR_NO</b> - privileged read/write, user no access</li>
<li><b>MPU_RGN_PERM_PRV_RW_USR_RO</b> - privileged read/write, user read-only</li>
<li><b>MPU_RGN_PERM_PRV_RW_USR_RW</b> - privileged read/write, user read/write</li>
<li><b>MPU_RGN_PERM_PRV_RO_USR_NO</b> - privileged read-only, user no access</li>
<li><b>MPU_RGN_PERM_PRV_RO_USR_RO</b> - privileged read-only, user read-only</li>
</ul>
<p>The region is automatically divided into 8 equally-sized sub-regions by the MPU. Sub-regions can only be used in regions of size 256 bytes or larger. Any of these 8 sub-regions can be disabled, allowing for creation of ``holes'' in a region which can be left open, or overlaid by another region with different attributes. Any of the 8 sub-regions can be disabled with a logical OR of any of the following flags:</p>
<ul>
<li><b>MPU_SUB_RGN_DISABLE_0</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_1</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_2</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_3</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_4</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_5</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_6</b> </li>
<li><b>MPU_SUB_RGN_DISABLE_7</b> </li>
</ul>
<p>Finally, the region can be initially enabled or disabled with one of the following flags:</p>
<ul>
<li><b>MPU_RGN_ENABLE</b> </li>
<li><b>MPU_RGN_DISABLE</b> </li>
</ul>
<p>As an example, to set a region with the following attributes: size of 32 KB, execution enabled, read-only for both privileged and user, one sub-region disabled, and initially enabled; the <em>ui32Flags</em> parameter would have the following value:</p>
<p><code> (MPU_RGN_SIZE_32K | MPU_RGN_PERM_EXEC | MPU_RGN_PERM_PRV_RO_USR_RO | MPU_SUB_RGN_DISABLE_2 | MPU_RGN_ENABLE) </code></p>
<dl class="section note"><dt>Note</dt><dd>This function writes to multiple registers and is not protected from interrupts. It is possible that an interrupt which accesses a region may occur while that region is in the process of being changed. The safest way to handle this is to disable a region before changing it. Refer to the discussion of this in the API Detailed Description section.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a27fcd26de5ff56333143e9d4e48c2198">NVIC_MPU_ATTR</a>, <a class="el" href="hw__nvic_8h.html#a1310e6fcd8ad9dc6de1841c30890b3d2">NVIC_MPU_ATTR_BUFFRABLE</a>, <a class="el" href="hw__nvic_8h.html#a538036f9c4394e8538313e68dd00fffd">NVIC_MPU_ATTR_CACHEABLE</a>, <a class="el" href="hw__nvic_8h.html#a51299e27596a801bd96d2696b50caf10">NVIC_MPU_ATTR_SHAREABLE</a>, <a class="el" href="hw__nvic_8h.html#a3b344bf97566e487ec79dd8215df3c09">NVIC_MPU_ATTR_SIZE_M</a>, <a class="el" href="hw__nvic_8h.html#a8fd5ec44512b3ccad91f78ce3b522bc9">NVIC_MPU_ATTR_TEX_M</a>, <a class="el" href="hw__nvic_8h.html#a89eef9b61007afd7b03f5384a4eed0f4">NVIC_MPU_BASE</a>, and <a class="el" href="hw__nvic_8h.html#ac465a5bbc07ac6618a9d20ca0fa92bb4">NVIC_MPU_BASE_VALID</a>.</p>

</div>
</div>
<a id="ga197e3c9b41e6f05cf91ee618678dea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197e3c9b41e6f05cf91ee618678dea89">&sect;&nbsp;</a></span>MPURegionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPURegionGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current settings for a specific region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Region</td><td>is the region number to get. </td></tr>
    <tr><td class="paramname">pui32Addr</td><td>points to storage for the base address of the region. </td></tr>
    <tr><td class="paramname">pui32Flags</td><td>points to the attribute flags for the region.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves the configuration of a specific region. The meanings and format of the parameters is the same as that of the <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> function.</p>
<p>This function can be used to save the configuration of a region for later use with the <a class="el" href="group__mpu__api.html#ga6134864a66eb0a110320fc98a49c8c57">MPURegionSet()</a> function. The region's enable state is preserved in the attributes that are saved.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__nvic_8h.html#a27fcd26de5ff56333143e9d4e48c2198">NVIC_MPU_ATTR</a>, <a class="el" href="hw__nvic_8h.html#a89eef9b61007afd7b03f5384a4eed0f4">NVIC_MPU_BASE</a>, <a class="el" href="hw__nvic_8h.html#a4b81d3f15160fc142808d9d136e1abe2">NVIC_MPU_BASE_ADDR_M</a>, and <a class="el" href="hw__nvic_8h.html#ade051e0e6b4c898e3488eb39bfaae129">NVIC_MPU_NUMBER</a>.</p>

</div>
</div>
<a id="ga5f391e2bed9919c3e98ee744d76a5a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f391e2bed9919c3e98ee744d76a5a03">&sect;&nbsp;</a></span>MPUIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPUIntRegister </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the memory management fault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the memory management fault occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets and enables the handler to be called when the MPU generates a memory management fault due to a protection region access violation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>, and <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>.</p>

</div>
</div>
<a id="ga8bd36f9796c8a112476a11f381cd5c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd36f9796c8a112476a11f381cd5c90">&sect;&nbsp;</a></span>MPUIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPUIntUnregister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters an interrupt handler for the memory management fault.</p>
<p>This function disables and clears the handler to be called when a memory management fault occurs.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="interrupt_8h.html#a50e6a1690bac07a5eeb247a96052c880">FAULT_MPU</a>, <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>, and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
