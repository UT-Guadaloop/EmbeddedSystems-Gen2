<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>MSP432E4 DriverLib API Guide: Udma_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP432E4 DriverLib API Guide
   &#160;<span id="projectnumber">1.11.00.03</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Udma_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_d_m_a_control_table.html">tDMAControlTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacd1b76fcec3e9bf46b26b75774a47d61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#gacd1b76fcec3e9bf46b26b75774a47d61">uDMATaskStructEntry</a>(ui32TransferCount,  ui32ItemSize,  ui32SrcIncrement,  pvSrcAddr,  ui32DstIncrement,  pvDstAddr,  ui32ArbSize,  ui32Mode)</td></tr>
<tr class="separator:gacd1b76fcec3e9bf46b26b75774a47d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ba01506573508d62442e3b3e7408bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga7ba01506573508d62442e3b3e7408bb6">uDMAInit</a> (void)</td></tr>
<tr class="separator:ga7ba01506573508d62442e3b3e7408bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2c43120f113a79cbabf894f5503f41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga9c2c43120f113a79cbabf894f5503f41">uDMAEnable</a> (void)</td></tr>
<tr class="separator:ga9c2c43120f113a79cbabf894f5503f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850808381da300573a6101e5a27f4675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga850808381da300573a6101e5a27f4675">uDMADisable</a> (void)</td></tr>
<tr class="separator:ga850808381da300573a6101e5a27f4675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01185c0d570c65da3642e6c60ea4973"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#gad01185c0d570c65da3642e6c60ea4973">uDMAErrorStatusGet</a> (void)</td></tr>
<tr class="separator:gad01185c0d570c65da3642e6c60ea4973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875220775201c33cd3c97ebcbca83ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga875220775201c33cd3c97ebcbca83ac2">uDMAErrorStatusClear</a> (void)</td></tr>
<tr class="separator:ga875220775201c33cd3c97ebcbca83ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e21189773539bbc5f302863cd5bf06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a> (uint32_t ui32ChannelNum)</td></tr>
<tr class="separator:ga41e21189773539bbc5f302863cd5bf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ded922b57dbc5772036ddcbb8f28d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga28ded922b57dbc5772036ddcbb8f28d6">uDMAChannelDisable</a> (uint32_t ui32ChannelNum)</td></tr>
<tr class="separator:ga28ded922b57dbc5772036ddcbb8f28d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a15b561a538ff126aabac85ee311b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga71a15b561a538ff126aabac85ee311b2">uDMAChannelIsEnabled</a> (uint32_t ui32ChannelNum)</td></tr>
<tr class="separator:ga71a15b561a538ff126aabac85ee311b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc352c5b9404649922a555873619498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga1bc352c5b9404649922a555873619498">uDMAControlBaseSet</a> (void *psControlTable)</td></tr>
<tr class="separator:ga1bc352c5b9404649922a555873619498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c51018a10f41216497396e4ec5a6fd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga09c51018a10f41216497396e4ec5a6fd">uDMAControlBaseGet</a> (void)</td></tr>
<tr class="separator:ga09c51018a10f41216497396e4ec5a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d755ac6e59821949a57d1ceca7082ae"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga3d755ac6e59821949a57d1ceca7082ae">uDMAControlAlternateBaseGet</a> (void)</td></tr>
<tr class="separator:ga3d755ac6e59821949a57d1ceca7082ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1020903cbcc5a03434c3f5c13f252a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga1020903cbcc5a03434c3f5c13f252a72">uDMAChannelRequest</a> (uint32_t ui32ChannelNum)</td></tr>
<tr class="separator:ga1020903cbcc5a03434c3f5c13f252a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd88d930702b3773952214e27bba3f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#gadcd88d930702b3773952214e27bba3f6">uDMAChannelAttributeEnable</a> (uint32_t ui32ChannelNum, uint32_t ui32Attr)</td></tr>
<tr class="separator:gadcd88d930702b3773952214e27bba3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687745cb1ba10bcfbaac4bf0bbfd4132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga687745cb1ba10bcfbaac4bf0bbfd4132">uDMAChannelAttributeDisable</a> (uint32_t ui32ChannelNum, uint32_t ui32Attr)</td></tr>
<tr class="separator:ga687745cb1ba10bcfbaac4bf0bbfd4132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741cac245ca559d1a1112077a7f46b8c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga741cac245ca559d1a1112077a7f46b8c">uDMAChannelAttributeGet</a> (uint32_t ui32ChannelNum)</td></tr>
<tr class="separator:ga741cac245ca559d1a1112077a7f46b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f73ab006ff6a593eeeb947130bbdf6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a> (uint32_t ui32ChannelStructIndex, uint32_t ui32Control)</td></tr>
<tr class="separator:ga6f73ab006ff6a593eeeb947130bbdf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938c21dc70cb6e11e6eb826de0fa21c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a> (uint32_t ui32ChannelStructIndex, uint32_t ui32Mode, void *pvSrcAddr, void *pvDstAddr, uint32_t ui32TransferSize)</td></tr>
<tr class="separator:ga938c21dc70cb6e11e6eb826de0fa21c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac152bd620c5edc6d2d348ac7771c882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#gaac152bd620c5edc6d2d348ac7771c882">uDMAChannelScatterGatherSet</a> (uint32_t ui32ChannelNum, uint32_t ui32TaskCount, void *pvTaskList, uint32_t ui32IsPeriphSG)</td></tr>
<tr class="separator:gaac152bd620c5edc6d2d348ac7771c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52908962d5fdc8ad21d14a3ebb19c0b9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga52908962d5fdc8ad21d14a3ebb19c0b9">uDMAChannelSizeGet</a> (uint32_t ui32ChannelStructIndex)</td></tr>
<tr class="separator:ga52908962d5fdc8ad21d14a3ebb19c0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a74cc2b06a6a59506dcdfabd0c7972"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga84a74cc2b06a6a59506dcdfabd0c7972">uDMAChannelModeGet</a> (uint32_t ui32ChannelStructIndex)</td></tr>
<tr class="separator:ga84a74cc2b06a6a59506dcdfabd0c7972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e714509554e38d29563bf7832f7098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister</a> (uint32_t ui32IntChannel, void(*pfnHandler)(void))</td></tr>
<tr class="separator:ga38e714509554e38d29563bf7832f7098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8728732286c8948fd715e58ca04dbd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#ga8728732286c8948fd715e58ca04dbd84">uDMAIntUnregister</a> (uint32_t ui32IntChannel)</td></tr>
<tr class="separator:ga8728732286c8948fd715e58ca04dbd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c73411a7305843059d0984efaf7770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udma__api.html#gaa3c73411a7305843059d0984efaf7770">uDMAChannelAssign</a> (uint32_t ui32Mapping)</td></tr>
<tr class="separator:gaa3c73411a7305843059d0984efaf7770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="udma_intro"></a>
Introduction</h1>
<p>The Micro Direct Memory Access (uDMA) API provides functions to configure the MSP432E4 uDMA controller. The uDMA controller is designed to work with the ARM Cortex-M processor and provides an efficient and low-overhead means of transferring blocks of data in the system.</p>
<p>The uDMA controller has the following features:</p>
<ul>
<li>dedicated channels for supported peripherals</li>
<li>one channel each for receive and transmit for devices with receive and transmit paths</li>
<li>dedicated channel for software initiated data transfers</li>
<li>channels can be independently configured and operated</li>
<li>an arbitration scheme that is configurable per channel</li>
<li>two levels of priority</li>
<li>subordinate to Cortex-M processor bus usage</li>
<li>data sizes of 8, 16, or 32 bits</li>
<li>address increment of byte, half-word, word, or none</li>
<li>maskable device requests</li>
<li>optional software initiated transfers on any channel</li>
<li>interrupt on transfer completion</li>
</ul>
<p>The uDMA controller supports several different transfer modes, allowing for complex transfer schemes. The following transfer modes are provided:</p>
<ul>
<li><b>Basic</b> mode performs a simple transfer when a request is asserted by a device. This mode is appropriate to use with peripherals where the peripheral asserts the request signal whenever data should be transferred. The transfer pauses if the request is de-asserted, even if the transfer is not complete.</li>
<li><b>Auto-request</b> mode performs a simple transfer that is started by a request, but always completes the entire transfer, even if the request is de-asserted. This mode is appropriate to use with software-initiated transfers.</li>
<li><b>Ping-Pong</b> mode is used to transfer data to or from two buffers, switching from one buffer to the other as each buffer fills. This mode is appropriate to use with peripherals as a way to ensure a continuous flow of data to or from the peripheral. However, it is more complex to set up and requires code to manage the ping-pong buffers in the interrupt handler.</li>
<li><b>Memory scatter-gather</b> mode is a complex mode that provides a way to set up a list of transfer ``tasks'' for the uDMA controller. Blocks of data can be transferred to and from arbitrary locations in memory.</li>
<li><b>Peripheral scatter-gather</b> mode is similar to memory scatter-gather mode except that it is controlled by a peripheral request.</li>
</ul>
<p>Detailed explanation of the various transfer modes is beyond the scope of this document. Please refer to the device data sheet for more information on the operation of the uDMA controller.</p>
<p>The naming convention for the microDMA controller is to use the Greek letter <code>mu'' to represent</code>micro''. For the purposes of this document, and in the software library function names, a lower case <code>u'' will be used in place of </code>mu'' when the controller is referred to as ``uDMA''.</p>
<dl class="section note"><dt>Note</dt><dd>When the GPIO_O_DATA register is the source or destination, the application code must use the bit banded address space instead of specifying the source or destination address as GPIO_O_DATA.</dd></dl>
<h1><a class="anchor" id="udma_api"></a>
API Functions</h1>
<p>The uDMA API functions provide a means to enable and configure the MSP432E4 uDMA controller to perform DMA transfers.</p>
<p>The general order of function calls to set up and perform a uDMA transfer is the following:</p>
<ul>
<li><a class="el" href="group__udma__api.html#ga9c2c43120f113a79cbabf894f5503f41">uDMAEnable()</a> is called once to enable the controller.</li>
<li><a class="el" href="group__udma__api.html#ga1bc352c5b9404649922a555873619498">uDMAControlBaseSet()</a> is called once to set the channel control table.</li>
<li><a class="el" href="group__udma__api.html#gadcd88d930702b3773952214e27bba3f6">uDMAChannelAttributeEnable()</a> is called once or infrequently to configure the behavior of the channel.</li>
<li><a class="el" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet()</a> is used to set up characteristics of the data transfer. It is only called once if the nature of the data transfer does not change.</li>
<li><a class="el" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet()</a> is used to set the buffer pointers and size for a transfer. It is called before each new transfer.</li>
<li><a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable()</a> enables a channel to perform data transfers.</li>
<li><a class="el" href="group__udma__api.html#ga1020903cbcc5a03434c3f5c13f252a72">uDMAChannelRequest()</a> is used to initiate a software based transfer. This is normally not used for peripheral based transfers.</li>
</ul>
<p>In order to use the uDMA controller, you must first enable it by calling <a class="el" href="group__udma__api.html#ga9c2c43120f113a79cbabf894f5503f41">uDMAEnable()</a>. You can later disable it, if no longer needed, by calling <a class="el" href="group__udma__api.html#ga850808381da300573a6101e5a27f4675">uDMADisable()</a>.</p>
<p>Once the uDMA controller is enabled, you must tell it where to find the channel control structures in system memory by using the function <a class="el" href="group__udma__api.html#ga1bc352c5b9404649922a555873619498">uDMAControlBaseSet()</a> and passing a pointer to the base of the channel control structure. The control structure must be allocated by the application. One way to do allocate the control structure is to declare an array of data type <code>int8_t</code> or <code>uint8_t</code>. In order to support all channels and transfer modes, the control table array should be 1024 bytes, but it can be fewer depending on transfer modes used and number of channels actually used.</p>
<dl class="section note"><dt>Note</dt><dd>The control table must be aligned on a 1024-byte boundary.</dd></dl>
<p>The uDMA controller supports multiple channels. Each channel has a set of attribute flags to control certain uDMA features and channel behavior. The attribute flags are configured with the function <a class="el" href="group__udma__api.html#gadcd88d930702b3773952214e27bba3f6">uDMAChannelAttributeEnable()</a> and cleared with <a class="el" href="group__udma__api.html#ga687745cb1ba10bcfbaac4bf0bbfd4132">uDMAChannelAttributeDisable()</a>. The setting of the channel attribute flags can be queried using the function <a class="el" href="group__udma__api.html#ga741cac245ca559d1a1112077a7f46b8c">uDMAChannelAttributeGet()</a>.</p>
<p>Next, the control parameters of the DMA transfer must be configured. These parameters control the size and address increment of the data items to be transferred. The function <a class="el" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet()</a> is used to set up these control parameters.</p>
<p>All of the functions mentioned so far are used only once or infrequently to set up the uDMA channel and transfer. In order to configure the transfer addresses, transfer size, and transfer mode, use the function <a class="el" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet()</a>. This function must be called for each new transfer. Once everything is set up, the channel is enabled by calling <a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable()</a>, which must be done before each new transfer. The uDMA controller automatically disables the channel at the completion of a transfer. A channel can be manually disabled by using <a class="el" href="group__udma__api.html#ga28ded922b57dbc5772036ddcbb8f28d6">uDMAChannelDisable()</a>.</p>
<p>There are additional functions that can be used to query the status of a channel, either from an interrupt handler or in polling fashion. The function <a class="el" href="group__udma__api.html#ga52908962d5fdc8ad21d14a3ebb19c0b9">uDMAChannelSizeGet()</a> is used to find the amount of data remaining to transfer on a channel. This value is zero when a transfer is complete. The function <a class="el" href="group__udma__api.html#ga84a74cc2b06a6a59506dcdfabd0c7972">uDMAChannelModeGet()</a> can be used to find the transfer mode of a uDMA channel. This function is usually used to see if the mode indicates stopped, meaning that a transfer has completed on a channel that was previously running. The function <a class="el" href="group__udma__api.html#ga71a15b561a538ff126aabac85ee311b2">uDMAChannelIsEnabled()</a> can be used to determine if a particular channel is enabled.</p>
<p>If the application is using run-time interrupt registration (see <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>), then the function <a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister()</a> can be used to install an interrupt handler for the uDMA controller. This function also enables the interrupt on the system interrupt controller. If compile-time interrupt registration is used, then call the function <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a> to enable uDMA interrupts. When an interrupt handler has been installed with <a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister()</a>, it can be removed by calling <a class="el" href="group__udma__api.html#ga8728732286c8948fd715e58ca04dbd84">uDMAIntUnregister()</a>.</p>
<p>This interrupt handler is only for software-initiated transfers or errors. uDMA interrupts for a peripheral occur on the peripheral's dedicated interrupt channel and should be handled by the peripheral interrupt handler. It is not necessary to acknowledge or clear uDMA interrupt sources. They are cleared automatically when they are serviced.</p>
<p>The uDMA interrupt handler should use the function <a class="el" href="group__udma__api.html#gad01185c0d570c65da3642e6c60ea4973">uDMAErrorStatusGet()</a> to test if a uDMA error occurred. If so, the interrupt must be cleared by calling <a class="el" href="group__udma__api.html#ga875220775201c33cd3c97ebcbca83ac2">uDMAErrorStatusClear()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Many of the API functions take a channel parameter that includes the logical OR of one of the values <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b> to choose the primary or alternate control structure. For Basic and Auto transfer modes, only the primary control structure is needed. The alternate control structure is only needed for complex transfer modes of Ping-pong or Scatter-gather. Refer to the device data sheet for detailed information about transfer modes.</dd></dl>
<p><b>Special considerations for using scatter-gather operations</b></p>
<p>In order to use the scatter-gather modes of the uDMA controller, you must prepare a ``task'' list in memory that describes the scatter-gather operations. There is a helper macro, <a class="el" href="group__udma__api.html#gacd1b76fcec3e9bf46b26b75774a47d61">uDMATaskStructEntry</a> provided to help create the initialization values for the task list structure. Please see the documentation for this macro which includes a code snippet showing how it is used.</p>
<p>Once the task list is prepared, the appropriate uDMA channel must be configured for a scatter-gather operation. The best way to do this is to use the function <a class="el" href="group__udma__api.html#gaac152bd620c5edc6d2d348ac7771c882">uDMAChannelScatterGatherSet()</a>. Alternatively, the functions <a class="el" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet()</a> followed by <a class="el" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet()</a> can also be used.</p>
<dl class="section note"><dt>Note</dt><dd>The scatter-gather task list must be resident in SRAM. The uDMA controller cannot read from flash memory.</dd></dl>
<p><b>About uDMA Channel Function Parameters</b></p>
<p>Many of the uDMA API functions require a channel number as a parameter. There are two different uses of the channel number. In some cases, it is the number of the uDMA channel and is used to read or write registers within the uDMA controller. In this case, it is simply the channel number with no additional qualifier.</p>
<p>However, in other cases the channel number that is supplied as a parameter is really an index into the uDMA channel control structure. Because every uDMA channel has a primary and an alternate channel control structure, this index must also be specified as part of the channel number. The index is specified by passing a value for the channel parameter that is the logical OR of the actual channel number and one of <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b>. The default is the same as <b>UDMA_PRI_SELECT</b> so if you do not specify, the primary channel control structure is used, which is the right thing in most cases.</p>
<dl class="section note"><dt>Note</dt><dd>When <b>UDMA_ALT_SELECT</b> is specified, what is really happening is that channel index 32-63 is being used, because the alternate channel control structures for channels 0-31 are located at index locations 32-63 in the channel control table.</dd></dl>
<p>Here is an example of the first case. In this example, a uDMA channel is enabled, and only the channel number is used because this is programming a register in the uDMA controller.</p>
<div class="fragment"><div class="line"><a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(UDMA_CHANNEL_UART0RX);</div></div><!-- fragment --><p>Here is an example of the second case. In this example, the channel control structure is to be modified to configure some transfer parameters. Therefore in addition to specifying the channel index, the primary or alternate control structure must also be selected.</p>
<div class="fragment"><div class="line"><a class="code" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a>(UDMA_CHANNEL_UART0RX | <a class="code" href="udma_8h.html#ace46317707b0fda2f1eed512698308a4">UDMA_PRI_SELECT</a>, ...);</div></div><!-- fragment --><p>In order to help make it clear when one or the other form is to be used, the parameters are named differently in the API description. For functions that require just the channel number, the name of the parameter is <em>ulChannelNum</em>. For functions that require the channel index of the channel control structure, the name of the parameter is <em>ulChannelStructIdx</em>.</p>
<p><b>Selecting uDMA Channels</b></p>
<p>The uDMA controller has 32 channels, and therefore most of the API functions take a channel number with a value from 0-31 or a channel index with a value from 0-63 (the 32-63 is specified with the logical OR of the channel number with <b>UDMA_ALT_SELECT</b>). In order to avoid the need for hardcoded channel numbers in code, macros are provided that map channel names to channel numbers.</p>
<p>To use the default channel mapping, you may use one of the following choices whenever a channel number or index is needed. This list is all the possible channels that are defined by the API. However not all channels are available on all parts, depending on which peripherals are available on the part and which of those support uDMA. Please consult the data sheet for your specific part to see which uDMA channels are supported.</p>
<ul>
<li><b>UDMA_CHANNEL_USBEP1RX</b> for USB endpoint 1 receive</li>
<li><b>UDMA_CHANNEL_USBEP1TX</b> for USB endpoint 1 transmit</li>
<li><b>UDMA_CHANNEL_USBEP2RX</b> for USB endpoint 2 receive</li>
<li><b>UDMA_CHANNEL_USBEP2TX</b> for USB endpoint 2 transmit</li>
<li><b>UDMA_CHANNEL_USBEP3RX</b> for USB endpoint 3 receive</li>
<li><b>UDMA_CHANNEL_USBEP3TX</b> for USB endpoint 3 transmit</li>
<li><b>UDMA_CHANNEL_ETH0RX</b> for ethernet receive</li>
<li><b>UDMA_CHANNEL_ETH0TX</b> for ethernet transmit</li>
<li><b>UDMA_CHANNEL_UART0RX</b> for UART 0 receive channel</li>
<li><b>UDMA_CHANNEL_UART0TX</b> for UART 0 transmit channel</li>
<li><b>UDMA_CHANNEL_UART1RX</b> for UART 1 receive channel</li>
<li><b>UDMA_CHANNEL_UART1TX</b> for UART 1 transmit channel</li>
<li><b>UDMA_CHANNEL_SSI0RX</b> for SSI 0 receive channel</li>
<li><b>UDMA_CHANNEL_SSI0TX</b> for SSI 0 transmit channel</li>
<li><b>UDMA_CHANNEL_SSI1RX</b> for SSI 1 receive channel</li>
<li><b>UDMA_CHANNEL_SSI1TX</b> for SSI 1 transmit channel</li>
<li><b>UDMA_CHANNEL_ADC0</b> for ADC0 sequencer 0</li>
<li><b>UDMA_CHANNEL_ADC1</b> for ADC0 sequencer 1</li>
<li><b>UDMA_CHANNEL_ADC2</b> for ADC0 sequencer 2</li>
<li><b>UDMA_CHANNEL_ADC3</b> for ADC0 sequencer 3</li>
<li><b>UDMA_CHANNEL_TMR0A</b> for Timer 0A</li>
<li><b>UDMA_CHANNEL_TMR0B</b> for Timer 0B</li>
<li><b>UDMA_CHANNEL_TMR1A</b> for Timer 1A</li>
<li><b>UDMA_CHANNEL_TMR1B</b> for Timer 1B</li>
<li><b>UDMA_CHANNEL_I2S0RX</b> for I2S receive</li>
<li><b>UDMA_CHANNEL_I2S0TX</b> for I2S transmit</li>
<li><b>UDMA_CHANNEL_SW</b> for the software dedicated uDMA channel</li>
</ul>
<p>Some MSP432E4 parts also provide a secondary channel mapping. For those parts, each channel has a secondary peripheral mapping, allowing more choices in channel mapping and to allow some additional peripherals to use uDMA that are not available in the default mapping.</p>
<p>In order to select the default or secondary channel mapping, use the functions uDMAChannelSelectDefault() or uDMAChannelSelectSecondary(). Each channel can be configured individually to use the default or secondary mapping.</p>
<p>For example, the default for channel 0 is USBEP1RX. However this channel also has a secondary mapping to UART2RX. If an application requires use of uDMA with UART2 and does not use USB, then this channel could be remapped to UART2RX with the following function call:</p>
<div class="fragment"><div class="line">uDMAChannelSelectSecondary(UDMA_DEF_USBEP1RX_SEC_UART2RX);</div></div><!-- fragment --><p>For channels that have been configured to use the secondary mapping, there is a set of macros to use for specifying the channel. Here is the list of channels when secondary mapping is used. As before, this is the full list, the actual channels available depend on which specific MSP432E4 part is used.</p>
<ul>
<li><b>UDMA_SEC_CHANNEL_UART2RX_0</b> for UART2 receive using uDMA channel 0</li>
<li><b>UDMA_SEC_CHANNEL_UART2TX_1</b> for UART2 transmit using uDMA channel 1</li>
<li><b>UDMA_SEC_CHANNEL_TMR3A</b> for Timer 3A</li>
<li><b>UDMA_SEC_CHANNEL_TMR3B</b> for Timer 3B</li>
<li><b>UDMA_SEC_CHANNEL_TMR2A_4</b> for Timer 2A using uDMA channel 4</li>
<li><b>UDMA_SEC_CHANNEL_TMR2B_5</b> for Timer 2B using uDMA channel 5</li>
<li><b>UDMA_SEC_CHANNEL_TMR2A_6</b> for Timer 2A using uDMA channel 6</li>
<li><b>UDMA_SEC_CHANNEL_TMR2B_7</b> for Timer 2B using uDMA channel 7</li>
<li><b>UDMA_SEC_CHANNEL_UART1RX</b> for UART1 receive</li>
<li><b>UDMA_SEC_CHANNEL_UART1TX</b> for UART1 transmit</li>
<li><b>UDMA_SEC_CHANNEL_SSI1RX</b> for SSI1 receive</li>
<li><b>UDMA_SEC_CHANNEL_SSI1TX</b> for SSI1 transmit</li>
<li><b>UDMA_SEC_CHANNEL_UART2RX_12</b> for UART2 receive using uDMA channel 12</li>
<li><b>UDMA_SEC_CHANNEL_UART2TX_13</b> for UART2 transmit using uDMA channel 13</li>
<li><b>UDMA_SEC_CHANNEL_TMR2A_14</b> for Timer 2A using uDMA channel 14</li>
<li><b>UDMA_SEC_CHANNEL_TMR2B_15</b> for Timer 2B using uDMA channel 15</li>
<li><b>UDMA_SEC_CHANNEL_TMR1A</b> for Timer 1A</li>
<li><b>UDMA_SEC_CHANNEL_TMR1B</b> for Timer 1B</li>
<li><b>UDMA_SEC_CHANNEL_EPI0RX</b> for EPI read</li>
<li><b>UDMA_SEC_CHANNEL_EPI0TX</b> for EPI write</li>
<li><b>UDMA_SEC_CHANNEL_ADC10</b> for ADC1 sequencer 0</li>
<li><b>UDMA_SEC_CHANNEL_ADC11</b> for ADC1 sequencer 1</li>
<li><b>UDMA_SEC_CHANNEL_ADC12</b> for ADC1 sequencer 2</li>
<li><b>UDMA_SEC_CHANNEL_ADC13</b> for ADC1 sequencer 3</li>
<li><b>UDMA_SEC_CHANNEL_SW</b> for the software dedicated uDMA channel</li>
</ul>
<p>Further, some MSP432E4 parts provide up to five possible channel assignments. For those parts, us the <a class="el" href="group__udma__api.html#gaa3c73411a7305843059d0984efaf7770">uDMAChannelAssign()</a> function to configure the channel assignments.</p>
<h1><a class="anchor" id="udma_example"></a>
Programming Example</h1>
<p>The following example sets up the uDMA controller to perform a software initiated memory-to-memory transfer:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The application must allocate the channel control table.  This one is a</span></div><div class="line"><span class="comment">// full table for all modes and channels.</span></div><div class="line"><span class="comment">// NOTE: This table must be 1024-byte aligned.</span></div><div class="line"><span class="comment">//</span></div><div class="line">uint8_t pui8DMAControlTable[1024];</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Source and destination buffers used for the DMA transfer.</span></div><div class="line"><span class="comment">//</span></div><div class="line">uint8_t pui8SourceBuffer[256];</div><div class="line">uint8_t pui8DestBuffer[256];</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Enable the UDMA peripheral</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a>(<a class="code" href="sysctl_8h.html#a5e798596ef00539c9c08f6a4997825b7">SYSCTL_PERIPH_UDMA</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Wait for the UDMA module to be ready.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordflow">while</span>(!<a class="code" href="group__sysctl__api.html#ga7ddf1f06376894c31e5596f562c299ac">SysCtlPeripheralReady</a>(<a class="code" href="sysctl_8h.html#a5e798596ef00539c9c08f6a4997825b7">SYSCTL_PERIPH_UDMA</a>))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// // Enable the uDMA controller. //</span></div><div class="line"><a class="code" href="group__udma__api.html#ga9c2c43120f113a79cbabf894f5503f41">uDMAEnable</a>();</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set the base for the channel control table.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__udma__api.html#ga1bc352c5b9404649922a555873619498">uDMAControlBaseSet</a>(&amp;pui8DMAControlTable[0]);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// No attributes must be set for a software-based transfer.  The attributes</span></div><div class="line"><span class="comment">// are cleared by default, but are explicitly cleared here, in case they</span></div><div class="line"><span class="comment">// were set elsewhere.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__udma__api.html#ga687745cb1ba10bcfbaac4bf0bbfd4132">uDMAChannelAttributeDisable</a>(UDMA_CHANNEL_SW, UDMA_CONFIG_ALL);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Now set up the characteristics of the transfer for 8-bit data size, with</span></div><div class="line"><span class="comment">// source and destination increments in bytes, and a byte-wise buffer copy.</span></div><div class="line"><span class="comment">//  A bus arbitration size of 8 is used.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a>(UDMA_CHANNEL_SW | <a class="code" href="udma_8h.html#ace46317707b0fda2f1eed512698308a4">UDMA_PRI_SELECT</a>,</div><div class="line">                      <a class="code" href="udma_8h.html#acfd5e57fa4a0c7e33d76c9f0f663c70e">UDMA_SIZE_8</a> | <a class="code" href="udma_8h.html#a3a2ecfdeedc93963d2c5b6dcf3598d80">UDMA_SRC_INC_8</a> |</div><div class="line">                      <a class="code" href="udma_8h.html#a8df004d5dabcc2302bc3170f228d6a8e">UDMA_DST_INC_8</a> | <a class="code" href="udma_8h.html#a2916ea30baef012589a249563e3aeba3">UDMA_ARB_8</a>);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The transfer buffers and transfer size are now configured.  The transfer</span></div><div class="line"><span class="comment">// uses AUTO mode, which means that the transfer automatically runs to</span></div><div class="line"><span class="comment">// completion after the first request.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(UDMA_CHANNEL_SW | <a class="code" href="udma_8h.html#ace46317707b0fda2f1eed512698308a4">UDMA_PRI_SELECT</a>,</div><div class="line">                       <a class="code" href="udma_8h.html#a7eea31eaa16cc6da8aa6900fe25457e1">UDMA_MODE_AUTO</a>, pui8SourceBuffer, pui8DestBuffer,</div><div class="line">                       <span class="keyword">sizeof</span>(pui8DestBuffer));</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Finally, the channel must be enabled.  Because this is a software-</span></div><div class="line"><span class="comment">// initiated transfer, a request must also be made.  The request starts the</span></div><div class="line"><span class="comment">// transfer.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(UDMA_CHANNEL_SW);</div><div class="line"><a class="code" href="group__udma__api.html#ga1020903cbcc5a03434c3f5c13f252a72">uDMAChannelRequest</a>(UDMA_CHANNEL_SW);</div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacd1b76fcec3e9bf46b26b75774a47d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd1b76fcec3e9bf46b26b75774a47d61">&sect;&nbsp;</a></span>uDMATaskStructEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uDMATaskStructEntry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32TransferCount, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32ItemSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32SrcIncrement, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pvSrcAddr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32DstIncrement, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pvDstAddr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32ArbSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32Mode&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                         \</div><div class="line">        (((ui32SrcIncrement) == <a class="code" href="udma_8h.html#ace9a62c226f2e73cc1a7c56d80efa361">UDMA_SRC_INC_NONE</a>) ? (<span class="keywordtype">void</span> *)(pvSrcAddr) :    \</div><div class="line">            ((<span class="keywordtype">void</span> *)(&amp;((uint8_t *)(pvSrcAddr))[((ui32TransferCount) &lt;&lt;       \</div><div class="line">                                         ((ui32SrcIncrement) &gt;&gt; 26)) - 1]))), \</div><div class="line">            (((ui32DstIncrement) == <a class="code" href="udma_8h.html#aff850520540f2dd5ef6c016ac9bc85f8">UDMA_DST_INC_NONE</a>) ? (<span class="keywordtype">void</span> *)(pvDstAddr) :\</div><div class="line">            ((<span class="keywordtype">void</span> *)(&amp;((uint8_t *)(pvDstAddr))[((ui32TransferCount) &lt;&lt;       \</div><div class="line">                                         ((ui32DstIncrement) &gt;&gt; 30)) - 1]))), \</div><div class="line">        (ui32SrcIncrement) | (ui32DstIncrement) | (ui32ItemSize) |            \</div><div class="line">            (ui32ArbSize) |                                                   \</div><div class="line">        (((ui32TransferCount) - 1) &lt;&lt; 4) |                                    \</div><div class="line">        ((((ui32Mode) == <a class="code" href="udma_8h.html#ab99c1f842fc5873d9639dd5c81f52e96">UDMA_MODE_MEM_SCATTER_GATHER</a>) ||                     \</div><div class="line">          ((ui32Mode) == <a class="code" href="udma_8h.html#a45c6f39ddeb623a7d1df04d3e0b15998">UDMA_MODE_PER_SCATTER_GATHER</a>)) ?                     \</div><div class="line">                (ui32Mode) | <a class="code" href="udma_8h.html#ade8eb75e2d128f81131a52832c9046d7">UDMA_MODE_ALT_SELECT</a> : (ui32Mode)), 0            \</div><div class="line">    }</div><div class="ttc" id="udma_8h_html_aff850520540f2dd5ef6c016ac9bc85f8"><div class="ttname"><a href="udma_8h.html#aff850520540f2dd5ef6c016ac9bc85f8">UDMA_DST_INC_NONE</a></div><div class="ttdeci">#define UDMA_DST_INC_NONE</div><div class="ttdef"><b>Definition:</b> udma.h:228</div></div>
<div class="ttc" id="udma_8h_html_a45c6f39ddeb623a7d1df04d3e0b15998"><div class="ttname"><a href="udma_8h.html#a45c6f39ddeb623a7d1df04d3e0b15998">UDMA_MODE_PER_SCATTER_GATHER</a></div><div class="ttdeci">#define UDMA_MODE_PER_SCATTER_GATHER</div><div class="ttdef"><b>Definition:</b> udma.h:216</div></div>
<div class="ttc" id="udma_8h_html_ace9a62c226f2e73cc1a7c56d80efa361"><div class="ttname"><a href="udma_8h.html#ace9a62c226f2e73cc1a7c56d80efa361">UDMA_SRC_INC_NONE</a></div><div class="ttdeci">#define UDMA_SRC_INC_NONE</div><div class="ttdef"><b>Definition:</b> udma.h:232</div></div>
<div class="ttc" id="udma_8h_html_ab99c1f842fc5873d9639dd5c81f52e96"><div class="ttname"><a href="udma_8h.html#ab99c1f842fc5873d9639dd5c81f52e96">UDMA_MODE_MEM_SCATTER_GATHER</a></div><div class="ttdeci">#define UDMA_MODE_MEM_SCATTER_GATHER</div><div class="ttdef"><b>Definition:</b> udma.h:214</div></div>
<div class="ttc" id="udma_8h_html_ade8eb75e2d128f81131a52832c9046d7"><div class="ttname"><a href="udma_8h.html#ade8eb75e2d128f81131a52832c9046d7">UDMA_MODE_ALT_SELECT</a></div><div class="ttdeci">#define UDMA_MODE_ALT_SELECT</div><div class="ttdef"><b>Definition:</b> udma.h:218</div></div>
</div><!-- fragment --><p>A helper macro for building scatter-gather task table entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32TransferCount</td><td>is the count of items to transfer for this task. </td></tr>
    <tr><td class="paramname">ui32ItemSize</td><td>is the bit size of the items to transfer for this task. </td></tr>
    <tr><td class="paramname">ui32SrcIncrement</td><td>is the bit size increment for source data. </td></tr>
    <tr><td class="paramname">pvSrcAddr</td><td>is the starting address of the data to transfer. </td></tr>
    <tr><td class="paramname">ui32DstIncrement</td><td>is the bit size increment for destination data. </td></tr>
    <tr><td class="paramname">pvDstAddr</td><td>is the starting address of the destination data. </td></tr>
    <tr><td class="paramname">ui32ArbSize</td><td>is the arbitration size to use for the transfer task. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>is the transfer mode for this task.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is intended to be used to help populate a table of uDMA tasks for a scatter-gather transfer. This macro will calculate the values for the fields of a task structure entry based on the input parameters.</p>
<p>There are specific requirements for the values of each parameter. No checking is done so it is up to the caller to ensure that correct values are used for the parameters.</p>
<p>The <em>ui32TransferCount</em> parameter is the number of items that will be transferred by this task. It must be in the range 1-1024.</p>
<p>The <em>ui32ItemSize</em> parameter is the bit size of the transfer data. It must be one of <b>UDMA_SIZE_8</b>, <b>UDMA_SIZE_16</b>, or <b>UDMA_SIZE_32</b>.</p>
<p>The <em>ui32SrcIncrement</em> parameter is the increment size for the source data. It must be one of <b>UDMA_SRC_INC_8</b>, <b>UDMA_SRC_INC_16</b>, <b>UDMA_SRC_INC_32</b>, or <b>UDMA_SRC_INC_NONE</b>.</p>
<p>The <em>pvSrcAddr</em> parameter is a void pointer to the beginning of the source data.</p>
<p>The <em>ui32DstIncrement</em> parameter is the increment size for the destination data. It must be one of <b>UDMA_DST_INC_8</b>, <b>UDMA_DST_INC_16</b>, <b>UDMA_DST_INC_32</b>, or <b>UDMA_DST_INC_NONE</b>.</p>
<p>The <em>pvDstAddr</em> parameter is a void pointer to the beginning of the location where the data will be transferred.</p>
<p>The <em>ui32ArbSize</em> parameter is the arbitration size for the transfer, and must be one of <b>UDMA_ARB_1</b>, <b>UDMA_ARB_2</b>, <b>UDMA_ARB_4</b>, and so on up to <b>UDMA_ARB_1024</b>. This is used to select the arbitration size in powers of 2, from 1 to 1024.</p>
<p>The <em>ui32Mode</em> parameter is the mode to use for this transfer task. It must be one of <b>UDMA_MODE_BASIC</b>, <b>UDMA_MODE_AUTO</b>, <b>UDMA_MODE_MEM_SCATTER_GATHER</b>, or <b>UDMA_MODE_PER_SCATTER_GATHER</b>. Note that normally all tasks will be one of the scatter-gather modes while the last task is a task list will be AUTO or BASIC.</p>
<p>This macro is intended to be used to initialize individual entries of a structure of <a class="el" href="structt_d_m_a_control_table.html">tDMAControlTable</a> type, like this:</p>
<pre class="fragment">//!     tDMAControlTable MyTaskList[] =
//!     {
//!         uDMATaskStructEntry(Task1Count, UDMA_SIZE_8,
//!                             UDMA_SRC_INC_8, MySourceBuf,
//!                             UDMA_DST_INC_8, MyDestBuf,
//!                             UDMA_ARB_8, UDMA_MODE_MEM_SCATTER_GATHER),
//!         uDMATaskStructEntry(Task2Count, ...),
//!     }
//! </pre> <pre class="fragment">\return Nothing; this is not a function.  </pre> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7ba01506573508d62442e3b3e7408bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba01506573508d62442e3b3e7408bb6">&sect;&nbsp;</a></span>uDMAInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the uDMA for use.</p>
<p>This function assigns a default peripheral mapping for uDMA channels 20-25. This function must be called in order to prevent multiple channels from being assigned to the same peripheral by moving these channels to an encoding where they are in reserved status.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="udma_8h.html#a000b59d282bb437923632d7544878aa8">UDMA_CH20_RESERVED7</a>, <a class="el" href="udma_8h.html#a502b71e74ec0b629d29a9f2aeb0ffbce">UDMA_CH21_RESERVED7</a>, <a class="el" href="udma_8h.html#ac826e8ec6e42491b508e435ec86541e0">UDMA_CH22_RESERVED7</a>, <a class="el" href="udma_8h.html#afc03ea76282149d19eef45f269213d00">UDMA_CH23_RESERVED7</a>, <a class="el" href="udma_8h.html#aa357e38d464bdb643bbd9e7fc177a38f">UDMA_CH24_RESERVED7</a>, <a class="el" href="udma_8h.html#a586820566f6df9566f02e330f22994ee">UDMA_CH25_RESERVED7</a>, and <a class="el" href="group__udma__api.html#gaa3c73411a7305843059d0984efaf7770">uDMAChannelAssign()</a>.</p>

</div>
</div>
<a id="ga9c2c43120f113a79cbabf894f5503f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c2c43120f113a79cbabf894f5503f41">&sect;&nbsp;</a></span>uDMAEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the uDMA controller for use.</p>
<p>This function enables the uDMA controller. The uDMA controller must be enabled before it can be configured and used.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#a4319542243c34e0b6c8c428978eb43f9">UDMA_CFG</a>, and <a class="el" href="hw__udma_8h.html#afd62e359f3db2c3d56285d06390f77d7">UDMA_CFG_MASTEN</a>.</p>

</div>
</div>
<a id="ga850808381da300573a6101e5a27f4675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850808381da300573a6101e5a27f4675">&sect;&nbsp;</a></span>uDMADisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMADisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the uDMA controller for use.</p>
<p>This function disables the uDMA controller. Once disabled, the uDMA controller cannot operate until re-enabled with <a class="el" href="group__udma__api.html#ga9c2c43120f113a79cbabf894f5503f41">uDMAEnable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a4319542243c34e0b6c8c428978eb43f9">UDMA_CFG</a>.</p>

</div>
</div>
<a id="gad01185c0d570c65da3642e6c60ea4973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01185c0d570c65da3642e6c60ea4973">&sect;&nbsp;</a></span>uDMAErrorStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uDMAErrorStatusGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the uDMA error status.</p>
<p>This function returns the uDMA error status. It should be called from within the uDMA error interrupt handler to determine if a uDMA error occurred.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero if a uDMA error is pending. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a1faac050767fa7399b52d21ecbeace7b">UDMA_ERRCLR</a>.</p>

</div>
</div>
<a id="ga875220775201c33cd3c97ebcbca83ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875220775201c33cd3c97ebcbca83ac2">&sect;&nbsp;</a></span>uDMAErrorStatusClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAErrorStatusClear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the uDMA error interrupt.</p>
<p>This function clears a pending uDMA error interrupt. This function should be called from within the uDMA error interrupt handler to clear the interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a1faac050767fa7399b52d21ecbeace7b">UDMA_ERRCLR</a>.</p>

</div>
</div>
<a id="ga41e21189773539bbc5f302863cd5bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e21189773539bbc5f302863cd5bf06">&sect;&nbsp;</a></span>uDMAChannelEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a uDMA channel for operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel number to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables a specific uDMA channel for use. This function must be used to enable a channel before it can be used to perform a uDMA transfer.</p>
<p>When a uDMA transfer is completed, the channel is automatically disabled by the uDMA controller. Therefore, this function should be called prior to starting up any new transfer.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a864bbe5457eab3890f39e838dd0faebc">UDMA_ENASET</a>.</p>

</div>
</div>
<a id="ga28ded922b57dbc5772036ddcbb8f28d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ded922b57dbc5772036ddcbb8f28d6">&sect;&nbsp;</a></span>uDMAChannelDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a uDMA channel for operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel number to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables a specific uDMA channel. Once disabled, a channel cannot respond to uDMA transfer requests until re-enabled via <a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#ad6083ee9273019db8454bc298c3673e0">UDMA_ENACLR</a>.</p>

</div>
</div>
<a id="ga71a15b561a538ff126aabac85ee311b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a15b561a538ff126aabac85ee311b2">&sect;&nbsp;</a></span>uDMAChannelIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uDMAChannelIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a uDMA channel is enabled for operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel number to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks to see if a specific uDMA channel is enabled. This function can be used to check the status of a transfer, as the channel is automatically disabled at the end of a transfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the channel is enabled, <b>false</b> if disabled. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a864bbe5457eab3890f39e838dd0faebc">UDMA_ENASET</a>.</p>

</div>
</div>
<a id="ga1bc352c5b9404649922a555873619498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc352c5b9404649922a555873619498">&sect;&nbsp;</a></span>uDMAControlBaseSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAControlBaseSet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>psControlTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the base address for the channel control table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psControlTable</td><td>is a pointer to the 1024-byte-aligned base address of the uDMA channel control table.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the base address of the channel control table. This table resides in system memory and holds control information for each uDMA channel. The table must be aligned on a 1024-byte boundary. The base address must be configured before any of the channel functions can be used.</p>
<p>The size of the channel control table depends on the number of uDMA channels and the transfer modes that are used. Refer to the technical reference manual and the data sheet for more information about the channel control table.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>.</p>

</div>
</div>
<a id="ga09c51018a10f41216497396e4ec5a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c51018a10f41216497396e4ec5a6fd">&sect;&nbsp;</a></span>uDMAControlBaseGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* uDMAControlBaseGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the base address for the channel control table.</p>
<p>This function gets the base address of the channel control table. This table resides in system memory and holds control information for each uDMA channel.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the base address of the channel control table. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>.</p>

</div>
</div>
<a id="ga3d755ac6e59821949a57d1ceca7082ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d755ac6e59821949a57d1ceca7082ae">&sect;&nbsp;</a></span>uDMAControlAlternateBaseGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* uDMAControlAlternateBaseGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the base address for the channel control table alternate structures.</p>
<p>This function gets the base address of the second half of the channel control table that holds the alternate control structures for each channel.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the base address of the second half of the channel control table. </dd></dl>

<p>References <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#af548a1ff8481f3f9c2ca6251f9f7ea1b">UDMA_ALTBASE</a>.</p>

</div>
</div>
<a id="ga1020903cbcc5a03434c3f5c13f252a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1020903cbcc5a03434c3f5c13f252a72">&sect;&nbsp;</a></span>uDMAChannelRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests a uDMA channel to start a transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel number on which to request a uDMA transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows software to request a uDMA channel to begin a transfer. This function could be used for performing a memory-to-memory transfer, or if for some reason a transfer needs to be initiated by software instead of the peripheral associated with that channel.</p>
<dl class="section note"><dt>Note</dt><dd>If the channel is <b>UDMA_CHANNEL_SW</b> and interrupts are used, then the completion is signaled on the uDMA dedicated interrupt. If a peripheral channel is used, then the completion is signaled on the peripheral's interrupt.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#a72e58ae4b094a0d2c375aa71ff828505">UDMA_SWREQ</a>.</p>

</div>
</div>
<a id="gadcd88d930702b3773952214e27bba3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd88d930702b3773952214e27bba3f6">&sect;&nbsp;</a></span>uDMAChannelAttributeEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelAttributeEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables attributes of a uDMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel to configure. </td></tr>
    <tr><td class="paramname">ui32Attr</td><td>is a combination of attributes for the channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to enable attributes of a uDMA channel.</p>
<p>The <em>ui32Attr</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>UDMA_ATTR_USEBURST</b> is used to restrict transfers to use only burst mode.</li>
<li><b>UDMA_ATTR_ALTSELECT</b> is used to select the alternate control structure for this channel (it is very unlikely that this flag should be used).</li>
<li><b>UDMA_ATTR_HIGH_PRIORITY</b> is used to set this channel to high priority.</li>
<li><b>UDMA_ATTR_REQMASK</b> is used to mask the hardware request signal from the peripheral for this channel.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#aa94840220d20a5befb242b02ad5c5faf">UDMA_ALTSET</a>, <a class="el" href="udma_8h.html#a0b27e30dfe1f1ec530eda75e94fec571">UDMA_ATTR_ALTSELECT</a>, <a class="el" href="udma_8h.html#af9b9ed2a83ed20e155161beb4bff3586">UDMA_ATTR_HIGH_PRIORITY</a>, <a class="el" href="udma_8h.html#aa857541951178e9d8ba488470f3206b6">UDMA_ATTR_REQMASK</a>, <a class="el" href="udma_8h.html#a0445fc75f523048196ceb311b12c02ca">UDMA_ATTR_USEBURST</a>, <a class="el" href="hw__udma_8h.html#a616a171071e25adf3b2ffb37b3c4e31b">UDMA_PRIOSET</a>, <a class="el" href="hw__udma_8h.html#abefbeb3ff10b0d9388631bd4b0f4fae5">UDMA_REQMASKSET</a>, and <a class="el" href="hw__udma_8h.html#a93b7ff36ae2aa59087166fc2445a5f86">UDMA_USEBURSTSET</a>.</p>

</div>
</div>
<a id="ga687745cb1ba10bcfbaac4bf0bbfd4132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687745cb1ba10bcfbaac4bf0bbfd4132">&sect;&nbsp;</a></span>uDMAChannelAttributeDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelAttributeDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables attributes of a uDMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel to configure. </td></tr>
    <tr><td class="paramname">ui32Attr</td><td>is a combination of attributes for the channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to disable attributes of a uDMA channel.</p>
<p>The <em>ui32Attr</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>UDMA_ATTR_USEBURST</b> is used to restrict transfers to use only burst mode.</li>
<li><b>UDMA_ATTR_ALTSELECT</b> is used to select the alternate control structure for this channel.</li>
<li><b>UDMA_ATTR_HIGH_PRIORITY</b> is used to set this channel to high priority.</li>
<li><b>UDMA_ATTR_REQMASK</b> is used to mask the hardware request signal from the peripheral for this channel.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#a297a23ad50e4111b1fbd0690c4c4a1c2">UDMA_ALTCLR</a>, <a class="el" href="udma_8h.html#a0b27e30dfe1f1ec530eda75e94fec571">UDMA_ATTR_ALTSELECT</a>, <a class="el" href="udma_8h.html#af9b9ed2a83ed20e155161beb4bff3586">UDMA_ATTR_HIGH_PRIORITY</a>, <a class="el" href="udma_8h.html#aa857541951178e9d8ba488470f3206b6">UDMA_ATTR_REQMASK</a>, <a class="el" href="udma_8h.html#a0445fc75f523048196ceb311b12c02ca">UDMA_ATTR_USEBURST</a>, <a class="el" href="hw__udma_8h.html#a4551274bc3f8c607d10e7407030a043d">UDMA_PRIOCLR</a>, <a class="el" href="hw__udma_8h.html#a9bf39ed430bce60aff19ce8115120751">UDMA_REQMASKCLR</a>, and <a class="el" href="hw__udma_8h.html#a54570c67d2b37e5750c87393663d19e8">UDMA_USEBURSTCLR</a>.</p>

</div>
</div>
<a id="ga741cac245ca559d1a1112077a7f46b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741cac245ca559d1a1112077a7f46b8c">&sect;&nbsp;</a></span>uDMAChannelAttributeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uDMAChannelAttributeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the enabled attributes of a uDMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the channel to configure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a combination of flags representing the attributes of the uDMA channel.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the logical OR of the attributes of the uDMA channel, which can be any of the following:<ul>
<li><b>UDMA_ATTR_USEBURST</b> is used to restrict transfers to use only burst mode.</li>
<li><b>UDMA_ATTR_ALTSELECT</b> is used to select the alternate control structure for this channel.</li>
<li><b>UDMA_ATTR_HIGH_PRIORITY</b> is used to set this channel to high priority.</li>
<li><b>UDMA_ATTR_REQMASK</b> is used to mask the hardware request signal from the peripheral for this channel. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#aa94840220d20a5befb242b02ad5c5faf">UDMA_ALTSET</a>, <a class="el" href="udma_8h.html#a0b27e30dfe1f1ec530eda75e94fec571">UDMA_ATTR_ALTSELECT</a>, <a class="el" href="udma_8h.html#af9b9ed2a83ed20e155161beb4bff3586">UDMA_ATTR_HIGH_PRIORITY</a>, <a class="el" href="udma_8h.html#aa857541951178e9d8ba488470f3206b6">UDMA_ATTR_REQMASK</a>, <a class="el" href="udma_8h.html#a0445fc75f523048196ceb311b12c02ca">UDMA_ATTR_USEBURST</a>, <a class="el" href="hw__udma_8h.html#a616a171071e25adf3b2ffb37b3c4e31b">UDMA_PRIOSET</a>, <a class="el" href="hw__udma_8h.html#abefbeb3ff10b0d9388631bd4b0f4fae5">UDMA_REQMASKSET</a>, and <a class="el" href="hw__udma_8h.html#a93b7ff36ae2aa59087166fc2445a5f86">UDMA_USEBURSTSET</a>.</p>

</div>
</div>
<a id="ga6f73ab006ff6a593eeeb947130bbdf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f73ab006ff6a593eeeb947130bbdf6f">&sect;&nbsp;</a></span>uDMAChannelControlSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelControlSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelStructIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the control parameters for a uDMA channel control structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelStructIndex</td><td>is the logical OR of the uDMA channel number with <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b>. </td></tr>
    <tr><td class="paramname">ui32Control</td><td>is logical OR of several control values to set the control parameters for the channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set control parameters for a uDMA transfer. These parameters are typically not changed often.</p>
<p>The <em>ui32ChannelStructIndex</em> parameter should be the logical OR of the channel number with one of <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b> to choose whether the primary or alternate data structure is used.</p>
<p>The <em>ui32Control</em> parameter is the logical OR of five values: the data size, the source address increment, the destination address increment, the arbitration size, and the use burst flag. The choices available for each of these values is described below.</p>
<p>Choose the data size from one of <b>UDMA_SIZE_8</b>, <b>UDMA_SIZE_16</b>, or <b>UDMA_SIZE_32</b> to select a data size of 8, 16, or 32 bits.</p>
<p>Choose the source address increment from one of <b>UDMA_SRC_INC_8</b>, <b>UDMA_SRC_INC_16</b>, <b>UDMA_SRC_INC_32</b>, or <b>UDMA_SRC_INC_NONE</b> to select an address increment of 8-bit bytes, 16-bit half-words, 32-bit words, or to select non-incrementing.</p>
<p>Choose the destination address increment from one of <b>UDMA_DST_INC_8</b>, <b>UDMA_DST_INC_16</b>, <b>UDMA_DST_INC_32</b>, or <b>UDMA_DST_INC_NONE</b> to select an address increment of 8-bit bytes, 16-bit half-words, 32-bit words, or to select non-incrementing.</p>
<p>The arbitration size determines how many items are transferred before the uDMA controller re-arbitrates for the bus. Choose the arbitration size from one of <b>UDMA_ARB_1</b>, <b>UDMA_ARB_2</b>, <b>UDMA_ARB_4</b>, <b>UDMA_ARB_8</b>, through <b>UDMA_ARB_1024</b> to select the arbitration size from 1 to 1024 items, in powers of 2.</p>
<p>The value <b>UDMA_NEXT_USEBURST</b> is used to force the channel to only respond to burst requests at the tail end of a scatter-gather transfer.</p>
<dl class="section note"><dt>Note</dt><dd>The address increment cannot be smaller than the data size.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#a47776240d7ab85f1582acd753443ce75">UDMA_CHCTL_ARBSIZE_M</a>, <a class="el" href="hw__udma_8h.html#ac1264e9f4d0785fe752f86ea39242574">UDMA_CHCTL_DSTINC_M</a>, <a class="el" href="hw__udma_8h.html#a4d1a9c7817bc1a46b506451ac66a1cbd">UDMA_CHCTL_DSTSIZE_M</a>, <a class="el" href="hw__udma_8h.html#a31de6174f855ff5f8e1fb52f9d60f8a8">UDMA_CHCTL_NXTUSEBURST</a>, <a class="el" href="hw__udma_8h.html#acd028d22f870c5e7f7c93759c97d4f93">UDMA_CHCTL_SRCINC_M</a>, <a class="el" href="hw__udma_8h.html#a998df26f37c42e19df7c5df36a15a9cb">UDMA_CHCTL_SRCSIZE_M</a>, <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>, and <a class="el" href="structt_d_m_a_control_table.html#a408694668c5a110a70841dcdf90bed3b">tDMAControlTable::ui32Control</a>.</p>

</div>
</div>
<a id="ga938c21dc70cb6e11e6eb826de0fa21c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938c21dc70cb6e11e6eb826de0fa21c3">&sect;&nbsp;</a></span>uDMAChannelTransferSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelTransferSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelStructIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvDstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TransferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transfer parameters for a uDMA channel control structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelStructIndex</td><td>is the logical OR of the uDMA channel number with either <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b>. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>is the type of uDMA transfer. </td></tr>
    <tr><td class="paramname">pvSrcAddr</td><td>is the source address for the transfer. </td></tr>
    <tr><td class="paramname">pvDstAddr</td><td>is the destination address for the transfer. </td></tr>
    <tr><td class="paramname">ui32TransferSize</td><td>is the number of data items to transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the parameters for a uDMA transfer. These parameters are not typically changed often. The function <a class="el" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet()</a> MUST be called at least once for this channel prior to calling this function.</p>
<p>The <em>ui32ChannelStructIndex</em> parameter should be the logical OR of the channel number with one of <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b> to choose whether the primary or alternate data structure is used.</p>
<p>The <em>ui32Mode</em> parameter should be one of the following values:</p>
<ul>
<li><b>UDMA_MODE_STOP</b> stops the uDMA transfer. The controller sets the mode to this value at the end of a transfer.</li>
<li><b>UDMA_MODE_BASIC</b> to perform a basic transfer based on request.</li>
<li><b>UDMA_MODE_AUTO</b> to perform a transfer that always completes once started even if the request is removed.</li>
<li><b>UDMA_MODE_PINGPONG</b> to set up a transfer that switches between the primary and alternate control structures for the channel. This mode allows use of ping-pong buffering for uDMA transfers.</li>
<li><b>UDMA_MODE_MEM_SCATTER_GATHER</b> to set up a memory scatter-gather transfer.</li>
<li><b>UDMA_MODE_PER_SCATTER_GATHER</b> to set up a peripheral scatter-gather transfer.</li>
</ul>
<p>The <em>pvSrcAddr</em> and <em>pvDstAddr</em> parameters are pointers to the first location of the data to be transferred. These addresses should be aligned according to the item size. The compiler takes care of this alignment if the pointers are pointing to storage of the appropriate data type.</p>
<p>The <em>ui32TransferSize</em> parameter is the number of data items, not the number of bytes.</p>
<p>The two scatter-gather modes, memory and peripheral, are actually different depending on whether the primary or alternate control structure is selected. This function looks for the <b>UDMA_PRI_SELECT</b> and <b>UDMA_ALT_SELECT</b> flag along with the channel number and sets the scatter-gather mode as appropriate for the primary or alternate control structure.</p>
<p>The channel must also be enabled using <a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable()</a> after calling this function. The transfer does not begin until the channel has been configured and enabled. Note that the channel is automatically disabled after the transfer is completed, meaning that <a class="el" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable()</a> must be called again after setting up the next transfer.</p>
<dl class="section note"><dt>Note</dt><dd>Great care must be taken to not modify a channel control structure that is in use or else the results are unpredictable, including the possibility of undesired data transfers to or from memory or peripherals. For BASIC and AUTO modes, it is safe to make changes when the channel is disabled, or the <a class="el" href="group__udma__api.html#ga84a74cc2b06a6a59506dcdfabd0c7972">uDMAChannelModeGet()</a> returns <b>UDMA_MODE_STOP</b>. For PINGPONG or one of the SCATTER_GATHER modes, it is safe to modify the primary or alternate control structure only when the other is being used. The <a class="el" href="group__udma__api.html#ga84a74cc2b06a6a59506dcdfabd0c7972">uDMAChannelModeGet()</a> function returns <b>UDMA_MODE_STOP</b> when a channel control structure is inactive and safe to modify.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="structt_d_m_a_control_table.html#a7346504231dcaa51e6da47bb82256c8f">tDMAControlTable::pvDstEndAddr</a>, <a class="el" href="structt_d_m_a_control_table.html#a211c562f9f14e09e84cd8c215e69c7a5">tDMAControlTable::pvSrcEndAddr</a>, <a class="el" href="udma_8h.html#a771b6d461c641f0902ce146fe41a3321">UDMA_ALT_SELECT</a>, <a class="el" href="hw__udma_8h.html#ac1264e9f4d0785fe752f86ea39242574">UDMA_CHCTL_DSTINC_M</a>, <a class="el" href="hw__udma_8h.html#acd028d22f870c5e7f7c93759c97d4f93">UDMA_CHCTL_SRCINC_M</a>, <a class="el" href="hw__udma_8h.html#ae3ea72dfa406ca2a250dd62d271d3566">UDMA_CHCTL_XFERMODE_M</a>, <a class="el" href="hw__udma_8h.html#ab20c09d0d72e80b1556c0215454ea1d8">UDMA_CHCTL_XFERSIZE_M</a>, <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>, <a class="el" href="udma_8h.html#aff850520540f2dd5ef6c016ac9bc85f8">UDMA_DST_INC_NONE</a>, <a class="el" href="udma_8h.html#ade8eb75e2d128f81131a52832c9046d7">UDMA_MODE_ALT_SELECT</a>, <a class="el" href="udma_8h.html#ab99c1f842fc5873d9639dd5c81f52e96">UDMA_MODE_MEM_SCATTER_GATHER</a>, <a class="el" href="udma_8h.html#a45c6f39ddeb623a7d1df04d3e0b15998">UDMA_MODE_PER_SCATTER_GATHER</a>, <a class="el" href="udma_8h.html#ace9a62c226f2e73cc1a7c56d80efa361">UDMA_SRC_INC_NONE</a>, and <a class="el" href="structt_d_m_a_control_table.html#a408694668c5a110a70841dcdf90bed3b">tDMAControlTable::ui32Control</a>.</p>

</div>
</div>
<a id="gaac152bd620c5edc6d2d348ac7771c882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac152bd620c5edc6d2d348ac7771c882">&sect;&nbsp;</a></span>uDMAChannelScatterGatherSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelScatterGatherSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TaskCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvTaskList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IsPeriphSG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a uDMA channel for scatter-gather mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelNum</td><td>is the uDMA channel number. </td></tr>
    <tr><td class="paramname">ui32TaskCount</td><td>is the number of scatter-gather tasks to execute. </td></tr>
    <tr><td class="paramname">pvTaskList</td><td>is a pointer to the beginning of the scatter-gather task list. </td></tr>
    <tr><td class="paramname">ui32IsPeriphSG</td><td>is a flag to indicate it is a peripheral scatter-gather transfer (else it is memory scatter-gather transfer)</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure a channel for scatter-gather mode. The caller must have already set up a task list and must pass a pointer to the start of the task list as the <em>pvTaskList</em> parameter. The <em>ui32TaskCount</em> parameter is the count of tasks in the task list, not the size of the task list. The flag <em>bIsPeriphSG</em> should be used to indicate if scatter-gather should be configured for peripheral or memory operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udma__api.html#gacd1b76fcec3e9bf46b26b75774a47d61">uDMATaskStructEntry</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="structt_d_m_a_control_table.html#a7346504231dcaa51e6da47bb82256c8f">tDMAControlTable::pvDstEndAddr</a>, <a class="el" href="structt_d_m_a_control_table.html#a211c562f9f14e09e84cd8c215e69c7a5">tDMAControlTable::pvSrcEndAddr</a>, <a class="el" href="udma_8h.html#a771b6d461c641f0902ce146fe41a3321">UDMA_ALT_SELECT</a>, <a class="el" href="hw__udma_8h.html#a297a23ad50e4111b1fbd0690c4c4a1c2">UDMA_ALTCLR</a>, <a class="el" href="hw__udma_8h.html#abf5016e197e4f1ea31c6e77902587a43">UDMA_CHCTL_ARBSIZE_4</a>, <a class="el" href="hw__udma_8h.html#abd9009cbe6cb94351b44ad0b7c2ce0a1">UDMA_CHCTL_DSTINC_32</a>, <a class="el" href="hw__udma_8h.html#a6e7cba2be4f561a40a1dd154296b06e9">UDMA_CHCTL_DSTSIZE_32</a>, <a class="el" href="hw__udma_8h.html#a14161ca6906e08c2452e7429067af299">UDMA_CHCTL_SRCINC_32</a>, <a class="el" href="hw__udma_8h.html#ac7de0686f7dbd06d508297492bd68ba9">UDMA_CHCTL_SRCSIZE_32</a>, <a class="el" href="hw__udma_8h.html#a9e6063c5a69d1583b8771bd524ac176b">UDMA_CHCTL_XFERMODE_MEM_SG</a>, <a class="el" href="hw__udma_8h.html#aaa64533f9fdec32bf78225bae7a0509d">UDMA_CHCTL_XFERMODE_PER_SG</a>, <a class="el" href="hw__udma_8h.html#a3ba2fb1a3f7c5322d9785e77b5a8e9d4">UDMA_CHCTL_XFERSIZE_S</a>, <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>, <a class="el" href="structt_d_m_a_control_table.html#a408694668c5a110a70841dcdf90bed3b">tDMAControlTable::ui32Control</a>, and <a class="el" href="structt_d_m_a_control_table.html#a4f63f0ed18f20f7b81146ad194a259f9">tDMAControlTable::ui32Spare</a>.</p>

</div>
</div>
<a id="ga52908962d5fdc8ad21d14a3ebb19c0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52908962d5fdc8ad21d14a3ebb19c0b9">&sect;&nbsp;</a></span>uDMAChannelSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uDMAChannelSizeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelStructIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current transfer size for a uDMA channel control structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelStructIndex</td><td>is the logical OR of the uDMA channel number with either <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to get the uDMA transfer size for a channel. The transfer size is the number of items to transfer, where the size of an item might be 8, 16, or 32 bits. If a partial transfer has already occurred, then the number of remaining items is returned. If the transfer is complete, then 0 is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of items remaining to transfer. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#ae3ea72dfa406ca2a250dd62d271d3566">UDMA_CHCTL_XFERMODE_M</a>, <a class="el" href="hw__udma_8h.html#ab20c09d0d72e80b1556c0215454ea1d8">UDMA_CHCTL_XFERSIZE_M</a>, <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>, and <a class="el" href="structt_d_m_a_control_table.html#a408694668c5a110a70841dcdf90bed3b">tDMAControlTable::ui32Control</a>.</p>

</div>
</div>
<a id="ga84a74cc2b06a6a59506dcdfabd0c7972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84a74cc2b06a6a59506dcdfabd0c7972">&sect;&nbsp;</a></span>uDMAChannelModeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uDMAChannelModeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ChannelStructIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the transfer mode for a uDMA channel control structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32ChannelStructIndex</td><td>is the logical OR of the uDMA channel number with either <b>UDMA_PRI_SELECT</b> or <b>UDMA_ALT_SELECT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to get the transfer mode for the uDMA channel and to query the status of a transfer on a channel. When the transfer is complete the mode is <b>UDMA_MODE_STOP</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the transfer mode of the specified channel and control structure, which is one of the following values: <b>UDMA_MODE_STOP</b>, <b>UDMA_MODE_BASIC</b>, <b>UDMA_MODE_AUTO</b>, <b>UDMA_MODE_PINGPONG</b>, <b>UDMA_MODE_MEM_SCATTER_GATHER</b>, or <b>UDMA_MODE_PER_SCATTER_GATHER</b>. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__udma_8h.html#ae3ea72dfa406ca2a250dd62d271d3566">UDMA_CHCTL_XFERMODE_M</a>, <a class="el" href="hw__udma_8h.html#adaa31653cc45c57d88b97a67c25ca7ab">UDMA_CTLBASE</a>, <a class="el" href="udma_8h.html#ade8eb75e2d128f81131a52832c9046d7">UDMA_MODE_ALT_SELECT</a>, <a class="el" href="udma_8h.html#ab99c1f842fc5873d9639dd5c81f52e96">UDMA_MODE_MEM_SCATTER_GATHER</a>, <a class="el" href="udma_8h.html#a45c6f39ddeb623a7d1df04d3e0b15998">UDMA_MODE_PER_SCATTER_GATHER</a>, and <a class="el" href="structt_d_m_a_control_table.html#a408694668c5a110a70841dcdf90bed3b">tDMAControlTable::ui32Control</a>.</p>

</div>
</div>
<a id="ga38e714509554e38d29563bf7832f7098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38e714509554e38d29563bf7832f7098">&sect;&nbsp;</a></span>uDMAIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAIntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the uDMA controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32IntChannel</td><td>identifies which uDMA interrupt is to be registered. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the interrupt is activated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers and enables the handler to be called when the uDMA controller generates an interrupt. The <em>ui32IntChannel</em> parameter should be one of the following:</p>
<ul>
<li><b>INT_UDMA</b> to register an interrupt handler to process interrupts from the uDMA software channel (UDMA_CHANNEL_SW)</li>
<li><b>INT_UDMAERR</b> to register an interrupt handler to process uDMA error interrupts</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt handler for the uDMA is for transfer completion when the channel UDMA_CHANNEL_SW is used and for error interrupts. The interrupts for each peripheral channel are handled through the individual peripheral interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable()</a>, and <a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a>.</p>

</div>
</div>
<a id="ga8728732286c8948fd715e58ca04dbd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8728732286c8948fd715e58ca04dbd84">&sect;&nbsp;</a></span>uDMAIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAIntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters an interrupt handler for the uDMA controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32IntChannel</td><td>identifies which uDMA interrupt to unregister.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables and unregisters the handler to be called for the specified uDMA interrupt. The <em>ui32IntChannel</em> parameter should be one of <b>INT_UDMA</b> or <b>INT_UDMAERR</b> as documented for the function <a class="el" href="group__udma__api.html#ga38e714509554e38d29563bf7832f7098">uDMAIntRegister()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable()</a>, and <a class="el" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister()</a>.</p>

</div>
</div>
<a id="gaa3c73411a7305843059d0984efaf7770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c73411a7305843059d0984efaf7770">&sect;&nbsp;</a></span>uDMAChannelAssign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uDMAChannelAssign </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns a peripheral mapping for a uDMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Mapping</td><td>is a macro specifying the peripheral assignment for a channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function assigns a peripheral mapping to a uDMA channel. It is used to select which peripheral is used for a uDMA channel. The parameter <em>ui32Mapping</em> should be one of the macros named <b>UDMA_CHn_tttt</b> from the header file <em><a class="el" href="udma_8h.html">udma.h</a></em>. For example, to assign uDMA channel 0 to the UART2 RX channel, the parameter should be the macro <b>UDMA_CH0_UART2RX</b>.</p>
<p>Please consult the data sheet for a table showing all the possible peripheral assignments for the uDMA channels.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__udma_8h.html#ab9541afa3b9eddbc3767c47f76f295ab">UDMA_CHMAP0</a>.</p>

<p>Referenced by <a class="el" href="group__udma__api.html#ga7ba01506573508d62442e3b3e7408bb6">uDMAInit()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
