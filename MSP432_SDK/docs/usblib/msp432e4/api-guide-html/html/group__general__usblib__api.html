<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>USBLibAPIGuide: General_usblib_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">USBLibAPIGuide
   &#160;<span id="projectnumber">1.00.00.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">General_usblib_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga56273f836afe42a987e8624adbc71424"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga56273f836afe42a987e8624adbc71424">USB_DESC_ANY</a>&#160;&#160;&#160;0xFFFFFFFF</td></tr>
<tr class="separator:ga56273f836afe42a987e8624adbc71424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac345087d466526a2b0215b90cc460f5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gac345087d466526a2b0215b90cc460f5a">USBERR_HOST_IN_PID_ERROR</a>&#160;&#160;&#160;0x01000000</td></tr>
<tr class="memdesc:gac345087d466526a2b0215b90cc460f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host received an invalid PID in a transaction.  <a href="#gac345087d466526a2b0215b90cc460f5a">More...</a><br /></td></tr>
<tr class="separator:gac345087d466526a2b0215b90cc460f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c282a985f5e53eaca0d9bfe368b058"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gaa0c282a985f5e53eaca0d9bfe368b058">USBERR_HOST_IN_NOT_COMP</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="memdesc:gaa0c282a985f5e53eaca0d9bfe368b058"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host did not receive a response from a device.  <a href="#gaa0c282a985f5e53eaca0d9bfe368b058">More...</a><br /></td></tr>
<tr class="separator:gaa0c282a985f5e53eaca0d9bfe368b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70767693a5edfa486adce477c84e07d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gac70767693a5edfa486adce477c84e07d">USBERR_HOST_IN_STALL</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="memdesc:gac70767693a5edfa486adce477c84e07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host received a stall on an IN endpoint.  <a href="#gac70767693a5edfa486adce477c84e07d">More...</a><br /></td></tr>
<tr class="separator:gac70767693a5edfa486adce477c84e07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c86128b7f99efe931c9a60edbccdeda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga2c86128b7f99efe931c9a60edbccdeda">USBERR_HOST_IN_DATA_ERROR</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memdesc:ga2c86128b7f99efe931c9a60edbccdeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host detected a CRC or bit-stuffing error (isochronous mode).  <a href="#ga2c86128b7f99efe931c9a60edbccdeda">More...</a><br /></td></tr>
<tr class="separator:ga2c86128b7f99efe931c9a60edbccdeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1e5e851566f1327565c4b5951fce14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga3e1e5e851566f1327565c4b5951fce14">USBERR_HOST_IN_NAK_TO</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="separator:ga3e1e5e851566f1327565c4b5951fce14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95163db29bde884e071662bf5b2e7a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga95163db29bde884e071662bf5b2e7a4f">USBERR_HOST_IN_ERROR</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="memdesc:ga95163db29bde884e071662bf5b2e7a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host failed to communicate with a device via an IN endpoint.  <a href="#ga95163db29bde884e071662bf5b2e7a4f">More...</a><br /></td></tr>
<tr class="separator:ga95163db29bde884e071662bf5b2e7a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5120ad8976f6e6bcaf6a60ea962289fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga5120ad8976f6e6bcaf6a60ea962289fd">USBERR_HOST_IN_FIFO_FULL</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:ga5120ad8976f6e6bcaf6a60ea962289fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host receive FIFO is full.  <a href="#ga5120ad8976f6e6bcaf6a60ea962289fd">More...</a><br /></td></tr>
<tr class="separator:ga5120ad8976f6e6bcaf6a60ea962289fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc56a9bd9649b6f2e660e273659c48f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga9dc56a9bd9649b6f2e660e273659c48f">USBERR_HOST_OUT_NAK_TO</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:ga9dc56a9bd9649b6f2e660e273659c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb71e7101bf038804b5005f434a719e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga2cb71e7101bf038804b5005f434a719e">USBERR_HOST_OUT_NOT_COMP</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:ga2cb71e7101bf038804b5005f434a719e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host did not receive a response from a device (isochronous mode).  <a href="#ga2cb71e7101bf038804b5005f434a719e">More...</a><br /></td></tr>
<tr class="separator:ga2cb71e7101bf038804b5005f434a719e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04692593bf810b2b662d7cdffca6a3c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga04692593bf810b2b662d7cdffca6a3c2">USBERR_HOST_OUT_STALL</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:ga04692593bf810b2b662d7cdffca6a3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host received a stall on an OUT endpoint.  <a href="#ga04692593bf810b2b662d7cdffca6a3c2">More...</a><br /></td></tr>
<tr class="separator:ga04692593bf810b2b662d7cdffca6a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ece2efd5a4066924a20c26f228bd89a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga6ece2efd5a4066924a20c26f228bd89a">USBERR_HOST_OUT_ERROR</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga6ece2efd5a4066924a20c26f228bd89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host failed to communicate with a device via an OUT endpoint.  <a href="#ga6ece2efd5a4066924a20c26f228bd89a">More...</a><br /></td></tr>
<tr class="separator:ga6ece2efd5a4066924a20c26f228bd89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c967d648c54e8765aa5062e429aad63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga9c967d648c54e8765aa5062e429aad63">USBERR_HOST_EP0_NAK_TO</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:ga9c967d648c54e8765aa5062e429aad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6e7d9773f952f6cd716004243ba8b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga8b6e7d9773f952f6cd716004243ba8b1">USBERR_HOST_EP0_ERROR</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:ga8b6e7d9773f952f6cd716004243ba8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The host failed to communicate with a device via an endpoint zero.  <a href="#ga8b6e7d9773f952f6cd716004243ba8b1">More...</a><br /></td></tr>
<tr class="separator:ga8b6e7d9773f952f6cd716004243ba8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa9777292630d6830ad42338b9821e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga6aa9777292630d6830ad42338b9821e7">USBERR_DEV_RX_DATA_ERROR</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memdesc:ga6aa9777292630d6830ad42338b9821e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device detected a CRC error in received data.  <a href="#ga6aa9777292630d6830ad42338b9821e7">More...</a><br /></td></tr>
<tr class="separator:ga6aa9777292630d6830ad42338b9821e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c408d7328fec7ae4f0e1d243c22b613"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga6c408d7328fec7ae4f0e1d243c22b613">USBERR_DEV_RX_OVERRUN</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:ga6c408d7328fec7ae4f0e1d243c22b613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb600b9ea8119ab3018ec5fb77f70d5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gabb600b9ea8119ab3018ec5fb77f70d5c">USBERR_DEV_RX_FIFO_FULL</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:gabb600b9ea8119ab3018ec5fb77f70d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device receive FIFO is full.  <a href="#gabb600b9ea8119ab3018ec5fb77f70d5c">More...</a><br /></td></tr>
<tr class="separator:gabb600b9ea8119ab3018ec5fb77f70d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548d0631745d87203a20d4d137ae3a09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga548d0631745d87203a20d4d137ae3a09">USB_HOST_INTS</a>&#160;&#160;&#160;(USB_INTCTRL_VBUS_ERR)</td></tr>
<tr class="separator:ga548d0631745d87203a20d4d137ae3a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga51f3e724ef18491ce2291e205140d83e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structt_u_s_b_d_m_a_instance.html">tUSBDMAInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga51f3e724ef18491ce2291e205140d83e">tUSBDMAInstance</a></td></tr>
<tr class="separator:ga51f3e724ef18491ce2291e205140d83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1096ec8132f36128b53b7b506019dae9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga1096ec8132f36128b53b7b506019dae9">tUSBModeCallback</a>) (uint32_t ui32Index, <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> iMode)</td></tr>
<tr class="separator:ga1096ec8132f36128b53b7b506019dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b2c7063c0895d2a98a78918d907f90"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga28b2c7063c0895d2a98a78918d907f90">tUSBCallback</a>) (void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgParam, void *pvMsgData)</td></tr>
<tr class="separator:ga28b2c7063c0895d2a98a78918d907f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga31e8cc45b2a98ae64491dc055114b628"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> { <br />
&#160;&#160;<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628a3bd089f927356e565b6081c989d1c138">eUSBModeDevice</a> = 0, 
<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628add4aadcd7bae9f0af3813000d07f9464">eUSBModeHost</a>, 
<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628a2a6fab83dddeb4abd6c76c78124b145a">eUSBModeOTG</a>, 
<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40">eUSBModeNone</a>, 
<br />
&#160;&#160;<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628acbad6622a489765b96d063d649e8a023">eUSBModeForceHost</a>, 
<a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad3874ba18e37798ee3cb5c557116a698">eUSBModeForceDevice</a>
<br />
 }</td></tr>
<tr class="separator:ga31e8cc45b2a98ae64491dc055114b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded7d9b37df85ca90e41af1e6f689613"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gaded7d9b37df85ca90e41af1e6f689613">tUSBOTGState</a> { <br />
&#160;&#160;<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613ad27b94149ebd752d51688fb7e6acf2ab">eUSBOTGModeIdle</a>, 
<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613aa1323cefb9f788a26457d7af0e2979e5">eUSBOTGModeWaitID</a>, 
<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613a804a983f079213830ee95fc2587f5a07">eUSBOTGModeWait</a>, 
<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613aaf76a56955110c0fd0f69d83cbe05851">eUSBOTGModeBWaitCon</a>, 
<br />
&#160;&#160;<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613aecd777355caca853b040e4798c318057">eUSBOTGModeBDevice</a>, 
<a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613a2e55713b539035c755ddfc2499eb8b62">eUSBOTGModeAHost</a>
<br />
 }</td></tr>
<tr class="separator:gaded7d9b37df85ca90e41af1e6f689613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab243cb14579868181bc72b750c1fdfa4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gab243cb14579868181bc72b750c1fdfa4">USBDescGetNum</a> (tDescriptorHeader *psDesc, uint32_t ui32Size, uint32_t ui32Type)</td></tr>
<tr class="separator:gab243cb14579868181bc72b750c1fdfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a39fd14e9b62ad421f03b3f9eb8812"><td class="memItemLeft" align="right" valign="top">tDescriptorHeader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga27a39fd14e9b62ad421f03b3f9eb8812">USBDescGet</a> (tDescriptorHeader *psDesc, uint32_t ui32Size, uint32_t ui32Type, uint32_t ui32Index)</td></tr>
<tr class="separator:ga27a39fd14e9b62ad421f03b3f9eb8812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833bcedfa64ba47eaffa2ed9847bc832"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga833bcedfa64ba47eaffa2ed9847bc832">USBDescGetNumAlternateInterfaces</a> (tConfigDescriptor *psConfig, uint8_t ui8InterfaceNumber)</td></tr>
<tr class="separator:ga833bcedfa64ba47eaffa2ed9847bc832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e32a340fb8d693049abf2788767ef5"><td class="memItemLeft" align="right" valign="top">tInterfaceDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gaa0e32a340fb8d693049abf2788767ef5">USBDescGetInterface</a> (tConfigDescriptor *psConfig, uint32_t ui32Index, uint32_t ui32Alt)</td></tr>
<tr class="separator:gaa0e32a340fb8d693049abf2788767ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4660d78efa5b8f601c93ec5c999b5f4a"><td class="memItemLeft" align="right" valign="top">tEndpointDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga4660d78efa5b8f601c93ec5c999b5f4a">USBDescGetInterfaceEndpoint</a> (tInterfaceDescriptor *psInterface, uint32_t ui32Index, uint32_t ui32Size)</td></tr>
<tr class="separator:ga4660d78efa5b8f601c93ec5c999b5f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76261a6a917ef4b0b596f91f06cc4c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga76261a6a917ef4b0b596f91f06cc4c6b">USBStackModeSet</a> (uint32_t ui32Index, <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> iUSBMode, <a class="el" href="group__general__usblib__api.html#ga1096ec8132f36128b53b7b506019dae9">tUSBModeCallback</a> pfnCallback)</td></tr>
<tr class="separator:ga76261a6a917ef4b0b596f91f06cc4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0178cee084efca10209dd9a9eaeab1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler</a> (void)</td></tr>
<tr class="separator:gae0178cee084efca10209dd9a9eaeab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6b4cb7df409d056c59a11e38be1b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gacf6b4cb7df409d056c59a11e38be1b2b">InternalUSBTickInit</a> (void)</td></tr>
<tr class="separator:gacf6b4cb7df409d056c59a11e38be1b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c93dd41aa0868392adce925bc7ddc39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga3c93dd41aa0868392adce925bc7ddc39">InternalUSBTickReset</a> (void)</td></tr>
<tr class="separator:ga3c93dd41aa0868392adce925bc7ddc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac719b1dcf3305b8c459b43f025fd09a5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gac719b1dcf3305b8c459b43f025fd09a5">InternalUSBRegisterTickHandler</a> (<a class="el" href="group__usblib__dma__api.html#ga143136780ce8b1a1c8f75ff004e7d8c6">tUSBTickHandler</a> pfHandler, void *pvInstance)</td></tr>
<tr class="separator:gac719b1dcf3305b8c459b43f025fd09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702ced12b6588bfa8a75922477f65800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga702ced12b6588bfa8a75922477f65800">InternalUSBStartOfFrameTick</a> (uint32_t ui32TicksmS)</td></tr>
<tr class="separator:ga702ced12b6588bfa8a75922477f65800"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafc6aafb732127c6f1d9cb66d738c6607"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gafc6aafb732127c6f1d9cb66d738c6607">g_iUSBMode</a> = <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40">eUSBModeNone</a></td></tr>
<tr class="separator:gafc6aafb732127c6f1d9cb66d738c6607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047cb1187d56d649dd5eda319fe23c8a"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga047cb1187d56d649dd5eda319fe23c8a">g_ui32PollRate</a></td></tr>
<tr class="separator:ga047cb1187d56d649dd5eda319fe23c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78691fc2c849004b53ce2f67fc5f3a2"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gac78691fc2c849004b53ce2f67fc5f3a2">g_ui32WaitTicks</a> = 0</td></tr>
<tr class="separator:gac78691fc2c849004b53ce2f67fc5f3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830335f7a4fe3752317f6114f12307fe"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__general__usblib__api.html#gaded7d9b37df85ca90e41af1e6f689613">tUSBOTGState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga830335f7a4fe3752317f6114f12307fe">g_eOTGModeState</a></td></tr>
<tr class="separator:ga830335f7a4fe3752317f6114f12307fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e63a878bc4c533e43276cd97f0d9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__usblib__dma__api.html#ga143136780ce8b1a1c8f75ff004e7d8c6">tUSBTickHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gae6e63a878bc4c533e43276cd97f0d9db">g_pfnTickHandlers</a> [<a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>]</td></tr>
<tr class="separator:gae6e63a878bc4c533e43276cd97f0d9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b49104e1a75fd25e94d2fbbb037be1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#gac1b49104e1a75fd25e94d2fbbb037be1">g_pvTickInstance</a> [<a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>]</td></tr>
<tr class="separator:gac1b49104e1a75fd25e94d2fbbb037be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bca186737fbaa176e3ed2425f36325a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga8bca186737fbaa176e3ed2425f36325a">g_bUSBTimerInitialized</a> = false</td></tr>
<tr class="separator:ga8bca186737fbaa176e3ed2425f36325a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039de15fd461539e25595386e32710d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga039de15fd461539e25595386e32710d0">g_ui32CurrentUSBTick</a> = 0</td></tr>
<tr class="separator:ga039de15fd461539e25595386e32710d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403806c90de91531674d6665c8b5b447"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__general__usblib__api.html#ga403806c90de91531674d6665c8b5b447">g_ui32USBSOFCount</a> = 0</td></tr>
<tr class="separator:ga403806c90de91531674d6665c8b5b447"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga56273f836afe42a987e8624adbc71424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56273f836afe42a987e8624adbc71424">&sect;&nbsp;</a></span>USB_DESC_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_DESC_ANY&#160;&#160;&#160;0xFFFFFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The USB_DESC_ANY label is used as a wild card in several of the descriptor parsing APIs to determine whether or not particular search criteria should be ignored. </p>

<p>Referenced by <a class="el" href="group__device__api.html#ga039c52bf27ef7adc726df1d5fb0ca970">USBDCDConfigGetInterface()</a>, <a class="el" href="group__general__usblib__api.html#ga27a39fd14e9b62ad421f03b3f9eb8812">USBDescGet()</a>, <a class="el" href="group__general__usblib__api.html#gaa0e32a340fb8d693049abf2788767ef5">USBDescGetInterface()</a>, <a class="el" href="group__general__usblib__api.html#gab243cb14579868181bc72b750c1fdfa4">USBDescGetNum()</a>, <a class="el" href="group__device__api.html#gad25366c33b7be25ef9c443f98de7cab6">USBDeviceConfig()</a>, and <a class="el" href="group__device__api.html#ga7d5f183e9986574a94f4b0f3916577f1">USBDeviceConfigAlternate()</a>.</p>

</div>
</div>
<a id="gac345087d466526a2b0215b90cc460f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac345087d466526a2b0215b90cc460f5a">&sect;&nbsp;</a></span>USBERR_HOST_IN_PID_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_PID_ERROR&#160;&#160;&#160;0x01000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host received an invalid PID in a transaction. </p>

</div>
</div>
<a id="gaa0c282a985f5e53eaca0d9bfe368b058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c282a985f5e53eaca0d9bfe368b058">&sect;&nbsp;</a></span>USBERR_HOST_IN_NOT_COMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_NOT_COMP&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host did not receive a response from a device. </p>

</div>
</div>
<a id="gac70767693a5edfa486adce477c84e07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac70767693a5edfa486adce477c84e07d">&sect;&nbsp;</a></span>USBERR_HOST_IN_STALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_STALL&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host received a stall on an IN endpoint. </p>

</div>
</div>
<a id="ga2c86128b7f99efe931c9a60edbccdeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c86128b7f99efe931c9a60edbccdeda">&sect;&nbsp;</a></span>USBERR_HOST_IN_DATA_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_DATA_ERROR&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host detected a CRC or bit-stuffing error (isochronous mode). </p>

</div>
</div>
<a id="ga3e1e5e851566f1327565c4b5951fce14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e1e5e851566f1327565c4b5951fce14">&sect;&nbsp;</a></span>USBERR_HOST_IN_NAK_TO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_NAK_TO&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The host received NAK on an IN endpoint for longer than the specified timeout period (interrupt, bulk and control modes). </p>

</div>
</div>
<a id="ga95163db29bde884e071662bf5b2e7a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95163db29bde884e071662bf5b2e7a4f">&sect;&nbsp;</a></span>USBERR_HOST_IN_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_ERROR&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host failed to communicate with a device via an IN endpoint. </p>

</div>
</div>
<a id="ga5120ad8976f6e6bcaf6a60ea962289fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5120ad8976f6e6bcaf6a60ea962289fd">&sect;&nbsp;</a></span>USBERR_HOST_IN_FIFO_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_IN_FIFO_FULL&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host receive FIFO is full. </p>

</div>
</div>
<a id="ga9dc56a9bd9649b6f2e660e273659c48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dc56a9bd9649b6f2e660e273659c48f">&sect;&nbsp;</a></span>USBERR_HOST_OUT_NAK_TO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_OUT_NAK_TO&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The host received NAK on an OUT endpoint for longer than the specified timeout period (bulk, interrupt and control modes). </p>

</div>
</div>
<a id="ga2cb71e7101bf038804b5005f434a719e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb71e7101bf038804b5005f434a719e">&sect;&nbsp;</a></span>USBERR_HOST_OUT_NOT_COMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_OUT_NOT_COMP&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host did not receive a response from a device (isochronous mode). </p>

</div>
</div>
<a id="ga04692593bf810b2b662d7cdffca6a3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04692593bf810b2b662d7cdffca6a3c2">&sect;&nbsp;</a></span>USBERR_HOST_OUT_STALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_OUT_STALL&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host received a stall on an OUT endpoint. </p>

</div>
</div>
<a id="ga6ece2efd5a4066924a20c26f228bd89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ece2efd5a4066924a20c26f228bd89a">&sect;&nbsp;</a></span>USBERR_HOST_OUT_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_OUT_ERROR&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host failed to communicate with a device via an OUT endpoint. </p>

</div>
</div>
<a id="ga9c967d648c54e8765aa5062e429aad63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c967d648c54e8765aa5062e429aad63">&sect;&nbsp;</a></span>USBERR_HOST_EP0_NAK_TO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_EP0_NAK_TO&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The host received NAK on endpoint 0 for longer than the configured timeout. </p>

</div>
</div>
<a id="ga8b6e7d9773f952f6cd716004243ba8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b6e7d9773f952f6cd716004243ba8b1">&sect;&nbsp;</a></span>USBERR_HOST_EP0_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_HOST_EP0_ERROR&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The host failed to communicate with a device via an endpoint zero. </p>

</div>
</div>
<a id="ga6aa9777292630d6830ad42338b9821e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa9777292630d6830ad42338b9821e7">&sect;&nbsp;</a></span>USBERR_DEV_RX_DATA_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_DEV_RX_DATA_ERROR&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device detected a CRC error in received data. </p>

</div>
</div>
<a id="ga6c408d7328fec7ae4f0e1d243c22b613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c408d7328fec7ae4f0e1d243c22b613">&sect;&nbsp;</a></span>USBERR_DEV_RX_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_DEV_RX_OVERRUN&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The device was unable to receive a packet from the host since the receive FIFO is full. </p>

</div>
</div>
<a id="gabb600b9ea8119ab3018ec5fb77f70d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb600b9ea8119ab3018ec5fb77f70d5c">&sect;&nbsp;</a></span>USBERR_DEV_RX_FIFO_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBERR_DEV_RX_FIFO_FULL&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device receive FIFO is full. </p>

</div>
</div>
<a id="ga548d0631745d87203a20d4d137ae3a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548d0631745d87203a20d4d137ae3a09">&sect;&nbsp;</a></span>USB_HOST_INTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_HOST_INTS&#160;&#160;&#160;(USB_INTCTRL_VBUS_ERR)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga51f3e724ef18491ce2291e205140d83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f3e724ef18491ce2291e205140d83e">&sect;&nbsp;</a></span>tUSBDMAInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structt_u_s_b_d_m_a_instance.html">tUSBDMAInstance</a> <a class="el" href="structt_u_s_b_d_m_a_instance.html">tUSBDMAInstance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1096ec8132f36128b53b7b506019dae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1096ec8132f36128b53b7b506019dae9">&sect;&nbsp;</a></span>tUSBModeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tUSBModeCallback) (uint32_t ui32Index, <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> iMode)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga28b2c7063c0895d2a98a78918d907f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b2c7063c0895d2a98a78918d907f90">&sect;&nbsp;</a></span>tUSBCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(*  tUSBCallback) (void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgParam, void *pvMsgData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvCBData</td><td>is the callback pointer associated with the instance generating the callback. This is a value provided by the client during initialization of the instance making the callback. </td></tr>
    <tr><td class="paramname">ui32Event</td><td>is the identifier of the asynchronous event which is being notified to the client. </td></tr>
    <tr><td class="paramname">ui32MsgParam</td><td>is an event-specific parameter. </td></tr>
    <tr><td class="paramname">pvMsgData</td><td>is an event-specific data pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>A function pointer provided to the USB layer by the application which will be called to notify it of all asynchronous events relating to data transmission or reception. This callback is used by device class drivers and host pipe functions.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns an event-dependent value. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga31e8cc45b2a98ae64491dc055114b628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e8cc45b2a98ae64491dc055114b628">&sect;&nbsp;</a></span>tUSBMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operating mode required by the USB library client. This type is used by applications which wish to be able to switch between host and device modes by calling the <a class="el" href="group__general__usblib__api.html#ga76261a6a917ef4b0b596f91f06cc4c6b">USBStackModeSet()</a> API. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628a3bd089f927356e565b6081c989d1c138"></a>eUSBModeDevice&#160;</td><td class="fielddoc"><p>Operate in USB device mode with active monitoring of VBUS and the ID pin must be pulled to a logic high value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628add4aadcd7bae9f0af3813000d07f9464"></a>eUSBModeHost&#160;</td><td class="fielddoc"><p>Operate in USB host mode with active monitoring of VBUS and the ID pin must be pulled to a logic low value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628a2a6fab83dddeb4abd6c76c78124b145a"></a>eUSBModeOTG&#160;</td><td class="fielddoc"><p>Operate as an On-The-Go device which requires both VBUS and ID to be connected directly to the USB controller from the USB connector. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40"></a>eUSBModeNone&#160;</td><td class="fielddoc"><p>A marker indicating that no USB mode has yet been set by the application. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628acbad6622a489765b96d063d649e8a023"></a>eUSBModeForceHost&#160;</td><td class="fielddoc"><p>Force host mode so that the VBUS and ID pins are not used or monitored by the USB controller. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31e8cc45b2a98ae64491dc055114b628ad3874ba18e37798ee3cb5c557116a698"></a>eUSBModeForceDevice&#160;</td><td class="fielddoc"><p>Forcing device mode so that the VBUS and ID pins are not used or monitored by the USB controller. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaded7d9b37df85ca90e41af1e6f689613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded7d9b37df85ca90e41af1e6f689613">&sect;&nbsp;</a></span>tUSBOTGState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__general__usblib__api.html#gaded7d9b37df85ca90e41af1e6f689613">tUSBOTGState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613ad27b94149ebd752d51688fb7e6acf2ab"></a>eUSBOTGModeIdle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613aa1323cefb9f788a26457d7af0e2979e5"></a>eUSBOTGModeWaitID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613a804a983f079213830ee95fc2587f5a07"></a>eUSBOTGModeWait&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613aaf76a56955110c0fd0f69d83cbe05851"></a>eUSBOTGModeBWaitCon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613aecd777355caca853b040e4798c318057"></a>eUSBOTGModeBDevice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaded7d9b37df85ca90e41af1e6f689613a2e55713b539035c755ddfc2499eb8b62"></a>eUSBOTGModeAHost&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab243cb14579868181bc72b750c1fdfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab243cb14579868181bc72b750c1fdfa4">&sect;&nbsp;</a></span>USBDescGetNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDescGetNum </td>
          <td>(</td>
          <td class="paramtype">tDescriptorHeader *&#160;</td>
          <td class="paramname"><em>psDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the number of individual descriptors of a particular type within a supplied buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDesc</td><td>points to the first byte of a block of standard USB descriptors. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the number of bytes of descriptor data found at pointer <em>psDesc</em>. </td></tr>
    <tr><td class="paramname">ui32Type</td><td>identifies the type of descriptor that is to be counted. If the value is <b>USB_DESC_ANY</b>, the function returns the total number of descriptors regardless of type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to count the number of descriptors of a particular type within a block of descriptors. The caller can provide a specific type value which the function matches against the second byte of each descriptor or, alternatively, can specify <b>USB_DESC_ANY</b> to have the function count all descriptors regardless of their type.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of descriptors found in the supplied block of data. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#gacac99adf3355844e5aa3287eff58142a">NEXT_USB_DESCRIPTOR</a>, and <a class="el" href="group__general__usblib__api.html#ga56273f836afe42a987e8624adbc71424">USB_DESC_ANY</a>.</p>

<p>Referenced by <a class="el" href="group__device__api.html#gafa39281e68fa7bacfd62d6c40a72a45a">USBDCDConfigDescGet()</a>, and <a class="el" href="group__device__api.html#ga59bc733739197141db6f38cbe4cc5a89">USBDCDConfigDescGetNum()</a>.</p>

</div>
</div>
<a id="ga27a39fd14e9b62ad421f03b3f9eb8812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a39fd14e9b62ad421f03b3f9eb8812">&sect;&nbsp;</a></span>USBDescGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tDescriptorHeader * USBDescGet </td>
          <td>(</td>
          <td class="paramtype">tDescriptorHeader *&#160;</td>
          <td class="paramname"><em>psDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the number of individual descriptors of a particular type within a supplied buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDesc</td><td>points to the first byte of a block of standard USB descriptors. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the number of bytes of descriptor data found at pointer <em>psDesc</em>. </td></tr>
    <tr><td class="paramname">ui32Type</td><td>identifies the type of descriptor that is to be found. If the value is <b>USB_DESC_ANY</b>, the function returns a pointer to the n-th descriptor regardless of type. </td></tr>
    <tr><td class="paramname">ui32Index</td><td>is the zero based index of the descriptor whose pointer is to be returned. For example, passing value 1 in <em>ui32Index</em> returns the second matching descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a pointer to the n-th descriptor of a particular type found in the block of <em>ui32Size</em> bytes starting at <em>psDesc</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the header of the required descriptor if found or NULL otherwise. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#gacac99adf3355844e5aa3287eff58142a">NEXT_USB_DESCRIPTOR</a>, and <a class="el" href="group__general__usblib__api.html#ga56273f836afe42a987e8624adbc71424">USB_DESC_ANY</a>.</p>

<p>Referenced by <a class="el" href="group__device__api.html#gafa39281e68fa7bacfd62d6c40a72a45a">USBDCDConfigDescGet()</a>, <a class="el" href="group__general__usblib__api.html#gaa0e32a340fb8d693049abf2788767ef5">USBDescGetInterface()</a>, and <a class="el" href="group__general__usblib__api.html#ga4660d78efa5b8f601c93ec5c999b5f4a">USBDescGetInterfaceEndpoint()</a>.</p>

</div>
</div>
<a id="ga833bcedfa64ba47eaffa2ed9847bc832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga833bcedfa64ba47eaffa2ed9847bc832">&sect;&nbsp;</a></span>USBDescGetNumAlternateInterfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDescGetNumAlternateInterfaces </td>
          <td>(</td>
          <td class="paramtype">tConfigDescriptor *&#160;</td>
          <td class="paramname"><em>psConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8InterfaceNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the number of different alternate configurations for a given interface within a configuration descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psConfig</td><td>points to the first byte of a standard USB configuration descriptor. </td></tr>
    <tr><td class="paramname">ui8InterfaceNumber</td><td>is the interface number for which the number of alternate configurations is to be counted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to count the number of alternate settings for a specific interface within a configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of alternate versions of the specified interface or 0 if the interface number supplied cannot be found in the config descriptor. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#gacac99adf3355844e5aa3287eff58142a">NEXT_USB_DESCRIPTOR</a>, and <a class="el" href="group__usbchap9__src.html#gaefd56033b4b680837f946ffccdfa7d3b">USB_DTYPE_INTERFACE</a>.</p>

</div>
</div>
<a id="gaa0e32a340fb8d693049abf2788767ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e32a340fb8d693049abf2788767ef5">&sect;&nbsp;</a></span>USBDescGetInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tInterfaceDescriptor * USBDescGetInterface </td>
          <td>(</td>
          <td class="paramtype">tConfigDescriptor *&#160;</td>
          <td class="paramname"><em>psConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the n-th interface descriptor in a configuration descriptor that applies to the supplied alternate setting number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psConfig</td><td>points to the first byte of a standard USB configuration descriptor. </td></tr>
    <tr><td class="paramname">ui32Index</td><td>is the zero based index of the interface that is to be found. If <em>ui32Alt</em> is set to a value other than <b>USB_DESC_ANY</b>, this will be equivalent to the interface number being searched for. </td></tr>
    <tr><td class="paramname">ui32Alt</td><td>is the alternate setting number which is to be searched for. If this value is <b>USB_DESC_ANY</b>, the alternate setting is ignored and all interface descriptors are considered in the search.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a pointer to the n-th interface descriptor found in the supplied configuration descriptor. If <em>ui32Alt</em> is not <b>USB_DESC_ANY</b>, only interface descriptors which are part of the supplied alternate setting are considered in the search otherwise all interface descriptors are considered.</p>
<p>Note that, although alternate settings can be applied on an interface-by- interface basis, the number of interfaces offered is fixed for a given config descriptor. Hence, this function will correctly find the unique interface descriptor for that interface's alternate setting number <em>ui32Alt</em> if <em>ui32Index</em> is set to the required interface number and <em>ui32Alt</em> is set to a valid alternate setting number for that interface.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the required interface descriptor if found or NULL otherwise. </dd></dl>

<p>References <a class="el" href="group__general__usblib__api.html#ga56273f836afe42a987e8624adbc71424">USB_DESC_ANY</a>, <a class="el" href="group__usbchap9__src.html#gaefd56033b4b680837f946ffccdfa7d3b">USB_DTYPE_INTERFACE</a>, and <a class="el" href="group__general__usblib__api.html#ga27a39fd14e9b62ad421f03b3f9eb8812">USBDescGet()</a>.</p>

</div>
</div>
<a id="ga4660d78efa5b8f601c93ec5c999b5f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4660d78efa5b8f601c93ec5c999b5f4a">&sect;&nbsp;</a></span>USBDescGetInterfaceEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tEndpointDescriptor * USBDescGetInterfaceEndpoint </td>
          <td>(</td>
          <td class="paramtype">tInterfaceDescriptor *&#160;</td>
          <td class="paramname"><em>psInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the n-th endpoint descriptor in the supplied interface descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psInterface</td><td>points to the first byte of a standard USB interface descriptor. </td></tr>
    <tr><td class="paramname">ui32Index</td><td>is the zero based index of the endpoint that is to be found. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>contains the maximum number of bytes that the function may search beyond <em>psInterface</em> while looking for the requested endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a pointer to the n-th endpoint descriptor found in the supplied interface descriptor. If the <em>ui32Index</em> parameter is invalid (greater than or equal to the bNumEndpoints field of the interface descriptor) or the endpoint cannot be found within <em>ui32Size</em> bytes of the interface descriptor pointer, the function will return NULL.</p>
<p>Note that, although the USB 2.0 specification states that endpoint descriptors must follow the interface descriptor that they relate to, it also states that device specific descriptors should follow any standard descriptor that they relate to. As a result, we cannot assume that each interface descriptor will be followed by nothing but an ordered list of its own endpoints and, hence, the function needs to be provided <em>ui32Size</em> to limit the search range.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the requested endpoint descriptor if found or NULL otherwise. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#gaf4bc77da317012c0324d2c2d34b2ea5d">USB_DTYPE_ENDPOINT</a>, and <a class="el" href="group__general__usblib__api.html#ga27a39fd14e9b62ad421f03b3f9eb8812">USBDescGet()</a>.</p>

</div>
</div>
<a id="ga76261a6a917ef4b0b596f91f06cc4c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76261a6a917ef4b0b596f91f06cc4c6b">&sect;&nbsp;</a></span>USBStackModeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBStackModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a>&#160;</td>
          <td class="paramname"><em>iUSBMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general__usblib__api.html#ga1096ec8132f36128b53b7b506019dae9">tUSBModeCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows dual mode application to switch between USB device and host modes and provides a method to force the controller into the desired mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies the USB controller whose mode of operation is to be set. This parameter must be set to 0. </td></tr>
    <tr><td class="paramname">iUSBMode</td><td>indicates the mode that the application wishes to operate in. Valid values are <b>eUSBModeDevice</b> to operate as a USB device and <b>eUSBModeHost</b> to operate as a USB host. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is a pointer to a function which the USB library will call each time the mode is changed to indicate the new operating mode. In cases where <em>iUSBMode</em> is set to either <b>eUSBModeDevice</b> or <b>eUSBModeHost</b>, the callback will be made immediately to allow the application to perform any host or device specific initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a USB application that can operate in host or device mode to indicate to the USB stack the mode that it wishes to use. The caller is responsible for cleaning up the interface and removing itself from the bus prior to making this call and reconfiguring afterwards. The <em>pfnCallback</em> function can be a <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL(0)</a> value to indicate that no notification is required.</p>
<p>For successful dual mode mode operation, an application must register <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a> as the interrupt handler for the USB0 interrupt. This handler is responsible for steering interrupts to the device or host stack depending upon the chosen mode. Devices which do not require dual mode capability should register either <em><a class="el" href="group__device__api.html#ga2ef4bd267370d40087cba4c899b7c9d3">USB0_IRQDeviceHandler()</a></em> or <em><a class="el" href="group__usblib__hcd.html#ga96a648f5969831614c96ecc1ffb9a4f7">USB0_IRQHostHandler()</a></em> instead. Registering <em><a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a></em> for a single mode application will result in an application binary larger than required since library functions for both USB operating modes will be included even though only one mode is required.</p>
<p>Single mode applications (those offering exclusively USB device or USB host functionality) are only required to call this function if they need to force the mode of the controller to Host or Device mode. This is usually in the event that the application needs to reused the USBVBUS and/or USBID pins as GPIOs.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__general__usblib__api.html#gafc6aafb732127c6f1d9cb66d738c6607">g_iUSBMode</a>.</p>

</div>
</div>
<a id="gae0178cee084efca10209dd9a9eaeab1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0178cee084efca10209dd9a9eaeab1f">&sect;&nbsp;</a></span>USB0DualModeIntHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB0DualModeIntHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Steers USB interrupts from controller to the correct handler in the USB stack.</p>
<p>This interrupt handler is used in applications which require to operate in both host and device mode. It steers the USB hardware interrupt to the correct handler in the USB stack depending upon the current operating mode of the application, USB device or host.</p>
<p>For successful dual mode operation, an application must register <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a> in the CPU vector table as the interrupt handler for the USB0 interrupt. This handler is responsible for steering interrupts to the device or host stack depending upon the chosen mode.</p>
<dl class="section note"><dt>Note</dt><dd>Devices which do not require dual mode capability should register either <a class="el" href="group__device__api.html#ga2ef4bd267370d40087cba4c899b7c9d3">USB0_IRQDeviceHandler()</a> or <a class="el" href="group__usblib__hcd.html#ga96a648f5969831614c96ecc1ffb9a4f7">USB0_IRQHostHandler()</a> instead. Registering <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a> for a single mode application will result in an application binary larger than required since library functions for both USB operating modes will be included even though only one mode is actually required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628a3bd089f927356e565b6081c989d1c138">eUSBModeDevice</a>, <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628add4aadcd7bae9f0af3813000d07f9464">eUSBModeHost</a>, <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40">eUSBModeNone</a>, <a class="el" href="group__general__usblib__api.html#gafc6aafb732127c6f1d9cb66d738c6607">g_iUSBMode</a>, <a class="el" href="group__general__usblib__api.html#ga548d0631745d87203a20d4d137ae3a09">USB_HOST_INTS</a>, <a class="el" href="group__device__api.html#ga64f4fbe501df5c933b835ac63f78ddda">USBDeviceIntHandlerInternal()</a>, and <a class="el" href="group__usblib__hcd.html#ga97d0ae9c014ca65c58c1e625a21e4f13">USBHostIntHandlerInternal()</a>.</p>

</div>
</div>
<a id="gacf6b4cb7df409d056c59a11e38be1b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6b4cb7df409d056c59a11e38be1b2b">&sect;&nbsp;</a></span>InternalUSBTickInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InternalUSBTickInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__general__usblib__api.html#ga8bca186737fbaa176e3ed2425f36325a">g_bUSBTimerInitialized</a>, <a class="el" href="group__general__usblib__api.html#gae6e63a878bc4c533e43276cd97f0d9db">g_pfnTickHandlers</a>, <a class="el" href="group__general__usblib__api.html#gac1b49104e1a75fd25e94d2fbbb037be1">g_pvTickInstance</a>, and <a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>.</p>

<p>Referenced by <a class="el" href="group__dualmode__api.html#gae3248cbfc4251061c4d7bfa613ab3878">USBDualModeInit()</a>.</p>

</div>
</div>
<a id="ga3c93dd41aa0868392adce925bc7ddc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c93dd41aa0868392adce925bc7ddc39">&sect;&nbsp;</a></span>InternalUSBTickReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InternalUSBTickReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__general__usblib__api.html#ga8bca186737fbaa176e3ed2425f36325a">g_bUSBTimerInitialized</a>.</p>

<p>Referenced by <a class="el" href="group__device__api.html#ga9f57ce4fb4d92257c2573fc9d29b7b5a">USBDCDTerm()</a>.</p>

</div>
</div>
<a id="gac719b1dcf3305b8c459b43f025fd09a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac719b1dcf3305b8c459b43f025fd09a5">&sect;&nbsp;</a></span>InternalUSBRegisterTickHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t InternalUSBRegisterTickHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__dma__api.html#ga143136780ce8b1a1c8f75ff004e7d8c6">tUSBTickHandler</a>&#160;</td>
          <td class="paramname"><em>pfHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__general__usblib__api.html#gae6e63a878bc4c533e43276cd97f0d9db">g_pfnTickHandlers</a>, <a class="el" href="group__general__usblib__api.html#gac1b49104e1a75fd25e94d2fbbb037be1">g_pvTickInstance</a>, and <a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>.</p>

</div>
</div>
<a id="ga702ced12b6588bfa8a75922477f65800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702ced12b6588bfa8a75922477f65800">&sect;&nbsp;</a></span>InternalUSBStartOfFrameTick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InternalUSBStartOfFrameTick </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TicksmS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__general__usblib__api.html#gae6e63a878bc4c533e43276cd97f0d9db">g_pfnTickHandlers</a>, <a class="el" href="group__general__usblib__api.html#gac1b49104e1a75fd25e94d2fbbb037be1">g_pvTickInstance</a>, <a class="el" href="group__general__usblib__api.html#ga039de15fd461539e25595386e32710d0">g_ui32CurrentUSBTick</a>, and <a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__dma__api.html#ga64f4fbe501df5c933b835ac63f78ddda">USBDeviceIntHandlerInternal()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gafc6aafb732127c6f1d9cb66d738c6607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc6aafb732127c6f1d9cb66d738c6607">&sect;&nbsp;</a></span>g_iUSBMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> g_iUSBMode = <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40">eUSBModeNone</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a>, <a class="el" href="group__device__api.html#ga4bcf6daf0452a45fa33f6159a7bb8e83">USBDCDInit()</a>, <a class="el" href="group__usblib__hcd.html#ga6b79ac3d9da9ae19736518719bd1a16a">USBHCDInit()</a>, <a class="el" href="group__usblib__otg.html#gaf0f7d6138d7d6224d813f08d32a19e1b">USBOTGModeInit()</a>, and <a class="el" href="group__general__usblib__api.html#ga76261a6a917ef4b0b596f91f06cc4c6b">USBStackModeSet()</a>.</p>

</div>
</div>
<a id="ga047cb1187d56d649dd5eda319fe23c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047cb1187d56d649dd5eda319fe23c8a">&sect;&nbsp;</a></span>g_ui32PollRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t g_ui32PollRate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__otg.html#gafafe22aa65f5fdd012005a8ad72dad21">USBOTGMain()</a>, and <a class="el" href="group__usblib__otg.html#gad7fa2ac89dd7729ffaa06f2f5095901f">USBOTGPollRate()</a>.</p>

</div>
</div>
<a id="gac78691fc2c849004b53ce2f67fc5f3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78691fc2c849004b53ce2f67fc5f3a2">&sect;&nbsp;</a></span>g_ui32WaitTicks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t g_ui32WaitTicks = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__otg.html#gafafe22aa65f5fdd012005a8ad72dad21">USBOTGMain()</a>.</p>

</div>
</div>
<a id="ga830335f7a4fe3752317f6114f12307fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830335f7a4fe3752317f6114f12307fe">&sect;&nbsp;</a></span>g_eOTGModeState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__general__usblib__api.html#gaded7d9b37df85ca90e41af1e6f689613">tUSBOTGState</a> g_eOTGModeState</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__otg.html#ga66296ccc0b4f0d2bf2e12fc3d5b11435">OTGDeviceDisconnect()</a>, <a class="el" href="group__usblib__otg.html#ga3e4b3a14f920e47677d531ecf644699e">USB0_IRQOTGModeHandler()</a>, and <a class="el" href="group__usblib__otg.html#gafafe22aa65f5fdd012005a8ad72dad21">USBOTGMain()</a>.</p>

</div>
</div>
<a id="gae6e63a878bc4c533e43276cd97f0d9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6e63a878bc4c533e43276cd97f0d9db">&sect;&nbsp;</a></span>g_pfnTickHandlers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__usblib__dma__api.html#ga143136780ce8b1a1c8f75ff004e7d8c6">tUSBTickHandler</a> g_pfnTickHandlers[<a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gac719b1dcf3305b8c459b43f025fd09a5">InternalUSBRegisterTickHandler()</a>, <a class="el" href="group__general__usblib__api.html#ga702ced12b6588bfa8a75922477f65800">InternalUSBStartOfFrameTick()</a>, and <a class="el" href="group__general__usblib__api.html#gacf6b4cb7df409d056c59a11e38be1b2b">InternalUSBTickInit()</a>.</p>

</div>
</div>
<a id="gac1b49104e1a75fd25e94d2fbbb037be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b49104e1a75fd25e94d2fbbb037be1">&sect;&nbsp;</a></span>g_pvTickInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* g_pvTickInstance[<a class="el" href="group__usblib__dma__api.html#gaef3d1f8bc87014f84eae51e95d9fd521">MAX_USB_TICK_HANDLERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gac719b1dcf3305b8c459b43f025fd09a5">InternalUSBRegisterTickHandler()</a>, <a class="el" href="group__general__usblib__api.html#ga702ced12b6588bfa8a75922477f65800">InternalUSBStartOfFrameTick()</a>, and <a class="el" href="group__general__usblib__api.html#gacf6b4cb7df409d056c59a11e38be1b2b">InternalUSBTickInit()</a>.</p>

</div>
</div>
<a id="ga8bca186737fbaa176e3ed2425f36325a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bca186737fbaa176e3ed2425f36325a">&sect;&nbsp;</a></span>g_bUSBTimerInitialized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool g_bUSBTimerInitialized = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gacf6b4cb7df409d056c59a11e38be1b2b">InternalUSBTickInit()</a>, and <a class="el" href="group__general__usblib__api.html#ga3c93dd41aa0868392adce925bc7ddc39">InternalUSBTickReset()</a>.</p>

</div>
</div>
<a id="ga039de15fd461539e25595386e32710d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039de15fd461539e25595386e32710d0">&sect;&nbsp;</a></span>g_ui32CurrentUSBTick</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t g_ui32CurrentUSBTick = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#ga702ced12b6588bfa8a75922477f65800">InternalUSBStartOfFrameTick()</a>.</p>

</div>
</div>
<a id="ga403806c90de91531674d6665c8b5b447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga403806c90de91531674d6665c8b5b447">&sect;&nbsp;</a></span>g_ui32USBSOFCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t g_ui32USBSOFCount = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__dma__api.html#ga64f4fbe501df5c933b835ac63f78ddda">USBDeviceIntHandlerInternal()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
