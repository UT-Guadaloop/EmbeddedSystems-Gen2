<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>USBLibAPIGuide: Usblib_hcd</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">USBLibAPIGuide
   &#160;<span id="projectnumber">1.00.00.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Usblib_hcd</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gade3447c8b071bc651eeff0054ff3f6e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gade3447c8b071bc651eeff0054ff3f6e6">USBHCD_PIPE_UNUSED</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:gade3447c8b071bc651eeff0054ff3f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e134a9391395685589bb30b50a8a254"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga0e134a9391395685589bb30b50a8a254">USBHCD_PIPE_CONTROL</a>&#160;&#160;&#160;0x00130000</td></tr>
<tr class="separator:ga0e134a9391395685589bb30b50a8a254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee548b8e8775860d541238cf9d3c80d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaee548b8e8775860d541238cf9d3c80d1">USBHCD_PIPE_BULK_OUT</a>&#160;&#160;&#160;0x00210000</td></tr>
<tr class="separator:gaee548b8e8775860d541238cf9d3c80d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd4350b6d54f1b150a157eb8d0bb961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga7bd4350b6d54f1b150a157eb8d0bb961">USBHCD_PIPE_BULK_IN</a>&#160;&#160;&#160;0x00220000</td></tr>
<tr class="separator:ga7bd4350b6d54f1b150a157eb8d0bb961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba52adf42b3fa51eff225d18ed29368"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8ba52adf42b3fa51eff225d18ed29368">USBHCD_PIPE_INTR_OUT</a>&#160;&#160;&#160;0x00410000</td></tr>
<tr class="separator:ga8ba52adf42b3fa51eff225d18ed29368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd87439ca588c9598431434915749a53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gacd87439ca588c9598431434915749a53">USBHCD_PIPE_INTR_IN</a>&#160;&#160;&#160;0x00420000</td></tr>
<tr class="separator:gacd87439ca588c9598431434915749a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7677d3cf45cba4e76fe869fb58ddb89a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga7677d3cf45cba4e76fe869fb58ddb89a">USBHCD_PIPE_ISOC_OUT</a>&#160;&#160;&#160;0x00810000</td></tr>
<tr class="separator:ga7677d3cf45cba4e76fe869fb58ddb89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464b17e771b98dccff1c9ca7f3b3f5a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga464b17e771b98dccff1c9ca7f3b3f5a4">USBHCD_PIPE_ISOC_IN</a>&#160;&#160;&#160;0x00820000</td></tr>
<tr class="separator:ga464b17e771b98dccff1c9ca7f3b3f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d542f3fcaafa23faeda3454425b0ec0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga6d542f3fcaafa23faeda3454425b0ec0">USBHCD_PIPE_ISOC_OUT_DMA</a>&#160;&#160;&#160;0x01810000</td></tr>
<tr class="separator:ga6d542f3fcaafa23faeda3454425b0ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c6184dbb93e8ffabb7139fe5dc2edc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga73c6184dbb93e8ffabb7139fe5dc2edc">USBHCD_PIPE_ISOC_IN_DMA</a>&#160;&#160;&#160;0x01820000</td></tr>
<tr class="separator:ga73c6184dbb93e8ffabb7139fe5dc2edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d0e46c65c46ee5a0d42921f0902a99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga12d0e46c65c46ee5a0d42921f0902a99">USBHCD_PIPE_BULK_OUT_DMA</a>&#160;&#160;&#160;0x01210000</td></tr>
<tr class="separator:ga12d0e46c65c46ee5a0d42921f0902a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bea6750070b4f93791bd9555a2ea5f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga2bea6750070b4f93791bd9555a2ea5f1">USBHCD_PIPE_BULK_IN_DMA</a>&#160;&#160;&#160;0x01220000</td></tr>
<tr class="separator:ga2bea6750070b4f93791bd9555a2ea5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbc1b07110de83e1a6aa03d917be1a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaecbc1b07110de83e1a6aa03d917be1a7">USBHCD_FAULT_LOW</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:gaecbc1b07110de83e1a6aa03d917be1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c031a7a88d06e01218bd34ddda799c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga1c031a7a88d06e01218bd34ddda799c1">USBHCD_FAULT_HIGH</a>&#160;&#160;&#160;0x00000030</td></tr>
<tr class="separator:ga1c031a7a88d06e01218bd34ddda799c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c12a9e55d3cebc7fe21cf432a341d6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga4c12a9e55d3cebc7fe21cf432a341d6d">USBHCD_FAULT_VBUS_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga4c12a9e55d3cebc7fe21cf432a341d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd9ab68889e273078c9bea769b6c280"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaafd9ab68889e273078c9bea769b6c280">USBHCD_FAULT_VBUS_TRI</a>&#160;&#160;&#160;0x00000140</td></tr>
<tr class="separator:gaafd9ab68889e273078c9bea769b6c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855c6b5f7a0e0e39428cff061ff0a591"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga855c6b5f7a0e0e39428cff061ff0a591">USBHCD_FAULT_VBUS_DIS</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="separator:ga855c6b5f7a0e0e39428cff061ff0a591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9c9963db1ac4cb045d87c8aa361a25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gabb9c9963db1ac4cb045d87c8aa361a25">USBHCD_VBUS_MANUAL</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:gabb9c9963db1ac4cb045d87c8aa361a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9544adc80da78c49286c3436bc4be2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gad9544adc80da78c49286c3436bc4be2e">USBHCD_VBUS_AUTO_LOW</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gad9544adc80da78c49286c3436bc4be2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79a96acfe19644abad91cbbdb136638"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf79a96acfe19644abad91cbbdb136638">USBHCD_VBUS_AUTO_HIGH</a>&#160;&#160;&#160;0x00000003</td></tr>
<tr class="separator:gaf79a96acfe19644abad91cbbdb136638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8143820fb6ae4c2bd017d1b99710a69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaa8143820fb6ae4c2bd017d1b99710a69">USBHCD_VBUS_FILTER</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:gaa8143820fb6ae4c2bd017d1b99710a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ab8e8094037c34ba548403ccf323c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gab2ab8e8094037c34ba548403ccf323c6">USBHCD_LPM_AVAIL</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:gab2ab8e8094037c34ba548403ccf323c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97320596add061e95cb5b931b3734513"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga97320596add061e95cb5b931b3734513">USBHCD_LPM_ERROR</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga97320596add061e95cb5b931b3734513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087cdcec0c54cddcf64aa4e5fa20b355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga087cdcec0c54cddcf64aa4e5fa20b355">USBHCD_LPM_PENDING</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:ga087cdcec0c54cddcf64aa4e5fa20b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d261472653237f418f6fc4ea32a4ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga21d261472653237f418f6fc4ea32a4ad">DECLARE_EVENT_DRIVER</a>(VarName,  pfnOpen,  pfnClose,  pfnEvent)</td></tr>
<tr class="separator:ga21d261472653237f418f6fc4ea32a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7eda9b970cc1166ad1f41f6c0ee7b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gafc7eda9b970cc1166ad1f41f6c0ee7b0">USB_HOST_PWREN_AUTO</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gafc7eda9b970cc1166ad1f41f6c0ee7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89d220b4f1a5b5d36301db598053dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf89d220b4f1a5b5d36301db598053dc2">INT_EVENT_VBUS_ERR</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gaf89d220b4f1a5b5d36301db598053dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab855f89e2376215b77a7d837de150c77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gab855f89e2376215b77a7d837de150c77">INT_EVENT_CONNECT</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gab855f89e2376215b77a7d837de150c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99828dec4fd85573b6eb7b46948f163b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga99828dec4fd85573b6eb7b46948f163b">INT_EVENT_DISCONNECT</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga99828dec4fd85573b6eb7b46948f163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80baaa06215f352316f511f1bfadada"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gae80baaa06215f352316f511f1bfadada">INT_EVENT_POWER_FAULT</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:gae80baaa06215f352316f511f1bfadada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac774fa499dbce43e9be1535cff1b4ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gac774fa499dbce43e9be1535cff1b4ae7">INT_EVENT_SOF</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gac774fa499dbce43e9be1535cff1b4ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97bbc29bb0d940cff966a9aa6fe5320e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga97bbc29bb0d940cff966a9aa6fe5320e">INT_EVENT_ENUM</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga97bbc29bb0d940cff966a9aa6fe5320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf652817b981898c67edc1b69b17f2f7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf652817b981898c67edc1b69b17f2f7e">INT_EVENT_LPM_PEND</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:gaf652817b981898c67edc1b69b17f2f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8863e8fb651137c9379305e2aa7780c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8863e8fb651137c9379305e2aa7780c2">INT_EVENT_LPM</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:ga8863e8fb651137c9379305e2aa7780c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b765e78c87a9b6bd93fef299e31051"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga99b765e78c87a9b6bd93fef299e31051">USBHDEV_FLAG_NOTIFYINT</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga99b765e78c87a9b6bd93fef299e31051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada4792c60a04722d08aa5bf1eea3b74f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gada4792c60a04722d08aa5bf1eea3b74f">USBHDEV_FLAG_LPMPEND</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gada4792c60a04722d08aa5bf1eea3b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7469041f29bebded62fdbec4a127a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga1f7469041f29bebded62fdbec4a127a6">USBHDEV_FLAG_LPMERROR</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:ga1f7469041f29bebded62fdbec4a127a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2007414177b849e1c84aec30f0114b4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga2007414177b849e1c84aec30f0114b4e">USBHDEV_FLAG_ALLOCATED</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="separator:ga2007414177b849e1c84aec30f0114b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77efb2e4d4f36e029d69503b3c6079c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga77efb2e4d4f36e029d69503b3c6079c9">MAX_NUM_PIPES</a>&#160;&#160;&#160;15</td></tr>
<tr class="separator:ga77efb2e4d4f36e029d69503b3c6079c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8644e6bf744bc721081d63b9b4d8f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga3a8644e6bf744bc721081d63b9b4d8f7">MAX_NUM_DMA_CHANNELS</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga3a8644e6bf744bc721081d63b9b4d8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c345cc5c8069c1712dacad037414976"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga2c345cc5c8069c1712dacad037414976">USBHCD_DMA_UNUSED</a>&#160;&#160;&#160;0xff</td></tr>
<tr class="separator:ga2c345cc5c8069c1712dacad037414976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b6983b56a32a6c7118e5c9ed73edfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gad3b6983b56a32a6c7118e5c9ed73edfc">EP_PIPE_TYPE_LOW_SPEED</a>&#160;&#160;&#160;0x02000000</td></tr>
<tr class="separator:gad3b6983b56a32a6c7118e5c9ed73edfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dee1facc1f933f8b476c58a69e04617"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga4dee1facc1f933f8b476c58a69e04617">EP_PIPE_USE_UDMA</a>&#160;&#160;&#160;0x01000000</td></tr>
<tr class="separator:ga4dee1facc1f933f8b476c58a69e04617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c68b2a2e8d16220fdccd772f6dfbceb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8c68b2a2e8d16220fdccd772f6dfbceb">EP_PIPE_TYPE_ISOC</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr class="separator:ga8c68b2a2e8d16220fdccd772f6dfbceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8e8b5849224c957159440cdddda3e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaba8e8b5849224c957159440cdddda3e4">EP_PIPE_TYPE_INTR</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="separator:gaba8e8b5849224c957159440cdddda3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcfa4cd9d4511e759a81da4e3951a8ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gafcfa4cd9d4511e759a81da4e3951a8ac">EP_PIPE_TYPE_BULK</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:gafcfa4cd9d4511e759a81da4e3951a8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b3457adb35e3a618b9f24dd7dbcfe3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga62b3457adb35e3a618b9f24dd7dbcfe3">EP_PIPE_TYPE_CONTROL</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:ga62b3457adb35e3a618b9f24dd7dbcfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c7b48b18cd520ac41ca57cbe3a15af3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga3c7b48b18cd520ac41ca57cbe3a15af3">EP_PIPE_TYPE_IN</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:ga3c7b48b18cd520ac41ca57cbe3a15af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a5c4bdb67ac541c87fe26703883a01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga13a5c4bdb67ac541c87fe26703883a01">EP_PIPE_TYPE_OUT</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:ga13a5c4bdb67ac541c87fe26703883a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80ff2f3162205ed9d38ade396703ded"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>&#160;&#160;&#160;0x0000ffff</td></tr>
<tr class="separator:gaf80ff2f3162205ed9d38ade396703ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c5d8d8a277a9eaca589420d0b21e72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gac9c5d8d8a277a9eaca589420d0b21e72">OUT_PIPE_HANDLE</a>(ui32Idx)</td></tr>
<tr class="separator:gac9c5d8d8a277a9eaca589420d0b21e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8086216d44e8c265c501e6fb8ac71ba1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8086216d44e8c265c501e6fb8ac71ba1">IN_PIPE_HANDLE</a>(ui32Idx)</td></tr>
<tr class="separator:ga8086216d44e8c265c501e6fb8ac71ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf74b0caf840f0d3222cb1dc563684c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaadf74b0caf840f0d3222cb1dc563684c">EP_OFFSET</a>(Endpoint)&#160;&#160;&#160;(Endpoint - 0x10)</td></tr>
<tr class="separator:gaadf74b0caf840f0d3222cb1dc563684c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3cb4ce1332b6a61e88029daf1226925d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga3cb4ce1332b6a61e88029daf1226925d">tHCDPipeCallback</a>) (uint32_t ui32Pipe, uint32_t ui32Event)</td></tr>
<tr class="separator:ga3cb4ce1332b6a61e88029daf1226925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069725dbb3431c9f746927610fb6f422"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga069725dbb3431c9f746927610fb6f422">tUSBHostDevice</a></td></tr>
<tr class="separator:ga069725dbb3431c9f746927610fb6f422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabc3f5e99cefcf597f763076cfdbf2696"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gabc3f5e99cefcf597f763076cfdbf2696">tEP0State</a> { <br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696adcb6708fe105e9cb02f4e382019989c1">eUSBStateIdle</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696ac35b54c0cd74234ebb62e6ca05e05ac8">eUSBStateTx</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a81ef9a55fc6f4a8378639e9145598b1b">eUSBStateTxConfig</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a93020218daf932d37ee433bafe68a390">eUSBStateRx</a>, 
<br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696aa97b8e53b49db975692882b2a9fb6150">eUSBStateStatus</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a4135f6319d3ccec3bda25ea4da6f5cb0">eUSBStateStall</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a813c95af6931423119be55bc754b0a24">eEP0StateIdle</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a7e59f231e9f68cbf2cd3b55036e2b68d">eEP0StateSetupIN</a>, 
<br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a93c0b3987ea680a9a3c7417a2260a238">eEP0StateSetupOUT</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a12a99855f2e81efb6b4f4233fdf197ce">eEP0StateRx</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696ad3542acc4958a047b150b4d2e885c455">eEP0StateStatus</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696ac74d6c63fd43ea6674c7fc2f0cf03272">eEP0StateStatusIN</a>, 
<br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696a4ef3ed17922447de14de8a18644494f7">eEP0StateStall</a>, 
<a class="el" href="group__usblib__hcd.html#ggabc3f5e99cefcf597f763076cfdbf2696afd2ca830f97e2837b9d27659d0a9e54b">eEP0StateError</a>
<br />
 }</td></tr>
<tr class="separator:gabc3f5e99cefcf597f763076cfdbf2696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4951a6f301ff2e037630a34a7d64ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gabb4951a6f301ff2e037630a34a7d64ea">tUSBHDeviceState</a> { <br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa8abc30cf49613e464090617a9f48935e">eHCDDevDisconnected</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa2692b08a82c434c771eee1ec48c19c71">eHCDDevConnected</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaaa19387f696e9eb38c928f136a51f18ab">eHCDDevConnectedHub</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa13a443b526e5bd0aac43c8dbf48cda34">eHCDDevRequest</a>, 
<br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa2d4a082bfe37d497f87904481655fdbd">eHCDDevReset</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa7709fd9e1b680a36f2e34a9786a26764">eHCDDevAddressed</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaac7a7321ac13c543ffc90cb89d1962397">eHCDDevConfigured</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaaa12443acc2131af332f9f03fce71818e">eHCDDevGetStrings</a>, 
<br />
&#160;&#160;<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaab8ad68084e76a8b6b6d0db1207603762">eHCDDevError</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa32dd2faaa5f84cddd40115e7757eac21">eHCDVBUSError</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaacbbcc47f79dd743d8d6facdf6189e7e3">eHCDPowerFault</a>, 
<a class="el" href="group__usblib__hcd.html#ggabb4951a6f301ff2e037630a34a7d64eaa434b648f2820587395f5f082f9c04a7b">eHCDIdle</a>
<br />
 }</td></tr>
<tr class="separator:gabb4951a6f301ff2e037630a34a7d64ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66296ccc0b4f0d2bf2e12fc3d5b11435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga66296ccc0b4f0d2bf2e12fc3d5b11435">OTGDeviceDisconnect</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga66296ccc0b4f0d2bf2e12fc3d5b11435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312ec4c41f8eb09258b72636b57bcd4b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga312ec4c41f8eb09258b72636b57bcd4b">ConfigDescAlloc</a> (<a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice, uint32_t ui32Size)</td></tr>
<tr class="separator:ga312ec4c41f8eb09258b72636b57bcd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a582f2a432498c3d22e2d318430e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga71a582f2a432498c3d22e2d318430e5a">ConfigDescFree</a> (<a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice)</td></tr>
<tr class="separator:ga71a582f2a432498c3d22e2d318430e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2545972bd2bfd79829dd21ca373254a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf2545972bd2bfd79829dd21ca373254a">USBHCDEventEnable</a> (uint32_t ui32Index, void *pvEventDriver, uint32_t ui32Event)</td></tr>
<tr class="separator:gaf2545972bd2bfd79829dd21ca373254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb0d7da79ae6713350726d796acb635"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8eb0d7da79ae6713350726d796acb635">USBHCDEventDisable</a> (uint32_t ui32Index, void *pvEventDriver, uint32_t ui32Event)</td></tr>
<tr class="separator:ga8eb0d7da79ae6713350726d796acb635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41464e862a76e3ccbdfa379a0a92670"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gac41464e862a76e3ccbdfa379a0a92670">USBHCDPipeTransferSizeGet</a> (uint32_t ui32Pipe)</td></tr>
<tr class="separator:gac41464e862a76e3ccbdfa379a0a92670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d30cf9b53e02759e717a7c0d7fd74f4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga4d30cf9b53e02759e717a7c0d7fd74f4">USBHCDPipeAllocSize</a> (uint32_t ui32Index, uint32_t ui32EndpointType, <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice, uint32_t ui32Size, <a class="el" href="group__usblib__hcd.html#ga3cb4ce1332b6a61e88029daf1226925d">tHCDPipeCallback</a> pfnCallback)</td></tr>
<tr class="separator:ga4d30cf9b53e02759e717a7c0d7fd74f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf804c6e895faea7d825cb3a9c0f38a60"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc</a> (uint32_t ui32Index, uint32_t ui32EndpointType, <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice, <a class="el" href="group__usblib__hcd.html#ga3cb4ce1332b6a61e88029daf1226925d">tHCDPipeCallback</a> pfnCallback)</td></tr>
<tr class="separator:gaf804c6e895faea7d825cb3a9c0f38a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90eb5644130f579d98fbd81027dbad8e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga90eb5644130f579d98fbd81027dbad8e">USBHCDPipeConfig</a> (uint32_t ui32Pipe, uint32_t ui32MaxPayload, uint32_t ui32Interval, uint32_t ui32TargetEndpoint)</td></tr>
<tr class="separator:ga90eb5644130f579d98fbd81027dbad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e154a06493413b3c953b8fed2222a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf7e154a06493413b3c953b8fed2222a6">USBHCDPipeStatus</a> (uint32_t ui32Pipe)</td></tr>
<tr class="separator:gaf7e154a06493413b3c953b8fed2222a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e25fa42e07b795bb2484d478395f2b1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga1e25fa42e07b795bb2484d478395f2b1">USBHCDPipeWrite</a> (uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:ga1e25fa42e07b795bb2484d478395f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cf106720569ee7276f4178129aa898"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule</a> (uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:ga06cf106720569ee7276f4178129aa898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f82cf837684e765625e1f7e83a02ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga5f82cf837684e765625e1f7e83a02ce2">USBHCDPipeReadNonBlocking</a> (uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:ga5f82cf837684e765625e1f7e83a02ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9955bacdc4c448c3554ca07d21dd881f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga9955bacdc4c448c3554ca07d21dd881f">USBHCDPipeDataAck</a> (uint32_t ui32Pipe)</td></tr>
<tr class="separator:ga9955bacdc4c448c3554ca07d21dd881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac32f7cfa838cb39452b4543aa9d2a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gabac32f7cfa838cb39452b4543aa9d2a7">USBHCDPipeRead</a> (uint32_t ui32Pipe, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:gabac32f7cfa838cb39452b4543aa9d2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4511ac416938adac9fd4d5fa4156abfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga4511ac416938adac9fd4d5fa4156abfd">USBHCDPipeFree</a> (uint32_t ui32Pipe)</td></tr>
<tr class="separator:ga4511ac416938adac9fd4d5fa4156abfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2458bcfaceeac64f35ccbf90421048ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga2458bcfaceeac64f35ccbf90421048ac">USBHCDPowerConfigInit</a> (uint32_t ui32Index, uint32_t ui32PwrConfig)</td></tr>
<tr class="separator:ga2458bcfaceeac64f35ccbf90421048ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489b557c5356dc4a47937952563813db"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga489b557c5356dc4a47937952563813db">USBHCDPowerConfigGet</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga489b557c5356dc4a47937952563813db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25f089687d2c34ef00d3d2f7f916d53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gab25f089687d2c34ef00d3d2f7f916d53">USBHCDPowerConfigSet</a> (uint32_t ui32Index, uint32_t ui32Config)</td></tr>
<tr class="separator:gab25f089687d2c34ef00d3d2f7f916d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad70e65f97918456bc3a706fb2edd6a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaad70e65f97918456bc3a706fb2edd6a3">USBHCDPowerAutomatic</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:gaad70e65f97918456bc3a706fb2edd6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b79ac3d9da9ae19736518719bd1a16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga6b79ac3d9da9ae19736518719bd1a16a">USBHCDInit</a> (uint32_t ui32Index, void *pvPool, uint32_t ui32PoolSize)</td></tr>
<tr class="separator:ga6b79ac3d9da9ae19736518719bd1a16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ded177760ee026d12348de1daacd45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers</a> (uint32_t ui32Index, const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> *const *ppsHClassDrvs, uint32_t ui32NumDrivers)</td></tr>
<tr class="separator:ga9ded177760ee026d12348de1daacd45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8cf0ba9bf4e3f6704f09fc9193d77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gadc8cf0ba9bf4e3f6704f09fc9193d77e">USBHCDTerm</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:gadc8cf0ba9bf4e3f6704f09fc9193d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c33fb00687831f0d46ba9554f25bb91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga4c33fb00687831f0d46ba9554f25bb91">USBHCDReset</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga4c33fb00687831f0d46ba9554f25bb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b34f432c9d244b01963d9a85357506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga58b34f432c9d244b01963d9a85357506">USBHCDSuspend</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga58b34f432c9d244b01963d9a85357506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0485567d29ff1f63e9bbb415b368d552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga0485567d29ff1f63e9bbb415b368d552">USBHCDResume</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga0485567d29ff1f63e9bbb415b368d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b96ba9fac1cfe4b2d143ec5e919eb0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga04b96ba9fac1cfe4b2d143ec5e919eb0">USBHCDStringDescriptorGet</a> (<a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice, uint8_t *pui8Buffer, uint32_t ui32Size, uint32_t ui32LangID, uint32_t ui32StringIndex)</td></tr>
<tr class="separator:ga04b96ba9fac1cfe4b2d143ec5e919eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac53e55b293eb19d876df84a5584fd256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gac53e55b293eb19d876df84a5584fd256">USBHCDSetAddress</a> (uint32_t ui32DevIndex, uint32_t ui32DevAddress)</td></tr>
<tr class="separator:gac53e55b293eb19d876df84a5584fd256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2c3b673456728709390f105502a8e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga7c2c3b673456728709390f105502a8e3">USBHCDSetConfig</a> (uint32_t ui32Index, uint32_t ui32Device, uint32_t ui32Configuration)</td></tr>
<tr class="separator:ga7c2c3b673456728709390f105502a8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4a9dab92a6d4aed63519b8c57e722d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga9b4a9dab92a6d4aed63519b8c57e722d">USBHCDSetInterface</a> (uint32_t ui32Index, uint32_t ui32Device, uint32_t ui32Interface, uint32_t ui32AltSetting)</td></tr>
<tr class="separator:ga9b4a9dab92a6d4aed63519b8c57e722d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2f1a37f33e1ded4a4ea6132002ae84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga7d2f1a37f33e1ded4a4ea6132002ae84">USBHostCheckPipes</a> (void)</td></tr>
<tr class="separator:ga7d2f1a37f33e1ded4a4ea6132002ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d0ae9c014ca65c58c1e625a21e4f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga97d0ae9c014ca65c58c1e625a21e4f13">USBHostIntHandlerInternal</a> (uint32_t ui32Index, uint32_t ui32Status)</td></tr>
<tr class="separator:ga97d0ae9c014ca65c58c1e625a21e4f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a648f5969831614c96ecc1ffb9a4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga96a648f5969831614c96ecc1ffb9a4f7">USB0_IRQHostHandler</a> (void)</td></tr>
<tr class="separator:ga96a648f5969831614c96ecc1ffb9a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9221b274d44b252f310f30447331ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaf9221b274d44b252f310f30447331ed1">InternalUSBHCDSendEvent</a> (uint32_t ui32Index, <a class="el" href="structt_event_info.html">tEventInfo</a> *psEvent, uint32_t ui32EvFlag)</td></tr>
<tr class="separator:gaf9221b274d44b252f310f30447331ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34c6f46e6821db0445a6ce1d7fc30ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaa34c6f46e6821db0445a6ce1d7fc30ec">USBHCDMain</a> (void)</td></tr>
<tr class="separator:gaa34c6f46e6821db0445a6ce1d7fc30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b750f4799829a3efe895ccadf41217e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer</a> (uint32_t ui32Index, tUSBRequest *psSetupPacket, <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice, uint8_t *pui8Data, uint32_t ui32Size, uint32_t ui32MaxPacketSize)</td></tr>
<tr class="separator:ga8b750f4799829a3efe895ccadf41217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d343e68187420479928b57ef873dfd4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8d343e68187420479928b57ef873dfd4">USBHCDHubDeviceConnected</a> (uint32_t ui32Index, uint8_t ui8Hub, uint8_t ui8Port, uint32_t ui32Speed)</td></tr>
<tr class="separator:ga8d343e68187420479928b57ef873dfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa178232be85db3e930e2fa92d61d4845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaa178232be85db3e930e2fa92d61d4845">USBHCDHubDeviceDisconnected</a> (uint32_t ui32Index, uint32_t ui32DevIndex)</td></tr>
<tr class="separator:gaa178232be85db3e930e2fa92d61d4845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2903774d85134000dace293b0909854f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga2903774d85134000dace293b0909854f">USBHCDDevHubPort</a> (uint32_t ui32Instance)</td></tr>
<tr class="separator:ga2903774d85134000dace293b0909854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4fef3c357299923fa71f261c6b1b94"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga5a4fef3c357299923fa71f261c6b1b94">USBHCDDevAddress</a> (uint32_t ui32Instance)</td></tr>
<tr class="separator:ga5a4fef3c357299923fa71f261c6b1b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c7c2c61ba3c968d9b30fa9594d09f9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga29c7c2c61ba3c968d9b30fa9594d09f9">USBHCDDevClass</a> (uint32_t ui32Instance, uint32_t ui32Interface)</td></tr>
<tr class="separator:ga29c7c2c61ba3c968d9b30fa9594d09f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7801e1a136723975b4e1404f053c83"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gaad7801e1a136723975b4e1404f053c83">USBHCDDevSubClass</a> (uint32_t ui32Instance, uint32_t ui32Interface)</td></tr>
<tr class="separator:gaad7801e1a136723975b4e1404f053c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db93f0812e715f08ca65ab862abfb93"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga8db93f0812e715f08ca65ab862abfb93">USBHCDDevProtocol</a> (uint32_t ui32Instance, uint32_t ui32Interface)</td></tr>
<tr class="separator:ga8db93f0812e715f08ca65ab862abfb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e587ab23242d4de2ac5a6052f7afead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga0e587ab23242d4de2ac5a6052f7afead">USBHCDFeatureSet</a> (uint32_t ui32Index, uint32_t ui32Feature, void *pvFeature)</td></tr>
<tr class="separator:ga0e587ab23242d4de2ac5a6052f7afead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397601992d02bbb4da500c2419036ddb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus</a> (<a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice)</td></tr>
<tr class="separator:ga397601992d02bbb4da500c2419036ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58a11d54ef7f4a976bc0a0614dbc64c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#gad58a11d54ef7f4a976bc0a0614dbc64c">USBHCDLPMSleep</a> (<a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *psDevice)</td></tr>
<tr class="separator:gad58a11d54ef7f4a976bc0a0614dbc64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e82a86e9880f48ba52239da4ae1799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga30e82a86e9880f48ba52239da4ae1799">USBHCDLPMResume</a> (uint32_t ui32Index)</td></tr>
<tr class="separator:ga30e82a86e9880f48ba52239da4ae1799"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0bb842a4e7d8055f5c082ad392aa2ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__hcd.html#ga0bb842a4e7d8055f5c082ad392aa2ad1">g_iUSBMode</a></td></tr>
<tr class="separator:ga0bb842a4e7d8055f5c082ad392aa2ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade3447c8b071bc651eeff0054ff3f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade3447c8b071bc651eeff0054ff3f6e6">&sect;&nbsp;</a></span>USBHCD_PIPE_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_UNUSED&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0e134a9391395685589bb30b50a8a254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e134a9391395685589bb30b50a8a254">&sect;&nbsp;</a></span>USBHCD_PIPE_CONTROL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_CONTROL&#160;&#160;&#160;0x00130000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaee548b8e8775860d541238cf9d3c80d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee548b8e8775860d541238cf9d3c80d1">&sect;&nbsp;</a></span>USBHCD_PIPE_BULK_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_BULK_OUT&#160;&#160;&#160;0x00210000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7bd4350b6d54f1b150a157eb8d0bb961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd4350b6d54f1b150a157eb8d0bb961">&sect;&nbsp;</a></span>USBHCD_PIPE_BULK_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_BULK_IN&#160;&#160;&#160;0x00220000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8ba52adf42b3fa51eff225d18ed29368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ba52adf42b3fa51eff225d18ed29368">&sect;&nbsp;</a></span>USBHCD_PIPE_INTR_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_INTR_OUT&#160;&#160;&#160;0x00410000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacd87439ca588c9598431434915749a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd87439ca588c9598431434915749a53">&sect;&nbsp;</a></span>USBHCD_PIPE_INTR_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_INTR_IN&#160;&#160;&#160;0x00420000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7677d3cf45cba4e76fe869fb58ddb89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7677d3cf45cba4e76fe869fb58ddb89a">&sect;&nbsp;</a></span>USBHCD_PIPE_ISOC_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_ISOC_OUT&#160;&#160;&#160;0x00810000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga464b17e771b98dccff1c9ca7f3b3f5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464b17e771b98dccff1c9ca7f3b3f5a4">&sect;&nbsp;</a></span>USBHCD_PIPE_ISOC_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_ISOC_IN&#160;&#160;&#160;0x00820000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6d542f3fcaafa23faeda3454425b0ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d542f3fcaafa23faeda3454425b0ec0">&sect;&nbsp;</a></span>USBHCD_PIPE_ISOC_OUT_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_ISOC_OUT_DMA&#160;&#160;&#160;0x01810000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga73c6184dbb93e8ffabb7139fe5dc2edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c6184dbb93e8ffabb7139fe5dc2edc">&sect;&nbsp;</a></span>USBHCD_PIPE_ISOC_IN_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_ISOC_IN_DMA&#160;&#160;&#160;0x01820000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga12d0e46c65c46ee5a0d42921f0902a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12d0e46c65c46ee5a0d42921f0902a99">&sect;&nbsp;</a></span>USBHCD_PIPE_BULK_OUT_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_BULK_OUT_DMA&#160;&#160;&#160;0x01210000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2bea6750070b4f93791bd9555a2ea5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bea6750070b4f93791bd9555a2ea5f1">&sect;&nbsp;</a></span>USBHCD_PIPE_BULK_IN_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_PIPE_BULK_IN_DMA&#160;&#160;&#160;0x01220000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaecbc1b07110de83e1a6aa03d917be1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbc1b07110de83e1a6aa03d917be1a7">&sect;&nbsp;</a></span>USBHCD_FAULT_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_FAULT_LOW&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1c031a7a88d06e01218bd34ddda799c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c031a7a88d06e01218bd34ddda799c1">&sect;&nbsp;</a></span>USBHCD_FAULT_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_FAULT_HIGH&#160;&#160;&#160;0x00000030</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c12a9e55d3cebc7fe21cf432a341d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c12a9e55d3cebc7fe21cf432a341d6d">&sect;&nbsp;</a></span>USBHCD_FAULT_VBUS_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_FAULT_VBUS_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaafd9ab68889e273078c9bea769b6c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd9ab68889e273078c9bea769b6c280">&sect;&nbsp;</a></span>USBHCD_FAULT_VBUS_TRI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_FAULT_VBUS_TRI&#160;&#160;&#160;0x00000140</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga855c6b5f7a0e0e39428cff061ff0a591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga855c6b5f7a0e0e39428cff061ff0a591">&sect;&nbsp;</a></span>USBHCD_FAULT_VBUS_DIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_FAULT_VBUS_DIS&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabb9c9963db1ac4cb045d87c8aa361a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb9c9963db1ac4cb045d87c8aa361a25">&sect;&nbsp;</a></span>USBHCD_VBUS_MANUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_VBUS_MANUAL&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad9544adc80da78c49286c3436bc4be2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9544adc80da78c49286c3436bc4be2e">&sect;&nbsp;</a></span>USBHCD_VBUS_AUTO_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_VBUS_AUTO_LOW&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf79a96acfe19644abad91cbbdb136638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79a96acfe19644abad91cbbdb136638">&sect;&nbsp;</a></span>USBHCD_VBUS_AUTO_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_VBUS_AUTO_HIGH&#160;&#160;&#160;0x00000003</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa8143820fb6ae4c2bd017d1b99710a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8143820fb6ae4c2bd017d1b99710a69">&sect;&nbsp;</a></span>USBHCD_VBUS_FILTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_VBUS_FILTER&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab2ab8e8094037c34ba548403ccf323c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ab8e8094037c34ba548403ccf323c6">&sect;&nbsp;</a></span>USBHCD_LPM_AVAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_LPM_AVAIL&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="ga97320596add061e95cb5b931b3734513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97320596add061e95cb5b931b3734513">&sect;&nbsp;</a></span>USBHCD_LPM_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_LPM_ERROR&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="ga087cdcec0c54cddcf64aa4e5fa20b355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087cdcec0c54cddcf64aa4e5fa20b355">&sect;&nbsp;</a></span>USBHCD_LPM_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_LPM_PENDING&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="ga21d261472653237f418f6fc4ea32a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d261472653237f418f6fc4ea32a4ad">&sect;&nbsp;</a></span>DECLARE_EVENT_DRIVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_EVENT_DRIVER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VarName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pfnOpen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pfnClose, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pfnEvent&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> IntFn(<span class="keywordtype">void</span> *pvData);                                                   \</div><div class="line">const <a class="code" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> VarName =                                         \</div><div class="line">{                                                                           \</div><div class="line">    USB_CLASS_EVENTS,                                                       \</div><div class="line">    0,                                                                      \</div><div class="line">    0,                                                                      \</div><div class="line">    pfnEvent                                                                \</div><div class="line">}</div><div class="ttc" id="structt_u_s_b_host_class_driver_html"><div class="ttname"><a href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a></div><div class="ttdef"><b>Definition:</b> usbhost.h:156</div></div>
</div><!-- fragment --><p>This macro is used to declare an instance of an Event driver for the USB library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VarName</td><td>is the name of the variable. </td></tr>
    <tr><td class="paramname">pfnOpen</td><td>is the callback for the Open call to this driver. This value is currently reserved and should be set to 0. </td></tr>
    <tr><td class="paramname">pfnClose</td><td>is the callback for the Close call to this driver. This value is currently reserved and should be set to 0. </td></tr>
    <tr><td class="paramname">pfnEvent</td><td>is the callback that will be called for various USB events.</td></tr>
  </table>
  </dd>
</dl>
<p>The first parameter is the actual name of the variable that will be declared by this macro. The second and third parameter are reserved for future functionality and are unused and should be set to zero. The last parameter is the actual callback function and is specified as a function pointer of the type:</p>
<pre class="fragment">//! void (*pfnEvent)(void *pvData);
//! </pre> <pre class="fragment">When the \e pfnEvent function is called the void pointer that is passed in
as a parameter should be cast to a pointer to a structure of type
tEventInfo.  This will contain the event that caused the pfnEvent function
to be called.  </pre> 
</div>
</div>
<a id="gafc7eda9b970cc1166ad1f41f6c0ee7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7eda9b970cc1166ad1f41f6c0ee7b0">&sect;&nbsp;</a></span>USB_HOST_PWREN_AUTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_HOST_PWREN_AUTO&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf89d220b4f1a5b5d36301db598053dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89d220b4f1a5b5d36301db598053dc2">&sect;&nbsp;</a></span>INT_EVENT_VBUS_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_VBUS_ERR&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab855f89e2376215b77a7d837de150c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab855f89e2376215b77a7d837de150c77">&sect;&nbsp;</a></span>INT_EVENT_CONNECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_CONNECT&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99828dec4fd85573b6eb7b46948f163b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99828dec4fd85573b6eb7b46948f163b">&sect;&nbsp;</a></span>INT_EVENT_DISCONNECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_DISCONNECT&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae80baaa06215f352316f511f1bfadada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae80baaa06215f352316f511f1bfadada">&sect;&nbsp;</a></span>INT_EVENT_POWER_FAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_POWER_FAULT&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac774fa499dbce43e9be1535cff1b4ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac774fa499dbce43e9be1535cff1b4ae7">&sect;&nbsp;</a></span>INT_EVENT_SOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_SOF&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga97bbc29bb0d940cff966a9aa6fe5320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97bbc29bb0d940cff966a9aa6fe5320e">&sect;&nbsp;</a></span>INT_EVENT_ENUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_ENUM&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf652817b981898c67edc1b69b17f2f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf652817b981898c67edc1b69b17f2f7e">&sect;&nbsp;</a></span>INT_EVENT_LPM_PEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_LPM_PEND&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8863e8fb651137c9379305e2aa7780c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8863e8fb651137c9379305e2aa7780c2">&sect;&nbsp;</a></span>INT_EVENT_LPM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT_EVENT_LPM&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99b765e78c87a9b6bd93fef299e31051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99b765e78c87a9b6bd93fef299e31051">&sect;&nbsp;</a></span>USBHDEV_FLAG_NOTIFYINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHDEV_FLAG_NOTIFYINT&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gada4792c60a04722d08aa5bf1eea3b74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada4792c60a04722d08aa5bf1eea3b74f">&sect;&nbsp;</a></span>USBHDEV_FLAG_LPMPEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHDEV_FLAG_LPMPEND&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="ga1f7469041f29bebded62fdbec4a127a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7469041f29bebded62fdbec4a127a6">&sect;&nbsp;</a></span>USBHDEV_FLAG_LPMERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHDEV_FLAG_LPMERROR&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="ga2007414177b849e1c84aec30f0114b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2007414177b849e1c84aec30f0114b4e">&sect;&nbsp;</a></span>USBHDEV_FLAG_ALLOCATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHDEV_FLAG_ALLOCATED&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga77efb2e4d4f36e029d69503b3c6079c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77efb2e4d4f36e029d69503b3c6079c9">&sect;&nbsp;</a></span>MAX_NUM_PIPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_NUM_PIPES&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga4d30cf9b53e02759e717a7c0d7fd74f4">USBHCDPipeAllocSize()</a>.</p>

</div>
</div>
<a id="ga3a8644e6bf744bc721081d63b9b4d8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a8644e6bf744bc721081d63b9b4d8f7">&sect;&nbsp;</a></span>MAX_NUM_DMA_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_NUM_DMA_CHANNELS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2c345cc5c8069c1712dacad037414976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c345cc5c8069c1712dacad037414976">&sect;&nbsp;</a></span>USBHCD_DMA_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBHCD_DMA_UNUSED&#160;&#160;&#160;0xff</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad3b6983b56a32a6c7118e5c9ed73edfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3b6983b56a32a6c7118e5c9ed73edfc">&sect;&nbsp;</a></span>EP_PIPE_TYPE_LOW_SPEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_LOW_SPEED&#160;&#160;&#160;0x02000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4dee1facc1f933f8b476c58a69e04617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dee1facc1f933f8b476c58a69e04617">&sect;&nbsp;</a></span>EP_PIPE_USE_UDMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_USE_UDMA&#160;&#160;&#160;0x01000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a>, and <a class="el" href="group__usblib__hcd.html#ga1e25fa42e07b795bb2484d478395f2b1">USBHCDPipeWrite()</a>.</p>

</div>
</div>
<a id="ga8c68b2a2e8d16220fdccd772f6dfbceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c68b2a2e8d16220fdccd772f6dfbceb">&sect;&nbsp;</a></span>EP_PIPE_TYPE_ISOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_ISOC&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba8e8b5849224c957159440cdddda3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8e8b5849224c957159440cdddda3e4">&sect;&nbsp;</a></span>EP_PIPE_TYPE_INTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_INTR&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafcfa4cd9d4511e759a81da4e3951a8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcfa4cd9d4511e759a81da4e3951a8ac">&sect;&nbsp;</a></span>EP_PIPE_TYPE_BULK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_BULK&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga62b3457adb35e3a618b9f24dd7dbcfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b3457adb35e3a618b9f24dd7dbcfe3">&sect;&nbsp;</a></span>EP_PIPE_TYPE_CONTROL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_CONTROL&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3c7b48b18cd520ac41ca57cbe3a15af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c7b48b18cd520ac41ca57cbe3a15af3">&sect;&nbsp;</a></span>EP_PIPE_TYPE_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_IN&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga13a5c4bdb67ac541c87fe26703883a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13a5c4bdb67ac541c87fe26703883a01">&sect;&nbsp;</a></span>EP_PIPE_TYPE_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_TYPE_OUT&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga4d30cf9b53e02759e717a7c0d7fd74f4">USBHCDPipeAllocSize()</a>, <a class="el" href="group__usblib__hcd.html#ga90eb5644130f579d98fbd81027dbad8e">USBHCDPipeConfig()</a>, <a class="el" href="group__usblib__hcd.html#ga4511ac416938adac9fd4d5fa4156abfd">USBHCDPipeFree()</a>, and <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a>.</p>

</div>
</div>
<a id="gaf80ff2f3162205ed9d38ade396703ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80ff2f3162205ed9d38ade396703ded">&sect;&nbsp;</a></span>EP_PIPE_IDX_M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_PIPE_IDX_M&#160;&#160;&#160;0x0000ffff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga90eb5644130f579d98fbd81027dbad8e">USBHCDPipeConfig()</a>, <a class="el" href="group__usblib__hcd.html#ga9955bacdc4c448c3554ca07d21dd881f">USBHCDPipeDataAck()</a>, <a class="el" href="group__usblib__hcd.html#ga4511ac416938adac9fd4d5fa4156abfd">USBHCDPipeFree()</a>, <a class="el" href="group__usblib__hcd.html#gabac32f7cfa838cb39452b4543aa9d2a7">USBHCDPipeRead()</a>, <a class="el" href="group__usblib__hcd.html#ga5f82cf837684e765625e1f7e83a02ce2">USBHCDPipeReadNonBlocking()</a>, <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a>, <a class="el" href="group__usblib__hcd.html#gac41464e862a76e3ccbdfa379a0a92670">USBHCDPipeTransferSizeGet()</a>, and <a class="el" href="group__usblib__hcd.html#ga1e25fa42e07b795bb2484d478395f2b1">USBHCDPipeWrite()</a>.</p>

</div>
</div>
<a id="gac9c5d8d8a277a9eaca589420d0b21e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9c5d8d8a277a9eaca589420d0b21e72">&sect;&nbsp;</a></span>OUT_PIPE_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUT_PIPE_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32Idx</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(g_sUSBHCD.psUSBOUTPipes[ui32Idx].ui32Type |  \</div><div class="line">                                 ui32Idx)</div></div><!-- fragment -->
</div>
</div>
<a id="ga8086216d44e8c265c501e6fb8ac71ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8086216d44e8c265c501e6fb8ac71ba1">&sect;&nbsp;</a></span>IN_PIPE_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IN_PIPE_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ui32Idx</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(g_sUSBHCD.psUSBINPipes[ui32Idx].ui32Type |   \</div><div class="line">                                 ui32Idx)</div></div><!-- fragment -->
</div>
</div>
<a id="gaadf74b0caf840f0d3222cb1dc563684c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf74b0caf840f0d3222cb1dc563684c">&sect;&nbsp;</a></span>EP_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EP_OFFSET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Endpoint</td><td>)</td>
          <td>&#160;&#160;&#160;(Endpoint - 0x10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3cb4ce1332b6a61e88029daf1226925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb4ce1332b6a61e88029daf1226925d">&sect;&nbsp;</a></span>tHCDPipeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  tHCDPipeCallback) (uint32_t ui32Pipe, uint32_t ui32Event)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga069725dbb3431c9f746927610fb6f422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga069725dbb3431c9f746927610fb6f422">&sect;&nbsp;</a></span>tUSBHostDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> <a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabc3f5e99cefcf597f763076cfdbf2696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc3f5e99cefcf597f763076cfdbf2696">&sect;&nbsp;</a></span>tEP0State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="usbdevicepriv_8h.html#abc3f5e99cefcf597f763076cfdbf2696">tEP0State</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696adcb6708fe105e9cb02f4e382019989c1"></a>eUSBStateIdle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696ac35b54c0cd74234ebb62e6ca05e05ac8"></a>eUSBStateTx&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a81ef9a55fc6f4a8378639e9145598b1b"></a>eUSBStateTxConfig&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a93020218daf932d37ee433bafe68a390"></a>eUSBStateRx&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696aa97b8e53b49db975692882b2a9fb6150"></a>eUSBStateStatus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a4135f6319d3ccec3bda25ea4da6f5cb0"></a>eUSBStateStall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a813c95af6931423119be55bc754b0a24"></a>eEP0StateIdle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a7e59f231e9f68cbf2cd3b55036e2b68d"></a>eEP0StateSetupIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a93c0b3987ea680a9a3c7417a2260a238"></a>eEP0StateSetupOUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a12a99855f2e81efb6b4f4233fdf197ce"></a>eEP0StateRx&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696ad3542acc4958a047b150b4d2e885c455"></a>eEP0StateStatus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696ac74d6c63fd43ea6674c7fc2f0cf03272"></a>eEP0StateStatusIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696a4ef3ed17922447de14de8a18644494f7"></a>eEP0StateStall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabc3f5e99cefcf597f763076cfdbf2696afd2ca830f97e2837b9d27659d0a9e54b"></a>eEP0StateError&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gabb4951a6f301ff2e037630a34a7d64ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb4951a6f301ff2e037630a34a7d64ea">&sect;&nbsp;</a></span>tUSBHDeviceState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__usblib__hcd.html#gabb4951a6f301ff2e037630a34a7d64ea">tUSBHDeviceState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa8abc30cf49613e464090617a9f48935e"></a>eHCDDevDisconnected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa2692b08a82c434c771eee1ec48c19c71"></a>eHCDDevConnected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaaa19387f696e9eb38c928f136a51f18ab"></a>eHCDDevConnectedHub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa13a443b526e5bd0aac43c8dbf48cda34"></a>eHCDDevRequest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa2d4a082bfe37d497f87904481655fdbd"></a>eHCDDevReset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa7709fd9e1b680a36f2e34a9786a26764"></a>eHCDDevAddressed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaac7a7321ac13c543ffc90cb89d1962397"></a>eHCDDevConfigured&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaaa12443acc2131af332f9f03fce71818e"></a>eHCDDevGetStrings&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaab8ad68084e76a8b6b6d0db1207603762"></a>eHCDDevError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa32dd2faaa5f84cddd40115e7757eac21"></a>eHCDVBUSError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaacbbcc47f79dd743d8d6facdf6189e7e3"></a>eHCDPowerFault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabb4951a6f301ff2e037630a34a7d64eaa434b648f2820587395f5f082f9c04a7b"></a>eHCDIdle&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga66296ccc0b4f0d2bf2e12fc3d5b11435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66296ccc0b4f0d2bf2e12fc3d5b11435">&sect;&nbsp;</a></span>OTGDeviceDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTGDeviceDisconnect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__general__usblib__api.html#ggaded7d9b37df85ca90e41af1e6f689613a2e55713b539035c755ddfc2499eb8b62">eUSBOTGModeAHost</a>, and <a class="el" href="group__general__usblib__api.html#ga830335f7a4fe3752317f6114f12307fe">g_eOTGModeState</a>.</p>

</div>
</div>
<a id="ga312ec4c41f8eb09258b72636b57bcd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312ec4c41f8eb09258b72636b57bcd4b">&sect;&nbsp;</a></span>ConfigDescAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ConfigDescAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga71a582f2a432498c3d22e2d318430e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a582f2a432498c3d22e2d318430e5a">&sect;&nbsp;</a></span>ConfigDescFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConfigDescFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf2545972bd2bfd79829dd21ca373254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2545972bd2bfd79829dd21ca373254a">&sect;&nbsp;</a></span>USBHCDEventEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHCDEventEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvEventDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to enable a specific USB HCD event notification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">pvEventDriver</td><td>is the event driver structure that was passed into the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function as part of the array of <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> structures. </td></tr>
    <tr><td class="paramname">ui32Event</td><td>is the event to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called to enable event callbacks for a specific USB HCD event. The requested event is passed in the <em>ui32Event</em> parameter. Not all events can be enables so the function will return zero if the event provided cannot be enabled. The <em>pvEventDriver</em> is a pointer to the event driver structure that the caller passed into the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function. This structure is typically declared with the <a class="el" href="group__usblib__hcd.html#ga21d261472653237f418f6fc4ea32a4ad">DECLARE_EVENT_DRIVER()</a> macro and included as part of the array of pointers to <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> structures that is passed to the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns a non-zero number if the event was successfully enabled and returns zero if the event cannot be enabled. </dd></dl>

</div>
</div>
<a id="ga8eb0d7da79ae6713350726d796acb635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eb0d7da79ae6713350726d796acb635">&sect;&nbsp;</a></span>USBHCDEventDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHCDEventDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvEventDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to disable a specific USB HCD event notification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">pvEventDriver</td><td>is the event driver structure that was passed into the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function as part of the array of <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> structures. </td></tr>
    <tr><td class="paramname">ui32Event</td><td>is the event to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called to disable event callbacks for a specific USB HCD event. The requested event is passed in the <em>ui32Event</em> parameter. Not all events can be enables so the function will return zero if the event provided cannot be enabled. The <em>pvEventDriver</em> is a pointer to the event driver structure that the caller passed into the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function. This structure is typically declared with the <a class="el" href="group__usblib__hcd.html#ga21d261472653237f418f6fc4ea32a4ad">DECLARE_EVENT_DRIVER()</a> macro and included as part of the array of pointers to <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> structures that is passed to the <a class="el" href="group__usblib__hcd.html#ga9ded177760ee026d12348de1daacd45c">USBHCDRegisterDrivers()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns a non-zero number if the event was successfully disabled and returns zero if the event cannot be disabled. </dd></dl>

</div>
</div>
<a id="gac41464e862a76e3ccbdfa379a0a92670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41464e862a76e3ccbdfa379a0a92670">&sect;&nbsp;</a></span>USBHCDPipeTransferSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeTransferSizeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current byte count of a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the allocated endpoint to modify.</td></tr>
  </table>
  </dd>
</dl>
<p>This call returns the current or last byte count for a transfer using the pipe specified by the <em>ui32Pipe</em> parameter. This is typically used to determine the actual byte count received when a <b>USB_EVENT_RX_AVAILABLE</b> occurs.</p>
<dl class="section return"><dt>Returns</dt><dd>If the call was successful, this function returns the number of bytes transfered by the USB pipe. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>.</p>

</div>
</div>
<a id="ga4d30cf9b53e02759e717a7c0d7fd74f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d30cf9b53e02759e717a7c0d7fd74f4">&sect;&nbsp;</a></span>USBHCDPipeAllocSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeAllocSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32EndpointType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__hcd.html#ga3cb4ce1332b6a61e88029daf1226925d">tHCDPipeCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to allocate a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32EndpointType</td><td>is the type of endpoint that this pipe will be communicating with. </td></tr>
    <tr><td class="paramname">psDevice</td><td>is the device instance associated with this endpoint. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the FIFO in bytes. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is the function that will be called when events occur on this USB Pipe.</td></tr>
  </table>
  </dd>
</dl>
<p>Since there are a limited number of USB HCD pipes that can be used in the host controller, this function is used to temporarily or permanently acquire one of the endpoints. Unlike the <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a> function this function allows the caller to specify the size of the FIFO allocated to this endpoint in the <em>ui32Size</em> parameter. This function also provides a method to register a callback for status changes on this endpoint. If no callbacks are desired then the <em>pfnCallback</em> function should be set to 0. The callback should be used when using the <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a> function so that the caller is notified when the action is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns a value indicating which pipe was reserved. If the value is 0 then there were no pipes currently available. This value should be passed to any USBHCDPipe APIs to indicate which pipe is being accessed. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga13a5c4bdb67ac541c87fe26703883a01">EP_PIPE_TYPE_OUT</a>, and <a class="el" href="group__usblib__hcd.html#ga77efb2e4d4f36e029d69503b3c6079c9">MAX_NUM_PIPES</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a>.</p>

</div>
</div>
<a id="gaf804c6e895faea7d825cb3a9c0f38a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf804c6e895faea7d825cb3a9c0f38a60">&sect;&nbsp;</a></span>USBHCDPipeAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeAlloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32EndpointType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__hcd.html#ga3cb4ce1332b6a61e88029daf1226925d">tHCDPipeCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to allocate a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32EndpointType</td><td>is the type of endpoint that this pipe will be communicating with. </td></tr>
    <tr><td class="paramname">psDevice</td><td>is the device instance associated with this endpoint. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is the function that will be called when events occur on this USB Pipe.</td></tr>
  </table>
  </dd>
</dl>
<p>Since there are a limited number of USB HCD pipes that can be used in the host controller, this function is used to temporarily or permanently acquire one of the endpoints. It also provides a method to register a callback for status changes on this endpoint. If no callbacks are desired then the <em>pfnCallback</em> function should be set to 0. The callback should be used when using the <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a> function so that the caller is notified when the action is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns a value indicating which pipe was reserved. If the value is 0 then there were no pipes currently available. This value should be passed to any USBHCDPipe APIs to indicate which pipe is being accessed. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga4d30cf9b53e02759e717a7c0d7fd74f4">USBHCDPipeAllocSize()</a>.</p>

</div>
</div>
<a id="ga90eb5644130f579d98fbd81027dbad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90eb5644130f579d98fbd81027dbad8e">&sect;&nbsp;</a></span>USBHCDPipeConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TargetEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to configure a USB HCD pipe.</p>
<p>This should be called after allocating a USB pipe with a call to <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a>. It is used to set the configuration associated with an endpoint like the max payload and target endpoint. The <em>ui32MaxPayload</em> parameter is typically read directly from the devices endpoint descriptor and is expressed in bytes.</p>
<p>Setting the <em>ui32Interval</em> parameter depends on the type of endpoint being configured. For endpoints that do not need to use the <em>ui32Interval</em> parameter <em>ui32Interval</em> should be set to 0. For Bulk <em>ui32Interval</em> is a value from 2-16 and will set the NAK timeout value as 2^(<em>ui32Interval-1</em>) frames. For interrupt endpoints <em>ui32Interval</em> is a value from 1-255 and is the count in frames between polling the endpoint. For isochronous endpoints <em>ui32Interval</em> ranges from 1-16 and is the polling interval in frames represented as 2^(<em>ui32Interval-1</em>) frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the allocated endpoint to modify. </td></tr>
    <tr><td class="paramname">ui32MaxPayload</td><td>is maximum data that can be handled per transaction. </td></tr>
    <tr><td class="paramname">ui32Interval</td><td>is the polling interval for data transfers expressed in frames. </td></tr>
    <tr><td class="paramname">ui32TargetEndpoint</td><td>is the target endpoint on the device to communicate with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the call was successful, this function returns zero any other value indicates an error. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>, <a class="el" href="group__usblib__hcd.html#ga13a5c4bdb67ac541c87fe26703883a01">EP_PIPE_TYPE_OUT</a>, and <a class="el" href="structt_u_s_b_host_device.html#a89210de9ba9777c04f9f9bb2ad201f77">tUSBHostDevice::ui32Flags</a>.</p>

</div>
</div>
<a id="gaf7e154a06493413b3c953b8fed2222a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e154a06493413b3c953b8fed2222a6">&sect;&nbsp;</a></span>USBHCDPipeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to return the current status of a USB HCD pipe.</p>
<p>This function will return the current status for a given USB pipe. If there is no status to report this call will simply return <b>USBHCD_PIPE_NO_CHANGE</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB pipe for this status request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the current status for the given endpoint. This will be one of the <b>USBHCD_PIPE_*</b> values. </dd></dl>

</div>
</div>
<a id="ga1e25fa42e07b795bb2484d478395f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e25fa42e07b795bb2484d478395f2b1">&sect;&nbsp;</a></span>USBHCDPipeWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to write data to a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB pipe to put data into. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data to send. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the amount of data to send.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will block until it has sent as much data as was requested using the USB pipe's FIFO. The caller should have registered a callback with the <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a> call in order to be informed when the data has been transmitted. The value returned by this function can be less than the <em>ui32Size</em> requested if the USB pipe has less space available than this request is making.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were scheduled to be sent on the given USB pipe. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>, and <a class="el" href="group__usblib__hcd.html#ga4dee1facc1f933f8b476c58a69e04617">EP_PIPE_USE_UDMA</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class__cdc.html#ga75a3b4567e8198bf25780e5a798e6085">USBHCDCWriteData()</a>.</p>

</div>
</div>
<a id="ga06cf106720569ee7276f4178129aa898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cf106720569ee7276f4178129aa898">&sect;&nbsp;</a></span>USBHCDPipeSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeSchedule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to schedule and IN transaction on a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB pipe to read data from. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to store the data that is received. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Data</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will not block depending on the type of pipe passed in will schedule either a send of data to the device or a read of data from the device. In either case the amount of data will be limited to what will fit in the FIFO for a given endpoint.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were sent in the case of a transfer of data or it will return 0 for a request on a USB IN pipe. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>, <a class="el" href="group__usblib__hcd.html#ga13a5c4bdb67ac541c87fe26703883a01">EP_PIPE_TYPE_OUT</a>, and <a class="el" href="group__usblib__hcd.html#ga4dee1facc1f933f8b476c58a69e04617">EP_PIPE_USE_UDMA</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#gaee0cd88dd6bf6531fb8d3456c858d7b2">USBHostAudioPlay()</a>, and <a class="el" href="group__usblib__host__class.html#ga2551ad61aeb9f64111c9db7fad742c48">USBHostAudioRecord()</a>.</p>

</div>
</div>
<a id="ga5f82cf837684e765625e1f7e83a02ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f82cf837684e765625e1f7e83a02ce2">&sect;&nbsp;</a></span>USBHCDPipeReadNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeReadNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to read data from a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB pipe to read data from. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to store the data that is received. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Data</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will not block and will only read as much data as requested or as much data is currently available from the USB pipe. The caller should have registered a callback with the <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a> call in order to be informed when the data has been received. The value returned by this function can be less than the <em>ui32Size</em> requested if the USB pipe has less data available than was requested.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were returned in the <em>pui8Data</em> buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga38170ed323efd3f4752252aa9aaa2401">USBHHIDGetReport()</a>.</p>

</div>
</div>
<a id="ga9955bacdc4c448c3554ca07d21dd881f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9955bacdc4c448c3554ca07d21dd881f">&sect;&nbsp;</a></span>USBHCDPipeDataAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDPipeDataAck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acknowledges data received via an interrupt IN pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB INT pipe whose last packet is to be acknowledged.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to acknowledge reception of data on an interrupt IN pipe. A transfer on an interrupt IN endpoint is scheduled via a call to <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a> and the application is notified when data is received using a <b>USB_EVENT_RX_AVAILABLE</b> event. In the handler for this event, the application must call <a class="el" href="group__usblib__hcd.html#ga9955bacdc4c448c3554ca07d21dd881f">USBHCDPipeDataAck()</a> to have the USB controller ACK the data from the device and complete the transaction.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>.</p>

</div>
</div>
<a id="gabac32f7cfa838cb39452b4543aa9d2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac32f7cfa838cb39452b4543aa9d2a7">&sect;&nbsp;</a></span>USBHCDPipeRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPipeRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to read data from a USB HCD pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the USB pipe to read data from. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to store the data that is received. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Data</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will block and will only return when it has read as much data as requested from the USB pipe. The caller must register a callback with the <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a> call in order to be informed when the data has been received. If the caller provides a non-zero pointer in the <em>pui8Data</em> parameter then the data is copied into the buffer before the callback occurs. If the caller provides a zero in <em>pui8Data</em> parameter then the caller is responsible for reading the data out of the FIFO when the <b>USB_EVENT_RX_AVAILABLE</b> callback event occurs. The value returned by this function can be less than the <em>ui32Size</em> requested if the USB pipe has less data available than was requested.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were returned in the <em>pui8Data</em> buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class__cdc.html#gafcbf5fa5bd1d216bd2968b586d5bbc80">USBHCDCReadData()</a>.</p>

</div>
</div>
<a id="ga4511ac416938adac9fd4d5fa4156abfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4511ac416938adac9fd4d5fa4156abfd">&sect;&nbsp;</a></span>USBHCDPipeFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDPipeFree </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to release a USB pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Pipe</td><td>is the allocated USB pipe to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to release a USB pipe that was allocated by a call to <a class="el" href="group__usblib__hcd.html#gaf804c6e895faea7d825cb3a9c0f38a60">USBHCDPipeAlloc()</a> for use by some other device endpoint in the system. Freeing an unallocated or invalid pipe will not generate an error and will instead simply return.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gaf80ff2f3162205ed9d38ade396703ded">EP_PIPE_IDX_M</a>, and <a class="el" href="group__usblib__hcd.html#ga13a5c4bdb67ac541c87fe26703883a01">EP_PIPE_TYPE_OUT</a>.</p>

</div>
</div>
<a id="ga2458bcfaceeac64f35ccbf90421048ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2458bcfaceeac64f35ccbf90421048ac">&sect;&nbsp;</a></span>USBHCDPowerConfigInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDPowerConfigInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PwrConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the power pin and power fault configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32PwrConfig</td><td>is the power configuration to use for the application.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be called before HCDInit() is called so that the power pin configuration can be set before power is enabled. The <em>ui32PwrConfig</em> flags specify the power fault level sensitivity, the power fault action, and the power enable pin level and source.</p>
<p>One of the following can be selected as the power fault level sensitivity:</p>
<ul>
<li><b>USBHCD_FAULT_LOW</b> - An external power fault is indicated by the pin being driven low.</li>
<li><b>USBHCD_FAULT_HIGH</b> - An external power fault is indicated by the pin being driven high.</li>
</ul>
<p>One of the following can be selected as the power fault action:</p>
<ul>
<li><b>USBHCD_FAULT_VBUS_NONE</b> - No automatic action when power fault detected.</li>
<li><b>USBHCD_FAULT_VBUS_TRI</b> - Automatically Tri-state the USBnEPEN pin on a power fault.</li>
<li><b>USBHCD_FAULT_VBUS_DIS</b> - Automatically drive the USBnEPEN pin to it's inactive state on a power fault.</li>
</ul>
<p>One of the following can be selected as the power enable level and source:</p>
<ul>
<li><b>USBHCD_VBUS_MANUAL</b> - Power control is completely managed by the application, the USB library will provide a power callback to request power state changes.</li>
<li><b>USBHCD_VBUS_AUTO_LOW</b> - USBEPEN is driven low by the USB controller automatically if USBOTGSessionRequest() has enabled a session.</li>
<li><b>USBHCD_VBUS_AUTO_HIGH</b> - USBEPEN is driven high by the USB controller automatically if USBOTGSessionRequest() has enabled a session.</li>
</ul>
<p>If <b>USBHCD_VBUS_MANUAL</b> is used then the application must provide an event driver to receive the <b>USB_EVENT_POWER_ENABLE</b> and <b>USB_EVENT_POWER_DISABLE</b> events and enable and disable power to VBUS when requested by the USB library. The application should respond to a power control callback by enabling or disabling VBUS as soon as possible and before returning from the callback function.</p>
<dl class="section note"><dt>Note</dt><dd>The following values should no longer be used with the USB library: <b>USB_HOST_PWRFLT_LOW</b>, <b>USB_HOST_PWRFLT_HIGH</b>, <b>USB_HOST_PWRFLT_EP_NONE</b>, <b>USB_HOST_PWRFLT_EP_TRI</b>, <b>USB_HOST_PWRFLT_EP_LOW</b>, <b>USB_HOST_PWRFLT_EP_HIGH</b>, <b>USB_HOST_PWREN_LOW</b>, <b>USB_HOST_PWREN_HIGH</b>, <b>USB_HOST_PWREN_VBLOW</b>, and <b>USB_HOST_PWREN_VBHIGH</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga489b557c5356dc4a47937952563813db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga489b557c5356dc4a47937952563813db">&sect;&nbsp;</a></span>USBHCDPowerConfigGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPowerConfigGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the power pin and power fault configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will return the current power control pin configuration as set by the <a class="el" href="group__usblib__hcd.html#ga2458bcfaceeac64f35ccbf90421048ac">USBHCDPowerConfigInit()</a> function or the defaults if not yet set. See the <a class="el" href="group__usblib__hcd.html#ga2458bcfaceeac64f35ccbf90421048ac">USBHCDPowerConfigInit()</a> documentation for the meaning of the bits that are returned by this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The configuration of the power control pins. </dd></dl>

<p>Referenced by <a class="el" href="group__dualmode__api.html#gae3248cbfc4251061c4d7bfa613ab3878">USBDualModeInit()</a>.</p>

</div>
</div>
<a id="gab25f089687d2c34ef00d3d2f7f916d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25f089687d2c34ef00d3d2f7f916d53">&sect;&nbsp;</a></span>USBHCDPowerConfigSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPowerConfigSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the power pin and power fault configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>specifies which USB power configuration to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will set the current power control pin configuration as set by the <a class="el" href="group__usblib__hcd.html#ga2458bcfaceeac64f35ccbf90421048ac">USBHCDPowerConfigInit()</a> function or the defaults if not yet set. See the <a class="el" href="group__usblib__hcd.html#ga2458bcfaceeac64f35ccbf90421048ac">USBHCDPowerConfigInit()</a> documentation for the meaning of the bits that are set by this function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns zero to indicate the power setting is now active. </dd></dl>

</div>
</div>
<a id="gaad70e65f97918456bc3a706fb2edd6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad70e65f97918456bc3a706fb2edd6a3">&sect;&nbsp;</a></span>USBHCDPowerAutomatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDPowerAutomatic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns if the current power settings will automatically handle enabling and disabling VBUS power.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns if the current power control pin configuration will automatically apply power or whether it will be left to the application to turn on power when it is notified.</p>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value indicates that power is automatically applied and a value of zero indicates that the application must manually apply power. </dd></dl>

<p>Referenced by <a class="el" href="group__usblib__otg.html#ga3e4b3a14f920e47677d531ecf644699e">USB0_IRQOTGModeHandler()</a>, and <a class="el" href="group__dualmode__api.html#gae3248cbfc4251061c4d7bfa613ab3878">USBDualModeInit()</a>.</p>

</div>
</div>
<a id="ga6b79ac3d9da9ae19736518719bd1a16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b79ac3d9da9ae19736518719bd1a16a">&sect;&nbsp;</a></span>USBHCDInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to initialize the HCD code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">pvPool</td><td>is a pointer to the data to use as a memory pool for this controller. </td></tr>
    <tr><td class="paramname">ui32PoolSize</td><td>is the size in bytes of the buffer passed in as <em>pvPool</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will perform all the necessary operations to allow the USB host controller to begin enumeration and communication with devices. This function should typically be called once at the start of an application once all of the device and class drivers are ready for normal operation. This call will start up the USB host controller and any connected device will immediately start the enumeration sequence.</p>
<p>The <a class="el" href="group__general__usblib__api.html#ga76261a6a917ef4b0b596f91f06cc4c6b">USBStackModeSet()</a> function can be called with eUSBModeHost in order to cause the USB library to force the USB operating mode to a host controller. This allows the application to used the USBVBUS and USBID pins as GPIOs on devices that support forcing OTG to operate as a host only controller. By default the USB library will assume that the USBVBUS and USBID pins are configured as USB pins and not GPIOs.</p>
<p>The memory pool passed to this function must be at least as large as a typical configuration descriptor for devices that are to be supported. This value is application-dependent however it should never be less than 32 bytes and, in most cases, should be at least 64 bytes. If there is not sufficient memory to load a configuration descriptor from a device, the device will not be recognized by the USB library's host controller driver.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628a3bd089f927356e565b6081c989d1c138">eUSBModeDevice</a>, <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad3874ba18e37798ee3cb5c557116a698">eUSBModeForceDevice</a>, <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628add4aadcd7bae9f0af3813000d07f9464">eUSBModeHost</a>, <a class="el" href="group__general__usblib__api.html#gga31e8cc45b2a98ae64491dc055114b628ad9b4c0a8b9afb3e391b0a49189c7cf40">eUSBModeNone</a>, and <a class="el" href="group__usblib__hcd.html#ga0bb842a4e7d8055f5c082ad392aa2ad1">g_iUSBMode</a>.</p>

</div>
</div>
<a id="ga9ded177760ee026d12348de1daacd45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ded177760ee026d12348de1daacd45c">&sect;&nbsp;</a></span>USBHCDRegisterDrivers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDRegisterDrivers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> *const *&#160;</td>
          <td class="paramname"><em>ppsHClassDrvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumDrivers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to initialize the HCD class driver list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ppsHClassDrvs</td><td>is an array of host class drivers that are supported on this controller. </td></tr>
    <tr><td class="paramname">ui32NumDrivers</td><td>is the number of entries in the <em>pHostClassDrivers</em> array.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will set the host classes supported by the host controller specified by the <em>ui32Index</em> parameter. This function should be called before enabling the host controller driver with the <a class="el" href="group__usblib__hcd.html#ga6b79ac3d9da9ae19736518719bd1a16a">USBHCDInit()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gadc8cf0ba9bf4e3f6704f09fc9193d77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc8cf0ba9bf4e3f6704f09fc9193d77e">&sect;&nbsp;</a></span>USBHCDTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDTerm </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to terminate the HCD code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will clean up the USB host controller and disable it in preparation for shutdown or a switch to USB device mode. Once this call is made, <em><a class="el" href="group__usblib__hcd.html#ga6b79ac3d9da9ae19736518719bd1a16a">USBHCDInit()</a></em> may be called to reinitialize the controller and prepare for host mode operation.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga4c33fb00687831f0d46ba9554f25bb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c33fb00687831f0d46ba9554f25bb91">&sect;&nbsp;</a></span>USBHCDReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates reset signaling on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles sending out reset signaling on the USB bus. After returning from this function, any attached device on the USB bus should have returned to it's reset state.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga58b34f432c9d244b01963d9a85357506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b34f432c9d244b01963d9a85357506">&sect;&nbsp;</a></span>USBHCDSuspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDSuspend </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will generate suspend signaling on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to generate suspend signaling on the USB bus. In order to leave the suspended state, the application should call <a class="el" href="group__usblib__hcd.html#ga0485567d29ff1f63e9bbb415b368d552">USBHCDResume()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga0485567d29ff1f63e9bbb415b368d552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0485567d29ff1f63e9bbb415b368d552">&sect;&nbsp;</a></span>USBHCDResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDResume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will generate resume signaling on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to generate resume signaling on the USB bus in order to cause USB devices to leave their suspended state. This call should not be made unless a preceding call to <a class="el" href="group__usblib__hcd.html#ga58b34f432c9d244b01963d9a85357506">USBHCDSuspend()</a> has been made.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga04b96ba9fac1cfe4b2d143ec5e919eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b96ba9fac1cfe4b2d143ec5e919eb0">&sect;&nbsp;</a></span>USBHCDStringDescriptorGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDStringDescriptorGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32LangID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32StringIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function issues a request for a string descriptor from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDevice</td><td>is the device for this request. </td></tr>
    <tr><td class="paramname">pui8Buffer</td><td>is the pointer to the buffer to store the requested string descriptor. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer passed in the buffer that will be used for this request. </td></tr>
    <tr><td class="paramname">ui32LangID</td><td>is the ID of the language for the requested string. </td></tr>
    <tr><td class="paramname">ui32StringIndex</td><td>is the index for the request.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will request a string descriptor from the device of the type specified in the <em>ui32DescriptorType</em> parameter. The <em>pui8Descriptor</em> pointer is the location where the request results will be stored. The <em>ui32Size</em> should be passed in to indicate the size of the <em>pui8Descriptor</em> buffer. The <em>ui32DevAddress</em> parameter is used to specify the device address to communicate with on the USB bus. This value should be specified as 0 for any non-configured device on the USB bus and be changed to the address set by a call to <a class="el" href="group__usblib__hcd.html#gac53e55b293eb19d876df84a5584fd256">USBHCDSetAddress()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes returned in the <em>pui8Buffer</em> due to the request. This value can be zero if the device did not respond. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_host_device.html#a52120d4e50cfae7d4a54bff498f545d6">tUSBHostDevice::sDeviceDescriptor</a>, <a class="el" href="group__usbchap9__src.html#gabde1b2a68da742b490fa1281c80cce39">USB_DTYPE_STRING</a>, <a class="el" href="group__usbchap9__src.html#ga52d2c61ad05fa9c1bf52ab4c340baa80">USB_RTYPE_DEVICE</a>, <a class="el" href="group__usbchap9__src.html#gad60bc6172e46c7fe98139bb1fcc41dd1">USB_RTYPE_DIR_IN</a>, <a class="el" href="group__usbchap9__src.html#ga6f978116659ac9295ed48cb78dd9c3b8">USB_RTYPE_STANDARD</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__usbchap9__src.html#ga9175805ff47cbabd04f8913faa37869a">USBREQ_GET_DESCRIPTOR</a>.</p>

</div>
</div>
<a id="gac53e55b293eb19d876df84a5584fd256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac53e55b293eb19d876df84a5584fd256">&sect;&nbsp;</a></span>USBHCDSetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDSetAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32DevIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32DevAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to send the set address command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32DevIndex</td><td>is the index of the device whose address is to be set. This value must be 0 to indicate that the device is connected directly to the host controller. Higher values indicate devices connected via a hub. </td></tr>
    <tr><td class="paramname">ui32DevAddress</td><td>is the new device address to use for a device.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="group__usblib__hcd.html#gac53e55b293eb19d876df84a5584fd256">USBHCDSetAddress()</a> function is used to set the USB device address, once a device has been discovered on the bus. This call is typically issued following a USB reset triggered by a call the <a class="el" href="group__usblib__hcd.html#ga4c33fb00687831f0d46ba9554f25bb91">USBHCDReset()</a>. The address passed into this function via the <em>ui32DevAddress</em> parameter is used for all further communications with the device after this function returns.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#ga52d2c61ad05fa9c1bf52ab4c340baa80">USB_RTYPE_DEVICE</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga6f978116659ac9295ed48cb78dd9c3b8">USB_RTYPE_STANDARD</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__usbchap9__src.html#ga0d9881487129f5dbb3ef09f02a534cf6">USBREQ_SET_ADDRESS</a>.</p>

</div>
</div>
<a id="ga7c2c3b673456728709390f105502a8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2c3b673456728709390f105502a8e3">&sect;&nbsp;</a></span>USBHCDSetConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDSetConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the current configuration for a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32Device</td><td>is the USB device for this function. </td></tr>
    <tr><td class="paramname">ui32Configuration</td><td>is one of the devices valid configurations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set the current device configuration for a USB device. The <em>ui32Configuration</em> value must be one of the configuration indexes that was returned in the configuration descriptor from the device, or a value of 0. If 0 is passed in, the device will return to it's addressed state and no longer be in a configured state. If the value is non-zero then the device will change to the requested configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usbchap9__src.html#ga52d2c61ad05fa9c1bf52ab4c340baa80">USB_RTYPE_DEVICE</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga6f978116659ac9295ed48cb78dd9c3b8">USB_RTYPE_STANDARD</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__usbchap9__src.html#gadf890a3bf8edfa08fe431d3a16415f22">USBREQ_SET_CONFIG</a>.</p>

</div>
</div>
<a id="ga9b4a9dab92a6d4aed63519b8c57e722d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b4a9dab92a6d4aed63519b8c57e722d">&sect;&nbsp;</a></span>USBHCDSetInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDSetInterface </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32AltSetting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the current interface and alternate setting for an interface on a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use. </td></tr>
    <tr><td class="paramname">ui32Device</td><td>is the USB device for this function. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is one of the valid interface numbers for a device. </td></tr>
    <tr><td class="paramname">ui32AltSetting</td><td>is one of the valid alternate interfaces for the <em>ui32Interface</em> number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to change the alternate setting for one of the valid interfaces on a USB device. The <em>ui32Device</em> specifies the device instance that was returned when the device was connected. This call will set the USB device's interface based on the <em>ui32Interface</em> and <em>ui32AltSetting</em>.</p>
<p><b>Example:</b> Set the USB device interface 2 to alternate setting 1.</p>
<pre class="fragment">//! USBHCDSetInterface(0, ui32Device, 2, 1);
//! </pre> <pre class="fragment">\return None.  </pre> 
<p>References <a class="el" href="structt_u_s_b_host_device.html#ad0e6b0fdc3b8fbc0e5b396e94b4da7ff">tUSBHostDevice::ui32Interface</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usbchap9__src.html#ga6f978116659ac9295ed48cb78dd9c3b8">USB_RTYPE_STANDARD</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__usbchap9__src.html#ga20bf72acf5060aa9371891c8b402b570">USBREQ_SET_INTERFACE</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#gaee0cd88dd6bf6531fb8d3456c858d7b2">USBHostAudioPlay()</a>, and <a class="el" href="group__usblib__host__class.html#ga2551ad61aeb9f64111c9db7fad742c48">USBHostAudioRecord()</a>.</p>

</div>
</div>
<a id="ga7d2f1a37f33e1ded4a4ea6132002ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d2f1a37f33e1ded4a4ea6132002ae84">&sect;&nbsp;</a></span>USBHostCheckPipes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHostCheckPipes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga97d0ae9c014ca65c58c1e625a21e4f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d0ae9c014ca65c58c1e625a21e4f13">&sect;&nbsp;</a></span>USBHostIntHandlerInternal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHostIntHandlerInternal </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga96a648f5969831614c96ecc1ffb9a4f7">USB0_IRQHostHandler()</a>, and <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a>.</p>

</div>
</div>
<a id="ga96a648f5969831614c96ecc1ffb9a4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96a648f5969831614c96ecc1ffb9a4f7">&sect;&nbsp;</a></span>USB0_IRQHostHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB0_IRQHostHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The USB host mode interrupt handler for controller index 0.</p>
<p>This the main USB interrupt handler entry point. This handler will branch the interrupt off to the appropriate handlers depending on the current status of the USB controller. This function must be placed in the interrupt table in order for the USB Library host stack to function.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga97d0ae9c014ca65c58c1e625a21e4f13">USBHostIntHandlerInternal()</a>.</p>

</div>
</div>
<a id="gaf9221b274d44b252f310f30447331ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9221b274d44b252f310f30447331ed1">&sect;&nbsp;</a></span>InternalUSBHCDSendEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InternalUSBHCDSendEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_event_info.html">tEventInfo</a> *&#160;</td>
          <td class="paramname"><em>psEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32EvFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__otg.html#ga3e4b3a14f920e47677d531ecf644699e">USB0_IRQOTGModeHandler()</a>.</p>

</div>
</div>
<a id="gaa34c6f46e6821db0445a6ce1d7fc30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34c6f46e6821db0445a6ce1d7fc30ec">&sect;&nbsp;</a></span>USBHCDMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDMain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the main routine for the Host Controller Driver.</p>
<p>This function is the main routine for the host controller driver, and must be called periodically by the main application outside of a callback context. This allows for a simple cooperative system to access the the host controller driver interface without the need for an RTOS. All time critical operations are handled in interrupt context but all blocking operations are run from the this function to allow them to block and wait for completion without holding off other interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga8b750f4799829a3efe895ccadf41217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b750f4799829a3efe895ccadf41217e">&sect;&nbsp;</a></span>USBHCDControlTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDControlTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tUSBRequest *&#160;</td>
          <td class="paramname"><em>psSetupPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxPacketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function completes a control transaction to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>is the controller index to use for this transfer. </td></tr>
    <tr><td class="paramname">psSetupPacket</td><td>is the setup request to be sent. </td></tr>
    <tr><td class="paramname">psDevice</td><td>is the device instance pointer for this request. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data to send for OUT requests or the receive buffer for IN requests. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in <em>pui8Data</em>. </td></tr>
    <tr><td class="paramname">ui32MaxPacketSize</td><td>is the maximum packet size for the device for this request.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles the state changes necessary to send a control transaction to a device. This function should not be called from within an interrupt callback as it is a blocking function.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes of data that were sent or received as a result of this request. </dd></dl>

<p>Referenced by <a class="el" href="group__usblib__host__class__cdc.html#gabefc0849a1e0c5591e834b28c5fb1eef">USBHCDCGetLineCoding()</a>, <a class="el" href="group__usblib__host__class__cdc.html#ga0cf73f4545da0e5f31fdd7c0fa77adb1">USBHCDCSetControlLineState()</a>, <a class="el" href="group__usblib__host__class__cdc.html#gab2eb315a3653f8d8305ed0e192f7cc27">USBHCDCSetLineCoding()</a>, <a class="el" href="group__usblib__hcd.html#gac53e55b293eb19d876df84a5584fd256">USBHCDSetAddress()</a>, <a class="el" href="group__usblib__hcd.html#ga7c2c3b673456728709390f105502a8e3">USBHCDSetConfig()</a>, <a class="el" href="group__usblib__hcd.html#ga9b4a9dab92a6d4aed63519b8c57e722d">USBHCDSetInterface()</a>, <a class="el" href="group__usblib__hcd.html#ga04b96ba9fac1cfe4b2d143ec5e919eb0">USBHCDStringDescriptorGet()</a>, <a class="el" href="group__usblib__host__class.html#ga60f42ac242c24f0dc097ed999c28951b">USBHHIDGetReportDescriptor()</a>, <a class="el" href="group__usblib__host__class.html#gadde7ecf8d577f1a6c34f4014553708be">USBHHIDSetIdle()</a>, <a class="el" href="group__usblib__host__class.html#gace42556c163b54cf10c1e9086521ff86">USBHHIDSetProtocol()</a>, <a class="el" href="group__usblib__host__class.html#ga95e8d86b812d94d07b2e14591661910c">USBHHIDSetReport()</a>, and <a class="el" href="group__usblib__host__class.html#ga5ecda02fbcb26d6fad0d5d05ed86a9a5">USBHostAudioVolumeSet()</a>.</p>

</div>
</div>
<a id="ga8d343e68187420479928b57ef873dfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d343e68187420479928b57ef873dfd4">&sect;&nbsp;</a></span>USBHCDHubDeviceConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDHubDeviceConnected </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="usbhostenum_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>, and <a class="el" href="usblib_8h.html#a062bf64e497f39bd2e98dc55219b7522">MAX_USB_DEVICES</a>.</p>

</div>
</div>
<a id="gaa178232be85db3e930e2fa92d61d4845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa178232be85db3e930e2fa92d61d4845">&sect;&nbsp;</a></span>USBHCDHubDeviceDisconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDHubDeviceDisconnected </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32DevIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="usbhostenum_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>, and <a class="el" href="usblib_8h.html#a062bf64e497f39bd2e98dc55219b7522">MAX_USB_DEVICES</a>.</p>

</div>
</div>
<a id="ga2903774d85134000dace293b0909854f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2903774d85134000dace293b0909854f">&sect;&nbsp;</a></span>USBHCDDevHubPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHCDDevHubPort </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the USB hub port for the requested device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Instance</td><td>is a unique value indicating which device to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the USB hub port for the device that is associated with the <em>ui32Instance</em> parameter. The caller must use the value for <em>ui32Instance</em> was passed to the application when it receives a <b>USB_EVENT_CONNECTED</b> event. The function returns the USB hub port for the interface number specified by the <em>ui32Interface</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>The USB hub port for the requested interface. </dd></dl>

</div>
</div>
<a id="ga5a4fef3c357299923fa71f261c6b1b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4fef3c357299923fa71f261c6b1b94">&sect;&nbsp;</a></span>USBHCDDevAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHCDDevAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will return the USB address for the requested device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Instance</td><td>is a unique value indicating which device to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the USB address for the device that is associated with the <em>ui32Instance</em> parameter. The caller must use a value for <em>ui32Instance</em> have been passed to the application when it receives a <b>USB_EVENT_CONNECTED</b> event. The function will return the USB address for the interface number specified by the <em>ui32Interface</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>The USB address for the requested interface. </dd></dl>

</div>
</div>
<a id="ga29c7c2c61ba3c968d9b30fa9594d09f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c7c2c61ba3c968d9b30fa9594d09f9">&sect;&nbsp;</a></span>USBHCDDevClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHCDDevClass </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will return the USB class for the requested device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Instance</td><td>is a unique value indicating which device to query. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to query for the USB class.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the USB class for the device that is associated with the <em>ui32Instance</em> parameter. The caller must use a value for <em>ui32Instance</em> have been passed to the application when it receives a <b>USB_EVENT_CONNECTED</b> event. The function will return the USB class for the interface number specified by the <em>ui32Interface</em> parameter. If <em>ui32Interface</em> is set to 0xFFFFFFFF then the function will return the USB class for the first interface that is found in the device's USB descriptors.</p>
<dl class="section return"><dt>Returns</dt><dd>The USB class for the requested interface. </dd></dl>

</div>
</div>
<a id="gaad7801e1a136723975b4e1404f053c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad7801e1a136723975b4e1404f053c83">&sect;&nbsp;</a></span>USBHCDDevSubClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHCDDevSubClass </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will return the USB subclass for the requested device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Instance</td><td>is a unique value indicating which device to query. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to query for the USB subclass.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the USB subclass for the device that is associated with the <em>ui32Instance</em> parameter. The caller must use a value for <em>ui32Instance</em> have been passed to the application when it receives a <b>USB_EVENT_CONNECTED</b> event. The function will return the USB subclass for the interface number specified by the <em>ui32Interface</em> parameter. If <em>ui32Interface</em> is set to 0xFFFFFFFF then the function will return the USB subclass for the first interface that is found in the device's USB descriptors.</p>
<dl class="section return"><dt>Returns</dt><dd>The USB subclass for the requested interface. </dd></dl>

</div>
</div>
<a id="ga8db93f0812e715f08ca65ab862abfb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db93f0812e715f08ca65ab862abfb93">&sect;&nbsp;</a></span>USBHCDDevProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBHCDDevProtocol </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the USB protocol for the requested device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Instance</td><td>is a unique value indicating which device to query. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to query for the USB protocol.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the USB protocol for the device that is associated with the <em>ui32Instance</em> parameter. The caller must use a value for <em>ui32Instance</em> have been passed to the application when it receives a <b>USB_EVENT_CONNECTED</b> event. The function will return the USB protocol for the interface number specified by the <em>ui32Interface</em> parameter. If <em>ui32Interface</em> is set to 0xFFFFFFFF then the function will return the USB protocol for the first interface that is found in the device's USB descriptors.</p>
<dl class="section return"><dt>Returns</dt><dd>The USB protocol for the requested interface. </dd></dl>

</div>
</div>
<a id="ga0e587ab23242d4de2ac5a6052f7afead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e587ab23242d4de2ac5a6052f7afead">&sect;&nbsp;</a></span>USBHCDFeatureSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBHCDFeatureSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvFeature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets one of the <b>USBLIB_FEATURE_</b> requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>is the index of the USB controller to access. </td></tr>
    <tr><td class="paramname">ui32Feature</td><td>is one of the <b>USBLIB_FEATURE_</b> defines. </td></tr>
    <tr><td class="paramname">pvFeature</td><td>is a pointer to the data for the <b>USBLIB_FEATURE</b> request.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends the requested feature request to the USB library. Not all features are supported by all devices so see the documentation for the <b>USBLIB_FEATURE_</b> to determine if the feature is supported.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the feature was set and <b>false</b> if the feature is not supported or could not be changed to the requested value. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#gaf44486a930553c62bcea656ae58e966a">USBLIB_FEATURE_CPUCLK</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__otg.html#gaf1f36b98c3b943b1fe7f28d6155c18ce">USBOTGFeatureSet()</a>.</p>

</div>
</div>
<a id="ga397601992d02bbb4da500c2419036ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397601992d02bbb4da500c2419036ddb">&sect;&nbsp;</a></span>USBHCDLPMStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDLPMStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current status of an LPM request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDevice</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status of LPM requests for a given device. This is called to determine if a previous request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - There are no pending LPM requests on this specific device or the last request completed successfully.</li>
<li><b>USBHCD_LPM_ERROR</b> - The last LPM request for this device did not complete successfully.</li>
<li><b>USBHCD_LPM_PENDING</b> - The last LPM request has not completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structt_u_s_b_host_device.html#a89210de9ba9777c04f9f9bb2ad201f77">tUSBHostDevice::ui32Flags</a>, <a class="el" href="group__usblib__hcd.html#gab2ab8e8094037c34ba548403ccf323c6">USBHCD_LPM_AVAIL</a>, <a class="el" href="group__usblib__hcd.html#ga97320596add061e95cb5b931b3734513">USBHCD_LPM_ERROR</a>, <a class="el" href="group__usblib__hcd.html#ga087cdcec0c54cddcf64aa4e5fa20b355">USBHCD_LPM_PENDING</a>, <a class="el" href="group__usblib__hcd.html#ga1f7469041f29bebded62fdbec4a127a6">USBHDEV_FLAG_LPMERROR</a>, and <a class="el" href="group__usblib__hcd.html#gada4792c60a04722d08aa5bf1eea3b74f">USBHDEV_FLAG_LPMPEND</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga208c5fe377e8d9e93a835d0a6ec7a2cf">USBHHIDLPMStatus()</a>, <a class="el" href="group__usblib__host__class.html#ga2d5d43391f05dcd1cbaa77cc44fb0472">USBHHubLPMStatus()</a>, <a class="el" href="group__usblib__host__class.html#ga6809a58356c09139db0d10df4b1a7277">USBHMSCLPMStatus()</a>, and <a class="el" href="group__usblib__host__class.html#ga5b202c0868d3b00f07aba76abb0b6a2f">USBHostAudioLPMStatus()</a>.</p>

</div>
</div>
<a id="gad58a11d54ef7f4a976bc0a0614dbc64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad58a11d54ef7f4a976bc0a0614dbc64c">&sect;&nbsp;</a></span>USBHCDLPMSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHCDLPMSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_host_device.html">tUSBHostDevice</a> *&#160;</td>
          <td class="paramname"><em>psDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates an LPM request for a device to enter L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDevice</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends a request to a device to enter the LPM L1 sleep state. The caller must check the return value to see if the request can be attempted at this time. If another LPM transaction is busy on another device this function will return <b>USBHCD_LPM_PENDING</b> or <b>USBHCD_LPM_AVAIL</b> if the LPM request was scheduled to be sent. The caller should check the <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a> function to determine if the request has completed.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li>USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.</li>
<li>USBHCD_LPM_PENDING - There is already an LPM request pending. </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga0c436efb2b57e84241f2d6ec2e9719ec">USBHHIDLPMSleep()</a>, <a class="el" href="group__usblib__host__class.html#ga463b791f9b743cd981cbdb487a5fcfe3">USBHHubLPMSleep()</a>, <a class="el" href="group__usblib__host__class.html#gab1462107691a9229ad16397781056b72">USBHMSCLPMSleep()</a>, and <a class="el" href="group__usblib__host__class.html#ga6cc2fb766353fb5ee10230fb27b07dd2">USBHostAudioLPMSleep()</a>.</p>

</div>
</div>
<a id="ga30e82a86e9880f48ba52239da4ae1799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e82a86e9880f48ba52239da4ae1799">&sect;&nbsp;</a></span>USBHCDLPMResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHCDLPMResume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates an LPM request for a device to exit L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>specifies which USB controller to use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will start LPM resume signaling on the USB bus. This wakes all devices and is similar to <a class="el" href="group__usblib__hcd.html#ga0485567d29ff1f63e9bbb415b368d552">USBHCDResume()</a> call but is triggered by an LPM request.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga0bb842a4e7d8055f5c082ad392aa2ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb842a4e7d8055f5c082ad392aa2ad1">&sect;&nbsp;</a></span>g_iUSBMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__general__usblib__api.html#ga31e8cc45b2a98ae64491dc055114b628">tUSBMode</a> g_iUSBMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__general__usblib__api.html#gae0178cee084efca10209dd9a9eaeab1f">USB0DualModeIntHandler()</a>, <a class="el" href="group__usblib__hcd.html#ga6b79ac3d9da9ae19736518719bd1a16a">USBHCDInit()</a>, <a class="el" href="group__usblib__otg.html#gaf0f7d6138d7d6224d813f08d32a19e1b">USBOTGModeInit()</a>, and <a class="el" href="group__general__usblib__api.html#ga76261a6a917ef4b0b596f91f06cc4c6b">USBStackModeSet()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
