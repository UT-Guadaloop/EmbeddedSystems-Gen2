<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>USBLibAPIGuide: Bulk_device_class_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">USBLibAPIGuide
   &#160;<span id="projectnumber">1.00.00.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Bulk_device_class_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_bulk_instance.html">tBulkInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_d_bulk_device.html">tUSBDBulkDevice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga35a55f7b5c93f8d24361739c1977a1ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga35a55f7b5c93f8d24361739c1977a1ec">USB_RX_ERROR_FLAGS</a></td></tr>
<tr class="separator:ga35a55f7b5c93f8d24361739c1977a1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b1d71e1a8ddffa8966136aa50e536f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga91b1d71e1a8ddffa8966136aa50e536f">BULK_DO_PACKET_RX</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ga91b1d71e1a8ddffa8966136aa50e536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d98cf260b6f07e93099abff0f48d80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga54d98cf260b6f07e93099abff0f48d80">DATA_IN_ENDPOINT</a>&#160;&#160;&#160;USB_EP_1</td></tr>
<tr class="separator:ga54d98cf260b6f07e93099abff0f48d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2a09756efeaf9c110658eee80183fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga8c2a09756efeaf9c110658eee80183fb">DATA_OUT_ENDPOINT</a>&#160;&#160;&#160;USB_EP_1</td></tr>
<tr class="separator:ga8c2a09756efeaf9c110658eee80183fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bce80377cfacdd4d82d2b9942b2b0f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga9bce80377cfacdd4d82d2b9942b2b0f2">DATA_IN_EP_MAX_SIZE</a>&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_64)</td></tr>
<tr class="separator:ga9bce80377cfacdd4d82d2b9942b2b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3013e5d58eaa9d3509753b50397db95d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga3013e5d58eaa9d3509753b50397db95d">DATA_OUT_EP_MAX_SIZE</a>&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_64)</td></tr>
<tr class="separator:ga3013e5d58eaa9d3509753b50397db95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b6b01a3e45837df7647ac898308c08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga49b6b01a3e45837df7647ac898308c08">DATA_IN_EP_MAX_SIZE_HS</a>&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_512)</td></tr>
<tr class="separator:ga49b6b01a3e45837df7647ac898308c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd88fdb3b458efbed13a69ce341cbf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga6bd88fdb3b458efbed13a69ce341cbf1">DATA_OUT_EP_MAX_SIZE_HS</a>&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_512)</td></tr>
<tr class="separator:ga6bd88fdb3b458efbed13a69ce341cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc023ea13673c19fc981aace97412c83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gafc023ea13673c19fc981aace97412c83">NUM_BULK_SECTIONS</a></td></tr>
<tr class="separator:gafc023ea13673c19fc981aace97412c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad513d1d93c7e05d14b3a85ba33651794"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>&#160;&#160;&#160;(23)</td></tr>
<tr class="separator:gad513d1d93c7e05d14b3a85ba33651794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacd99874f5c5557d31ca72570226440"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gaaacd99874f5c5557d31ca72570226440">COMPOSITE_DBULK_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>)</td></tr>
<tr class="separator:gaaacd99874f5c5557d31ca72570226440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2d5284020a6e0328426be1094feda97b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga2d5284020a6e0328426be1094feda97b">tBulkState</a> { <a class="el" href="group__bulk__device__class__api.html#gga2d5284020a6e0328426be1094feda97ba8bff53502b23f78ed0ce553fe49b09c7">eBulkStateUnconfigured</a>, 
<a class="el" href="group__bulk__device__class__api.html#gga2d5284020a6e0328426be1094feda97bac9fc66bc126c1b29e60f72f8af101962">eBulkStateIdle</a>, 
<a class="el" href="group__bulk__device__class__api.html#gga2d5284020a6e0328426be1094feda97ba59f8005b3c8c38baf537d7a4625eacc5">eBulkStateWaitData</a>, 
<a class="el" href="group__bulk__device__class__api.html#gga2d5284020a6e0328426be1094feda97baf7352ad0c13bb1818386c70ab3af5f84">eBulkStateWaitClient</a>
 }</td></tr>
<tr class="separator:ga2d5284020a6e0328426be1094feda97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga862414b1691f275926103bc9d4b7772f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit</a> (uint32_t ui32Index, <a class="el" href="structt_u_s_b_d_bulk_device.html">tUSBDBulkDevice</a> *psBulkDevice)</td></tr>
<tr class="separator:ga862414b1691f275926103bc9d4b7772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e8c2af0b58232dccbff5dc2731e928"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga55e8c2af0b58232dccbff5dc2731e928">USBDBulkCompositeInit</a> (uint32_t ui32Index, <a class="el" href="structt_u_s_b_d_bulk_device.html">tUSBDBulkDevice</a> *psBulkDevice, <a class="el" href="structt_composite_entry.html">tCompositeEntry</a> *psCompEntry)</td></tr>
<tr class="separator:ga55e8c2af0b58232dccbff5dc2731e928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf659eaa605fefce5e90ce90fcc840ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gacf659eaa605fefce5e90ce90fcc840ea">USBDBulkTerm</a> (void *pvBulkDevice)</td></tr>
<tr class="separator:gacf659eaa605fefce5e90ce90fcc840ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacced7fce026501e738f800ae1211957b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gacced7fce026501e738f800ae1211957b">USBDBulkSetRxCBData</a> (void *pvBulkDevice, void *pvCBData)</td></tr>
<tr class="separator:gacced7fce026501e738f800ae1211957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd7d0815d61b61ecca3e976668bba8d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga9bd7d0815d61b61ecca3e976668bba8d">USBDBulkSetTxCBData</a> (void *pvBulkDevice, void *pvCBData)</td></tr>
<tr class="separator:ga9bd7d0815d61b61ecca3e976668bba8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga626671973e1e885b5b4acba8cdda0e19"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga626671973e1e885b5b4acba8cdda0e19">USBDBulkPacketWrite</a> (void *pvBulkDevice, uint8_t *pi8Data, uint32_t ui32Length, bool bLast)</td></tr>
<tr class="separator:ga626671973e1e885b5b4acba8cdda0e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1484b7bcca7ae815eba04635d4eea802"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga1484b7bcca7ae815eba04635d4eea802">USBDBulkPacketRead</a> (void *pvBulkDevice, uint8_t *pi8Data, uint32_t ui32Length, bool bLast)</td></tr>
<tr class="separator:ga1484b7bcca7ae815eba04635d4eea802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7c7106abd4d76ca446fc7dab14c5e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gabc7c7106abd4d76ca446fc7dab14c5e6">USBDBulkTxPacketAvailable</a> (void *pvBulkDevice)</td></tr>
<tr class="separator:gabc7c7106abd4d76ca446fc7dab14c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a9228bf5efcfc7879d3e6b90a143e9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gaf7a9228bf5efcfc7879d3e6b90a143e9">USBDBulkRxPacketAvailable</a> (void *pvBulkDevice)</td></tr>
<tr class="separator:gaf7a9228bf5efcfc7879d3e6b90a143e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f18ed619c2fc108a861c37952ab34c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gad1f18ed619c2fc108a861c37952ab34c">USBDBulkPowerStatusSet</a> (void *pvBulkDevice, uint8_t ui8Power)</td></tr>
<tr class="separator:gad1f18ed619c2fc108a861c37952ab34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391c2c89613cc63dd8479607911044fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga391c2c89613cc63dd8479607911044fb">USBDBulkRemoteWakeupRequest</a> (void *pvBulkDevice)</td></tr>
<tr class="separator:ga391c2c89613cc63dd8479607911044fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0b2f65c2a2ff2dccdc14014775b5ef48"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga0b2f65c2a2ff2dccdc14014775b5ef48">g_pui8BulkDeviceDescriptor</a> []</td></tr>
<tr class="separator:ga0b2f65c2a2ff2dccdc14014775b5ef48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fce7c0e61c485c2a382d403dacb655"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gae3fce7c0e61c485c2a382d403dacb655">g_pui8BulkDescriptor</a> []</td></tr>
<tr class="separator:gae3fce7c0e61c485c2a382d403dacb655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433317e5e4c6afee8d06b01946bb5cc6"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga433317e5e4c6afee8d06b01946bb5cc6">g_pui8BulkInterface</a> [<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>]</td></tr>
<tr class="separator:ga433317e5e4c6afee8d06b01946bb5cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807b71c9aad4464cf34fb15ba8a26bc3"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga807b71c9aad4464cf34fb15ba8a26bc3">g_pui8BulkInterfaceHS</a> [<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>]</td></tr>
<tr class="separator:ga807b71c9aad4464cf34fb15ba8a26bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad600b1227572563250b89b640da90214"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_section.html">tConfigSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gad600b1227572563250b89b640da90214">g_sBulkConfigSection</a></td></tr>
<tr class="separator:gad600b1227572563250b89b640da90214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022064693f1faa3e7ebc1c50d45a7810"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_section.html">tConfigSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga022064693f1faa3e7ebc1c50d45a7810">g_sBulkInterfaceSection</a></td></tr>
<tr class="separator:ga022064693f1faa3e7ebc1c50d45a7810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f218f30a53c75424525f594754df89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_section.html">tConfigSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga80f218f30a53c75424525f594754df89">g_sBulkInterfaceSectionHS</a></td></tr>
<tr class="separator:ga80f218f30a53c75424525f594754df89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4dd55577889f3ffd323333afd64154a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_section.html">tConfigSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a> []</td></tr>
<tr class="separator:gad4dd55577889f3ffd323333afd64154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada27c860ff4cd5c61352f326371e021b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_section.html">tConfigSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gada27c860ff4cd5c61352f326371e021b">g_psBulkSectionsHS</a> []</td></tr>
<tr class="separator:gada27c860ff4cd5c61352f326371e021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40af3cfe88c284ae374eabc7839bd4d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_header.html">tConfigHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga40af3cfe88c284ae374eabc7839bd4d5">g_sBulkConfigHeader</a></td></tr>
<tr class="separator:ga40af3cfe88c284ae374eabc7839bd4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaecec1719e14e4bcc13e5f62c7e9c36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_header.html">tConfigHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gaaaecec1719e14e4bcc13e5f62c7e9c36">g_sBulkConfigHeaderHS</a></td></tr>
<tr class="separator:gaaaecec1719e14e4bcc13e5f62c7e9c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac086a0d3342c613e40792529c1d9d6e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_header.html">tConfigHeader</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#gac086a0d3342c613e40792529c1d9d6e3">g_ppBulkConfigDescriptors</a> []</td></tr>
<tr class="separator:gac086a0d3342c613e40792529c1d9d6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8509a01e1851dfa8a8d7ffee94d972a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_config_header.html">tConfigHeader</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga8509a01e1851dfa8a8d7ffee94d972a3">g_ppBulkConfigDescriptorsHS</a> []</td></tr>
<tr class="separator:ga8509a01e1851dfa8a8d7ffee94d972a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488b91aba1a8cb9b9a6d0e7430b2b9cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_custom_handlers.html">tCustomHandlers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bulk__device__class__api.html#ga488b91aba1a8cb9b9a6d0e7430b2b9cc">g_sBulkHandlers</a></td></tr>
<tr class="separator:ga488b91aba1a8cb9b9a6d0e7430b2b9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga35a55f7b5c93f8d24361739c1977a1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a55f7b5c93f8d24361739c1977a1ec">&sect;&nbsp;</a></span>USB_RX_ERROR_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_RX_ERROR_FLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__general__usblib__api.html#ga6aa9777292630d6830ad42338b9821e7">USBERR_DEV_RX_DATA_ERROR</a> |                   \</div><div class="line">                                 USBERR_DEV_RX_OVERRUN |                      \</div><div class="line">                                 USBERR_DEV_RX_FIFO_FULL)</div><div class="ttc" id="group__general__usblib__api_html_ga6aa9777292630d6830ad42338b9821e7"><div class="ttname"><a href="group__general__usblib__api.html#ga6aa9777292630d6830ad42338b9821e7">USBERR_DEV_RX_DATA_ERROR</a></div><div class="ttdeci">#define USBERR_DEV_RX_DATA_ERROR</div><div class="ttdoc">The device detected a CRC error in received data. </div><div class="ttdef"><b>Definition:</b> usblib.h:1303</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga91b1d71e1a8ddffa8966136aa50e536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b1d71e1a8ddffa8966136aa50e536f">&sect;&nbsp;</a></span>BULK_DO_PACKET_RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BULK_DO_PACKET_RX&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga54d98cf260b6f07e93099abff0f48d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54d98cf260b6f07e93099abff0f48d80">&sect;&nbsp;</a></span>DATA_IN_ENDPOINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_IN_ENDPOINT&#160;&#160;&#160;USB_EP_1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8c2a09756efeaf9c110658eee80183fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2a09756efeaf9c110658eee80183fb">&sect;&nbsp;</a></span>DATA_OUT_ENDPOINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_OUT_ENDPOINT&#160;&#160;&#160;USB_EP_1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9bce80377cfacdd4d82d2b9942b2b0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bce80377cfacdd4d82d2b9942b2b0f2">&sect;&nbsp;</a></span>DATA_IN_EP_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_IN_EP_MAX_SIZE&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_64)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3013e5d58eaa9d3509753b50397db95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3013e5d58eaa9d3509753b50397db95d">&sect;&nbsp;</a></span>DATA_OUT_EP_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_OUT_EP_MAX_SIZE&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_64)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga49b6b01a3e45837df7647ac898308c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49b6b01a3e45837df7647ac898308c08">&sect;&nbsp;</a></span>DATA_IN_EP_MAX_SIZE_HS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_IN_EP_MAX_SIZE_HS&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_512)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6bd88fdb3b458efbed13a69ce341cbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bd88fdb3b458efbed13a69ce341cbf1">&sect;&nbsp;</a></span>DATA_OUT_EP_MAX_SIZE_HS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_OUT_EP_MAX_SIZE_HS&#160;&#160;&#160;USBFIFOSizeToBytes(USB_FIFO_SZ_512)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafc023ea13673c19fc981aace97412c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc023ea13673c19fc981aace97412c83">&sect;&nbsp;</a></span>NUM_BULK_SECTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_BULK_SECTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<span class="keyword">sizeof</span>(<a class="code" href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a>) /                   \</div><div class="line">                                 <span class="keyword">sizeof</span>(<a class="code" href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a>[0]))</div><div class="ttc" id="group__bulk__device__class__api_html_gad4dd55577889f3ffd323333afd64154a"><div class="ttname"><a href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a></div><div class="ttdeci">const tConfigSection * g_psBulkSections[]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:254</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad513d1d93c7e05d14b3a85ba33651794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad513d1d93c7e05d14b3a85ba33651794">&sect;&nbsp;</a></span>BULKINTERFACE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BULKINTERFACE_SIZE&#160;&#160;&#160;(23)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaacd99874f5c5557d31ca72570226440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacd99874f5c5557d31ca72570226440">&sect;&nbsp;</a></span>COMPOSITE_DBULK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPOSITE_DBULK_SIZE&#160;&#160;&#160;(<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of the memory that should be allocated to create a configuration descriptor for a single instance of the USB Bulk Device. This does not include the configuration descriptor which is automatically ignored by the composite device class. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2d5284020a6e0328426be1094feda97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d5284020a6e0328426be1094feda97b">&sect;&nbsp;</a></span>tBulkState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__bulk__device__class__api.html#ga2d5284020a6e0328426be1094feda97b">tBulkState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2d5284020a6e0328426be1094feda97ba8bff53502b23f78ed0ce553fe49b09c7"></a>eBulkStateUnconfigured&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2d5284020a6e0328426be1094feda97bac9fc66bc126c1b29e60f72f8af101962"></a>eBulkStateIdle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2d5284020a6e0328426be1094feda97ba59f8005b3c8c38baf537d7a4625eacc5"></a>eBulkStateWaitData&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2d5284020a6e0328426be1094feda97baf7352ad0c13bb1818386c70ab3af5f84"></a>eBulkStateWaitClient&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga862414b1691f275926103bc9d4b7772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862414b1691f275926103bc9d4b7772f">&sect;&nbsp;</a></span>USBDBulkInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * USBDBulkInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_d_bulk_device.html">tUSBDBulkDevice</a> *&#160;</td>
          <td class="paramname"><em>psBulkDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes bulk device operation for a given USB controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>is the index of the USB controller which is to be initialized for bulk device operation. </td></tr>
    <tr><td class="paramname">psBulkDevice</td><td>points to a structure containing parameters customizing the operation of the bulk device.</td></tr>
  </table>
  </dd>
</dl>
<p>An application wishing to make use of a USB bulk communication channel must call this function to initialize the USB controller and attach the device to the USB bus. This function performs all required USB initialization.</p>
<p>On successful completion, this function will return the <em>psBulkDevice</em> pointer passed to it. This must be passed on all future calls to the device driver related to this device.</p>
<p>The USBDBulk interface offers packet-based transmit and receive operation. If the application would rather use block based communication with transmit and receive buffers, USB buffers may be used above the bulk transmit and receive channels to offer this functionality.</p>
<p>Transmit Operation:</p>
<p>Calls to <a class="el" href="group__bulk__device__class__api.html#ga626671973e1e885b5b4acba8cdda0e19">USBDBulkPacketWrite()</a> must send no more than 64 bytes of data for FS USB and 512 bytes for HS USB at a time and may only be made when no other transmission is currently outstanding.</p>
<p>Once a packet of data has been acknowledged by the USB host, a <b>USB_EVENT_TX_COMPLETE</b> event is sent to the application callback to inform it that another packet may be transmitted.</p>
<p>Receive Operation:</p>
<p>An incoming USB data packet will result in a call to the application callback with event <b>USBD_EVENT_RX_AVAILABLE</b>. The application must then call <a class="el" href="group__bulk__device__class__api.html#ga1484b7bcca7ae815eba04635d4eea802">USBDBulkPacketRead()</a>, passing a buffer capable of holding 64 bytes for FS USB and 512 bytes for HS USB, to retrieve the data and acknowledge reception to the USB host.</p>
<dl class="section note"><dt>Note</dt><dd>The application must not make any calls to the low level USB Device API if interacting with USB via the USB bulk device class API. Doing so will cause unpredictable (though almost certainly unpleasant) behavior.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL on failure or void pointer that should be used with the remaining USB bulk class APSs. </dd></dl>

<p>References <a class="el" href="group__bulk__device__class__api.html#gae3fce7c0e61c485c2a382d403dacb655">g_pui8BulkDescriptor</a>, <a class="el" href="group__bulk__device__class__api.html#ga0b2f65c2a2ff2dccdc14014775b5ef48">g_pui8BulkDeviceDescriptor</a>, <a class="el" href="structt_bulk_instance.html#a521ef2b1ce40b407848d6f7d087cc58f">tBulkInstance::sDevInfo</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#a5ffcc5f1b6c9a19aa1807dfc8eebb148">tUSBDBulkDevice::sPrivateData</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#a0a57eb0e7c158869f4418d976f86b857">tUSBDBulkDevice::ui16MaxPowermA</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#adad09e8f00469ccc1b95ec592dddd047">tUSBDBulkDevice::ui16PID</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#a25a1c3b6c3933efbf7694b1202ffa0e7">tUSBDBulkDevice::ui16VID</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#a57362542474483f463070dbb4585ffdc">tUSBDBulkDevice::ui8PwrAttributes</a>, <a class="el" href="group__bulk__device__class__api.html#ga55e8c2af0b58232dccbff5dc2731e928">USBDBulkCompositeInit()</a>, and <a class="el" href="group__device__api.html#ga4bcf6daf0452a45fa33f6159a7bb8e83">USBDCDInit()</a>.</p>

</div>
</div>
<a id="ga55e8c2af0b58232dccbff5dc2731e928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55e8c2af0b58232dccbff5dc2731e928">&sect;&nbsp;</a></span>USBDBulkCompositeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * USBDBulkCompositeInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_d_bulk_device.html">tUSBDBulkDevice</a> *&#160;</td>
          <td class="paramname"><em>psBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_composite_entry.html">tCompositeEntry</a> *&#160;</td>
          <td class="paramname"><em>psCompEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes bulk device operation for a given USB controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>is the index of the USB controller which is to be initialized for bulk device operation. </td></tr>
    <tr><td class="paramname">psBulkDevice</td><td>points to a structure containing parameters customizing the operation of the bulk device. </td></tr>
    <tr><td class="paramname">psCompEntry</td><td>is the composite device entry to initialize when creating a composite device.</td></tr>
  </table>
  </dd>
</dl>
<p>This call is very similar to <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a> except that it is used for initializing an instance of the bulk device for use in a composite device. When this bulk device is part of a composite device, then the <em>psCompEntry</em> should point to the composite device entry to initialize. This is part of the array that is passed to the <a class="el" href="group__composite__device__class__api.html#gab8fdf472494a5f95efddf0453c93138e">USBDCompositeInit()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns zero on failure or a non-zero value that should be used with the remaining USB Bulk APIs. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_d_bulk_device.html#a0e6bc3346b6338551a5d3ecad4e24a05">tUSBDBulkDevice::pfnRxCallback</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#ac1f548c9bd5b975bdeac75acf0ddeac1">tUSBDBulkDevice::pfnTxCallback</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#ad7e4f6190a07f59ca61cc9462b4184dc">tUSBDBulkDevice::ppui8StringDescriptors</a>, <a class="el" href="structt_composite_entry.html#a755f26f4219d9b6b41b17707cdb48238">tCompositeEntry::psDevInfo</a>, <a class="el" href="structt_composite_entry.html#a246379c5fcea48599eb512613ff91fa0">tCompositeEntry::pvInstance</a>, <a class="el" href="structt_bulk_instance.html#a521ef2b1ce40b407848d6f7d087cc58f">tBulkInstance::sDevInfo</a>, <a class="el" href="structt_u_s_b_d_bulk_device.html#a5ffcc5f1b6c9a19aa1807dfc8eebb148">tUSBDBulkDevice::sPrivateData</a>, <a class="el" href="group__device__api.html#ga9f2b669ae791b0b392777c22bde7ba22">USBDCDFeatureGet()</a>, and <a class="el" href="group__usblib__buffer__api.html#ga223a3144b79014ba24b7d2d79c50c824">USBLIB_FEATURE_USBULPI</a>.</p>

<p>Referenced by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</p>

</div>
</div>
<a id="gacf659eaa605fefce5e90ce90fcc840ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf659eaa605fefce5e90ce90fcc840ea">&sect;&nbsp;</a></span>USBDBulkTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDBulkTerm </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shut down the bulk device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function terminates device operation for the instance supplied and removes the device from the USB bus. This function should not be called if the bulk device is part of a composite device and instead the <a class="el" href="group__composite__device__class__api.html#ga4d2cce5989a336e0ec8acf0b4a7bf4f5">USBDCompositeTerm()</a> function should be called for the full composite device.</p>
<p>Following this call, the <em>pvBulkDevice</em> instance should not me used in any other calls.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_bulk_instance.html#a87274ea3b14eb36d717ad713397fd961">tBulkInstance::ui32USBBase</a>, <a class="el" href="group__usblib__dma__api.html#ga81cc4a7ba34a796284794cb3d48d0275">USBBaseToIndex</a>, and <a class="el" href="group__device__api.html#ga9f57ce4fb4d92257c2573fc9d29b7b5a">USBDCDTerm()</a>.</p>

</div>
</div>
<a id="gacced7fce026501e738f800ae1211957b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacced7fce026501e738f800ae1211957b">&sect;&nbsp;</a></span>USBDBulkSetRxCBData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * USBDBulkSetRxCBData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCBData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the client-specific pointer parameter for the receive channel callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>. </td></tr>
    <tr><td class="paramname">pvCBData</td><td>is the pointer that client wishes to be provided on each event sent to the receive channel callback function.</td></tr>
  </table>
  </dd>
</dl>
<p>The client uses this function to change the callback pointer passed in the first parameter on all callbacks to the <em>pfnRxCallback</em> function passed on <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</p>
<p>If a client wants to make runtime changes in the callback pointer, it must ensure that the <em>pvBulkDevice</em> structure passed to <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a> resides in RAM. If this structure is in flash, callback pointer changes are not possible.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the previous callback pointer that was being used for this instance's receive callback. </dd></dl>

</div>
</div>
<a id="ga9bd7d0815d61b61ecca3e976668bba8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd7d0815d61b61ecca3e976668bba8d">&sect;&nbsp;</a></span>USBDBulkSetTxCBData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * USBDBulkSetTxCBData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCBData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the client-specific pointer parameter for the transmit callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>. </td></tr>
    <tr><td class="paramname">pvCBData</td><td>is the pointer that client wishes to be provided on each event sent to the transmit channel callback function.</td></tr>
  </table>
  </dd>
</dl>
<p>The client uses this function to change the callback pointer passed in the first parameter on all callbacks to the <em>pfnTxCallback</em> function passed on <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</p>
<p>If a client wants to make runtime changes in the callback pointer, it must ensure that the <em>pvBulkDevice</em> structure passed to <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a> resides in RAM. If this structure is in flash, callback pointer changes are not possible.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the previous callback pointer that was being used for this instance's transmit callback. </dd></dl>

</div>
</div>
<a id="ga626671973e1e885b5b4acba8cdda0e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga626671973e1e885b5b4acba8cdda0e19">&sect;&nbsp;</a></span>USBDBulkPacketWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDBulkPacketWrite </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pi8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits a packet of data to the USB host via the bulk data interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>. </td></tr>
    <tr><td class="paramname">pi8Data</td><td>points to the first byte of data which is to be transmitted. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes of data to transmit. </td></tr>
    <tr><td class="paramname">bLast</td><td>indicates whether more data is to be written before a packet should be scheduled for transmission. If <b>true</b>, the client will make a further call to this function. If <b>false</b>, no further call will be made and the driver should schedule transmission of a short packet.</td></tr>
  </table>
  </dd>
</dl>
<p>This function schedules the supplied data for transmission to the USB host in a single USB packet. If no transmission is currently ongoing, the data is immediately copied to the relevant USB endpoint FIFO for transmission. Whenever a USB packet is acknowledged by the host, a <b>USB_EVENT_TX_COMPLETE</b> event will be sent to the transmit channel callback indicating that more data can now be transmitted.</p>
<p>The maximum value for <em>ui32Length</em> is 64 bytes (the maximum USB packet size for the bulk endpoints in use by the device). Attempts to send more data than this will result in a return code of 0 indicating that the data cannot be sent.</p>
<p>The <em>bLast</em> parameter allows a client to make multiple calls to this function before scheduling transmission of the packet to the host. This can be helpful if, for example, constructing a packet on the fly or writing a packet which spans the wrap point in a ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually sent. At this level, this will either be the number of bytes passed (if less than or equal to the maximum packet size for the USB endpoint in use and no outstanding transmission ongoing) or 0 to indicate a failure. </dd></dl>

</div>
</div>
<a id="ga1484b7bcca7ae815eba04635d4eea802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1484b7bcca7ae815eba04635d4eea802">&sect;&nbsp;</a></span>USBDBulkPacketRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDBulkPacketRead </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pi8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a packet of data received from the USB host via the bulk data interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>. </td></tr>
    <tr><td class="paramname">pi8Data</td><td>points to a buffer into which the received data will be written. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the size of the buffer pointed to by pi8Data. </td></tr>
    <tr><td class="paramname">bLast</td><td>indicates whether the client will make a further call to read additional data from the packet.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads up to <em>ui32Length</em> bytes of data received from the USB host into the supplied application buffer. If the driver detects that the entire packet has been read, it is acknowledged to the host.</p>
<p>The <em>bLast</em> parameter is ignored in this implementation since the end of a packet can be determined without relying upon the client to provide this information.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes of data read. </dd></dl>

<p>References <a class="el" href="structt_bulk_instance.html#a87274ea3b14eb36d717ad713397fd961">tBulkInstance::ui32USBBase</a>, and <a class="el" href="structt_bulk_instance.html#a4bf48aa00aeeeebefdcb222ff90fa5c1">tBulkInstance::ui8OUTEndpoint</a>.</p>

</div>
</div>
<a id="gabc7c7106abd4d76ca446fc7dab14c5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7c7106abd4d76ca446fc7dab14c5e6">&sect;&nbsp;</a></span>USBDBulkTxPacketAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDBulkTxPacketAvailable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of free bytes in the transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the maximum number of bytes that can be passed on a call to <a class="el" href="group__bulk__device__class__api.html#ga626671973e1e885b5b4acba8cdda0e19">USBDBulkPacketWrite()</a> and accepted for transmission. The value returned will be the maximum USB packet size (64) if no transmission is currently outstanding or 0 if a transmission is in progress.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes available in the transmit buffer. </dd></dl>

<p>References <a class="el" href="group__bulk__device__class__api.html#gga2d5284020a6e0328426be1094feda97bac9fc66bc126c1b29e60f72f8af101962">eBulkStateIdle</a>, and <a class="el" href="structt_bulk_instance.html#a76e0daa8e5c89751dafd2a9dfd56ba77">tBulkInstance::iBulkTxState</a>.</p>

</div>
</div>
<a id="gaf7a9228bf5efcfc7879d3e6b90a143e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a9228bf5efcfc7879d3e6b90a143e9">&sect;&nbsp;</a></span>USBDBulkRxPacketAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBDBulkRxPacketAvailable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a packet is available and, if so, the size of the buffer required to read it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the device instance structure as returned by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function may be used to determine if a received packet remains to be read and allows the application to determine the buffer size needed to read the data.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if no received packet remains unprocessed or the size of the packet if a packet is waiting to be read. </dd></dl>

<p>References <a class="el" href="structt_bulk_instance.html#a87274ea3b14eb36d717ad713397fd961">tBulkInstance::ui32USBBase</a>, and <a class="el" href="structt_bulk_instance.html#a4bf48aa00aeeeebefdcb222ff90fa5c1">tBulkInstance::ui8OUTEndpoint</a>.</p>

</div>
</div>
<a id="gad1f18ed619c2fc108a861c37952ab34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f18ed619c2fc108a861c37952ab34c">&sect;&nbsp;</a></span>USBDBulkPowerStatusSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDBulkPowerStatusSet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports the device power status (bus- or self-powered) to the USB library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the bulk device instance structure. </td></tr>
    <tr><td class="paramname">ui8Power</td><td>indicates the current power status, either <b>USB_STATUS_SELF_PWR</b> or <b>USB_STATUS_BUS_PWR</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>Applications which support switching between bus- or self-powered operation should call this function whenever the power source changes to indicate the current power status to the USB library. This information is required by the USB library to allow correct responses to be provided when the host requests status from the device.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__device__api.html#ga1053c140a50c7420fb517c564b2aee4b">USBDCDPowerStatusSet()</a>.</p>

</div>
</div>
<a id="ga391c2c89613cc63dd8479607911044fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391c2c89613cc63dd8479607911044fb">&sect;&nbsp;</a></span>USBDBulkRemoteWakeupRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBDBulkRemoteWakeupRequest </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBulkDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests a remote wake up to resume communication when in suspended state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvBulkDevice</td><td>is the pointer to the bulk device instance structure.</td></tr>
  </table>
  </dd>
</dl>
<p>When the bus is suspended, an application which supports remote wake up (advertised to the host via the configuration descriptor) may call this function to initiate remote wake up signaling to the host. If the remote wake up feature has not been disabled by the host, this will cause the bus to resume operation within 20mS. If the host has disabled remote wake up, <b>false</b> will be returned to indicate that the wake up request was not successful.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the remote wake up is not disabled and the signaling was started or <b>false</b> if remote wake up is disabled or if signaling is currently ongoing following a previous call to this function. </dd></dl>

<p>References <a class="el" href="group__device__api.html#ga3f7f86a21de551f6f8e535a3e017eb81">USBDCDRemoteWakeupRequest()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga0b2f65c2a2ff2dccdc14014775b5ef48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2f65c2a2ff2dccdc14014775b5ef48">&sect;&nbsp;</a></span>g_pui8BulkDeviceDescriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t g_pui8BulkDeviceDescriptor[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    18,                         </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga76eb46fb8a7219b6c824036f56b94a94">USB_DTYPE_DEVICE</a>,           </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a>(0x110),            </div><div class="line">                                </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga786ede10a801d8134ee4752591b03aa9">USB_CLASS_VEND_SPECIFIC</a>,    </div><div class="line">    0,                          </div><div class="line">    0,                          </div><div class="line">    64,                         </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a>(0),                </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a>(0),                </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a>(0x100),            </div><div class="line">    1,                          </div><div class="line">    2,                          </div><div class="line">    3,                          </div><div class="line">    1                           </div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_ga2793064eda4625b486c3db5befca35e3"><div class="ttname"><a href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a></div><div class="ttdeci">#define USBShort(ui16Value)</div><div class="ttdef"><b>Definition:</b> usblib.h:834</div></div>
<div class="ttc" id="group__usbchap9__src_html_ga786ede10a801d8134ee4752591b03aa9"><div class="ttname"><a href="group__usbchap9__src.html#ga786ede10a801d8134ee4752591b03aa9">USB_CLASS_VEND_SPECIFIC</a></div><div class="ttdeci">#define USB_CLASS_VEND_SPECIFIC</div><div class="ttdef"><b>Definition:</b> usblib.h:437</div></div>
<div class="ttc" id="group__usbchap9__src_html_ga76eb46fb8a7219b6c824036f56b94a94"><div class="ttname"><a href="group__usbchap9__src.html#ga76eb46fb8a7219b6c824036f56b94a94">USB_DTYPE_DEVICE</a></div><div class="ttdeci">#define USB_DTYPE_DEVICE</div><div class="ttdef"><b>Definition:</b> usblib.h:280</div></div>
</div><!-- fragment -->
<p>Referenced by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</p>

</div>
</div>
<a id="gae3fce7c0e61c485c2a382d403dacb655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fce7c0e61c485c2a382d403dacb655">&sect;&nbsp;</a></span>g_pui8BulkDescriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t g_pui8BulkDescriptor[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    9,                          </div><div class="line">    <a class="code" href="group__usbchap9__src.html#gad2d9345dbf8bb1ed7f49c7856d5d1ef8">USB_DTYPE_CONFIGURATION</a>,    </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a>(32),               </div><div class="line">    1,                          </div><div class="line">                                </div><div class="line">    1,                          </div><div class="line">    5,                          </div><div class="line">                                </div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga8878fe0d6aff0b1c70cd2b15df5a41f6">USB_CONF_ATTR_SELF_PWR</a>,     </div><div class="line">    250,                        </div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_gad2d9345dbf8bb1ed7f49c7856d5d1ef8"><div class="ttname"><a href="group__usbchap9__src.html#gad2d9345dbf8bb1ed7f49c7856d5d1ef8">USB_DTYPE_CONFIGURATION</a></div><div class="ttdeci">#define USB_DTYPE_CONFIGURATION</div><div class="ttdef"><b>Definition:</b> usblib.h:281</div></div>
<div class="ttc" id="group__usbchap9__src_html_ga2793064eda4625b486c3db5befca35e3"><div class="ttname"><a href="group__usbchap9__src.html#ga2793064eda4625b486c3db5befca35e3">USBShort</a></div><div class="ttdeci">#define USBShort(ui16Value)</div><div class="ttdef"><b>Definition:</b> usblib.h:834</div></div>
<div class="ttc" id="group__usbchap9__src_html_ga8878fe0d6aff0b1c70cd2b15df5a41f6"><div class="ttname"><a href="group__usbchap9__src.html#ga8878fe0d6aff0b1c70cd2b15df5a41f6">USB_CONF_ATTR_SELF_PWR</a></div><div class="ttdeci">#define USB_CONF_ATTR_SELF_PWR</div><div class="ttdef"><b>Definition:</b> usblib.h:602</div></div>
</div><!-- fragment -->
<p>Referenced by <a class="el" href="group__bulk__device__class__api.html#ga862414b1691f275926103bc9d4b7772f">USBDBulkInit()</a>.</p>

</div>
</div>
<a id="ga433317e5e4c6afee8d06b01946bb5cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433317e5e4c6afee8d06b01946bb5cc6">&sect;&nbsp;</a></span>g_pui8BulkInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t g_pui8BulkInterface[<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga807b71c9aad4464cf34fb15ba8a26bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807b71c9aad4464cf34fb15ba8a26bc3">&sect;&nbsp;</a></span>g_pui8BulkInterfaceHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t g_pui8BulkInterfaceHS[<a class="el" href="group__bulk__device__class__api.html#gad513d1d93c7e05d14b3a85ba33651794">BULKINTERFACE_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad600b1227572563250b89b640da90214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad600b1227572563250b89b640da90214">&sect;&nbsp;</a></span>g_sBulkConfigSection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_section.html">tConfigSection</a> g_sBulkConfigSection</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <span class="keyword">sizeof</span>(<a class="code" href="group__bulk__device__class__api.html#gae3fce7c0e61c485c2a382d403dacb655">g_pui8BulkDescriptor</a>),</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#gae3fce7c0e61c485c2a382d403dacb655">g_pui8BulkDescriptor</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gae3fce7c0e61c485c2a382d403dacb655"><div class="ttname"><a href="group__bulk__device__class__api.html#gae3fce7c0e61c485c2a382d403dacb655">g_pui8BulkDescriptor</a></div><div class="ttdeci">uint8_t g_pui8BulkDescriptor[]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:122</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga022064693f1faa3e7ebc1c50d45a7810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga022064693f1faa3e7ebc1c50d45a7810">&sect;&nbsp;</a></span>g_sBulkInterfaceSection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_section.html">tConfigSection</a> g_sBulkInterfaceSection</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <span class="keyword">sizeof</span>(<a class="code" href="group__bulk__device__class__api.html#ga433317e5e4c6afee8d06b01946bb5cc6">g_pui8BulkInterface</a>),</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#ga433317e5e4c6afee8d06b01946bb5cc6">g_pui8BulkInterface</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_ga433317e5e4c6afee8d06b01946bb5cc6"><div class="ttname"><a href="group__bulk__device__class__api.html#ga433317e5e4c6afee8d06b01946bb5cc6">g_pui8BulkInterface</a></div><div class="ttdeci">const uint8_t g_pui8BulkInterface[BULKINTERFACE_SIZE]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:145</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga80f218f30a53c75424525f594754df89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80f218f30a53c75424525f594754df89">&sect;&nbsp;</a></span>g_sBulkInterfaceSectionHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_section.html">tConfigSection</a> g_sBulkInterfaceSectionHS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <span class="keyword">sizeof</span>(<a class="code" href="group__bulk__device__class__api.html#ga807b71c9aad4464cf34fb15ba8a26bc3">g_pui8BulkInterfaceHS</a>),</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#ga807b71c9aad4464cf34fb15ba8a26bc3">g_pui8BulkInterfaceHS</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_ga807b71c9aad4464cf34fb15ba8a26bc3"><div class="ttname"><a href="group__bulk__device__class__api.html#ga807b71c9aad4464cf34fb15ba8a26bc3">g_pui8BulkInterfaceHS</a></div><div class="ttdeci">const uint8_t g_pui8BulkInterfaceHS[BULKINTERFACE_SIZE]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:184</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad4dd55577889f3ffd323333afd64154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4dd55577889f3ffd323333afd64154a">&sect;&nbsp;</a></span>g_psBulkSections</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_section.html">tConfigSection</a>* g_psBulkSections[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#gad600b1227572563250b89b640da90214">g_sBulkConfigSection</a>,</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#ga022064693f1faa3e7ebc1c50d45a7810">g_sBulkInterfaceSection</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gad600b1227572563250b89b640da90214"><div class="ttname"><a href="group__bulk__device__class__api.html#gad600b1227572563250b89b640da90214">g_sBulkConfigSection</a></div><div class="ttdeci">const tConfigSection g_sBulkConfigSection</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:230</div></div>
<div class="ttc" id="group__bulk__device__class__api_html_ga022064693f1faa3e7ebc1c50d45a7810"><div class="ttname"><a href="group__bulk__device__class__api.html#ga022064693f1faa3e7ebc1c50d45a7810">g_sBulkInterfaceSection</a></div><div class="ttdeci">const tConfigSection g_sBulkInterfaceSection</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:236</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gada27c860ff4cd5c61352f326371e021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada27c860ff4cd5c61352f326371e021b">&sect;&nbsp;</a></span>g_psBulkSectionsHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_section.html">tConfigSection</a>* g_psBulkSectionsHS[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#gad600b1227572563250b89b640da90214">g_sBulkConfigSection</a>,</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#ga80f218f30a53c75424525f594754df89">g_sBulkInterfaceSectionHS</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gad600b1227572563250b89b640da90214"><div class="ttname"><a href="group__bulk__device__class__api.html#gad600b1227572563250b89b640da90214">g_sBulkConfigSection</a></div><div class="ttdeci">const tConfigSection g_sBulkConfigSection</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:230</div></div>
<div class="ttc" id="group__bulk__device__class__api_html_ga80f218f30a53c75424525f594754df89"><div class="ttname"><a href="group__bulk__device__class__api.html#ga80f218f30a53c75424525f594754df89">g_sBulkInterfaceSectionHS</a></div><div class="ttdeci">const tConfigSection g_sBulkInterfaceSectionHS</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:242</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga40af3cfe88c284ae374eabc7839bd4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40af3cfe88c284ae374eabc7839bd4d5">&sect;&nbsp;</a></span>g_sBulkConfigHeader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_header.html">tConfigHeader</a> g_sBulkConfigHeader</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#gafc023ea13673c19fc981aace97412c83">NUM_BULK_SECTIONS</a>,</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gafc023ea13673c19fc981aace97412c83"><div class="ttname"><a href="group__bulk__device__class__api.html#gafc023ea13673c19fc981aace97412c83">NUM_BULK_SECTIONS</a></div><div class="ttdeci">#define NUM_BULK_SECTIONS</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:266</div></div>
<div class="ttc" id="group__bulk__device__class__api_html_gad4dd55577889f3ffd323333afd64154a"><div class="ttname"><a href="group__bulk__device__class__api.html#gad4dd55577889f3ffd323333afd64154a">g_psBulkSections</a></div><div class="ttdeci">const tConfigSection * g_psBulkSections[]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:254</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaaaecec1719e14e4bcc13e5f62c7e9c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaecec1719e14e4bcc13e5f62c7e9c36">&sect;&nbsp;</a></span>g_sBulkConfigHeaderHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_header.html">tConfigHeader</a> g_sBulkConfigHeaderHS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#gafc023ea13673c19fc981aace97412c83">NUM_BULK_SECTIONS</a>,</div><div class="line">    <a class="code" href="group__bulk__device__class__api.html#gada27c860ff4cd5c61352f326371e021b">g_psBulkSectionsHS</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gafc023ea13673c19fc981aace97412c83"><div class="ttname"><a href="group__bulk__device__class__api.html#gafc023ea13673c19fc981aace97412c83">NUM_BULK_SECTIONS</a></div><div class="ttdeci">#define NUM_BULK_SECTIONS</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:266</div></div>
<div class="ttc" id="group__bulk__device__class__api_html_gada27c860ff4cd5c61352f326371e021b"><div class="ttname"><a href="group__bulk__device__class__api.html#gada27c860ff4cd5c61352f326371e021b">g_psBulkSectionsHS</a></div><div class="ttdeci">const tConfigSection * g_psBulkSectionsHS[]</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:260</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gac086a0d3342c613e40792529c1d9d6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac086a0d3342c613e40792529c1d9d6e3">&sect;&nbsp;</a></span>g_ppBulkConfigDescriptors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_header.html">tConfigHeader</a>* const g_ppBulkConfigDescriptors[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#ga40af3cfe88c284ae374eabc7839bd4d5">g_sBulkConfigHeader</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_ga40af3cfe88c284ae374eabc7839bd4d5"><div class="ttname"><a href="group__bulk__device__class__api.html#ga40af3cfe88c284ae374eabc7839bd4d5">g_sBulkConfigHeader</a></div><div class="ttdeci">const tConfigHeader g_sBulkConfigHeader</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:276</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8509a01e1851dfa8a8d7ffee94d972a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8509a01e1851dfa8a8d7ffee94d972a3">&sect;&nbsp;</a></span>g_ppBulkConfigDescriptorsHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_config_header.html">tConfigHeader</a>* const g_ppBulkConfigDescriptorsHS[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    &amp;<a class="code" href="group__bulk__device__class__api.html#gaaaecec1719e14e4bcc13e5f62c7e9c36">g_sBulkConfigHeaderHS</a></div><div class="line">}</div><div class="ttc" id="group__bulk__device__class__api_html_gaaaecec1719e14e4bcc13e5f62c7e9c36"><div class="ttname"><a href="group__bulk__device__class__api.html#gaaaecec1719e14e4bcc13e5f62c7e9c36">g_sBulkConfigHeaderHS</a></div><div class="ttdeci">const tConfigHeader g_sBulkConfigHeaderHS</div><div class="ttdef"><b>Definition:</b> usbdbulk.c:282</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga488b91aba1a8cb9b9a6d0e7430b2b9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488b91aba1a8cb9b9a6d0e7430b2b9cc">&sect;&nbsp;</a></span>g_sBulkHandlers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_custom_handlers.html">tCustomHandlers</a> g_sBulkHandlers</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
