<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>USBLibAPIGuide: Usblib_buffer_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">USBLibAPIGuide
   &#160;<span id="projectnumber">1.00.00.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Usblib_buffer_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_l_p_m_feature.html">tLPMFeature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_buffer_vars.html">tUSBBufferVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga77ed160682aa74770f87247e39ff771d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga77ed160682aa74770f87247e39ff771d">USB_BUFFER_FLAG_SEND_ZLP</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga77ed160682aa74770f87247e39ff771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac403f1d66684fbcebdfc5967a6212245"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gac403f1d66684fbcebdfc5967a6212245">USBLIB_FEATURE_LPM</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:gac403f1d66684fbcebdfc5967a6212245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e46aba0d11b6937ec581a386400028"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gad9e46aba0d11b6937ec581a386400028">USBLIB_FEATURE_LPM_RMT_WAKE</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gad9e46aba0d11b6937ec581a386400028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677f039dc296aec1ad2cb85dcee27e23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga677f039dc296aec1ad2cb85dcee27e23">USBLIB_FEATURE_LPM_EN</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga677f039dc296aec1ad2cb85dcee27e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3367f7cae948207f9c4ba0d15a67157a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga3367f7cae948207f9c4ba0d15a67157a">USBLIB_FEATURE_LPM_DIS</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga3367f7cae948207f9c4ba0d15a67157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44486a930553c62bcea656ae58e966a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaf44486a930553c62bcea656ae58e966a">USBLIB_FEATURE_CPUCLK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gaf44486a930553c62bcea656ae58e966a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26deb14bfab3fe40e5331b3484ea55a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga26deb14bfab3fe40e5331b3484ea55a8">USBLIB_FEATURE_USBPLL</a>&#160;&#160;&#160;0x00000003</td></tr>
<tr class="separator:ga26deb14bfab3fe40e5331b3484ea55a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223a3144b79014ba24b7d2d79c50c824"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga223a3144b79014ba24b7d2d79c50c824">USBLIB_FEATURE_USBULPI</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:ga223a3144b79014ba24b7d2d79c50c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0389e9cc2638f1c725d763f26d6fa44d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga0389e9cc2638f1c725d763f26d6fa44d">USBLIB_FEATURE_ULPI_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga0389e9cc2638f1c725d763f26d6fa44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423663f9827bc41aa467b02aabe08ced"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga423663f9827bc41aa467b02aabe08ced">USBLIB_FEATURE_ULPI_HS</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:ga423663f9827bc41aa467b02aabe08ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad780d5a582b9b98742064a91db3bbcae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gad780d5a582b9b98742064a91db3bbcae">USBLIB_FEATURE_ULPI_FS</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:gad780d5a582b9b98742064a91db3bbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5f5869b1d192e0b286d0415599df9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga6a5f5869b1d192e0b286d0415599df9c">USBLIB_FEATURE_POWER</a>&#160;&#160;&#160;0x00000005</td></tr>
<tr class="separator:ga6a5f5869b1d192e0b286d0415599df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15325ffbdbf1b641dd9410219dafa3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaf15325ffbdbf1b641dd9410219dafa3c">USBLIB_FEATURE_POWER_SELF</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:gaf15325ffbdbf1b641dd9410219dafa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332443e5b07b227a1c777c4812e3c538"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga332443e5b07b227a1c777c4812e3c538">USBLIB_FEATURE_POWER_BUS</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga332443e5b07b227a1c777c4812e3c538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0ddbe445c162770601486ed0642d1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga2f0ddbe445c162770601486ed0642d1b">USBLIB_FEATURE_REMOTE_WAKE</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:ga2f0ddbe445c162770601486ed0642d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&#160;&#160;&#160;((void *)0)</td></tr>
<tr class="separator:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadf6eea292082aacbeb79f51afb79f0fa"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gadf6eea292082aacbeb79f51afb79f0fa">tUSBPacketTransfer</a>) (void *pvHandle, uint8_t *pi8Data, uint32_t ui32Length, bool bLast)</td></tr>
<tr class="separator:gadf6eea292082aacbeb79f51afb79f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976d6bd40ff6c6e50b57995cc56bc7a6"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga976d6bd40ff6c6e50b57995cc56bc7a6">tUSBPacketAvailable</a>) (void *pvHandle)</td></tr>
<tr class="separator:ga976d6bd40ff6c6e50b57995cc56bc7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga856549d9a38cd3f277fb109641bee6f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga856549d9a38cd3f277fb109641bee6f2">USBBufferInit</a> (<a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer)</td></tr>
<tr class="separator:ga856549d9a38cd3f277fb109641bee6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d2821721fe0ad29a0f170f92033d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaa2d2821721fe0ad29a0f170f92033d59">USBBufferZeroLengthPacketInsert</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, bool bSendZLP)</td></tr>
<tr class="separator:gaa2d2821721fe0ad29a0f170f92033d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be848eac5b7942aefcf22a42e7130a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga4be848eac5b7942aefcf22a42e7130a8">USBBufferInfoGet</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, <a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psRingBuf)</td></tr>
<tr class="separator:ga4be848eac5b7942aefcf22a42e7130a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ed19b71ad061a3c1e733b61f58fb2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gab3ed19b71ad061a3c1e733b61f58fb2d">USBBufferDataWritten</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, uint32_t ui32Length)</td></tr>
<tr class="separator:gab3ed19b71ad061a3c1e733b61f58fb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53216ef0ab2407938d1149eae92c12b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga53216ef0ab2407938d1149eae92c12b8">USBBufferDataRemoved</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, uint32_t ui32Length)</td></tr>
<tr class="separator:ga53216ef0ab2407938d1149eae92c12b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1020ac08b3bc1a81e1aecabbd204d821"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga1020ac08b3bc1a81e1aecabbd204d821">USBBufferCallbackDataSet</a> (<a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, void *pvCBData)</td></tr>
<tr class="separator:ga1020ac08b3bc1a81e1aecabbd204d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efafc515898e1387ffacea9f50e4c15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, const uint8_t *pui8Data, uint32_t ui32Length)</td></tr>
<tr class="separator:ga8efafc515898e1387ffacea9f50e4c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71a50c8eeb52f525a3a46d58a9bbddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gab71a50c8eeb52f525a3a46d58a9bbddd">USBBufferFlush</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer)</td></tr>
<tr class="separator:gab71a50c8eeb52f525a3a46d58a9bbddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ddc9f6c45c2f9a3c78866253960f6f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gad4ddc9f6c45c2f9a3c78866253960f6f">USBBufferRead</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer, uint8_t *pui8Data, uint32_t ui32Length)</td></tr>
<tr class="separator:gad4ddc9f6c45c2f9a3c78866253960f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0e198851002d5f92bea0c97d79d0c1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga4d0e198851002d5f92bea0c97d79d0c1">USBBufferDataAvailable</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer)</td></tr>
<tr class="separator:ga4d0e198851002d5f92bea0c97d79d0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23136a5c833c931edaff7361fa670b26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga23136a5c833c931edaff7361fa670b26">USBBufferSpaceAvailable</a> (const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *psBuffer)</td></tr>
<tr class="separator:ga23136a5c833c931edaff7361fa670b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeceed1b2ad9155a666b614117db8822"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaaeceed1b2ad9155a666b614117db8822">USBBufferEventCallback</a> (void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgValue, void *pvMsgData)</td></tr>
<tr class="separator:gaaeceed1b2ad9155a666b614117db8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614330915826b0211f0ed35f48881b89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga614330915826b0211f0ed35f48881b89">USBRingBufFull</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:ga614330915826b0211f0ed35f48881b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb525807493779e930a1a500fdc3420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga5cb525807493779e930a1a500fdc3420">USBRingBufEmpty</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:ga5cb525807493779e930a1a500fdc3420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b570fdc2ba2f888bcd48fe0e938892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga82b570fdc2ba2f888bcd48fe0e938892">USBRingBufFlush</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:ga82b570fdc2ba2f888bcd48fe0e938892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd09e3f14d20263bdef863ef2ab23f0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:gabfd09e3f14d20263bdef863ef2ab23f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d7d9100742a5570812127625f6b36d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:gad0d7d9100742a5570812127625f6b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca25830827e91d90ec1bdd67f5e22393"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaca25830827e91d90ec1bdd67f5e22393">USBRingBufContigUsed</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:gaca25830827e91d90ec1bdd67f5e22393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c7949e1a90566d5a33baa190eec941"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga16c7949e1a90566d5a33baa190eec941">USBRingBufContigFree</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:ga16c7949e1a90566d5a33baa190eec941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf87ff287a5f79c3de06b9c6c63262c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gadf87ff287a5f79c3de06b9c6c63262c0">USBRingBufSize</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:gadf87ff287a5f79c3de06b9c6c63262c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8e4b33fd61ac15ed8b7edc105f54a4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga6f8e4b33fd61ac15ed8b7edc105f54a4">USBRingBufReadOne</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf)</td></tr>
<tr class="separator:ga6f8e4b33fd61ac15ed8b7edc105f54a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8114e76bcddb9800ca6eed068e290d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga0a8114e76bcddb9800ca6eed068e290d">USBRingBufRead</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, uint8_t *pui8Data, uint32_t ui32Length)</td></tr>
<tr class="separator:ga0a8114e76bcddb9800ca6eed068e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaedcab8ad741bd7d8f67142397f72190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaaedcab8ad741bd7d8f67142397f72190">USBRingBufAdvanceRead</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, uint32_t ui32NumBytes)</td></tr>
<tr class="separator:gaaedcab8ad741bd7d8f67142397f72190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca58d9aacaa30f01232919ad757fdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga3ca58d9aacaa30f01232919ad757fdab">USBRingBufAdvanceWrite</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, uint32_t ui32NumBytes)</td></tr>
<tr class="separator:ga3ca58d9aacaa30f01232919ad757fdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23b219a79b354c953efe83aa34aaa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gaa23b219a79b354c953efe83aa34aaa33">USBRingBufWriteOne</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, uint8_t ui8Data)</td></tr>
<tr class="separator:gaa23b219a79b354c953efe83aa34aaa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37d12ad9c5cef32d24dcd482d8938b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, const uint8_t *pui8Data, uint32_t ui32Length)</td></tr>
<tr class="separator:gab37d12ad9c5cef32d24dcd482d8938b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e3e76878f71e93b02af15f41a6b993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__buffer__api.html#ga73e3e76878f71e93b02af15f41a6b993">USBRingBufInit</a> (<a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *psUSBRingBuf, uint8_t *pui8Buf, uint32_t ui32Size)</td></tr>
<tr class="separator:ga73e3e76878f71e93b02af15f41a6b993"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga77ed160682aa74770f87247e39ff771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ed160682aa74770f87247e39ff771d">&sect;&nbsp;</a></span>USB_BUFFER_FLAG_SEND_ZLP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_BUFFER_FLAG_SEND_ZLP&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gaa2d2821721fe0ad29a0f170f92033d59">USBBufferZeroLengthPacketInsert()</a>.</p>

</div>
</div>
<a id="gac403f1d66684fbcebdfc5967a6212245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac403f1d66684fbcebdfc5967a6212245">&sect;&nbsp;</a></span>USBLIB_FEATURE_LPM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_LPM&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This feature setting enables or disables LPM support in the USB library in either host or device mode depending on if the <a class="el" href="group__usblib__hcd.html#ga0e587ab23242d4de2ac5a6052f7afead">USBHCDFeatureSet()</a> or <a class="el" href="group__device__api.html#ga9c15764d78336cd4542612bc3651e5d4">USBDCDFeatureSet()</a> is called. If no action is taken the default behavior of USB library is to not support LPM transactions. The <em>pvFeature</em> value is a pointer to a 32-bit value containing the a logical OR of the following values:</p>
<ul>
<li><b>USBLIB_FEATURE_LPM_EN</b> is used to enable LPM support in host or device mode.</li>
<li><b><a class="el" href="group__usblib__buffer__api.html#ga3367f7cae948207f9c4ba0d15a67157a">USBLIB_FEATURE_LPM_DIS(default)</a></b> is used to disable LPM support in host or device mode.</li>
<li><b>USBLIB_FEATURE_LPM_RMT_WAKE</b> is used to enable remote wake from an LPM suspended state. </li>
</ul>

<p>Referenced by <a class="el" href="group__device__api.html#ga9c15764d78336cd4542612bc3651e5d4">USBDCDFeatureSet()</a>.</p>

</div>
</div>
<a id="gad9e46aba0d11b6937ec581a386400028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e46aba0d11b6937ec581a386400028">&sect;&nbsp;</a></span>USBLIB_FEATURE_LPM_RMT_WAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_LPM_RMT_WAKE&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga677f039dc296aec1ad2cb85dcee27e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677f039dc296aec1ad2cb85dcee27e23">&sect;&nbsp;</a></span>USBLIB_FEATURE_LPM_EN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_LPM_EN&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__device__api.html#ga9c15764d78336cd4542612bc3651e5d4">USBDCDFeatureSet()</a>.</p>

</div>
</div>
<a id="ga3367f7cae948207f9c4ba0d15a67157a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3367f7cae948207f9c4ba0d15a67157a">&sect;&nbsp;</a></span>USBLIB_FEATURE_LPM_DIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_LPM_DIS&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf44486a930553c62bcea656ae58e966a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44486a930553c62bcea656ae58e966a">&sect;&nbsp;</a></span>USBLIB_FEATURE_CPUCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_CPUCLK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This feature setting allows an application to inform the USB library of the current processor speed that is can use for internal timing when the frame counter is not yet running. The <em>pvFeature</em> is a pointer to a 32-bit value that holds the processor frequency in Hz. </p>

<p>Referenced by <a class="el" href="group__usblib__hcd.html#ga0e587ab23242d4de2ac5a6052f7afead">USBHCDFeatureSet()</a>.</p>

</div>
</div>
<a id="ga26deb14bfab3fe40e5331b3484ea55a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26deb14bfab3fe40e5331b3484ea55a8">&sect;&nbsp;</a></span>USBLIB_FEATURE_USBPLL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_USBPLL&#160;&#160;&#160;0x00000003</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This feature setting allows an application to inform the USB library of the current USB PLL rate in cases where the USB library needs this information for internal configuration. If this feature is not set, then default rate for the USB PLL is 480MHz. The <em>pvFeature</em> is a pointer to an 32-bit value that holds the USB PLL speed in Hz. If the application needs to use an external USB clock the PLL value should be set to zero. This is used when connecting to an external USB phy which is providing the 60-MHz clock. </p>

<p>Referenced by <a class="el" href="group__device__api.html#ga9c15764d78336cd4542612bc3651e5d4">USBDCDFeatureSet()</a>.</p>

</div>
</div>
<a id="ga223a3144b79014ba24b7d2d79c50c824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223a3144b79014ba24b7d2d79c50c824">&sect;&nbsp;</a></span>USBLIB_FEATURE_USBULPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_USBULPI&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This feature setting allows an application to disable or configure and enable the ULPI features in the USB library. If this feature is not set, the default behavior is to not support ULPI operation. The <em>pvFeature</em> is a pointer to an 32-bit value that holds the USB ULPI configuration. The following are the valid settings for this feature:</p>
<ul>
<li>USBLIB_FEATURE_ULPI_NONE disables all ULPI support.</li>
<li>USBLIB_FEATURE_ULPI_HS enable ULPI with high speed support.</li>
<li>USBLIB_FEATURE_ULPI_FS enable ULPI with full speed support. </li>
</ul>

<p>Referenced by <a class="el" href="group__bulk__device__class__api.html#ga55e8c2af0b58232dccbff5dc2731e928">USBDBulkCompositeInit()</a>, <a class="el" href="group__cdc__device__class__api.html#ga558ca2dc67351293a531f502548bd94e">USBDCDCCompositeInit()</a>, and <a class="el" href="group__device__api.html#ga9f2b669ae791b0b392777c22bde7ba22">USBDCDFeatureGet()</a>.</p>

</div>
</div>
<a id="ga0389e9cc2638f1c725d763f26d6fa44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0389e9cc2638f1c725d763f26d6fa44d">&sect;&nbsp;</a></span>USBLIB_FEATURE_ULPI_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_ULPI_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga423663f9827bc41aa467b02aabe08ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423663f9827bc41aa467b02aabe08ced">&sect;&nbsp;</a></span>USBLIB_FEATURE_ULPI_HS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_ULPI_HS&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad780d5a582b9b98742064a91db3bbcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad780d5a582b9b98742064a91db3bbcae">&sect;&nbsp;</a></span>USBLIB_FEATURE_ULPI_FS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_ULPI_FS&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6a5f5869b1d192e0b286d0415599df9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a5f5869b1d192e0b286d0415599df9c">&sect;&nbsp;</a></span>USBLIB_FEATURE_POWER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_POWER&#160;&#160;&#160;0x00000005</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This feature setting enables or disables various power settings in the USB library in either host or device mode depending on if the <a class="el" href="group__usblib__hcd.html#ga0e587ab23242d4de2ac5a6052f7afead">USBHCDFeatureSet()</a> or <a class="el" href="group__device__api.html#ga9c15764d78336cd4542612bc3651e5d4">USBDCDFeatureSet()</a> is called. The <em>pvFeature</em> value is a pointer to a 32-bit value containing the a logical OR of the following values:</p>
<ul>
<li><b>USBLIB_FEATURE_POWER_BUS</b> - USB device mode is bus powered(default).</li>
<li><b>USBLIB_FEATURE_POWER_SELF</b> - USB device mode is self powered.</li>
<li><b>USBLIB_FEATURE_REMOTE_WAKE</b> - Enable USB remote wake feature. </li>
</ul>

</div>
</div>
<a id="gaf15325ffbdbf1b641dd9410219dafa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf15325ffbdbf1b641dd9410219dafa3c">&sect;&nbsp;</a></span>USBLIB_FEATURE_POWER_SELF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_POWER_SELF&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga332443e5b07b227a1c777c4812e3c538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332443e5b07b227a1c777c4812e3c538">&sect;&nbsp;</a></span>USBLIB_FEATURE_POWER_BUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_POWER_BUS&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2f0ddbe445c162770601486ed0642d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0ddbe445c162770601486ed0642d1b">&sect;&nbsp;</a></span>USBLIB_FEATURE_REMOTE_WAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_FEATURE_REMOTE_WAKE&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070d2ce7b6bb7e5c05602aa8c308d0c4">&sect;&nbsp;</a></span>NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULL&#160;&#160;&#160;((void *)0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gaaedcab8ad741bd7d8f67142397f72190">USBRingBufAdvanceRead()</a>, <a class="el" href="group__usblib__buffer__api.html#ga3ca58d9aacaa30f01232919ad757fdab">USBRingBufAdvanceWrite()</a>, <a class="el" href="group__usblib__buffer__api.html#ga16c7949e1a90566d5a33baa190eec941">USBRingBufContigFree()</a>, <a class="el" href="group__usblib__buffer__api.html#gaca25830827e91d90ec1bdd67f5e22393">USBRingBufContigUsed()</a>, <a class="el" href="group__usblib__buffer__api.html#ga5cb525807493779e930a1a500fdc3420">USBRingBufEmpty()</a>, <a class="el" href="group__usblib__buffer__api.html#ga82b570fdc2ba2f888bcd48fe0e938892">USBRingBufFlush()</a>, <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>, <a class="el" href="group__usblib__buffer__api.html#ga614330915826b0211f0ed35f48881b89">USBRingBufFull()</a>, <a class="el" href="group__usblib__buffer__api.html#ga73e3e76878f71e93b02af15f41a6b993">USBRingBufInit()</a>, <a class="el" href="group__usblib__buffer__api.html#ga0a8114e76bcddb9800ca6eed068e290d">USBRingBufRead()</a>, <a class="el" href="group__usblib__buffer__api.html#ga6f8e4b33fd61ac15ed8b7edc105f54a4">USBRingBufReadOne()</a>, <a class="el" href="group__usblib__buffer__api.html#gadf87ff287a5f79c3de06b9c6c63262c0">USBRingBufSize()</a>, <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>, <a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite()</a>, and <a class="el" href="group__usblib__buffer__api.html#gaa23b219a79b354c953efe83aa34aaa33">USBRingBufWriteOne()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gadf6eea292082aacbeb79f51afb79f0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6eea292082aacbeb79f51afb79f0fa">&sect;&nbsp;</a></span>tUSBPacketTransfer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(*  tUSBPacketTransfer) (void *pvHandle, uint8_t *pi8Data, uint32_t ui32Length, bool bLast)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function pointer type which describes either a class driver packet read or packet write function (both have the same prototype) to the USB buffer object. </p>

</div>
</div>
<a id="ga976d6bd40ff6c6e50b57995cc56bc7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga976d6bd40ff6c6e50b57995cc56bc7a6">&sect;&nbsp;</a></span>tUSBPacketAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(*  tUSBPacketAvailable) (void *pvHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function pointer type which describes either a class driver transmit or receive packet available function (both have the same prototype) to the USB buffer object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvHandle</td><td>is the handle of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga856549d9a38cd3f277fb109641bee6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga856549d9a38cd3f277fb109641bee6f2">&sect;&nbsp;</a></span>USBBufferInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a>* USBBufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a USB buffer object to be used with a given USB controller and device or host class driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>points to a structure containing information on the buffer memory to be used and the underlying device or host class driver whose data is to be buffered. This structure must remain accessible for as long as the buffer is in use.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to initialize a USB buffer object and insert it into the function and callback interfaces between an underlying driver and the application. The caller supplies information on both the RAM to be used to buffer data, the type of buffer to be created (transmit or receive) and the functions to be called in the lower layer to transfer data to or from the USB controller.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the original buffer structure pointer if successful or NULL if an error is detected. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer.html#aa66dd45d6fdedcf3262b6460b9e594fd">tUSBBuffer::pfnAvailable</a>, <a class="el" href="structt_u_s_b_buffer.html#a9c846a912bc72e198dcfc22df90a28e8">tUSBBuffer::pfnCallback</a>, <a class="el" href="structt_u_s_b_buffer.html#a55fa63bcb297fd7b65321ec28eb1cfa6">tUSBBuffer::pfnTransfer</a>, <a class="el" href="structt_u_s_b_buffer.html#a100388daadbfeed48ee8f0566852a6fc">tUSBBuffer::pui8Buffer</a>, <a class="el" href="structt_u_s_b_buffer.html#aa80183b707d7f0bbe73cbc72f25e843b">tUSBBuffer::sPrivateData</a>, <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, <a class="el" href="structt_u_s_b_buffer.html#a7b1b1d57dece898be43e20b3fe5dd254">tUSBBuffer::ui32BufferSize</a>, <a class="el" href="structt_u_s_b_buffer_vars.html#afdf16a82e3d0831f56ea9be5fb69a9d6">tUSBBufferVars::ui32Flags</a>, and <a class="el" href="group__usblib__buffer__api.html#ga73e3e76878f71e93b02af15f41a6b993">USBRingBufInit()</a>.</p>

</div>
</div>
<a id="gaa2d2821721fe0ad29a0f170f92033d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2d2821721fe0ad29a0f170f92033d59">&sect;&nbsp;</a></span>USBBufferZeroLengthPacketInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBBufferZeroLengthPacketInsert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSendZLP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables zero-length packet insertion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance whose information is being queried. </td></tr>
    <tr><td class="paramname">bSendZLP</td><td>is <b>true</b> to send zero-length packets or <b>false</b> to prevent them from being sent.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the use of zero-length packets to be controlled by an application. In cases where the USB buffer has sent a full (64 byte) packet and then discovers that the transmit buffer is empty, the default behavior is to do nothing. Some protocols, however, require that a zero- length packet be inserted to signal the end of the data. When using such a protocol, this function should be called with <em>bSendZLP</em> set to <b>true</b> to enable the desired behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#afdf16a82e3d0831f56ea9be5fb69a9d6">tUSBBufferVars::ui32Flags</a>, and <a class="el" href="group__usblib__buffer__api.html#ga77ed160682aa74770f87247e39ff771d">USB_BUFFER_FLAG_SEND_ZLP</a>.</p>

</div>
</div>
<a id="ga4be848eac5b7942aefcf22a42e7130a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be848eac5b7942aefcf22a42e7130a8">&sect;&nbsp;</a></span>USBBufferInfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBBufferInfoGet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psRingBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current ring buffer indices for this USB buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance whose information is being queried. </td></tr>
    <tr><td class="paramname">psRingBuf</td><td>is a pointer to storage that will be written with the current ring buffer control structure for this USB buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is provided to aid a client wishing to write data directly into the USB buffer rather than using the <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a> function. This may be necessary to control when the USBBuffer starts transmission of a large block of data, for example.</p>
<p>A transmit buffer will immediately send a new packet on any call to <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a> if the underlying layer indicates that a transmission can be started. In some cases this is not desirable and a client may wish to wishes to write more data to the buffer in advance of starting transmission to the lower layer. In such cases, this function may be called to retrieve the current ring buffer indices and the buffer accessed directly. Once the client has written all data it wishes to send, it should call function <a class="el" href="group__usblib__buffer__api.html#gab3ed19b71ad061a3c1e733b61f58fb2d">USBBufferDataWritten()</a> to indicate that transmission may begin.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_ring_buf_object.html#a03941128a8ce870e1f76ee16f812d3ce">tUSBRingBufObject::pui8Buf</a>, <a class="el" href="structt_u_s_b_buffer.html#aa80183b707d7f0bbe73cbc72f25e843b">tUSBBuffer::sPrivateData</a>, <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

</div>
</div>
<a id="gab3ed19b71ad061a3c1e733b61f58fb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ed19b71ad061a3c1e733b61f58fb2d">&sect;&nbsp;</a></span>USBBufferDataWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBBufferDataWritten </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a client has written data directly into the buffer and wishes to start transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance into which data has been written. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes of data that the client has written.</td></tr>
  </table>
  </dd>
</dl>
<p>This function updates the USB buffer write pointer and starts transmission of the data in the buffer assuming the lower layer is ready to receive a new packet. The function is provided to aid a client wishing to write data directly into the USB buffer rather than using the <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a> function. This may be necessary to control when the USB buffer starts transmission of a large block of data, for example.</p>
<p>A transmit buffer will immediately send a new packet on any call to <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a> if the underlying layer indicates that a transmission can be started. In some cases this is not desirable and a client may wish to write more data to the buffer in advance of starting transmission to the lower layer. In such cases, <a class="el" href="group__usblib__buffer__api.html#ga4be848eac5b7942aefcf22a42e7130a8">USBBufferInfoGet()</a> may be called to retrieve the current ring buffer indices and the buffer accessed directly. Once the client has written all data it wishes to send (taking care to handle the ring buffer wrap), it should call this function to indicate that transmission may begin.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, and <a class="el" href="group__usblib__buffer__api.html#ga3ca58d9aacaa30f01232919ad757fdab">USBRingBufAdvanceWrite()</a>.</p>

</div>
</div>
<a id="ga53216ef0ab2407938d1149eae92c12b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53216ef0ab2407938d1149eae92c12b8">&sect;&nbsp;</a></span>USBBufferDataRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBBufferDataRemoved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a client has read data directly out of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance from which data has been read. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes of data that the client has read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function updates the USB buffer read pointer to remove data that the client has read directly rather than via a call to <a class="el" href="group__usblib__buffer__api.html#gad4ddc9f6c45c2f9a3c78866253960f6f">USBBufferRead()</a>. The function is provided to aid a client wishing to minimize data copying. To read directly from the buffer, a client must call <a class="el" href="group__usblib__buffer__api.html#ga4be848eac5b7942aefcf22a42e7130a8">USBBufferInfoGet()</a> to retrieve the current buffer inpsBufVarsdices. With this information, the data following the current read index can be read. Once the client has processed much data as it needs, <a class="el" href="group__usblib__buffer__api.html#ga53216ef0ab2407938d1149eae92c12b8">USBBufferDataRemoved()</a> must be called to advance the read pointer past the data that has been read and free up that section of the buffer. The client must take care to correctly handle the wrap point if accessing the buffer directly.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, and <a class="el" href="group__usblib__buffer__api.html#gaaedcab8ad741bd7d8f67142397f72190">USBRingBufAdvanceRead()</a>.</p>

</div>
</div>
<a id="ga1020ac08b3bc1a81e1aecabbd204d821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1020ac08b3bc1a81e1aecabbd204d821">&sect;&nbsp;</a></span>USBBufferCallbackDataSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* USBBufferCallbackDataSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCBData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the callback pointer supplied to clients of this buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance whose callback data is to be changed. </td></tr>
    <tr><td class="paramname">pvCBData</td><td>is the pointer the client wishes to receive on all future callbacks from this buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the callback pointer which this buffer will supply to clients as the <em>pvCBData</em> parameter in all future calls to the event callback.</p>
<dl class="section note"><dt>Note</dt><dd>If this function is to be used, the application must ensure that the <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> structure used to describe this buffer is held in RAM rather than flash. The <em>pvCBData</em> value passed is written directly into this structure.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the previous callback pointer set for the buffer. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer.html#af6f01914a3bc2f8a8fe4e0eb4eff2d1b">tUSBBuffer::pvCBData</a>.</p>

</div>
</div>
<a id="ga8efafc515898e1387ffacea9f50e4c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8efafc515898e1387ffacea9f50e4c15">&sect;&nbsp;</a></span>USBBufferWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBBufferWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a block of data to the transmit buffer and queues it for transmission to the USB controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>points to the pointer instance into which data is to be written. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>points to the first byte of data which is to be written. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes of data to write to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies the supplied data into the transmit buffer. The transmit buffer data will be packetized according to the constraints imposed by the lower layer in use and sent to the USB controller as soon as possible. Once a packet is transmitted and acknowledged, a <b>USB_EVENT_TX_COMPLETE</b> event will be sent to the application callback indicating the number of bytes that have been sent from the buffer.</p>
<p>Attempts to send more data than there is space for in the transmit buffer will result in fewer bytes than expected being written. The value returned by the function indicates the actual number of bytes copied to the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually written. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer.html#af6ee434a4d9288747f32fea68cb1af41">tUSBBuffer::bTransmitBuffer</a>, <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>, and <a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite()</a>.</p>

</div>
</div>
<a id="gab71a50c8eeb52f525a3a46d58a9bbddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71a50c8eeb52f525a3a46d58a9bbddd">&sect;&nbsp;</a></span>USBBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBBufferFlush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes a USB buffer, discarding any data that it contains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance which is to be flushed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function discards all data currently in the supplied buffer without processing (transmitting it via the USB controller or passing it to the client depending upon the buffer mode).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, and <a class="el" href="group__usblib__buffer__api.html#ga82b570fdc2ba2f888bcd48fe0e938892">USBRingBufFlush()</a>.</p>

</div>
</div>
<a id="gad4ddc9f6c45c2f9a3c78866253960f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ddc9f6c45c2f9a3c78866253960f6f">&sect;&nbsp;</a></span>USBBufferRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBBufferRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a block of data from a USB receive buffer into storage supplied by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance from which data is to be read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>points to a buffer into which the received data will be written. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the size of the buffer pointed to by pui8Data.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads up to <em>ui32Length</em> bytes of data received from the USB host into the supplied application buffer. If the receive buffer contains fewer than <em>ui32Length</em> bytes of data, the data that is present will be copied and the return code will indicate the actual number of bytes copied to <em>pui8Data</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes of data read. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, <a class="el" href="group__usblib__buffer__api.html#ga0a8114e76bcddb9800ca6eed068e290d">USBRingBufRead()</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

</div>
</div>
<a id="ga4d0e198851002d5f92bea0c97d79d0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d0e198851002d5f92bea0c97d79d0c1">&sect;&nbsp;</a></span>USBBufferDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBBufferDataAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes of data available in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance which is to be queried.</td></tr>
  </table>
  </dd>
</dl>
<p>This function may be used to determine the number of bytes of data in a buffer. For a receive buffer, this indicates the number of bytes that the client can read from the buffer using <a class="el" href="group__usblib__buffer__api.html#gad4ddc9f6c45c2f9a3c78866253960f6f">USBBufferRead()</a>. For a transmit buffer, this indicates the amount of data that remains to be sent to the USB controller.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes of data in the buffer. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

</div>
</div>
<a id="ga23136a5c833c931edaff7361fa670b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23136a5c833c931edaff7361fa670b26">&sect;&nbsp;</a></span>USBBufferSpaceAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBBufferSpaceAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt_u_s_b_buffer.html">tUSBBuffer</a> *&#160;</td>
          <td class="paramname"><em>psBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of free bytes in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psBuffer</td><td>is the pointer to the buffer instance which is to be queried.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of free bytes in the buffer. For a transmit buffer, this indicates the maximum number of bytes that can be passed on a call to <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a> and accepted for transmission. For a receive buffer, it indicates the number of bytes that can be read from the USB controller before the buffer will be full.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of free bytes in the buffer. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer_vars.html#a6905d39749167db20c6c5384555e74bf">tUSBBufferVars::sRingBuf</a>, and <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>.</p>

</div>
</div>
<a id="gaaeceed1b2ad9155a666b614117db8822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeceed1b2ad9155a666b614117db8822">&sect;&nbsp;</a></span>USBBufferEventCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBBufferEventCallback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCBData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MsgValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvMsgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the USB buffer to notify the client of asynchronous events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvCBData</td><td>is the client-supplied callback pointer associated with this buffer instance. </td></tr>
    <tr><td class="paramname">ui32Event</td><td>is the identifier of the event being sent. This will be a general event identifier of the form <b>USBD_EVENT_xxxx</b> or a device class-dependent event of the form <b>USBD_CDC_EVENT_xxx</b> or <b>USBD_HID_EVENT_xxx</b>. </td></tr>
    <tr><td class="paramname">ui32MsgValue</td><td>is an event-specific parameter value. </td></tr>
    <tr><td class="paramname">pvMsgData</td><td>is an event-specific data pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is the USB buffer event handler that applications should register with the USB device class driver as the callback for the channel which is to be buffered using this buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will never be called by an application. It is the handler that allows the USB buffer to be inserted above the device class driver or host pipe driver and below the application to offer buffering support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is dependent upon the event being processed. </dd></dl>

<p>References <a class="el" href="structt_u_s_b_buffer.html#af6ee434a4d9288747f32fea68cb1af41">tUSBBuffer::bTransmitBuffer</a>, and <a class="el" href="group__usblib__events.html#ga7d1c74fb600772a256ac444c177f40fd">USB_EVENT_RX_AVAILABLE</a>.</p>

</div>
</div>
<a id="ga614330915826b0211f0ed35f48881b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614330915826b0211f0ed35f48881b89">&sect;&nbsp;</a></span>USBRingBufFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBRingBufFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a ring buffer is full or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether or not a given ring buffer is full. The structure is specifically to ensure that we do not see warnings from the compiler related to the order of volatile accesses being undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the buffer is full or <b>false</b> otherwise. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

</div>
</div>
<a id="ga5cb525807493779e930a1a500fdc3420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb525807493779e930a1a500fdc3420">&sect;&nbsp;</a></span>USBRingBufEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBRingBufEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a ring buffer is empty or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether or not a given ring buffer is empty. The structure is specifically to ensure that we do not see warnings from the compiler related to the order of volatile accesses being undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the buffer is empty or <b>false</b> otherwise. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

</div>
</div>
<a id="ga82b570fdc2ba2f888bcd48fe0e938892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82b570fdc2ba2f888bcd48fe0e938892">&sect;&nbsp;</a></span>USBRingBufFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties the ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to empty.</td></tr>
  </table>
  </dd>
</dl>
<p>Discards all data from the ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gab71a50c8eeb52f525a3a46d58a9bbddd">USBBufferFlush()</a>.</p>

</div>
</div>
<a id="gabfd09e3f14d20263bdef863ef2ab23f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd09e3f14d20263bdef863ef2ab23f0">&sect;&nbsp;</a></span>USBRingBufUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBRingBufUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of bytes stored in ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of bytes stored in the ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes stored in the ring buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga4d0e198851002d5f92bea0c97d79d0c1">USBBufferDataAvailable()</a>, <a class="el" href="group__usblib__buffer__api.html#gad4ddc9f6c45c2f9a3c78866253960f6f">USBBufferRead()</a>, <a class="el" href="group__usblib__buffer__api.html#gaaedcab8ad741bd7d8f67142397f72190">USBRingBufAdvanceRead()</a>, <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>, <a class="el" href="group__usblib__buffer__api.html#ga0a8114e76bcddb9800ca6eed068e290d">USBRingBufRead()</a>, and <a class="el" href="group__usblib__buffer__api.html#ga6f8e4b33fd61ac15ed8b7edc105f54a4">USBRingBufReadOne()</a>.</p>

</div>
</div>
<a id="gad0d7d9100742a5570812127625f6b36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0d7d9100742a5570812127625f6b36d">&sect;&nbsp;</a></span>USBRingBufFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBRingBufFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of bytes available in a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of bytes available in the ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes available in the ring buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga23136a5c833c931edaff7361fa670b26">USBBufferSpaceAvailable()</a>, <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a>, <a class="el" href="group__usblib__buffer__api.html#ga3ca58d9aacaa30f01232919ad757fdab">USBRingBufAdvanceWrite()</a>, <a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite()</a>, and <a class="el" href="group__usblib__buffer__api.html#gaa23b219a79b354c953efe83aa34aaa33">USBRingBufWriteOne()</a>.</p>

</div>
</div>
<a id="gaca25830827e91d90ec1bdd67f5e22393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca25830827e91d90ec1bdd67f5e22393">&sect;&nbsp;</a></span>USBRingBufContigUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBRingBufContigUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of contiguous bytes of data stored in ring buffer ahead of the current read pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of contiguous bytes of data available in the ring buffer ahead of the current read pointer. This represents the largest block of data which does not straddle the buffer wrap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of contiguous bytes available. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

</div>
</div>
<a id="ga16c7949e1a90566d5a33baa190eec941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c7949e1a90566d5a33baa190eec941">&sect;&nbsp;</a></span>USBRingBufContigFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBRingBufContigFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of contiguous free bytes available in a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of contiguous free bytes ahead of the current write pointer in the ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of contiguous bytes available in the ring buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

</div>
</div>
<a id="gadf87ff287a5f79c3de06b9c6c63262c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf87ff287a5f79c3de06b9c6c63262c0">&sect;&nbsp;</a></span>USBRingBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBRingBufSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size in bytes of a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>is the ring buffer object to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the size of the ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size in bytes of the ring buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>.</p>

</div>
</div>
<a id="ga6f8e4b33fd61ac15ed8b7edc105f54a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8e4b33fd61ac15ed8b7edc105f54a4">&sect;&nbsp;</a></span>USBRingBufReadOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBRingBufReadOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a single byte of data from a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to be written to.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a single byte of data from a ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The byte read from the ring buffer. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a03941128a8ce870e1f76ee16f812d3ce">tUSBRingBufObject::pui8Buf</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga0a8114e76bcddb9800ca6eed068e290d">USBRingBufRead()</a>.</p>

</div>
</div>
<a id="ga0a8114e76bcddb9800ca6eed068e290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a8114e76bcddb9800ca6eed068e290d">&sect;&nbsp;</a></span>USBRingBufRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to be read from. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>points to where the data should be stored. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a sequence of bytes from a ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="group__usblib__buffer__api.html#ga6f8e4b33fd61ac15ed8b7edc105f54a4">USBRingBufReadOne()</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gad4ddc9f6c45c2f9a3c78866253960f6f">USBBufferRead()</a>.</p>

</div>
</div>
<a id="gaaedcab8ad741bd7d8f67142397f72190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaedcab8ad741bd7d8f67142397f72190">&sect;&nbsp;</a></span>USBRingBufAdvanceRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufAdvanceRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes bytes from the ring buffer by advancing the read index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer from which bytes are to be removed. </td></tr>
    <tr><td class="paramname">ui32NumBytes</td><td>is the number of bytes to be removed from the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function advances the ring buffer read index by a given number of bytes, removing that number of bytes of data from the buffer. If <em>ui32NumBytes</em> is larger than the number of bytes currently in the buffer, the buffer is emptied.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, and <a class="el" href="group__usblib__buffer__api.html#gabfd09e3f14d20263bdef863ef2ab23f0">USBRingBufUsed()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga53216ef0ab2407938d1149eae92c12b8">USBBufferDataRemoved()</a>.</p>

</div>
</div>
<a id="ga3ca58d9aacaa30f01232919ad757fdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca58d9aacaa30f01232919ad757fdab">&sect;&nbsp;</a></span>USBRingBufAdvanceWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufAdvanceWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds bytes to the ring buffer by advancing the write index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to which bytes have been added. </td></tr>
    <tr><td class="paramname">ui32NumBytes</td><td>is the number of bytes added to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be used by clients who wish to add data to the buffer directly rather than via calls to <a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite()</a> or <a class="el" href="group__usblib__buffer__api.html#gaa23b219a79b354c953efe83aa34aaa33">USBRingBufWriteOne()</a>. It advances the write index by a given number of bytes.</p>
<dl class="section note"><dt>Note</dt><dd>It is considered an error if the <em>ui32NumBytes</em> parameter is larger than the amount of free space in the buffer and a debug build of this function will fail (ASSERT) if this condition is detected. In a release build, the buffer read pointer will be advanced if too much data is written but this will, of course, result in some of the oldest data in the buffer being discarded and also, depending upon how data is being read from the buffer, may result in a race condition which could corrupt the read pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>, and <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gab3ed19b71ad061a3c1e733b61f58fb2d">USBBufferDataWritten()</a>.</p>

</div>
</div>
<a id="gaa23b219a79b354c953efe83aa34aaa33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23b219a79b354c953efe83aa34aaa33">&sect;&nbsp;</a></span>USBRingBufWriteOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufWriteOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single byte of data to a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to be written to. </td></tr>
    <tr><td class="paramname">ui8Data</td><td>is the byte to be written.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes a single byte of data into a ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a03941128a8ce870e1f76ee16f812d3ce">tUSBRingBufObject::pui8Buf</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>, and <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#gab37d12ad9c5cef32d24dcd482d8938b4">USBRingBufWrite()</a>.</p>

</div>
</div>
<a id="gab37d12ad9c5cef32d24dcd482d8938b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37d12ad9c5cef32d24dcd482d8938b4">&sect;&nbsp;</a></span>USBRingBufWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to a ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to be written to. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>points to the data to be written. </td></tr>
    <tr><td class="paramname">ui32Length</td><td>is the number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<p>This function write a sequence of bytes into a ring buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="group__usblib__buffer__api.html#gad0d7d9100742a5570812127625f6b36d">USBRingBufFree()</a>, and <a class="el" href="group__usblib__buffer__api.html#gaa23b219a79b354c953efe83aa34aaa33">USBRingBufWriteOne()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga8efafc515898e1387ffacea9f50e4c15">USBBufferWrite()</a>.</p>

</div>
</div>
<a id="ga73e3e76878f71e93b02af15f41a6b993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e3e76878f71e93b02af15f41a6b993">&sect;&nbsp;</a></span>USBRingBufInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBRingBufInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_u_s_b_ring_buf_object.html">tUSBRingBufObject</a> *&#160;</td>
          <td class="paramname"><em>psUSBRingBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a ring buffer object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psUSBRingBuf</td><td>points to the ring buffer to be initialized. </td></tr>
    <tr><td class="paramname">pui8Buf</td><td>points to the data buffer to be used for the ring buffer. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes a ring buffer object, preparing it to store data.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__buffer__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a03941128a8ce870e1f76ee16f812d3ce">tUSBRingBufObject::pui8Buf</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#a85668cda127cada632b41db43bcb1b9e">tUSBRingBufObject::ui32ReadIndex</a>, <a class="el" href="structt_u_s_b_ring_buf_object.html#ad6f73058830fee2d64cd8249dfb4a926">tUSBRingBufObject::ui32Size</a>, and <a class="el" href="structt_u_s_b_ring_buf_object.html#aafdf0a7bdaff87637c76bbacf84c97f2">tUSBRingBufObject::ui32WriteIndex</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__buffer__api.html#ga856549d9a38cd3f277fb109641bee6f2">USBBufferInit()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
