<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>USBLibAPIGuide: Usblib_host_class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">USBLibAPIGuide
   &#160;<span id="projectnumber">1.00.00.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Usblib_host_class</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Usblib_host_class:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__usblib__host__class.png" border="0" alt="" usemap="#group____usblib____host____class"/>
<map name="group____usblib____host____class" id="group____usblib____host____class">
<area shape="rect" id="node1" href="group__usbchap9__src.html" title="Usbchap9_src" alt="" coords="327,5,439,32"/>
<area shape="rect" id="node2" href="group__hid__gamepad__device__class__api.html" title="Hid_gamepad_device\l_class_api" alt="" coords="302,57,465,98"/>
<area shape="rect" id="node3" href="group__hid__sensor__device__class__api.html" title="Hid_sensor_device_class_api" alt="" coords="278,123,489,149"/>
<area shape="rect" id="node4" href="group__hid__device__class__api.html" title="Hid_device_class_api" alt="" coords="303,176,464,203"/>
<area shape="rect" id="node5" href="group__cdc__device__class__api.html" title="Cdc_device_class_api" alt="" coords="302,227,465,253"/>
<area shape="rect" id="node7" href="group__hid__mouse__device__class__api.html" title="Hid_mouse_device_class_api" alt="" coords="277,277,489,304"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_u_s_b_audio_format.html">tUSBAudioFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_a_c_k_e_d.html">PACKED</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB_CDC_GET/SET_LINE_CODING request-specific data.  <a href="struct_p_a_c_k_e_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad08138d79f67854eeecedf8aa00a4aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gad08138d79f67854eeecedf8aa00a4aa4">INTERFACE_NUM_M</a>&#160;&#160;&#160;0x000000FF</td></tr>
<tr class="separator:gad08138d79f67854eeecedf8aa00a4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac787f136ea93a1bf94bc128c68d23055"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gac787f136ea93a1bf94bc128c68d23055">INTERFACE_ALTSETTING_M</a>&#160;&#160;&#160;0x0000FF00</td></tr>
<tr class="separator:gac787f136ea93a1bf94bc128c68d23055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae441b03a6a45f27f26825861a1e9bf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaae441b03a6a45f27f26825861a1e9bf1">INTERFACE_ALTSETTING_S</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gaae441b03a6a45f27f26825861a1e9bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e7fff5f4b55aa40d4e976fc103846b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab1e7fff5f4b55aa40d4e976fc103846b">INVALID_INTERFACE</a>&#160;&#160;&#160;0xffffffff</td></tr>
<tr class="separator:gab1e7fff5f4b55aa40d4e976fc103846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be972cd05ad6d81955b42c2f1050a77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga1be972cd05ad6d81955b42c2f1050a77">AUDIO_FLAG_OUT_ACTIVE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga1be972cd05ad6d81955b42c2f1050a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb17cfcbc03042558c6f19a893bb36f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaafb17cfcbc03042558c6f19a893bb36f">AUDIO_FLAG_IN_ACTIVE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gaafb17cfcbc03042558c6f19a893bb36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf9abc3d8353ecef4fb4491b5cf3a43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaedf9abc3d8353ecef4fb4491b5cf3a43">USBH_AUDIO_EVENT_OPEN</a>&#160;&#160;&#160;(<a class="el" href="group__usblib__events.html#ga4917d0aa7052bd10fc96d58325451233">USBH_AUDIO_EVENT_BASE</a> + 0)</td></tr>
<tr class="separator:gaedf9abc3d8353ecef4fb4491b5cf3a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814ee69240ad4e80c80c22e7057a9b14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga814ee69240ad4e80c80c22e7057a9b14">USBH_AUDIO_EVENT_CLOSE</a>&#160;&#160;&#160;(<a class="el" href="group__usblib__events.html#ga4917d0aa7052bd10fc96d58325451233">USBH_AUDIO_EVENT_BASE</a> + 1)</td></tr>
<tr class="separator:ga814ee69240ad4e80c80c22e7057a9b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb72eae6e9f259e9fdf6472c2a9b883"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga0eb72eae6e9f259e9fdf6472c2a9b883">USBH_AUDIO_FORMAT_IN</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga0eb72eae6e9f259e9fdf6472c2a9b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456ae436ea8b445d8bb2fb37ad2cac01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga456ae436ea8b445d8bb2fb37ad2cac01">USBH_AUDIO_FORMAT_OUT</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga456ae436ea8b445d8bb2fb37ad2cac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967fc671f8f299b17a383a3699eb3f12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga967fc671f8f299b17a383a3699eb3f12">MAX_HID_DEVICES</a>&#160;&#160;&#160;<a class="el" href="usblib_8h.html#a062bf64e497f39bd2e98dc55219b7522">MAX_USB_DEVICES</a></td></tr>
<tr class="separator:ga967fc671f8f299b17a383a3699eb3f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aac4d088468adc74fb5ee93ffe1a55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaa8aac4d088468adc74fb5ee93ffe1a55">USBH_EVENT_HID_SETRPT</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 0</td></tr>
<tr class="separator:gaa8aac4d088468adc74fb5ee93ffe1a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bf7863a46aa3fba6474220066d7c8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga73bf7863a46aa3fba6474220066d7c8e">USBH_EVENT_HID_REPORT</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 1</td></tr>
<tr class="separator:ga73bf7863a46aa3fba6474220066d7c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713352c6f7895bbcebd31cdb4f089e22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga713352c6f7895bbcebd31cdb4f089e22">USBH_EVENT_HID_KB_PRESS</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 16</td></tr>
<tr class="memdesc:ga713352c6f7895bbcebd31cdb4f089e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HID keyboard detected a key being pressed.  <a href="#ga713352c6f7895bbcebd31cdb4f089e22">More...</a><br /></td></tr>
<tr class="separator:ga713352c6f7895bbcebd31cdb4f089e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9b00fa1c9258f91ba76689d9d99291"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaec9b00fa1c9258f91ba76689d9d99291">USBH_EVENT_HID_KB_REL</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 17</td></tr>
<tr class="memdesc:gaec9b00fa1c9258f91ba76689d9d99291"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HID keyboard detected a key being released.  <a href="#gaec9b00fa1c9258f91ba76689d9d99291">More...</a><br /></td></tr>
<tr class="separator:gaec9b00fa1c9258f91ba76689d9d99291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0301f4124ea393a9f7d4c28106854b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaa0301f4124ea393a9f7d4c28106854b8">USBH_EVENT_HID_KB_MOD</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 18</td></tr>
<tr class="memdesc:gaa0301f4124ea393a9f7d4c28106854b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HID keyboard detected one of the keyboard modifiers being pressed.  <a href="#gaa0301f4124ea393a9f7d4c28106854b8">More...</a><br /></td></tr>
<tr class="separator:gaa0301f4124ea393a9f7d4c28106854b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d8f6369fc3050965825696d9740f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga46d8f6369fc3050965825696d9740f8f">USBH_EVENT_HID_MS_PRESS</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 32</td></tr>
<tr class="memdesc:ga46d8f6369fc3050965825696d9740f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A button was pressed on a HID mouse.  <a href="#ga46d8f6369fc3050965825696d9740f8f">More...</a><br /></td></tr>
<tr class="separator:ga46d8f6369fc3050965825696d9740f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227fd24912cfe564853264ea8c2ecaf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga227fd24912cfe564853264ea8c2ecaf0">USBH_EVENT_HID_MS_REL</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 33</td></tr>
<tr class="memdesc:ga227fd24912cfe564853264ea8c2ecaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A button was released on a HID mouse.  <a href="#ga227fd24912cfe564853264ea8c2ecaf0">More...</a><br /></td></tr>
<tr class="separator:ga227fd24912cfe564853264ea8c2ecaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29eb2e47af48083c26858d297468d1af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga29eb2e47af48083c26858d297468d1af">USBH_EVENT_HID_MS_X</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 34</td></tr>
<tr class="memdesc:ga29eb2e47af48083c26858d297468d1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HID mouse detected movement in the X direction.  <a href="#ga29eb2e47af48083c26858d297468d1af">More...</a><br /></td></tr>
<tr class="separator:ga29eb2e47af48083c26858d297468d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e0e03de352a054f3b9379b729b4779"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga16e0e03de352a054f3b9379b729b4779">USBH_EVENT_HID_MS_Y</a>&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 35</td></tr>
<tr class="memdesc:ga16e0e03de352a054f3b9379b729b4779"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HID mouse detected movement in the Y direction.  <a href="#ga16e0e03de352a054f3b9379b729b4779">More...</a><br /></td></tr>
<tr class="separator:ga16e0e03de352a054f3b9379b729b4779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b105bf9848fd6c899c07359a75af2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab2b105bf9848fd6c899c07359a75af2b">USBLIB_HUB_ACTIVE</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:gab2b105bf9848fd6c899c07359a75af2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf386184df8a50f87c5586bfb5bf33256"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaf386184df8a50f87c5586bfb5bf33256">USBLIB_HUB_HS</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gaf386184df8a50f87c5586bfb5bf33256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71cdbec17b79ea2fa16a43629c6971c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gac71cdbec17b79ea2fa16a43629c6971c">USBLIB_HUB_MULTI_TT</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:gac71cdbec17b79ea2fa16a43629c6971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cd2b1977ea5f7980cd753b7e5feb5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga60cd2b1977ea5f7980cd753b7e5feb5c">MSC_EVENT_OPEN</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga60cd2b1977ea5f7980cd753b7e5feb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ac4002e61f188b987f1ed69b2dd32b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gae7ac4002e61f188b987f1ed69b2dd32b">MSC_EVENT_CLOSE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gae7ac4002e61f188b987f1ed69b2dd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b9b1d4beb4947a99306da0cf307c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga61b9b1d4beb4947a99306da0cf307c4c">CBW_TAG_VALUE</a>&#160;&#160;&#160;0x54231990</td></tr>
<tr class="separator:ga61b9b1d4beb4947a99306da0cf307c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2e4175a2a6520e49bf29996f6a58d0e7"><td class="memItemLeft" align="right" valign="top">typedef struct tUSBHostAudioInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a></td></tr>
<tr class="separator:ga2e4175a2a6520e49bf29996f6a58d0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534eb8f6d4bbf15fff626d2e3778a641"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a>) (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Event, uint32_t ui32MsgParam, void *pvMsgData)</td></tr>
<tr class="separator:ga534eb8f6d4bbf15fff626d2e3778a641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76a2e328502c4443d4cfd9e706a8853"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gac76a2e328502c4443d4cfd9e706a8853">tHIDInstance</a></td></tr>
<tr class="separator:gac76a2e328502c4443d4cfd9e706a8853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3872a5c5c4b016c03952a48ce23d9632"><td class="memItemLeft" align="right" valign="top">typedef struct tUSBHMSCInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a></td></tr>
<tr class="separator:ga3872a5c5c4b016c03952a48ce23d9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee0ba89f6686e6a7d46b0b89577a447"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga3ee0ba89f6686e6a7d46b0b89577a447">tUSBHMSCCallback</a>) (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance, uint32_t ui32Event, void *pvEventData)</td></tr>
<tr class="separator:ga3ee0ba89f6686e6a7d46b0b89577a447"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa010a3a0cde509bc55412c6662a9ca13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaa010a3a0cde509bc55412c6662a9ca13">tHIDSubClassProtocol</a> { <a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13abf5f24b7c0e3287aa36cdb6d34ff4f38">eUSBHHIDClassNone</a> = 0, 
<a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13a420bad522e6f4172706d3307a1ed46ee">eUSBHHIDClassKeyboard</a>, 
<a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13a75e05afb2d407d9238131caac8606e55">eUSBHHIDClassMouse</a>, 
<a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13a5c0682a2959bf754a8d069dd8b73a3a2">eUSBHHIDClassVendor</a>
 }</td></tr>
<tr class="separator:gaa010a3a0cde509bc55412c6662a9ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab07ba21f6143babf719c934666532f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen</a> (uint32_t ui32Index, <a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a> pfnCallback)</td></tr>
<tr class="separator:gab07ba21f6143babf719c934666532f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a0507a1393de4ccc9147bbe3583af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga19a0507a1393de4ccc9147bbe3583af8">USBHostAudioClose</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance)</td></tr>
<tr class="separator:ga19a0507a1393de4ccc9147bbe3583af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b39f590e076ead17ae088483c878fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga34b39f590e076ead17ae088483c878fe">USBHostAudioVolumeGet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Interface, uint32_t ui32Channel)</td></tr>
<tr class="separator:ga34b39f590e076ead17ae088483c878fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0336c76517420047d24b840e149705"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga8c0336c76517420047d24b840e149705">USBHostAudioVolumeMaxGet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Interface, uint32_t ui32Channel)</td></tr>
<tr class="separator:ga8c0336c76517420047d24b840e149705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f28838d2cc84fd2b0d493fddaa57314"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga1f28838d2cc84fd2b0d493fddaa57314">USBHostAudioVolumeMinGet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Interface, uint32_t ui32Channel)</td></tr>
<tr class="separator:ga1f28838d2cc84fd2b0d493fddaa57314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad618c37156f86b80d734dace485600f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gad618c37156f86b80d734dace485600f9">USBHostAudioVolumeResGet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Interface, uint32_t ui32Channel)</td></tr>
<tr class="separator:gad618c37156f86b80d734dace485600f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecda02fbcb26d6fad0d5d05ed86a9a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga5ecda02fbcb26d6fad0d5d05ed86a9a5">USBHostAudioVolumeSet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Interface, uint32_t ui32Channel, uint32_t ui32Value)</td></tr>
<tr class="separator:ga5ecda02fbcb26d6fad0d5d05ed86a9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda66da1a449f0337c2c3f21cb499182"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gafda66da1a449f0337c2c3f21cb499182">USBHostAudioFormatGet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32SampleRate, uint32_t ui32Bits, uint32_t ui32Channels, uint32_t ui32Flags)</td></tr>
<tr class="separator:gafda66da1a449f0337c2c3f21cb499182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f5dbe05f8c6e7a5140e65a5b237164"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gae1f5dbe05f8c6e7a5140e65a5b237164">USBHostAudioFormatSet</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32SampleRate, uint32_t ui32Bits, uint32_t ui32Channels, uint32_t ui32Flags)</td></tr>
<tr class="separator:gae1f5dbe05f8c6e7a5140e65a5b237164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0cd88dd6bf6531fb8d3456c858d7b2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaee0cd88dd6bf6531fb8d3456c858d7b2">USBHostAudioPlay</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, void *pvBuffer, uint32_t ui32Size, <a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a> pfnCallback)</td></tr>
<tr class="separator:gaee0cd88dd6bf6531fb8d3456c858d7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551ad61aeb9f64111c9db7fad742c48"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga2551ad61aeb9f64111c9db7fad742c48">USBHostAudioRecord</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, void *pvBuffer, uint32_t ui32Size, <a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a> pfnCallback)</td></tr>
<tr class="separator:ga2551ad61aeb9f64111c9db7fad742c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc2fb766353fb5ee10230fb27b07dd2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga6cc2fb766353fb5ee10230fb27b07dd2">USBHostAudioLPMSleep</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance)</td></tr>
<tr class="separator:ga6cc2fb766353fb5ee10230fb27b07dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b202c0868d3b00f07aba76abb0b6a2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga5b202c0868d3b00f07aba76abb0b6a2f">USBHostAudioLPMStatus</a> (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance)</td></tr>
<tr class="separator:ga5b202c0868d3b00f07aba76abb0b6a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07a8033d7519a9489d46e680a6f3bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen</a> (<a class="el" href="group__usblib__host__class.html#gaa010a3a0cde509bc55412c6662a9ca13">tHIDSubClassProtocol</a> iDeviceType, <a class="el" href="group__general__usblib__api.html#ga28b2c7063c0895d2a98a78918d907f90">tUSBCallback</a> pfnCallback, void *pvCBData)</td></tr>
<tr class="separator:gab07a8033d7519a9489d46e680a6f3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f13efcf4cc8661db1b59ec27b73c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga60f13efcf4cc8661db1b59ec27b73c00">USBHHIDClose</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance)</td></tr>
<tr class="separator:ga60f13efcf4cc8661db1b59ec27b73c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde7ecf8d577f1a6c34f4014553708be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gadde7ecf8d577f1a6c34f4014553708be">USBHHIDSetIdle</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance, uint8_t ui8Duration, uint8_t ui8ReportID)</td></tr>
<tr class="separator:gadde7ecf8d577f1a6c34f4014553708be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f42ac242c24f0dc097ed999c28951b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga60f42ac242c24f0dc097ed999c28951b">USBHHIDGetReportDescriptor</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance, uint8_t *pui8Buffer, uint32_t ui32Size)</td></tr>
<tr class="separator:ga60f42ac242c24f0dc097ed999c28951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace42556c163b54cf10c1e9086521ff86"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gace42556c163b54cf10c1e9086521ff86">USBHHIDSetProtocol</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance, uint32_t ui32BootProtocol)</td></tr>
<tr class="separator:gace42556c163b54cf10c1e9086521ff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38170ed323efd3f4752252aa9aaa2401"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga38170ed323efd3f4752252aa9aaa2401">USBHHIDGetReport</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance, uint32_t ui32Interface, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:ga38170ed323efd3f4752252aa9aaa2401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e8d86b812d94d07b2e14591661910c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga95e8d86b812d94d07b2e14591661910c">USBHHIDSetReport</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance, uint32_t ui32Interface, uint8_t *pui8Data, uint32_t ui32Size)</td></tr>
<tr class="separator:ga95e8d86b812d94d07b2e14591661910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c436efb2b57e84241f2d6ec2e9719ec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga0c436efb2b57e84241f2d6ec2e9719ec">USBHHIDLPMSleep</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance)</td></tr>
<tr class="separator:ga0c436efb2b57e84241f2d6ec2e9719ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208c5fe377e8d9e93a835d0a6ec7a2cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga208c5fe377e8d9e93a835d0a6ec7a2cf">USBHHIDLPMStatus</a> (<a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *psHIDInstance)</td></tr>
<tr class="separator:ga208c5fe377e8d9e93a835d0a6ec7a2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b8837c6450481ab5cc6ff17793cff79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga9b8837c6450481ab5cc6ff17793cff79">USBHHubMain</a> (void)</td></tr>
<tr class="separator:ga9b8837c6450481ab5cc6ff17793cff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1be9548f40a8c469a9317c90ca21419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab1be9548f40a8c469a9317c90ca21419">USBHHubEnumerationComplete</a> (uint8_t ui8Hub, uint8_t ui8Port)</td></tr>
<tr class="separator:gab1be9548f40a8c469a9317c90ca21419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0903016a6157d46291b8ccddf838b658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga0903016a6157d46291b8ccddf838b658">USBHHubEnumerationError</a> (uint8_t ui8Hub, uint8_t ui8Port)</td></tr>
<tr class="separator:ga0903016a6157d46291b8ccddf838b658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501561d026c8cdedc510c0d60fdbb3a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga501561d026c8cdedc510c0d60fdbb3a3">USBHHubOpen</a> (<a class="el" href="usbhhub_8h.html#aafa05f5fe8ebff2241255c1f8520f45a">tUSBHHubCallback</a> pfnCallback)</td></tr>
<tr class="separator:ga501561d026c8cdedc510c0d60fdbb3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2145b63f3d8e22fd78a2e800793cef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaf2145b63f3d8e22fd78a2e800793cef8">USBHHubClose</a> (<a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *psHubInstance)</td></tr>
<tr class="separator:gaf2145b63f3d8e22fd78a2e800793cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb95931c55ea3ac9811d549d2b4eac97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gacb95931c55ea3ac9811d549d2b4eac97">USBHHubInit</a> (void)</td></tr>
<tr class="separator:gacb95931c55ea3ac9811d549d2b4eac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga463b791f9b743cd981cbdb487a5fcfe3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga463b791f9b743cd981cbdb487a5fcfe3">USBHHubLPMSleep</a> (<a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *psHubInstance)</td></tr>
<tr class="separator:ga463b791f9b743cd981cbdb487a5fcfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5d43391f05dcd1cbaa77cc44fb0472"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga2d5d43391f05dcd1cbaa77cc44fb0472">USBHHubLPMStatus</a> (<a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *psHubInstance)</td></tr>
<tr class="separator:ga2d5d43391f05dcd1cbaa77cc44fb0472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad78892088fb13e7b1cf312d3ecade497"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gad78892088fb13e7b1cf312d3ecade497">USBHMSCDriveReady</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance)</td></tr>
<tr class="separator:gad78892088fb13e7b1cf312d3ecade497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630c1582450053d4e0e6da13260d9a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga630c1582450053d4e0e6da13260d9a80">USBHMSCDriveOpen</a> (uint32_t ui32Drive, <a class="el" href="group__usblib__host__class.html#ga3ee0ba89f6686e6a7d46b0b89577a447">tUSBHMSCCallback</a> pfnCallback)</td></tr>
<tr class="separator:ga630c1582450053d4e0e6da13260d9a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7259732b5526edf9d0cad15d645b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gacc7259732b5526edf9d0cad15d645b1d">USBHMSCDriveClose</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance)</td></tr>
<tr class="separator:gacc7259732b5526edf9d0cad15d645b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7f1953ba798a4a9e97dc69ed5af010"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga2a7f1953ba798a4a9e97dc69ed5af010">USBHMSCBlockRead</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance, uint32_t ui32LBA, uint8_t *pui8Data, uint32_t ui32NumBlocks)</td></tr>
<tr class="separator:ga2a7f1953ba798a4a9e97dc69ed5af010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f8f8fd0d8a435275175d5ec9dbbe8d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gad5f8f8fd0d8a435275175d5ec9dbbe8d">USBHMSCBlockWrite</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance, uint32_t ui32LBA, uint8_t *pui8Data, uint32_t ui32NumBlocks)</td></tr>
<tr class="separator:gad5f8f8fd0d8a435275175d5ec9dbbe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1462107691a9229ad16397781056b72"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab1462107691a9229ad16397781056b72">USBHMSCLPMSleep</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance)</td></tr>
<tr class="separator:gab1462107691a9229ad16397781056b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6809a58356c09139db0d10df4b1a7277"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga6809a58356c09139db0d10df4b1a7277">USBHMSCLPMStatus</a> (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance)</td></tr>
<tr class="separator:ga6809a58356c09139db0d10df4b1a7277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38e2ffcdbe0169fe7098dafe6cccffd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gae38e2ffcdbe0169fe7098dafe6cccffd">USBHSCSIInquiry</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint8_t *pui8Data, uint32_t *pui32Size)</td></tr>
<tr class="separator:gae38e2ffcdbe0169fe7098dafe6cccffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319f25cf2c45b091bccde4f48f01637e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga319f25cf2c45b091bccde4f48f01637e">USBHSCSIReadCapacity</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint8_t *pui8Data, uint32_t *pui32Size)</td></tr>
<tr class="separator:ga319f25cf2c45b091bccde4f48f01637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cee0ad0998e50dbf11ea4504f22e136"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga0cee0ad0998e50dbf11ea4504f22e136">USBHSCSIReadCapacities</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint8_t *pui8Data, uint32_t *pui32Size)</td></tr>
<tr class="separator:ga0cee0ad0998e50dbf11ea4504f22e136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdf1d0c381b3afe65bb4e0b59952dbb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gabbdf1d0c381b3afe65bb4e0b59952dbb">USBHSCSIModeSense6</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint32_t ui32Flags, uint8_t *pui8Data, uint32_t *pui32Size)</td></tr>
<tr class="separator:gabbdf1d0c381b3afe65bb4e0b59952dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac4fdaa650ec718dd306eea476c72aa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga6ac4fdaa650ec718dd306eea476c72aa">USBHSCSITestUnitReady</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe)</td></tr>
<tr class="separator:ga6ac4fdaa650ec718dd306eea476c72aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ca18fb4dc111b02b3a29dfbe6534956"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga5ca18fb4dc111b02b3a29dfbe6534956">USBHSCSIRequestSense</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint8_t *pui8Data, uint32_t *pui32Size)</td></tr>
<tr class="separator:ga5ca18fb4dc111b02b3a29dfbe6534956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5281f9f2f24b4c9d5600983f2906bb9a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga5281f9f2f24b4c9d5600983f2906bb9a">USBHSCSIRead10</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint32_t ui32LBA, uint8_t *pui8Data, uint32_t *pui32Size, uint32_t ui32NumBlocks)</td></tr>
<tr class="separator:ga5281f9f2f24b4c9d5600983f2906bb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab977c4bfa1de53ba703a94c2ae71a32f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gab977c4bfa1de53ba703a94c2ae71a32f">USBHSCSIWrite10</a> (uint32_t ui32InPipe, uint32_t ui32OutPipe, uint32_t ui32LBA, uint8_t *pui8Data, uint32_t *pui32Size, uint32_t ui32NumBlocks)</td></tr>
<tr class="separator:gab977c4bfa1de53ba703a94c2ae71a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafa3dfe63aeb55ea6331618a61fa9b5a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gafa3dfe63aeb55ea6331618a61fa9b5a0">g_sUSBHostAudioClassDriver</a></td></tr>
<tr class="separator:gafa3dfe63aeb55ea6331618a61fa9b5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a50a22f781052b2b7d4685070aad569"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga0a50a22f781052b2b7d4685070aad569">g_sUSBHIDClassDriver</a></td></tr>
<tr class="separator:ga0a50a22f781052b2b7d4685070aad569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59334d8374485bdc7a741e6f6977f70c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#ga59334d8374485bdc7a741e6f6977f70c">g_sUSBHubClassDriver</a></td></tr>
<tr class="separator:ga59334d8374485bdc7a741e6f6977f70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf46ea1c58fa7fd6e70a661a16c33907"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usblib__host__class.html#gaaf46ea1c58fa7fd6e70a661a16c33907">g_sUSBHostMSCClassDriver</a></td></tr>
<tr class="separator:gaaf46ea1c58fa7fd6e70a661a16c33907"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad08138d79f67854eeecedf8aa00a4aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08138d79f67854eeecedf8aa00a4aa4">&sect;&nbsp;</a></span>INTERFACE_NUM_M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERFACE_NUM_M&#160;&#160;&#160;0x000000FF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac787f136ea93a1bf94bc128c68d23055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac787f136ea93a1bf94bc128c68d23055">&sect;&nbsp;</a></span>INTERFACE_ALTSETTING_M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERFACE_ALTSETTING_M&#160;&#160;&#160;0x0000FF00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaae441b03a6a45f27f26825861a1e9bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae441b03a6a45f27f26825861a1e9bf1">&sect;&nbsp;</a></span>INTERFACE_ALTSETTING_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERFACE_ALTSETTING_S&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab1e7fff5f4b55aa40d4e976fc103846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e7fff5f4b55aa40d4e976fc103846b">&sect;&nbsp;</a></span>INVALID_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_INTERFACE&#160;&#160;&#160;0xffffffff</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1be972cd05ad6d81955b42c2f1050a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be972cd05ad6d81955b42c2f1050a77">&sect;&nbsp;</a></span>AUDIO_FLAG_OUT_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AUDIO_FLAG_OUT_ACTIVE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__host__class.html#gaee0cd88dd6bf6531fb8d3456c858d7b2">USBHostAudioPlay()</a>.</p>

</div>
</div>
<a id="gaafb17cfcbc03042558c6f19a893bb36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafb17cfcbc03042558c6f19a893bb36f">&sect;&nbsp;</a></span>AUDIO_FLAG_IN_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AUDIO_FLAG_IN_ACTIVE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga2551ad61aeb9f64111c9db7fad742c48">USBHostAudioRecord()</a>.</p>

</div>
</div>
<a id="gaedf9abc3d8353ecef4fb4491b5cf3a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf9abc3d8353ecef4fb4491b5cf3a43">&sect;&nbsp;</a></span>USBH_AUDIO_EVENT_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_AUDIO_EVENT_OPEN&#160;&#160;&#160;(<a class="el" href="group__usblib__events.html#ga4917d0aa7052bd10fc96d58325451233">USBH_AUDIO_EVENT_BASE</a> + 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This USB host audio event indicates that the device is connected and ready to send or receive buffers. The <em>pvBuffer</em> and <em>ui32Param</em> values are not used in this event. </p>

</div>
</div>
<a id="ga814ee69240ad4e80c80c22e7057a9b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814ee69240ad4e80c80c22e7057a9b14">&sect;&nbsp;</a></span>USBH_AUDIO_EVENT_CLOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_AUDIO_EVENT_CLOSE&#160;&#160;&#160;(<a class="el" href="group__usblib__events.html#ga4917d0aa7052bd10fc96d58325451233">USBH_AUDIO_EVENT_BASE</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This USB host audio event indicates that the previously connected device has been disconnected. The <em>pvBuffer</em> and <em>ui32Param</em> values are not used in this event. </p>

</div>
</div>
<a id="ga0eb72eae6e9f259e9fdf6472c2a9b883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb72eae6e9f259e9fdf6472c2a9b883">&sect;&nbsp;</a></span>USBH_AUDIO_FORMAT_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_AUDIO_FORMAT_IN&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga456ae436ea8b445d8bb2fb37ad2cac01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456ae436ea8b445d8bb2fb37ad2cac01">&sect;&nbsp;</a></span>USBH_AUDIO_FORMAT_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_AUDIO_FORMAT_OUT&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga967fc671f8f299b17a383a3699eb3f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967fc671f8f299b17a383a3699eb3f12">&sect;&nbsp;</a></span>MAX_HID_DEVICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_HID_DEVICES&#160;&#160;&#160;<a class="el" href="usblib_8h.html#a062bf64e497f39bd2e98dc55219b7522">MAX_USB_DEVICES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>.</p>

</div>
</div>
<a id="gaa8aac4d088468adc74fb5ee93ffe1a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8aac4d088468adc74fb5ee93ffe1a55">&sect;&nbsp;</a></span>USBH_EVENT_HID_SETRPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_SETRPT&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga73bf7863a46aa3fba6474220066d7c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73bf7863a46aa3fba6474220066d7c8e">&sect;&nbsp;</a></span>USBH_EVENT_HID_REPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_REPORT&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga713352c6f7895bbcebd31cdb4f089e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713352c6f7895bbcebd31cdb4f089e22">&sect;&nbsp;</a></span>USBH_EVENT_HID_KB_PRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_KB_PRESS&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HID keyboard detected a key being pressed. </p>

</div>
</div>
<a id="gaec9b00fa1c9258f91ba76689d9d99291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9b00fa1c9258f91ba76689d9d99291">&sect;&nbsp;</a></span>USBH_EVENT_HID_KB_REL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_KB_REL&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 17</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HID keyboard detected a key being released. </p>

</div>
</div>
<a id="gaa0301f4124ea393a9f7d4c28106854b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0301f4124ea393a9f7d4c28106854b8">&sect;&nbsp;</a></span>USBH_EVENT_HID_KB_MOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_KB_MOD&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HID keyboard detected one of the keyboard modifiers being pressed. </p>

</div>
</div>
<a id="ga46d8f6369fc3050965825696d9740f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d8f6369fc3050965825696d9740f8f">&sect;&nbsp;</a></span>USBH_EVENT_HID_MS_PRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_MS_PRESS&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A button was pressed on a HID mouse. </p>

</div>
</div>
<a id="ga227fd24912cfe564853264ea8c2ecaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga227fd24912cfe564853264ea8c2ecaf0">&sect;&nbsp;</a></span>USBH_EVENT_HID_MS_REL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_MS_REL&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 33</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A button was released on a HID mouse. </p>

</div>
</div>
<a id="ga29eb2e47af48083c26858d297468d1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29eb2e47af48083c26858d297468d1af">&sect;&nbsp;</a></span>USBH_EVENT_HID_MS_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_MS_X&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 34</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HID mouse detected movement in the X direction. </p>

</div>
</div>
<a id="ga16e0e03de352a054f3b9379b729b4779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e0e03de352a054f3b9379b729b4779">&sect;&nbsp;</a></span>USBH_EVENT_HID_MS_Y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_EVENT_HID_MS_Y&#160;&#160;&#160;<a class="el" href="group__usblib__events.html#ga7eaedf39bd45c20ab206f3d89d5feabc">USBH_HID_EVENT_BASE</a> + 35</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HID mouse detected movement in the Y direction. </p>

</div>
</div>
<a id="gab2b105bf9848fd6c899c07359a75af2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b105bf9848fd6c899c07359a75af2b">&sect;&nbsp;</a></span>USBLIB_HUB_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_HUB_ACTIVE&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga9b8837c6450481ab5cc6ff17793cff79">USBHHubMain()</a>.</p>

</div>
</div>
<a id="gaf386184df8a50f87c5586bfb5bf33256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf386184df8a50f87c5586bfb5bf33256">&sect;&nbsp;</a></span>USBLIB_HUB_HS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_HUB_HS&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac71cdbec17b79ea2fa16a43629c6971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71cdbec17b79ea2fa16a43629c6971c">&sect;&nbsp;</a></span>USBLIB_HUB_MULTI_TT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBLIB_HUB_MULTI_TT&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga60cd2b1977ea5f7980cd753b7e5feb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60cd2b1977ea5f7980cd753b7e5feb5c">&sect;&nbsp;</a></span>MSC_EVENT_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSC_EVENT_OPEN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae7ac4002e61f188b987f1ed69b2dd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ac4002e61f188b987f1ed69b2dd32b">&sect;&nbsp;</a></span>MSC_EVENT_CLOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSC_EVENT_CLOSE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga61b9b1d4beb4947a99306da0cf307c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b9b1d4beb4947a99306da0cf307c4c">&sect;&nbsp;</a></span>CBW_TAG_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CBW_TAG_VALUE&#160;&#160;&#160;0x54231990</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2e4175a2a6520e49bf29996f6a58d0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4175a2a6520e49bf29996f6a58d0e7">&sect;&nbsp;</a></span>tUSBHostAudioInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct tUSBHostAudioInstance tUSBHostAudioInstance</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga534eb8f6d4bbf15fff626d2e3778a641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga534eb8f6d4bbf15fff626d2e3778a641">&sect;&nbsp;</a></span>tUSBHostAudioCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tUSBHostAudioCallback) (<a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *psAudioInstance, uint32_t ui32Event, uint32_t ui32MsgParam, void *pvMsgData)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac76a2e328502c4443d4cfd9e706a8853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76a2e328502c4443d4cfd9e706a8853">&sect;&nbsp;</a></span>tHIDInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> <a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3872a5c5c4b016c03952a48ce23d9632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3872a5c5c4b016c03952a48ce23d9632">&sect;&nbsp;</a></span>tUSBHMSCInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct tUSBHMSCInstance tUSBHMSCInstance</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3ee0ba89f6686e6a7d46b0b89577a447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee0ba89f6686e6a7d46b0b89577a447">&sect;&nbsp;</a></span>tUSBHMSCCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tUSBHMSCCallback) (<a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *psMSCInstance, uint32_t ui32Event, void *pvEventData)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa010a3a0cde509bc55412c6662a9ca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa010a3a0cde509bc55412c6662a9ca13">&sect;&nbsp;</a></span>tHIDSubClassProtocol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__usblib__host__class.html#gaa010a3a0cde509bc55412c6662a9ca13">tHIDSubClassProtocol</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following values are used to register callbacks to the USB HOST HID device class layer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa010a3a0cde509bc55412c6662a9ca13abf5f24b7c0e3287aa36cdb6d34ff4f38"></a>eUSBHHIDClassNone&#160;</td><td class="fielddoc"><p>No device should be used. This value should not be used by applications. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa010a3a0cde509bc55412c6662a9ca13a420bad522e6f4172706d3307a1ed46ee"></a>eUSBHHIDClassKeyboard&#160;</td><td class="fielddoc"><p>This is a keyboard device. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa010a3a0cde509bc55412c6662a9ca13a75e05afb2d407d9238131caac8606e55"></a>eUSBHHIDClassMouse&#160;</td><td class="fielddoc"><p>This is a mouse device. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa010a3a0cde509bc55412c6662a9ca13a5c0682a2959bf754a8d069dd8b73a3a2"></a>eUSBHHIDClassVendor&#160;</td><td class="fielddoc"><p>This is a vendor specific device. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab07ba21f6143babf719c934666532f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab07ba21f6143babf719c934666532f57">&sect;&nbsp;</a></span>USBHostAudioOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> * USBHostAudioOpen </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called before any devices are present to enable the host audio class driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Index</td><td>is the audio device to open (currently only 0 is supported). </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is the driver call back for host audio events.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called to open an instance of a host audio device and should provide a valid callback function for host audio events in the <em>pfnCallback</em> parameter. This function must be called before the USB host code can successfully enumerate an audio device.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the driver instance to use for the other host audio functions. If there is no instance available at the time of this call, this function returns zero. </dd></dl>

</div>
</div>
<a id="ga19a0507a1393de4ccc9147bbe3583af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a0507a1393de4ccc9147bbe3583af8">&sect;&nbsp;</a></span>USBHostAudioClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHostAudioClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called to release an audio device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is the device instance that is to be released.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when a host audio device needs to be released. This could be in preparation for shutdown or a switch to USB device mode, for example. Following this call, the audio device is available and can be opened again using a call to <a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen()</a>. After calling this function, the host audio driver will no longer provide any callbacks or accept calls to other audio driver APIs.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga34b39f590e076ead17ae088483c878fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34b39f590e076ead17ae088483c878fe">&sect;&nbsp;</a></span>USBHostAudioVolumeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioVolumeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the current volume setting for a given audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is an instance of the USB audio device. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to use to query the current volume setting. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the 0 based channel number to query.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to retrieve the current volume setting for an audio device on the channel specified by <em>ui32Channel</em>. The <em>ui32Interface</em> is ignored for now and should be set to 0 to access the default audio control interface. The <em>ui32Channel</em> value starts with 0 which is the master audio volume control interface. The remaining <em>ui32Channel</em> values provide access to various other audio channels, with 1 and 2 being left and right audio channels.</p>
<dl class="section note"><dt>Note</dt><dd>On devices that do not support volume control interfaces, this call returns 0, indicating a 0db setting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current volume setting for the requested interface. </dd></dl>

</div>
</div>
<a id="ga8c0336c76517420047d24b840e149705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0336c76517420047d24b840e149705">&sect;&nbsp;</a></span>USBHostAudioVolumeMaxGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioVolumeMaxGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the maximum volume setting for a given audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is an instance of the USB audio device. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to use to query the maximum volume control value. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the 0 based channel number to query.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to retrieve the maximum volume setting for an audio device on the channel specified by <em>ui32Channel</em>. The <em>ui32Interface</em> is ignored for now and should be set to 0 to access the default audio control interface. The <em>ui32Channel</em> value starts with 0 which is the master audio volume control interface. The remaining <em>ui32Channel</em> values provide access to various other audio channels, with 1 and 2 being left and right audio channels.</p>
<dl class="section note"><dt>Note</dt><dd>On devices that do not support volume control interfaces, this call returns 0, indicating a 0db setting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum volume setting for the requested interface. </dd></dl>

</div>
</div>
<a id="ga1f28838d2cc84fd2b0d493fddaa57314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f28838d2cc84fd2b0d493fddaa57314">&sect;&nbsp;</a></span>USBHostAudioVolumeMinGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioVolumeMinGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the minimum volume setting for a given audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is an instance of the USB audio device. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to use to query the minimum volume control value. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the 0 based channel number to query.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to retrieve the minimum volume setting for an audio device on the channel specified by <em>ui32Channel</em>. The <em>ui32Interface</em> is ignored for now and should be set to 0 to access the default audio control interface. The <em>ui32Channel</em> value starts with 0 which is the master audio volume control interface. The remaining <em>ui32Channel</em> values provide access to various other audio channels, with 1 and 2 being left and right audio channels.</p>
<dl class="section note"><dt>Note</dt><dd>On devices that do not support volume control interfaces, this call returns 0, indicating a 0db setting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the minimum volume setting for the requested interface. </dd></dl>

</div>
</div>
<a id="gad618c37156f86b80d734dace485600f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad618c37156f86b80d734dace485600f9">&sect;&nbsp;</a></span>USBHostAudioVolumeResGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioVolumeResGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the volume control resolution for a given audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is an instance of the USB audio device. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to use to query the resolution for the volume control. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the 0 based channel number to query.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to retrieve the volume control resolution for an audio device on the channel specified by <em>ui32Channel</em>. The <em>ui32Interface</em> is ignored for now and should be set to 0 to access the default audio control interface. The <em>ui32Channel</em> value starts with 0 which is the master audio volume control interface. The remaining <em>ui32Channel</em> values provide access to various other audio channels, with 1 and 2 being left and right audio channels.</p>
<dl class="section note"><dt>Note</dt><dd>On devices that do not support volume control interfaces, this call returns 0, indicating a 0db setting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the volume control resolution for the requested interface. </dd></dl>

</div>
</div>
<a id="ga5ecda02fbcb26d6fad0d5d05ed86a9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ecda02fbcb26d6fad0d5d05ed86a9a5">&sect;&nbsp;</a></span>USBHostAudioVolumeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHostAudioVolumeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the current volume setting for a given audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is an instance of the USB audio device. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface number to use to set the current volume setting. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the 0 based channel number to query. </td></tr>
    <tr><td class="paramname">ui32Value</td><td>is the value to write to the USB audio device.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to set the current volume setting for an audio device on the channel specified by <em>ui32Channel</em>. The <em>ui32Interface</em> is ignored for now and should be set to 0 to access the default audio control interface. The <em>ui32Channel</em> value starts with 0 which is the master audio volume control interface. The remaining <em>ui32Channel</em> values provide access to various other audio channels, with 1 and 2 being left and right audio channels.</p>
<dl class="section note"><dt>Note</dt><dd>On devices that do not support volume control interfaces, this call returns 0, indicating a 0db setting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="usbaudio_8h.html#a97af24b091faeebfab707470efd02434">USB_AC_SET_CUR</a>, <a class="el" href="group__usbchap9__src.html#gaf952bba71d036ef59bcbae8d68eb982a">USB_RTYPE_CLASS</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="usbaudio_8h.html#a1d99028963aad986e8e818b1b3b12711">VOLUME_CONTROL</a>.</p>

</div>
</div>
<a id="gafda66da1a449f0337c2c3f21cb499182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda66da1a449f0337c2c3f21cb499182">&sect;&nbsp;</a></span>USBHostAudioFormatGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioFormatGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32SampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to determine if an audio format is supported by the connected USB Audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is the device instance for this call. </td></tr>
    <tr><td class="paramname">ui32SampleRate</td><td>is the sample rate of the audio stream. </td></tr>
    <tr><td class="paramname">ui32Bits</td><td>is the number of bits per sample in the audio stream. </td></tr>
    <tr><td class="paramname">ui32Channels</td><td>is the number of channels in the audio stream. </td></tr>
    <tr><td class="paramname">ui32Flags</td><td>is a set of flags to determine what type of interface to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when an application needs to determine which audio formats are supported by a USB audio device that has been connected. The <em>psAudioInstance</em> value that is used with this call is the value that was returned from the <a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen()</a> function. This call checks the USB audio device to determine if it can support the values provided in the <em>ui32SampleRate</em>, <em>ui32Bits</em>, and <em>ui32Channels</em> values. The <em>ui32Flags</em> currently only supports either the <b>USBH_AUDIO_FORMAT_IN</b> or <b>USBH_AUDIO_FORMAT_OUT</b> values that indicates if a request is for an audio input and an audio output. If the format is supported this function returns zero, and this function returns a non-zero value if the format is not supported. This function does not set the current output or input format.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of zero indicates the supplied format is supported and a non-zero value indicates that the format is not supported. </dd></dl>

</div>
</div>
<a id="gae1f5dbe05f8c6e7a5140e65a5b237164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f5dbe05f8c6e7a5140e65a5b237164">&sect;&nbsp;</a></span>USBHostAudioFormatSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioFormatSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32SampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to set the current sample rate on an audio interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>specifies the device instance for this call. </td></tr>
    <tr><td class="paramname">ui32SampleRate</td><td>is the sample rate in Hz. </td></tr>
    <tr><td class="paramname">ui32Bits</td><td>is the number of bits per sample. </td></tr>
    <tr><td class="paramname">ui32Channels</td><td>is then number of audio channels. </td></tr>
    <tr><td class="paramname">ui32Flags</td><td>is a set of flags that determine the access type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when to set the current audio output or input format for a USB audio device. The <em>psAudioInstance</em> value that is used with this call is the value that was returned from the <a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen()</a> function. The application can use this call to insure that the audio format is supported and set the format at the same time. If the application is just checking for supported rates, then it should call the <a class="el" href="group__usblib__host__class.html#gafda66da1a449f0337c2c3f21cb499182">USBHostAudioFormatGet()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called before attempting to send or receive audio with the <a class="el" href="group__usblib__host__class.html#gaee0cd88dd6bf6531fb8d3456c858d7b2">USBHostAudioPlay()</a> or <a class="el" href="group__usblib__host__class.html#ga2551ad61aeb9f64111c9db7fad742c48">USBHostAudioRecord()</a> functions.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value indicates the supplied format is not supported and a zero value indicates that the format was supported and has been configured. </dd></dl>

</div>
</div>
<a id="gaee0cd88dd6bf6531fb8d3456c858d7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0cd88dd6bf6531fb8d3456c858d7b2">&sect;&nbsp;</a></span>USBHostAudioPlay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHostAudioPlay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to send an audio buffer to the USB audio device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>specifies the device instance for this call. </td></tr>
    <tr><td class="paramname">pvBuffer</td><td>is the audio buffer to send. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in bytes. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is a pointer to a callback function that is called when the buffer can be used again.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when an application needs to schedule a new buffer for output to the USB audio device. Since this call schedules the transfer and returns immediately, the application should provide a <em>pfnCallback</em> function to be notified when the buffer can be used again by the application. The <em>pfnCallback</em> function provided is called with the <em>pvBuffer</em> parameter set to the <em>pvBuffer</em> provided by this call, the <em>ui32Param</em> can be ignored and the <em>ui32Event</em> parameter is <b>USB_EVENT_TX_COMPLETE</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were scheduled to be sent. If this function returns zero then there was no USB audio device present or the request could not be satisfied at this time. </dd></dl>

<p>References <a class="el" href="group__usblib__host__class.html#ga1be972cd05ad6d81955b42c2f1050a77">AUDIO_FLAG_OUT_ACTIVE</a>, <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a>, and <a class="el" href="group__usblib__hcd.html#ga9b4a9dab92a6d4aed63519b8c57e722d">USBHCDSetInterface()</a>.</p>

</div>
</div>
<a id="ga2551ad61aeb9f64111c9db7fad742c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2551ad61aeb9f64111c9db7fad742c48">&sect;&nbsp;</a></span>USBHostAudioRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHostAudioRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga534eb8f6d4bbf15fff626d2e3778a641">tUSBHostAudioCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called to provide an audio buffer to the USB audio device for audio input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>specifies the device instance for this call. </td></tr>
    <tr><td class="paramname">pvBuffer</td><td>is the audio buffer to send. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the buffer in bytes. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is a pointer to a callback function that is called when the buffer has been filled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when an application needs to schedule a new buffer for input from the USB audio device. Since this call schedules the transfer and returns immediately, the application should provide a <em>pfnCallback</em> function to be notified when the buffer has been filled with audio data. When the <em>pfnCallback</em> function is called, the <em>pvBuffer</em> parameter is set to <em>pvBuffer</em> provided in this call, the <em>ui32Param</em> is the number of valid bytes in the pvBuffer and the <em>ui32Event</em> is set to <b>USB_EVENT_RX_AVAILABLE</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of bytes that were scheduled to be sent. If this function returns zero then there was no USB audio device present or the device does not support audio input. </dd></dl>

<p>References <a class="el" href="group__usblib__host__class.html#gaafb17cfcbc03042558c6f19a893bb36f">AUDIO_FLAG_IN_ACTIVE</a>, <a class="el" href="group__usblib__hcd.html#ga06cf106720569ee7276f4178129aa898">USBHCDPipeSchedule()</a>, and <a class="el" href="group__usblib__hcd.html#ga9b4a9dab92a6d4aed63519b8c57e722d">USBHCDSetInterface()</a>.</p>

</div>
</div>
<a id="ga6cc2fb766353fb5ee10230fb27b07dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc2fb766353fb5ee10230fb27b07dd2">&sect;&nbsp;</a></span>USBHostAudioLPMSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioLPMSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function forwards an LPM request for a device to enter L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is the audio device instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forwards a request from an application to the audio device class to request that a device enter the LPM L1 sleep state. The caller must check the return value to see if the request can be attempted at this time. If another LPM transaction is busy on this or another device, then this function returns <b>USBHCD_LPM_PENDING</b>. If the LPM request was scheduled to be sent the function returns <b>USBHCD_LPM_AVAIL</b>. The caller should check the <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a> function to determine if the request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - The transition to L1 state is scheduled to be sent.</li>
<li><b>USBHCD_LPM_PENDING</b> - There is already an LPM request pending. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gad58a11d54ef7f4a976bc0a0614dbc64c">USBHCDLPMSleep()</a>.</p>

</div>
</div>
<a id="ga5b202c0868d3b00f07aba76abb0b6a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b202c0868d3b00f07aba76abb0b6a2f">&sect;&nbsp;</a></span>USBHostAudioLPMStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHostAudioLPMStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga2e4175a2a6520e49bf29996f6a58d0e7">tUSBHostAudioInstance</a> *&#160;</td>
          <td class="paramname"><em>psAudioInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current status of an LPM request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psAudioInstance</td><td>is the audio device instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07ba21f6143babf719c934666532f57">USBHostAudioOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status of LPM requests for a given device. This is called to determine if a previous request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - There are no pending LPM requests on this specific device or the last request completed successfully.</li>
<li><b>USBHCD_LPM_ERROR</b> - The last LPM request for this device did not complete successfully.</li>
<li><b>USBHCD_LPM_PENDING</b> - The last LPM request has not completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="gab07a8033d7519a9489d46e680a6f3bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab07a8033d7519a9489d46e680a6f3bf7">&sect;&nbsp;</a></span>USBHHIDOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a>* USBHHIDOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#gaa010a3a0cde509bc55412c6662a9ca13">tHIDSubClassProtocol</a>&#160;</td>
          <td class="paramname"><em>iDeviceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general__usblib__api.html#ga28b2c7063c0895d2a98a78918d907f90">tUSBCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvCBData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to open an instance of a HID device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDeviceType</td><td>is the type of device that should be loaded for this instance of the HID device. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is the function that will be called whenever changes are detected for this device. </td></tr>
    <tr><td class="paramname">pvCBData</td><td>is the data that will be returned in when the <em>pfnCallback</em> function is called.</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates an instance of an specific type of HID device. The <em>iDeviceType</em> parameter is one subclass/protocol values of the types specified in enumerated types tHIDSubClassProtocol. Only devices that enumerate with this type will be called back via the <em>pfnCallback</em> function. The <em>pfnCallback</em> parameter is the callback function for any events that occur for this device type. The <em>pfnCallback</em> function must point to a valid function of type <em>tUSBCallback</em> for this call to complete successfully. To release this device instance the caller of <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a> should call <a class="el" href="group__usblib__host__class.html#ga60f13efcf4cc8661db1b59ec27b73c00">USBHHIDClose()</a> and pass in the value returned from the <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a> call.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns and instance value that should be used with any other APIs that require an instance value. If a value of 0 is returned then the device instance could not be created. </dd></dl>

<p>References <a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13abf5f24b7c0e3287aa36cdb6d34ff4f38">eUSBHHIDClassNone</a>, <a class="el" href="structt_h_i_d_instance.html#aa3cfe9d2a96934ab4c3300ac98569470">tHIDInstance::iDeviceType</a>, <a class="el" href="group__usblib__host__class.html#ga967fc671f8f299b17a383a3699eb3f12">MAX_HID_DEVICES</a>, <a class="el" href="structt_h_i_d_instance.html#a95f5da1c67a59eb3cabc83a4b0a014e6">tHIDInstance::pfnCallback</a>, and <a class="el" href="structt_h_i_d_instance.html#a43c7388fbf6cb95bfc2f4fb554c521fd">tHIDInstance::pvCBData</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga5517f68b7e0c058c177ef57622abffc9">USBHKeyboardOpen()</a>, and <a class="el" href="group__usblib__host__device.html#ga0c40098002820637ae4f6aff6ded7073">USBHMouseOpen()</a>.</p>

</div>
</div>
<a id="ga60f13efcf4cc8661db1b59ec27b73c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f13efcf4cc8661db1b59ec27b73c00">&sect;&nbsp;</a></span>USBHHIDClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHIDClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to release an instance of a HID device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the instance value for a HID device to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases an instance of a HID device that was created by a call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. This call is required to allow other HID devices to be enumerated after another HID device has been disconnected. The <em>psHIDInstance</em> parameter should hold the value that was returned from the previous call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__usblib__host__class.html#ggaa010a3a0cde509bc55412c6662a9ca13abf5f24b7c0e3287aa36cdb6d34ff4f38">eUSBHHIDClassNone</a>, <a class="el" href="structt_h_i_d_instance.html#aa3cfe9d2a96934ab4c3300ac98569470">tHIDInstance::iDeviceType</a>, and <a class="el" href="structt_h_i_d_instance.html#a95f5da1c67a59eb3cabc83a4b0a014e6">tHIDInstance::pfnCallback</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga599689f201822184fd47247507c048bb">USBHKeyboardClose()</a>, and <a class="el" href="group__usblib__host__device.html#ga8497d5cb2e5e6a1011d4c782957932bf">USBHMouseClose()</a>.</p>

</div>
</div>
<a id="gadde7ecf8d577f1a6c34f4014553708be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde7ecf8d577f1a6c34f4014553708be">&sect;&nbsp;</a></span>USBHHIDSetIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDSetIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8ReportID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the idle timeout for a HID device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the value that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. </td></tr>
    <tr><td class="paramname">ui8Duration</td><td>is the duration of the timeout in milliseconds. </td></tr>
    <tr><td class="paramname">ui8ReportID</td><td>is the report identifier to set the timeout on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will send the Set Idle command to a HID device to set the idle timeout for a given report. The length of the timeout is specified by the <em>ui8Duration</em> parameter and the report the timeout for is in the <em>ui8ReportID</em> value.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns 0. </dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, <a class="el" href="group__usbchap9__src.html#gaf952bba71d036ef59bcbae8d68eb982a">USB_RTYPE_CLASS</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__hid__device__class__api.html#ga2954f62fe1dac50642ae34dd241a654f">USBREQ_SET_IDLE</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga51319012bfc56f60efb8c93d39f9bee5">USBHKeyboardInit()</a>, <a class="el" href="group__usblib__host__device.html#ga3b9e1487fe9f7f71986e8ede4c3d2e35">USBHKeyboardPollRateSet()</a>, and <a class="el" href="group__usblib__host__device.html#ga1629e325dcae7f96903a9daf04cf78ce">USBHMouseInit()</a>.</p>

</div>
</div>
<a id="ga60f42ac242c24f0dc097ed999c28951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f42ac242c24f0dc097ed999c28951b">&sect;&nbsp;</a></span>USBHHIDGetReportDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDGetReportDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to retrieve the report descriptor for a given device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the value that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. </td></tr>
    <tr><td class="paramname">pui8Buffer</td><td>is the memory buffer to use to store the report descriptor. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to return a report descriptor from a HID device instance so that it can determine how to interpret reports that are returned from the device indicated by the <em>psHIDInstance</em> parameter. This call is blocking and will return the number of bytes read into the <em>pui8Buffer</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes read into the <em>pui8Buffer</em>. </dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, <a class="el" href="structt_u_s_b_host_device.html#a52120d4e50cfae7d4a54bff498f545d6">tUSBHostDevice::sDeviceDescriptor</a>, <a class="el" href="group__hid__device__class__api.html#ga22af8760b231d6a9b1d6402fbae26b1b">USB_HID_DTYPE_REPORT</a>, <a class="el" href="group__usbchap9__src.html#gad60bc6172e46c7fe98139bb1fcc41dd1">USB_RTYPE_DIR_IN</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usbchap9__src.html#ga6f978116659ac9295ed48cb78dd9c3b8">USB_RTYPE_STANDARD</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__usbchap9__src.html#ga9175805ff47cbabd04f8913faa37869a">USBREQ_GET_DESCRIPTOR</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga51319012bfc56f60efb8c93d39f9bee5">USBHKeyboardInit()</a>, and <a class="el" href="group__usblib__host__device.html#ga1629e325dcae7f96903a9daf04cf78ce">USBHMouseInit()</a>.</p>

</div>
</div>
<a id="gace42556c163b54cf10c1e9086521ff86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace42556c163b54cf10c1e9086521ff86">&sect;&nbsp;</a></span>USBHHIDSetProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDSetProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32BootProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set or clear the boot protocol state of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the value that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. </td></tr>
    <tr><td class="paramname">ui32BootProtocol</td><td>is either zero or non-zero to indicate which protocol to use for the device.</td></tr>
  </table>
  </dd>
</dl>
<p>A USB host device can use this function to set the protocol for a connected HID device. This is commonly used to set keyboards and mice into their simplified boot protocol modes to fix the report structure to a know state.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns 0. </dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, <a class="el" href="structt_u_s_b_host_device.html#a52120d4e50cfae7d4a54bff498f545d6">tUSBHostDevice::sDeviceDescriptor</a>, <a class="el" href="group__usbchap9__src.html#gaf952bba71d036ef59bcbae8d68eb982a">USB_RTYPE_CLASS</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__hid__device__class__api.html#ga4ad64bfbfce5cfbea15bfe26bc0adf10">USBREQ_SET_PROTOCOL</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga51319012bfc56f60efb8c93d39f9bee5">USBHKeyboardInit()</a>, and <a class="el" href="group__usblib__host__device.html#ga1629e325dcae7f96903a9daf04cf78ce">USBHMouseInit()</a>.</p>

</div>
</div>
<a id="ga38170ed323efd3f4752252aa9aaa2401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38170ed323efd3f4752252aa9aaa2401">&sect;&nbsp;</a></span>USBHHIDGetReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDGetReport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve a report from a HID device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the value that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface to retrieve the report from. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the memory buffer to use to store the report. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to retrieve a report from a USB pipe. It is usually called when the USB HID layer has detected a new data available in a USB pipe. The USB HID host device code will receive a <b>USB_EVENT_RX_AVAILABLE</b> event when data is available, allowing the callback function to retrieve the data.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes read from report. </dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#ac7665f34540dd64fc5313f4028f94478">tHIDInstance::ui32IntInPipe</a>, and <a class="el" href="group__usblib__hcd.html#ga5f82cf837684e765625e1f7e83a02ce2">USBHCDPipeReadNonBlocking()</a>.</p>

</div>
</div>
<a id="ga95e8d86b812d94d07b2e14591661910c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e8d86b812d94d07b2e14591661910c">&sect;&nbsp;</a></span>USBHHIDSetReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDSetReport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to send a report to a HID device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the value that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>. </td></tr>
    <tr><td class="paramname">ui32Interface</td><td>is the interface to send the report to. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the memory buffer to use to store the report. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size in bytes of the buffer pointed to by <em>pui8Buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to send a report to a USB HID device. It can be only be called from outside the callback context as this function will not return from the call until the data has been sent successfully.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes sent to the device. </dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, <a class="el" href="structt_u_s_b_host_device.html#a52120d4e50cfae7d4a54bff498f545d6">tUSBHostDevice::sDeviceDescriptor</a>, <a class="el" href="group__hid__device__class__api.html#ga106f05bceae42538756b29120bcae79c">USB_HID_REPORT_OUTPUT</a>, <a class="el" href="group__usbchap9__src.html#gaf952bba71d036ef59bcbae8d68eb982a">USB_RTYPE_CLASS</a>, <a class="el" href="group__usbchap9__src.html#ga1a995459004d5843eab26b5ac042eb6c">USB_RTYPE_DIR_OUT</a>, <a class="el" href="group__usbchap9__src.html#ga211bd45e653cf1b87cabb1f7e5f303b8">USB_RTYPE_INTERFACE</a>, <a class="el" href="group__usblib__hcd.html#ga8b750f4799829a3efe895ccadf41217e">USBHCDControlTransfer()</a>, and <a class="el" href="group__hid__device__class__api.html#ga68c1f75af926dabbf8a0ecc9a2fbcd5f">USBREQ_SET_REPORT</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga51319012bfc56f60efb8c93d39f9bee5">USBHKeyboardInit()</a>, and <a class="el" href="group__usblib__host__device.html#ga0a50cfc91f5ad3bed05c8a8697d70329">USBHKeyboardModifierSet()</a>.</p>

</div>
</div>
<a id="ga0c436efb2b57e84241f2d6ec2e9719ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c436efb2b57e84241f2d6ec2e9719ec">&sect;&nbsp;</a></span>USBHHIDLPMSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDLPMSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function forwards an LPM request for a device to enter L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the HID instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forwards a request from a HID device class to the host controller to request that a device enter the LPM L1 sleep state. The caller must check the return value to see if the request can be attempted at this time. If another LPM transaction is busy on this or another device, then this function returns <b>USBHCD_LPM_PENDING</b>. If the LPM request was scheduled to be sent the function returns <b>USBHCD_LPM_AVAIL</b>. The caller should check the <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a> function to determine if the request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li>USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.</li>
<li>USBHCD_LPM_PENDING - There is already an LPM request pending. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, and <a class="el" href="group__usblib__hcd.html#gad58a11d54ef7f4a976bc0a0614dbc64c">USBHCDLPMSleep()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga6c9d1c92ae746e28e69b3479e4bf1895">USBHKeyboardLPMSleep()</a>, and <a class="el" href="group__usblib__host__device.html#ga2151ed29965d9b31eafa1b97caabb3c2">USBHMouseLPMSleep()</a>.</p>

</div>
</div>
<a id="ga208c5fe377e8d9e93a835d0a6ec7a2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208c5fe377e8d9e93a835d0a6ec7a2cf">&sect;&nbsp;</a></span>USBHHIDLPMStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHIDLPMStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_h_i_d_instance.html">tHIDInstance</a> *&#160;</td>
          <td class="paramname"><em>psHIDInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current status of an LPM request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHIDInstance</td><td>is the HID instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#gab07a8033d7519a9489d46e680a6f3bf7">USBHHIDOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status of LPM requests for a given device. This is called to determine if a previous request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - There are no pending LPM requests on this specific device or the last request completed successfully.</li>
<li><b>USBHCD_LPM_ERROR</b> - The last LPM request for this device did not complete successfully.</li>
<li><b>USBHCD_LPM_PENDING</b> - The last LPM request has not completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="structt_h_i_d_instance.html#aaa8fb18c0f48b5e834cc6194dc6ebfd8">tHIDInstance::psDevice</a>, and <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__device.html#ga21045672ac4a6e22e7f3995fa3bc2ae3">USBHKeyboardLPMStatus()</a>, and <a class="el" href="group__usblib__host__device.html#ga92ccf8579e56e537928f09e25b59aaa0">USBHMouseLPMStatus()</a>.</p>

</div>
</div>
<a id="ga9b8837c6450481ab5cc6ff17793cff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b8837c6450481ab5cc6ff17793cff79">&sect;&nbsp;</a></span>USBHHubMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHubMain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="usbhostpriv_8h.html#a1c3e0040eb909cc7c1c4ac01c2e72a57a956a2532f1bc6a357c4c3cd74fe07abb">ePortConnected</a>, and <a class="el" href="group__usblib__host__class.html#gab2b105bf9848fd6c899c07359a75af2b">USBLIB_HUB_ACTIVE</a>.</p>

</div>
</div>
<a id="gab1be9548f40a8c469a9317c90ca21419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1be9548f40a8c469a9317c90ca21419">&sect;&nbsp;</a></span>USBHHubEnumerationComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHubEnumerationComplete </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs the hub class driver that a downstream device has been enumerated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui8Hub</td><td>is the address of the hub to which the downstream device is attached. </td></tr>
    <tr><td class="paramname">ui8Port</td><td>is the port on the hub to which the downstream device is attached.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by the host controller driver to inform the hub class driver that a downstream device has been enumerated successfully. The hub driver then moves on and continues enumeration of any other newly connected devices.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="usbhhub_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>, and <a class="el" href="usbhostpriv_8h.html#a1c3e0040eb909cc7c1c4ac01c2e72a57ac5c7995c71cd3396af32d3fd1b9bca27">ePortEnumerated</a>.</p>

</div>
</div>
<a id="ga0903016a6157d46291b8ccddf838b658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0903016a6157d46291b8ccddf838b658">&sect;&nbsp;</a></span>USBHHubEnumerationError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHubEnumerationError </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Informs the hub class driver that a downstream device failed to enumerate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui8Hub</td><td>is the address of the hub to which the downstream device is attached. </td></tr>
    <tr><td class="paramname">ui8Port</td><td>is the port on the hub to which the downstream device is attached.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by the host controller driver to inform the hub class driver that an attempt to enumerate a downstream device has failed. The hub driver then cleans up and continues enumeration of any other newly connected devices.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="usbhhub_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>, and <a class="el" href="usbhostpriv_8h.html#a1c3e0040eb909cc7c1c4ac01c2e72a57a86616285a578369aa6495cbc4c76aada">ePortError</a>.</p>

</div>
</div>
<a id="ga501561d026c8cdedc510c0d60fdbb3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501561d026c8cdedc510c0d60fdbb3a3">&sect;&nbsp;</a></span>USBHHubOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a>* USBHHubOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usbhhub_8h.html#aafa05f5fe8ebff2241255c1f8520f45a">tUSBHHubCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to enable the host hub class driver before any devices are present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnCallback</td><td>is the driver call back for host hub events.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called to open an instance of a host hub device and provides a valid callback function for host hub events in the <em>pfnCallback</em> parameter. This function must be called before the USB host code can successfully enumerate a hub device or any devices attached to the hub. The <em>pui8HubPool</em> is memory provided to the hub class to manage the devices that are connected to the hub. The <em>ui32PoolSize</em> is the number of bytes and should be at least 32 bytes per device including the hub device itself. A simple formula for providing memory to the hub class is <b>MAX_USB_DEVICES</b> * 32 bytes of data to allow for proper enumeration of connected devices. The value for <b>MAX_USB_DEVICES</b> is defined in the <a class="el" href="usblib_8h.html">usblib.h</a> file and controls the number of devices supported by the USB library. The <em>ui32NumHubs</em> parameter defaults to one and only one buffer of size tHubInstance is required to be passed in the <em>psHubInstance</em> parameter.</p>
<dl class="section note"><dt>Note</dt><dd>Changing the value of <b>MAX_USB_DEVICES</b> requires a rebuild of the USB library to have an effect on the library.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the driver instance to use for the other host hub functions. If there is no instance available at the time of this call, this function returns zero. </dd></dl>

<p>References <a class="el" href="usbhhub_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>.</p>

</div>
</div>
<a id="gaf2145b63f3d8e22fd78a2e800793cef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2145b63f3d8e22fd78a2e800793cef8">&sect;&nbsp;</a></span>USBHHubClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHubClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *&#160;</td>
          <td class="paramname"><em>psHubInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to release a hub device instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHubInstance</td><td>is the hub device instance that is to be released.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when an instance of the hub device must be released. This function is typically made in preparation for shutdown or a switch to function as a USB device when in OTG mode. Following this call, the hub device is no longer available, but it can be opened again using a call to <a class="el" href="group__usblib__host__class.html#ga501561d026c8cdedc510c0d60fdbb3a3">USBHHubOpen()</a>. After calling <a class="el" href="group__usblib__host__class.html#gaf2145b63f3d8e22fd78a2e800793cef8">USBHHubClose()</a>, the host hub driver no longer provides any callbacks or accepts calls to other hub driver APIs.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="usbhhub_8c.html#a2b1da0cb514f35f2dad5f19754377274">DEBUG_OUTPUT</a>.</p>

</div>
</div>
<a id="gacb95931c55ea3ac9811d549d2b4eac97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb95931c55ea3ac9811d549d2b4eac97">&sect;&nbsp;</a></span>USBHHubInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHHubInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga463b791f9b743cd981cbdb487a5fcfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga463b791f9b743cd981cbdb487a5fcfe3">&sect;&nbsp;</a></span>USBHHubLPMSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHubLPMSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *&#160;</td>
          <td class="paramname"><em>psHubInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function forwards an LPM request for a device to enter L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHubInstance</td><td>is the hub device instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#ga501561d026c8cdedc510c0d60fdbb3a3">USBHHubOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forwards a request from an application to the hub device class to request that a device enter the LPM L1 sleep state. The caller must check the return value to see if the request can be attempted at this time. If another LPM transaction is busy on this or another device, then this function returns <b>USBHCD_LPM_PENDING</b>. If the LPM request was scheduled to be sent the function returns <b>USBHCD_LPM_AVAIL</b>. The caller should check the <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a> function to determine if the request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - The transition to L1 state is scheduled to be sent.</li>
<li><b>USBHCD_LPM_PENDING</b> - There is already an LPM request pending. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gad58a11d54ef7f4a976bc0a0614dbc64c">USBHCDLPMSleep()</a>.</p>

</div>
</div>
<a id="ga2d5d43391f05dcd1cbaa77cc44fb0472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d5d43391f05dcd1cbaa77cc44fb0472">&sect;&nbsp;</a></span>USBHHubLPMStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHHubLPMStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usbhhub_8h.html#a5bc911c94b98eef2c036a0907b84706b">tHubInstance</a> *&#160;</td>
          <td class="paramname"><em>psHubInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current status of an LPM request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psHubInstance</td><td>is the hub device instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#ga501561d026c8cdedc510c0d60fdbb3a3">USBHHubOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status of LPM requests for a given device. This is called to determine if a previous request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - There are no pending LPM requests on this specific device or the last request completed successfully.</li>
<li><b>USBHCD_LPM_ERROR</b> - The last LPM request for this device did not complete successfully.</li>
<li><b>USBHCD_LPM_PENDING</b> - The last LPM request has not completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="gad78892088fb13e7b1cf312d3ecade497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad78892088fb13e7b1cf312d3ecade497">&sect;&nbsp;</a></span>USBHMSCDriveReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHMSCDriveReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a drive is ready to be accessed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the device instance to use for this read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks if the current device is ready to be accessed. It uses the <em>psMSCInstance</em> parameter to determine which device to check and returns zero when the device is ready. Any non-zero return code indicates that the device was not ready.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns zero if the device is ready and it returns a other value if the device is not ready or if an error occurred. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a987297d0beb29ca6e3e804936b40becd">SCSI_INQUIRY_DATA_SZ</a>.</p>

</div>
</div>
<a id="ga630c1582450053d4e0e6da13260d9a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630c1582450053d4e0e6da13260d9a80">&sect;&nbsp;</a></span>USBHMSCDriveOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> * USBHMSCDriveOpen </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Drive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3ee0ba89f6686e6a7d46b0b89577a447">tUSBHMSCCallback</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called before any devices are present to enable the mass storage device class driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Drive</td><td>is the drive number to open. </td></tr>
    <tr><td class="paramname">pfnCallback</td><td>is the driver callback for any mass storage events.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called to open an instance of a mass storage device. It should be called before any devices are connected to allow for proper notification of drive connection and disconnection. The <em>ui32Drive</em> parameter is a zero based index of the drives present in the system. There are a constant number of drives, and this number should only be greater than 0 if there is a USB hub present in the system. The application should also provide the <em>pfnCallback</em> to be notified of mass storage related events like device enumeration and device removal.</p>
<dl class="section return"><dt>Returns</dt><dd>This function will return the driver instance to use for the other mass storage functions. If there is no driver available at the time of this call, this function will return zero. </dd></dl>

</div>
</div>
<a id="gacc7259732b5526edf9d0cad15d645b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7259732b5526edf9d0cad15d645b1d">&sect;&nbsp;</a></span>USBHMSCDriveClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBHMSCDriveClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called to release a drive instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the device instance that is to be released.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when an MSC drive is to be released in preparation for shutdown or a switch to USB device mode, for example. Following this call, the drive is available for other clients who may open it again using a call to <a class="el" href="group__usblib__host__class.html#ga630c1582450053d4e0e6da13260d9a80">USBHMSCDriveOpen()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga2a7f1953ba798a4a9e97dc69ed5af010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a7f1953ba798a4a9e97dc69ed5af010">&sect;&nbsp;</a></span>USBHMSCBlockRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHMSCBlockRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32LBA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs a block read to an MSC device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the device instance to use for this read. </td></tr>
    <tr><td class="paramname">ui32LBA</td><td>is the logical block address to read on the device. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the returned data buffer. </td></tr>
    <tr><td class="paramname">ui32NumBlocks</td><td>is the number of blocks to read from the device.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will perform a block sized read from the device associated with the <em>psMSCInstance</em> parameter. The <em>ui32LBA</em> parameter specifies the logical block address to read on the device. This function will only perform <em>ui32NumBlocks</em> block sized reads. In most cases this is a read of 512 bytes of data. The <em>*pui8Data</em> buffer should be at least <em>ui32NumBlocks</em> * 512 bytes in size.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns zero for success and any negative value indicates a failure. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a6721c6a6801fb64668055d8da397d64b">SCSI_CMD_STATUS_PASS</a>, and <a class="el" href="group__usblib__host__class.html#ga5281f9f2f24b4c9d5600983f2906bb9a">USBHSCSIRead10()</a>.</p>

</div>
</div>
<a id="gad5f8f8fd0d8a435275175d5ec9dbbe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f8f8fd0d8a435275175d5ec9dbbe8d">&sect;&nbsp;</a></span>USBHMSCBlockWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t USBHMSCBlockWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32LBA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs a block write to an MSC device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the device instance to use for this write. </td></tr>
    <tr><td class="paramname">ui32LBA</td><td>is the logical block address to write on the device. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data to write out. </td></tr>
    <tr><td class="paramname">ui32NumBlocks</td><td>is the number of blocks to write to the device.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will perform a block sized write to the device associated with the <em>psMSCInstance</em> parameter. The <em>ui32LBA</em> parameter specifies the logical block address to write on the device. This function will only perform <em>ui32NumBlocks</em> block sized writes. In most cases this is a write of 512 bytes of data. The <em>*pui8Data</em> buffer should contain at least <em>ui32NumBlocks</em> * 512 bytes in size to prevent unwanted data being written to the device.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns zero for success and any negative value indicates a failure. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a6721c6a6801fb64668055d8da397d64b">SCSI_CMD_STATUS_PASS</a>, and <a class="el" href="group__usblib__host__class.html#gab977c4bfa1de53ba703a94c2ae71a32f">USBHSCSIWrite10()</a>.</p>

</div>
</div>
<a id="gab1462107691a9229ad16397781056b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1462107691a9229ad16397781056b72">&sect;&nbsp;</a></span>USBHMSCLPMSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHMSCLPMSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function forwards an LPM request for a device to enter L1 sleep state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the host mass storage class instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#ga630c1582450053d4e0e6da13260d9a80">USBHMSCDriveOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forwards a request from an application to the mass storage device class to request that a device enter the LPM L1 sleep state. The caller must check the return value to see if the request can be attempted at this time. If another LPM transaction is busy on this or another device, then this function returns <b>USBHCD_LPM_PENDING</b>. If the LPM request was scheduled to be sent the function returns <b>USBHCD_LPM_AVAIL</b>. The caller should check the <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a> function to determine if the request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li>USBHCD_LPM_AVAIL - The transition to L1 state is scheduled to be sent.</li>
<li>USBHCD_LPM_PENDING - There is already an LPM request pending. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#gad58a11d54ef7f4a976bc0a0614dbc64c">USBHCDLPMSleep()</a>.</p>

</div>
</div>
<a id="ga6809a58356c09139db0d10df4b1a7277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6809a58356c09139db0d10df4b1a7277">&sect;&nbsp;</a></span>USBHMSCLPMStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHMSCLPMStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__usblib__host__class.html#ga3872a5c5c4b016c03952a48ce23d9632">tUSBHMSCInstance</a> *&#160;</td>
          <td class="paramname"><em>psMSCInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current status of an LPM request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psMSCInstance</td><td>is the host mass storage class instance that was returned from the call to <a class="el" href="group__usblib__host__class.html#ga630c1582450053d4e0e6da13260d9a80">USBHMSCDriveOpen()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status of LPM requests for a given device. This is called to determine if a previous request completed successfully or if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the following values:<ul>
<li><b>USBHCD_LPM_AVAIL</b> - There are no pending LPM requests on this specific device or the last request completed successfully.</li>
<li><b>USBHCD_LPM_ERROR</b> - The last LPM request for this device did not complete successfully.</li>
<li><b>USBHCD_LPM_PENDING</b> - The last LPM request has not completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__usblib__hcd.html#ga397601992d02bbb4da500c2419036ddb">USBHCDLPMStatus()</a>.</p>

</div>
</div>
<a id="gae38e2ffcdbe0169fe7098dafe6cccffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38e2ffcdbe0169fe7098dafe6cccffd">&sect;&nbsp;</a></span>USBHSCSIInquiry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIInquiry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will issue the SCSI inquiry command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the results into. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of buffer that was passed in on entry and the number of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be used to issue a SCSI Inquiry command to a mass storage device. To allow for multiple devices, the <em>ui32InPipe</em> and <em>ui32OutPipe</em> parameters indicate which USB pipes to use for this call.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>pui8Data</em> buffer pointer should have at least <b>SCSI_INQUIRY_DATA_SZ</b> bytes of data or this function will overflow the buffer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the SCSI status from the command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, <a class="el" href="usbmsc_8h.html#ac55175d9a83a1729df6ed8cd0d6e51c3">SCSI_INQUIRY_CMD</a>, and <a class="el" href="usbmsc_8h.html#a987297d0beb29ca6e3e804936b40becd">SCSI_INQUIRY_DATA_SZ</a>.</p>

</div>
</div>
<a id="ga319f25cf2c45b091bccde4f48f01637e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga319f25cf2c45b091bccde4f48f01637e">&sect;&nbsp;</a></span>USBHSCSIReadCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIReadCapacity </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will issue the SCSI read capacity command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the results into. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of buffer that was passed in on entry and the number of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be used to issue a SCSI Read Capacity command to a mass storage device that is connected. To allow for multiple devices, the <em>ui32InPipe</em> and <em>ui32OutPipe</em> parameters indicate which USB pipes to use for this call.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>pui8Data</em> buffer pointer should have at least <b>SCSI_READ_CAPACITY_SZ</b> bytes of data or this function will overflow the buffer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the SCSI status from the command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, <a class="el" href="usbmsc_8h.html#a3dc6f7fadac7bfeffb644345a3adc670">SCSI_READ_CAPACITY</a>, and <a class="el" href="usbmsc_8h.html#a78b041f0405bb1f487e9fb6a59e914f9">SCSI_READ_CAPACITY_SZ</a>.</p>

</div>
</div>
<a id="ga0cee0ad0998e50dbf11ea4504f22e136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cee0ad0998e50dbf11ea4504f22e136">&sect;&nbsp;</a></span>USBHSCSIReadCapacities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIReadCapacities </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will issue the SCSI read capacities command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the results into. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of buffer that was passed in on entry and the number of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be used to issue a SCSI Read Capacities command to a mass storage device that is connected. To allow for multiple devices, the <em>ui32InPipe</em> and <em>ui32OutPipe</em> parameters indicate which USB pipes to use for this call.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the SCSI status from the command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, and <a class="el" href="usbmsc_8h.html#aec6b6a830c6de3faa8aac4449fb0d7d5">SCSI_READ_CAPACITIES</a>.</p>

</div>
</div>
<a id="gabbdf1d0c381b3afe65bb4e0b59952dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbdf1d0c381b3afe65bb4e0b59952dbb">&sect;&nbsp;</a></span>USBHSCSIModeSense6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIModeSense6 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will issue the SCSI Mode Sense(6) command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32Flags</td><td>is a combination of flags defining the exact query that is to be made. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the results into. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of the buffer on entry and number of bytes read on exit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be used to issue a SCSI Mode Sense(6) command to a mass storage device. To allow for multiple devices,the <em>ui32InPipe</em> and <em>ui32OutPipe</em> parameters indicate which USB pipes to use for this call. The call will return at most the number of bytes in the <em>pui32Size</em> parameter, however it can return less and change the <em>pui32Size</em> parameter to the number of valid bytes in the <em>*pui32Size</em> buffer.</p>
<p>The <em>ui32Flags</em> parameter is a combination of the following three sets of definitions:</p>
<p>One of the following values must be specified:</p>
<ul>
<li><b>SCSI_MS_PC_CURRENT</b> request for current settings.</li>
<li><b>SCSI_MS_PC_CHANGEABLE</b> request for changeable settings.</li>
<li><b>SCSI_MS_PC_DEFAULT</b> request for default settings.</li>
<li><b>SCSI_MS_PC_SAVED</b> request for the saved values.</li>
</ul>
<p>One of these following values must also be specified to determine the page code for the request:</p>
<ul>
<li><b>SCSI_MS_PC_VENDOR</b> is the vendor specific page code.</li>
<li><b>SCSI_MS_PC_DISCO</b> is the disconnect/reconnect page code.</li>
<li><b>SCSI_MS_PC_CONTROL</b> is the control page code.</li>
<li><b>SCSI_MS_PC_LUN</b> is the protocol specific LUN page code.</li>
<li><b>SCSI_MS_PC_PORT</b> is the protocol specific port page code.</li>
<li><b>SCSI_MS_PC_POWER</b> is the power condition page code.</li>
<li><b>SCSI_MS_PC_INFORM</b> is the informational exceptions page code.</li>
<li><b>SCSI_MS_PC_ALL</b> will request all pages codes supported by the device.</li>
</ul>
<p>The last value is optional and supports the following global flag:</p><ul>
<li><b>SCSI_MS_DBD</b> disables returning block descriptors.</li>
</ul>
<p>Example: Request for all current settings.</p>
<pre class="fragment">//! SCSIModeSense6(ui32InPipe, ui32OutPipe,
//!                SCSI_MS_PC_CURRENT | SCSI_MS_PC_ALL,
//!                pui8Data, pui32Size);
//! </pre> <pre class="fragment">\return This function returns the SCSI status from the command.  The value
will be either \b SCSI_CMD_STATUS_PASS or \b SCSI_CMD_STATUS_FAIL.  </pre> 
<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, and <a class="el" href="usbmsc_8h.html#ace5881df78d69a57fe44bdbfe8717d2b">SCSI_MODE_SENSE_6</a>.</p>

</div>
</div>
<a id="ga6ac4fdaa650ec718dd306eea476c72aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac4fdaa650ec718dd306eea476c72aa">&sect;&nbsp;</a></span>USBHSCSITestUnitReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSITestUnitReady </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function issues a SCSI Test Unit Ready command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to issue a SCSI Test Unit Ready command to a device. This call will simply return the results of issuing this command.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the results of the SCSI Test Unit Ready command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, and <a class="el" href="usbmsc_8h.html#ae9e768d850fcb29e45bab0df02a356d1">SCSI_TEST_UNIT_READY</a>.</p>

</div>
</div>
<a id="ga5ca18fb4dc111b02b3a29dfbe6534956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ca18fb4dc111b02b3a29dfbe6534956">&sect;&nbsp;</a></span>USBHSCSIRequestSense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIRequestSense </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function issues a SCSI Request Sense command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the results into. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of the buffer on entry and number of bytes read on exit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to issue a SCSI Request Sense command to a device. It will return the data in the buffer pointed to by <em>pui8Data</em>. The parameter <em>pui32Size</em> should have the allocation size in bytes of the buffer pointed to by <em>pui8Data</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the results of the SCSI Request Sense command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, and <a class="el" href="usbmsc_8h.html#ac21bf0803bcdb4ade96e2eb6ce4ef847">SCSI_REQUEST_SENSE</a>.</p>

</div>
</div>
<a id="ga5281f9f2f24b4c9d5600983f2906bb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5281f9f2f24b4c9d5600983f2906bb9a">&sect;&nbsp;</a></span>USBHSCSIRead10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIRead10 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32LBA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function issues a SCSI Read(10) command to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32LBA</td><td>is the logical block address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to return the data. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of the buffer on entry and number of bytes read on exit. </td></tr>
    <tr><td class="paramname">ui32NumBlocks</td><td>is the number of contiguous blocks to read from the device.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to issue a SCSI Read(10) command to a device. The <em>ui32LBA</em> parameter specifies the logical block address to read from the device. The data from this block will be returned in the buffer pointed to by <em>pui8Data</em>. The parameter <em>pui32Size</em> should indicate enough space to hold a full block size, or only the first <em>pui32Size</em> bytes of the LBA are returned.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the results of the SCSI Read(10) command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#a13d15823fa2aff04251cf3cac77b1d50">CBWFLAGS_DIR_IN</a>, and <a class="el" href="usbmsc_8h.html#a8e85dc8b00efd7d184f85ea068092f6d">SCSI_READ_10</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#ga2a7f1953ba798a4a9e97dc69ed5af010">USBHMSCBlockRead()</a>.</p>

</div>
</div>
<a id="gab977c4bfa1de53ba703a94c2ae71a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab977c4bfa1de53ba703a94c2ae71a32f">&sect;&nbsp;</a></span>USBHSCSIWrite10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBHSCSIWrite10 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32InPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32OutPipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32LBA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32NumBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function issues a SCSI Write(10) command to a device.</p>
<p>This function is used to issue a SCSI Write(10) command to a device. The <em>ui32LBA</em> parameter specifies the logical block address on the device. The data to write to this block should be in the buffer pointed to by <em>pui8Data</em> parameter. The parameter <em>pui32Size</em> should indicate the amount of data to write to the specified LBA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32InPipe</td><td>is the USB IN pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32OutPipe</td><td>is the USB OUT pipe to use for this command. </td></tr>
    <tr><td class="paramname">ui32LBA</td><td>is the logical block address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is the data buffer to write out. </td></tr>
    <tr><td class="paramname">pui32Size</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">ui32NumBlocks</td><td>is the number of contiguous blocks to write to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns the results of the SCSI Write(10) command. The value will be either <b>SCSI_CMD_STATUS_PASS</b> or <b>SCSI_CMD_STATUS_FAIL</b>. </dd></dl>

<p>References <a class="el" href="usbmsc_8h.html#ab1c265cc7b23f7a0dd2c495e94eeee33">CBWFLAGS_DIR_OUT</a>, and <a class="el" href="usbmsc_8h.html#accf844276ddbbbcdadbd7117f6e43b3a">SCSI_WRITE_10</a>.</p>

<p>Referenced by <a class="el" href="group__usblib__host__class.html#gad5f8f8fd0d8a435275175d5ec9dbbe8d">USBHMSCBlockWrite()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gafa3dfe63aeb55ea6331618a61fa9b5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa3dfe63aeb55ea6331618a61fa9b5a0">&sect;&nbsp;</a></span>g_sUSBHostAudioClassDriver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> g_sUSBHostAudioClassDriver</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__usbchap9__src.html#ga8785f84db1be6b0b5da34cd91a1b6138">USB_CLASS_AUDIO</a>,</div><div class="line">    USBAudioOpen,</div><div class="line">    USBAudioClose,</div><div class="line">    0</div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_ga8785f84db1be6b0b5da34cd91a1b6138"><div class="ttname"><a href="group__usbchap9__src.html#ga8785f84db1be6b0b5da34cd91a1b6138">USB_CLASS_AUDIO</a></div><div class="ttdeci">#define USB_CLASS_AUDIO</div><div class="ttdef"><b>Definition:</b> usblib.h:420</div></div>
</div><!-- fragment --><p>This constant global structure defines the Audio Class Driver that is provided with the USB library. </p>

</div>
</div>
<a id="ga0a50a22f781052b2b7d4685070aad569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a50a22f781052b2b7d4685070aad569">&sect;&nbsp;</a></span>g_sUSBHIDClassDriver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> g_sUSBHIDClassDriver</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__usbchap9__src.html#gaf062e949014bed74a8b5fedcf1705602">USB_CLASS_HID</a>,</div><div class="line">    HIDDriverOpen,</div><div class="line">    HIDDriverClose,</div><div class="line">    0</div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_gaf062e949014bed74a8b5fedcf1705602"><div class="ttname"><a href="group__usbchap9__src.html#gaf062e949014bed74a8b5fedcf1705602">USB_CLASS_HID</a></div><div class="ttdeci">#define USB_CLASS_HID</div><div class="ttdef"><b>Definition:</b> usblib.h:422</div></div>
</div><!-- fragment --><p>This constant global structure defines the HID Class Driver that is provided with the USB library. </p>

</div>
</div>
<a id="ga59334d8374485bdc7a741e6f6977f70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59334d8374485bdc7a741e6f6977f70c">&sect;&nbsp;</a></span>g_sUSBHubClassDriver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> g_sUSBHubClassDriver</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__usbchap9__src.html#gaac5a936a2d1a6e3403798b031294992a">USB_CLASS_HUB</a>,</div><div class="line">    HubDriverOpen,</div><div class="line">    HubDriverClose,</div><div class="line">    0</div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_gaac5a936a2d1a6e3403798b031294992a"><div class="ttname"><a href="group__usbchap9__src.html#gaac5a936a2d1a6e3403798b031294992a">USB_CLASS_HUB</a></div><div class="ttdeci">#define USB_CLASS_HUB</div><div class="ttdef"><b>Definition:</b> usblib.h:427</div></div>
</div><!-- fragment --><p>This constant global structure defines the Hub Class Driver that is provided with the USB library. </p>

</div>
</div>
<a id="gaaf46ea1c58fa7fd6e70a661a16c33907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf46ea1c58fa7fd6e70a661a16c33907">&sect;&nbsp;</a></span>g_sUSBHostMSCClassDriver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structt_u_s_b_host_class_driver.html">tUSBHostClassDriver</a> g_sUSBHostMSCClassDriver</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    <a class="code" href="group__usbchap9__src.html#gaa99b73e335df09e6545fc44798a3c1f2">USB_CLASS_MASS_STORAGE</a>,</div><div class="line">    USBHMSCOpen,</div><div class="line">    USBHMSCClose,</div><div class="line">    0</div><div class="line">}</div><div class="ttc" id="group__usbchap9__src_html_gaa99b73e335df09e6545fc44798a3c1f2"><div class="ttname"><a href="group__usbchap9__src.html#gaa99b73e335df09e6545fc44798a3c1f2">USB_CLASS_MASS_STORAGE</a></div><div class="ttdeci">#define USB_CLASS_MASS_STORAGE</div><div class="ttdef"><b>Definition:</b> usblib.h:426</div></div>
</div><!-- fragment --><p>This constant global structure defines the Mass Storage Class Driver that is provided with the USB library. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
