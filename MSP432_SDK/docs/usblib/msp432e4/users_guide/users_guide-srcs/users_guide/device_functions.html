

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device Functions &mdash; MSP432E4 USB Library 1.00.00.01 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Host Functions" href="host_functions.html" />
    <link rel="prev" title="MSP432E4 USB Library" href="../index.html" /> 
</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> MSP432E4 USB Library
          

          
          </a>

          
            
            
              <div class="version">
                1.00.00.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Device Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-structure">File Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api-choices-for-usb-devices">API Choices for USB Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usb-driverlib-api">USB DriverLib API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usb-library-device-api">USB Library Device API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-feature-api">USB Device Feature API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-pll-feature">USB Device PLL Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-ulpi-feature">USB Device ULPI Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-power-feature">USB Device Power Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-lpm-feature">USB Device LPM Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-power-apis">USB Device Power APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#usb-device-class-driver-apis">USB Device Class Driver APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usb-device-class-apis">USB Device Class APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#audio-device-class-driver">Audio Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#handling-audio-playback">Handling Audio Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handling-other-audio-messages">Handling Other Audio Messages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-generic-audio-device-class">Using the Generic Audio Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-audio-device-class-in-a-composite-device">Using the Audio Device Class in a Composite Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#audio-device-class-events">Audio Device Class Events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bulk-device-class-driver">Bulk Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bulk-device-class-events">Bulk Device Class Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#receive-channel-events">Receive Channel Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmit-channel-events">Transmit Channel Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-generic-bulk-device-class">Using the Generic Bulk Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-bulk-device-class-in-a-composite-device">Using the Bulk Device Class in a Composite Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#windows-drivers-for-generic-bulk-devices">Windows Drivers for Generic Bulk Devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sample-winusb-inf-file">Sample WinUSB INF file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-libusb-win32-inf-file">Sample libusb-win32 INF File</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cdc-device-class-driver">CDC Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cdc-device-class-events">CDC Device Class Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Receive Channel Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Transmit Channel Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-channel-events">Control Channel Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-cdc-device-class-driver">Using the CDC Device Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-composite-cdc-serial-device-class">Using the Composite CDC Serial Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#windows-drivers-for-cdc-serial-devices">Windows Drivers for CDC Serial Devices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#composite-device-class-driver">Composite Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-composite-device">Defining a Composite Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-memory">Allocating Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-device-class-instances">Defining Device Class Instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interface-handling">Interface Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string-handling">String Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-composite-device">Example Composite Device</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#composite-device-instance">Composite Device Instance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#device-firmware-upgrade-device-class-driver">Device Firmware Upgrade Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-the-dfu-device-class">Using the DFU Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#windows-drivers-for-dfu-devices">Windows Drivers for DFU Devices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hid-device-class-driver">HID Device Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hid-device-class-events">HID Device Class Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">Receive Channel Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Transmit Channel Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-hid-device-class-driver">Using the HID Device Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-composite-hid-mouse-device-class">Using the Composite HID Mouse Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handling-hid-reports">Handling HID Reports</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hid-mouse-device-class-api">HID Mouse Device Class API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hid-mouse-device-api-events">HID Mouse Device API Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-hid-mouse-device-class-api">Using the HID Mouse Device Class API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hid-keyboard-device-class-api">HID Keyboard Device Class API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hid-keyboard-device-api-events">HID Keyboard Device API Events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hid-gamepad-device-class-api">HID Gamepad Device Class API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-hid-gamepad-device">Defining a HID Gamepad Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-custom-hid-gamepad-report">Defining a Custom HID Gamepad Report</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hid-sensor-device-class-api">HID Sensor Device Class API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-hid-sensor-device">Defining a HID Sensor Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-sensor-hid-report">Defining a Sensor HID Report</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mass-storage-device-class-api">Mass Storage Device Class API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#customization">Customization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vid-and-pid">VID and PID</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-configuration">Power Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-strings">Device Strings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#media-access-functions">Media Access Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-callbacks">Event Callbacks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-mass-storage-device-class">Using the Mass Storage Device Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-composite-mass-storage-device-class">Using the Composite Mass Storage Device Class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-usb-device-api">Using the USB Device API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#building-descriptors">Building Descriptors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tdeviceinfo-pdevicedescriptor">tDeviceInfo.pDeviceDescriptor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tdeviceinfo-ppui8configdescriptors">tDeviceInfo.ppui8ConfigDescriptors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tdeviceinfo-ppui8stringdescriptors-and-tdeviceinfo-ui32numstringdescriptors">tDeviceInfo.ppui8StringDescriptors and tDeviceInfo.ui32NumStringDescriptors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#usb-event-handlers">USB Event Handlers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pfngetdescriptor">pfnGetDescriptor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnrequesthandler">pfnRequestHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfninterfacechange">pfnInterfaceChange</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnconfigchange">pfnConfigChange</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfndatareceived">pfnDataReceived</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfndatasent">pfnDataSent</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnresethandler">pfnResetHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnsuspendhandler">pfnSuspendHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnresumehandler">pfnResumeHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfndisconnecthandler">pfnDisconnectHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfnendpointhandler">pfnEndpointHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pfndevicehandler">pfnDeviceHandler</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interrupt-vector-selection">Interrupt Vector Selection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passing-control-to-the-usb-device-api">Passing Control to the USB Device API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="host_functions.html">Host Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">MSP432E4 USB Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Device Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-structure">File Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-choices-for-usb-devices">API Choices for USB Devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usb-driverlib-api">USB DriverLib API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-library-device-api">USB Library Device API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-class-driver-apis">USB Device Class Driver APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-device-class-apis">USB Device Class APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#audio-device-class-driver">Audio Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handling-audio-playback">Handling Audio Playback</a></li>
<li class="toctree-l4"><a class="reference internal" href="#handling-other-audio-messages">Handling Other Audio Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-generic-audio-device-class">Using the Generic Audio Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-audio-device-class-in-a-composite-device">Using the Audio Device Class in a Composite Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audio-device-class-events">Audio Device Class Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bulk-device-class-driver">Bulk Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bulk-device-class-events">Bulk Device Class Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-generic-bulk-device-class">Using the Generic Bulk Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-bulk-device-class-in-a-composite-device">Using the Bulk Device Class in a Composite Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-drivers-for-generic-bulk-devices">Windows Drivers for Generic Bulk Devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cdc-device-class-driver">CDC Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cdc-device-class-events">CDC Device Class Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-cdc-device-class-driver">Using the CDC Device Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-composite-cdc-serial-device-class">Using the Composite CDC Serial Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-drivers-for-cdc-serial-devices">Windows Drivers for CDC Serial Devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#composite-device-class-driver">Composite Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-composite-device">Defining a Composite Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocating-memory">Allocating Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-composite-device">Example Composite Device</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#device-firmware-upgrade-device-class-driver">Device Firmware Upgrade Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-the-dfu-device-class">Using the DFU Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-drivers-for-dfu-devices">Windows Drivers for DFU Devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hid-device-class-driver">HID Device Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hid-device-class-events">HID Device Class Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-hid-device-class-driver">Using the HID Device Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-composite-hid-mouse-device-class">Using the Composite HID Mouse Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#handling-hid-reports">Handling HID Reports</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hid-mouse-device-class-api">HID Mouse Device Class API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hid-mouse-device-api-events">HID Mouse Device API Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-hid-mouse-device-class-api">Using the HID Mouse Device Class API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hid-keyboard-device-class-api">HID Keyboard Device Class API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hid-keyboard-device-api-events">HID Keyboard Device API Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hid-gamepad-device-class-api">HID Gamepad Device Class API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-hid-gamepad-device">Defining a HID Gamepad Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-custom-hid-gamepad-report">Defining a Custom HID Gamepad Report</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hid-sensor-device-class-api">HID Sensor Device Class API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-hid-sensor-device">Defining a HID Sensor Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-a-sensor-hid-report">Defining a Sensor HID Report</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mass-storage-device-class-api">Mass Storage Device Class API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#customization">Customization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-mass-storage-device-class">Using the Mass Storage Device Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-composite-mass-storage-device-class">Using the Composite Mass Storage Device Class</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-usb-device-api">Using the USB Device API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-descriptors">Building Descriptors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-event-handlers">USB Event Handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-vector-selection">Interrupt Vector Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#passing-control-to-the-usb-device-api">Passing Control to the USB Device API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="host_functions.html">Host Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="otg_functions.html">OTG Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="otg_functions.html">OTG Functions</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MSP432E4 USB Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Device Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-functions">
<h1>Device Functions<a class="headerlink" href="#device-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the various API layers within the USB library that offer support for applications wishing to present themselves as USB devices. Several programming interfaces are provided ranging from the thinnest layer which merely abstracts the underlying USB controller hardware to high level interfaces offering simple APIs supporting specific devices.</p>
</div>
<div class="section" id="file-structure">
<h2>File Structure<a class="headerlink" href="#file-structure" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filename</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdevice.h</span></code></p></td>
<td><p>The header file containing device mode function prototypes and data types offered by the library. This file is the main header file defining the USB Device API.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdbulk.h</span></code></p></td>
<td><p>The header file defining the USB generic bulk device class driver API.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdcdc.h</span></code></p></td>
<td><p>The header file defining the USB Communication Device Class (CDC) device class driver API.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhid.h</span></code></p></td>
<td><p>The header file defining the USB Human Interface Device (HID) device class driver API.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhidkeyb.h</span></code></p></td>
<td><p>The header file defining the USB HID keyboard device class API.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhidmouse.h</span></code></p></td>
<td><p>The header file defining the USB HID keyboard device class API.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdenum.c</span></code></p></td>
<td><p>The source code for the USB device enumeration functions offered by the library.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhandler.c</span></code></p></td>
<td><p>The source code for the USB device interrupt handler.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdconfig.c</span></code></p></td>
<td><p>The source code for the USB device configuration functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdcdesc.c</span></code></p></td>
<td><p>The source code for functions used to parse configuration descriptors defined in terms of an array of sections (as used with the USB Device API).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdbulk.c</span></code></p></td>
<td><p>The source code for the USB generic bulk device class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdcdc.c</span></code></p></td>
<td><p>The source code for the USB Communication Device Class (CDC) device class driver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhid.c</span></code></p></td>
<td><p>The source code for the USB Human Interface Device (HID) device class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhidkeyb.c</span></code></p></td>
<td><p>The source code for the USB HID keyboard device class.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdhidmouse.c</span></code></p></td>
<td><p>The source code for the USB HID keyboard device class.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdevicepriv.h</span></code></p></td>
<td><p>The private header file containing definitions shared between various source files in the device directory. Applications must not include this header.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdcomp.h</span></code></p></td>
<td><p>The header file defining the USB composite device APIs</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdcomp.c</span></code></p></td>
<td><p>The source code for USB Composite device</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdsensor.h</span></code></p></td>
<td><p>The header file defining the USB HID Sensor device APIs</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdsensor.c</span></code></p></td>
<td><p>The source code for USB Sensor device</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbdmsc.h</span></code></p></td>
<td><p>The header file defining the USB MSC device class APIs</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbdmsc.c</span></code></p></td>
<td><p>The source code for USB MSC device class</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="api-choices-for-usb-devices">
<h2>API Choices for USB Devices<a class="headerlink" href="#api-choices-for-usb-devices" title="Permalink to this headline">¶</a></h2>
<p>The USB library contains four API layers relevant to the development of USB device applications. Moving down the stack, each API layer offers greater flexibility to an application but this is balanced by the greater effort required to use the lower layers. The available programming interfaces, starting at the highest level and working downwards, are:</p>
<ul class="simple">
<li><p>Device Class APIs</p></li>
<li><p>Device Class Driver APIs</p></li>
<li><p>The USB Device API</p></li>
<li><p>The USB DriverLib API</p></li>
</ul>
<div class="figure align-default" id="id5">
<img alt="USB Device Block Diagram" src="../../_images/usb_device_block_diagram.png" />
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">USB Device Block Diagram</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>In the above diagram, bold horizontal lines represent APIs that are available for application use. Four possible applications are shown, each using a different programming interface to implement their USB functionality. The following sections provide an overview of the features and limitations of each layer and indicate the kinds of application which may choose to use that layer.</p>
<div class="section" id="usb-driverlib-api">
<h3>USB DriverLib API<a class="headerlink" href="#usb-driverlib-api" title="Permalink to this headline">¶</a></h3>
<p>The lowest layer in the USB device stack is the USB driver which can be found within the Driver Library (DriverLib) with source code in <code class="docutils literal notranslate"><span class="pre">usb.c</span></code> and header file <code class="docutils literal notranslate"><span class="pre">usb.h</span></code>. “Application 1” in the previous diagram offers device functionality by writing directly to this API.</p>
<p>Due to the fact that this API is a very thin layer above the USB controller’s hardware registers and, hence, does not offer any higher level USB transaction support (such as endpoint zero transaction processing, standard descriptor and request processing, etc.), applications would not typically use this API as the only way to access USB functionality. This driver would, however, be a suitable interface to use if developing, for example, a third-party USB stack.</p>
</div>
<div class="section" id="usb-library-device-api">
<h3>USB Library Device API<a class="headerlink" href="#usb-library-device-api" title="Permalink to this headline">¶</a></h3>
<p>The USB Library Device API offers a group of functions specifically intended to allow development of fully-featured USB device applications with as much of the class-independent code as possible contained in the USB Library. The API supports device enumeration via standard requests from the host and handles the endpoint zero state machine on behalf of the application.</p>
<p>An application using this interface provides the descriptors that it wishes to publish to the host during initialization and these provide the information that the USB Device API requires to configure the hardware. Asynchronous events relating to the USB device are notified to the application by means of a collection of callback functions also provided to the USB Device API on initialization.</p>
<p>This API is used in the development of USB device class drivers and can also be used directly by applications which want to provide USB functionality not supported by an existing class driver. Examples of such devices would be those requiring complex alternate interface settings.</p>
<p>The USB Device API can be thought of as a set of high level device extensions to the USB DriverLib API rather than a wrapper over it. When developing to the USB Device API, some calls to the underlying USB DriverLib API are still necessary.</p>
<p>The header file for the USB Device API is <code class="docutils literal notranslate"><span class="pre">device/usbdevice.h</span></code></p>
<div class="section" id="usb-device-feature-api">
<h4>USB Device Feature API<a class="headerlink" href="#usb-device-feature-api" title="Permalink to this headline">¶</a></h4>
<p>The USB library provides a method to configure global settings for a USB device. The <code class="docutils literal notranslate"><span class="pre">USBDCDFeatureSet()</span></code> function allows applications to modify the libraries configurable features options by setting features before starting up the USB library. This allows for run-time customizations of the USB library without requiring rebuilding of the library. Applications use these configurable options to control features like power settings and clocking options.</p>
</div>
<div class="section" id="usb-device-pll-feature">
<h4>USB Device PLL Feature<a class="headerlink" href="#usb-device-pll-feature" title="Permalink to this headline">¶</a></h4>
<p>The USB library must know what the application is using for the main PLL since the USB controller uses this to generate the USB clock. The USB library defaults to a 480 MHz PLL frequency, however if this is not the case then the application must call the <code class="docutils literal notranslate"><span class="pre">USBDCDFeatureSet()</span></code> function with the <strong>USBLIB_FEATURE_USBPLL</strong> option to inform the USB library of the non-default PLL frequency. The following is an example of configuring the USB library to operate when the application is using a 320 MHz PLL.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32PLLFrequency</span><span class="p">;</span>

<span class="n">ui32PLLFrequency</span> <span class="o">=</span> <span class="mi">320000000</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Inform the USB library that the system is running using a 320 MHz PLL.</span>
<span class="c1">//</span>
<span class="n">USBDCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_USBPLL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32PLLFrequency</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-device-ulpi-feature">
<h4>USB Device ULPI Feature<a class="headerlink" href="#usb-device-ulpi-feature" title="Permalink to this headline">¶</a></h4>
<p>The USB Library also supports using an external ULPI USB phy to allow operating the USB controller in high speed mode. This feature is enabled by setting the <strong>USBLIB_FEATURE_USBULPI</strong> option combined with the desired speed. From the applications perspective this has no affect to normal USB operation other than the necessity to properly enable the USB external phy pins. The possible options are the following:</p>
<ul class="simple">
<li><p><strong>USBLIB_FEATURE_ULPI_NONE</strong> - Disable ULPI and use the internal phy(default).</p></li>
<li><p><strong>USBLIB_FEATURE_ULPI_HS</strong> - Use an externally connected ULPI phy at high-speed.</p></li>
<li><p><strong>USBLIB_FEATURE_ULPI_FS</strong> - Use an externally connected ULPI phy at full-speed.</p></li>
</ul>
<p>The following is an example of configuring the USB library to use and external phy operating in high speed mode.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32ULPI</span><span class="p">;</span>

<span class="n">ui32ULPI</span> <span class="o">=</span> <span class="n">USBLIB_FEATURE_ULPI_HS</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Enable the use of an external USB ULPI connected phy.</span>
<span class="c1">//</span>
<span class="n">USBDCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_USBULPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32ULPI</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-device-power-feature">
<h4>USB Device Power Feature<a class="headerlink" href="#usb-device-power-feature" title="Permalink to this headline">¶</a></h4>
<p>Because many USB devices need to determine their own power configuration options, the USB library provides a feature settings for power as well. The power options are set using the <strong>USBLIB_FEATURE_POWER</strong> value with the following options:</p>
<ul class="simple">
<li><p><strong>USBLIB_FEATURE_POWER_BUS</strong> - USB device mode is bus powered(default).</p></li>
<li><p><strong>USBLIB_FEATURE_POWER_SELF</strong> - USB device mode is self powered.</p></li>
<li><p><strong>USBLIB_FEATURE_REMOTE_WAKE</strong> - Enable USB remote wake feature.</p></li>
</ul>
<p>The following is an example of configuring the USB library to be self-powered with remote wake enabled.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32Power</span><span class="p">;</span>

<span class="n">ui32ULPI</span> <span class="o">=</span> <span class="n">USBLIB_FEATURE_POWER_SELF</span> <span class="o">|</span> <span class="n">USBLIB_FEATURE_REMOTE_WAKE</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Configure as self powered with remote wake capabilities.</span>
<span class="c1">//</span>
<span class="n">USBDCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_POWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32Power</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-device-lpm-feature">
<h4>USB Device LPM Feature<a class="headerlink" href="#usb-device-lpm-feature" title="Permalink to this headline">¶</a></h4>
<p>This feature is not enabled by default and therefore must be enabled by the application if it wishes to use the LPM feature. These options also set using using the <code class="docutils literal notranslate"><span class="pre">USBDCDFeatureSet()</span></code> API and have the following options:</p>
<ul class="simple">
<li><p><strong>USBLIB_FEATURE_LPM_DIS</strong> - Disable LPM transactions (default).</p></li>
<li><p><strong>USBLIB_FEATURE_LPM_EN</strong> - Enable receiving LPM transactions.</p></li>
<li><p><strong>USBLIB_FEATURE_LPM_RMT_WAKE</strong> - Enable support for LPM remote wake feature.</p></li>
</ul>
<p>The following is an example of configuring the USB library enable LPM mode and enable the device as an LPM remote wake device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32LPMFeature</span><span class="p">;</span>

<span class="n">ui32LPMFeature</span> <span class="o">=</span> <span class="n">USBLIB_FEATURE_LPM_EN</span> <span class="o">|</span> <span class="n">USBLIB_FEATURE_LPM_RMT_WAKE</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Enable LPM transactions and remote LPM wake.</span>
<span class="c1">//</span>
<span class="n">USBDCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_LPM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32LPMFeature</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-device-power-apis">
<h4>USB Device Power APIs<a class="headerlink" href="#usb-device-power-apis" title="Permalink to this headline">¶</a></h4>
<p>When an application has enabled certain power related features like remote wake and LPM it also needs the ability to trigger run-time events using the USB library. The only USB device mode run-time power functions are the <code class="docutils literal notranslate"><span class="pre">USBDCDRemoteWakeupRequest()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBDCDRemoteWakeLPM()</span></code> functions which are both used to trigger remote wake requests to the USB host controller. The <code class="docutils literal notranslate"><span class="pre">USBDCDRemoteWakeupRequest()</span></code> is used when a device has received a normal USB suspend request and the application needs to wake the USB host. The <code class="docutils literal notranslate"><span class="pre">USBDCDRemoteWakeLPM()</span></code> is used when a device entered a suspended state due to an LPM suspend event and needs to wake the USB host.</p>
</div>
</div>
<div class="section" id="usb-device-class-driver-apis">
<h3>USB Device Class Driver APIs<a class="headerlink" href="#usb-device-class-driver-apis" title="Permalink to this headline">¶</a></h3>
<p>Device Class Drivers offer high level USB function to applications wishing to offer particular USB features without having to deal with most of the USB transaction handling and connection management that would otherwise be required. These drivers provide high level APIs for several commonly-used USB device classes with the following features.</p>
<ul class="simple">
<li><p>Extremely easy to use. Device setup involves creating a set of static data structures and calling a single initialization API.</p></li>
<li><p>Configurable VID/PID, power parameters and string table to allow easy customization of the device without the need to modify any library code.</p></li>
<li><p>Consistent interfaces. All device class drivers use similar APIs making it very straightforward to move between them.</p></li>
<li><p>Minimal application overhead. The vast majority of USB handling is performed within the class driver and lower layers leaving the application to deal only with reading and writing data.</p></li>
<li><p>May be used with optional USB buffer objects to further simplify data transmission and reception. Using USB buffers, interaction with the device class driver can become as simple as a read/write API with no state machine required to ensure that data is transmitted or received at the correct time.</p></li>
<li><p>Device Class Driver APIs completely wrap the underlying USB Device and USB Driver APIs so only a single API interface is used by the application.</p></li>
</ul>
<p>Balancing these advantages, application developers should note the following restrictions that apply when using the Device Class Driver APIs.</p>
<ul class="simple">
<li><p>No calls may be made to any other USB layer while the device class driver API is in use.</p></li>
<li><p>Alternate configurations are not supported by the supplied device class drivers.</p></li>
</ul>
<p>Device class drivers are currently provided to allow creation of a generic bulk device, a Communication Device Class (virtual serial port) device and a Human Interface Device class device (mouse, keyboard, joystick, etc.). A special class driver for composite devices is also included. This acts as a wrapper allowing multiple device class drivers to be used in a single device. Detailed information on each of these classes can be found later in this document.</p>
</div>
<div class="section" id="usb-device-class-apis">
<h3>USB Device Class APIs<a class="headerlink" href="#usb-device-class-apis" title="Permalink to this headline">¶</a></h3>
<p>In some cases, a standard device class may offer the possibility of creating a great number of different and varied devices using the same class and in these cases an additional API layer can be provided to further specialize the device operation and simplify the interface to the application.</p>
<p>The Human Interface Device (HID) class is one such class. It is used to support a wide variety of devices including keyboards, joysticks, mice and game controllers but the interface is specified in such a way that it could be used for a huge number of vendor-specific devices offering data gathering capability. As a result, the HID device class driver is extremely general to allow support for as wide a range of devices as possible. To simplify the use of the interface, specific APIs are provided to support BIOS-compatible keyboard and mouse operation. Using the mouse class API instead of the base HID class driver API, an application can make itself visible to the USB host as a mouse using an extremely simple interface consisting of an initialization call and a call to inform the host of mouse movement or button presses. Similarly, using the keyboard device class API, the application can use a single API to send key make and break information to the host without having to be aware of the
underlying HID structures and USB protocols.</p>
<p>Example applications <code class="docutils literal notranslate"><span class="pre">usb_dev_mouse</span></code> and <code class="docutils literal notranslate"><span class="pre">usb_dev_keyboard</span></code> make use of the HID mouse and keyboard device class APIs respectively.</p>
</div>
</div>
<div class="section" id="audio-device-class-driver">
<h2>Audio Device Class Driver<a class="headerlink" href="#audio-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>The USB audio device class provides a playback interface which allows an application to act as a generic USB audio device to any host operating systems that natively supports USB audio devices. Most operating systems provide native support for generic audio class devices which means that no operating system specific drivers are required. The USB audio device class provides a single 16 bit stereo playback interface at 48kHz sample rate and also provides volume and mute controls.</p>
<div class="figure align-default" id="id6">
<img alt="USB Audio Device" src="../../_images/usb_audio_device.png" />
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">USB Audio Device</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="handling-audio-playback">
<h3>Handling Audio Playback<a class="headerlink" href="#handling-audio-playback" title="Permalink to this headline">¶</a></h3>
<p>The audio playback path is handled by the application passing buffers to be filled to the USB audio class and receiving them back with audio data from the USB host controller. The USB audio class only holds one buffer at a time and returns it to the application when it is full. Because the USB audio class only holds one buffer, it is important to pass in a new buffer to the USB audio class as soon as possible once a buffer is returned to the application to prevent underflow from the USB host controller. Since most audio playback methods uses at least two buffers, one that is playing and one that is being filled, the single buffer in the USB audio class allows for minimal buffering and eliminates copying of data between buffers. When the application has an audio buffer that needs to be filled it passes it to the USB audio class using the <code class="docutils literal notranslate"><span class="pre">USBAudioBufferOut()</span></code> function. The USB audio class returns the buffer to the application via the audio message handler that the application provided
in the pfnHandler member of the <code class="docutils literal notranslate"><span class="pre">tUSBDAudioDevice</span></code> structure. As soon as the audio device is active the application can provide a buffer to the USB audio class with a call to <code class="docutils literal notranslate"><span class="pre">USBAudioBufferOut()</span></code>. This call only fails if the USB audio class already has a buffer, at this point the application must wait for a previous buffer to be returned with a <code class="docutils literal notranslate"><span class="pre">USBD_AUDIO_EVENT_DATAOUT</span></code> message. Once the <code class="docutils literal notranslate"><span class="pre">USBD_AUDIO_EVENT_DATAOUT</span></code> message is received, the buffer has been filled and can be played. The buffer provided may not be completely full so the application should only play the portion of the buffer indicated by the message. To prevent underflow the application should always be sure that the audio device class has an empty buffer to fill as soon as a filled buffer is returned. The USB audio class does not provide a way to stop playing audio because typically when the USB host controller stops playing audio the host simply stops providing data to the USB audio device and playback stops.
This does not result in any notification to the application other than <code class="docutils literal notranslate"><span class="pre">USBD_AUDIO_EVENT_DATAOUT</span></code> messages stop being received. If the application needs to stop receiving data, it can simply stop providing buffers to the USB audio class and the audio class ignores any incoming data from the USB host controller.</p>
</div>
<div class="section" id="handling-other-audio-messages">
<h3>Handling Other Audio Messages<a class="headerlink" href="#handling-other-audio-messages" title="Permalink to this headline">¶</a></h3>
<p>The USB audio class also provides a few other notification messages to the application. These are the <strong>USBD_AUDIO_EVENT_VOLUME</strong> and <strong>USBD_AUDIO_EVENT_MUTE</strong> messages which are both inform the application of volume and mute changes in the playback stream. The <strong>USBD_AUDIO_EVENT_VOLUME</strong> message returns a value that ranges from 0 - 100 in percentage for the playback volume. The <strong>USBD_AUDIO_EVENT_MUTE</strong> is either zero indicating that the playback path is not muted or 1 indicating that the playback path is muted. The application should always take care to defer any lenghty processing of messages to its non-callback routines to prevent underflow/overflow conditions from occuring.</p>
</div>
<div class="section" id="using-the-generic-audio-device-class">
<h3>Using the Generic Audio Device Class<a class="headerlink" href="#using-the-generic-audio-device-class" title="Permalink to this headline">¶</a></h3>
<p>To add USB Audio data playback capability to your application via the Audio Device Class Driver, take the following steps.</p>
<ul class="simple">
<li><p>Add the following header files to the source file(s) which are to support USB:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdaudio.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define the six entry string descriptor table which is used to describe various features of your new device to the host system. The following is the string table taken from the <code class="docutils literal notranslate"><span class="pre">usb_dev_audio</span></code> example application. Edit the actual strings to suit your application and take care to ensure that you also update the length field (the first byte) of each descriptor to correctly reflect the length of the string and descriptor header. The number of string descriptors you include must be (1 + (5 * num languages)) where the number of languages agrees with the list published in string descriptor 0, <code class="docutils literal notranslate"><span class="pre">g_pLangDescriptor</span></code>. The strings for each language must be grouped together with all the language 1 strings before all the language 2 strings and so on.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The languages supported by this device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8LangDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">4</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_LANG_EN_US</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The manufacturer string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ManufacturerString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The product string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ProductString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;E&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The serial number string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SerialNumberString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The interface description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8HIDInterfaceString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">15</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The configuration description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ConfigString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The descriptor string table.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppui8StringDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pui8LangDescriptor</span><span class="p">,</span>
    <span class="n">g_pui8ManufacturerString</span><span class="p">,</span>
    <span class="n">g_pui8ProductString</span><span class="p">,</span>
    <span class="n">g_pui8SerialNumberString</span><span class="p">,</span>
    <span class="n">g_pui8HIDInterfaceString</span><span class="p">,</span>
    <span class="n">g_pui8ConfigString</span>
<span class="p">};</span>

<span class="cp">#define NUM_STRING_DESCRIPTORS (sizeof(g_ppui8StringDescriptors) /            \</span>
<span class="cp">                                sizeof(uint8_t *))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDAudioDevice</span></code> structure and initialize all fields as required for your application.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDAudioDevice</span> <span class="n">g_sAudioDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The vendor string for your device (8 chars).</span>
    <span class="c1">//</span>
    <span class="n">USB_YOUR_VENDOR_STRING</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product string for your device (16 chars).</span>
    <span class="c1">//</span>
    <span class="n">USB_YOUR_PRODUCT_STRING</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The revision string for your device (4 chars BCD).</span>
    <span class="c1">//</span>
    <span class="n">USB_YOUR_REVISION_STRING</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your control callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBAudioMessageHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_ppui8StringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table.</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Maximum volume setting expressed as and 8.8 signed fixed point number.</span>
    <span class="c1">//</span>
    <span class="n">VOLUME_MAX</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Minimum volume setting expressed as and 8.8 signed fixed point number.</span>
    <span class="c1">//</span>
    <span class="n">VOLUME_MIN</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Minimum volume step expressed as and 8.8 signed fixed point number.</span>
    <span class="c1">//</span>
    <span class="n">VOLUME_STEP</span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p>From your main initialization function call the audio device class driver initialization function to configure the USB controller and place the device on the bus.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDAudioInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sAudioDevice</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, the audio message handler is sent the <strong>USB_EVENT_CONNECTED</strong> event.</p></li>
<li><p>Once the host is configured to use the Audio device the audio message handler is called with a <strong>USBD_AUDIO_EVENT_ACTIVE</strong> event.</p></li>
</ul>
</div>
<div class="section" id="using-the-audio-device-class-in-a-composite-device">
<h3>Using the Audio Device Class in a Composite Device<a class="headerlink" href="#using-the-audio-device-class-in-a-composite-device" title="Permalink to this headline">¶</a></h3>
<p>When using the audio device class in a composite device, the configuration of the device is very similar to how it is configured as a non-composite device. Follow all of the configuration steps in the previous section with the exception of calling <code class="docutils literal notranslate"><span class="pre">USBDAudioCompositeInit()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">USBDAudioInit()</span></code>. This prepares an instance of the audio device class to be enumerated as part of a composite device. The <code class="docutils literal notranslate"><span class="pre">USBDAudioCompositeInit()</span></code> function takes the audio device structure and a pointer to a <code class="docutils literal notranslate"><span class="pre">tCompositeEntry</span></code> value so that it can properly initialize the audio device and the composite entry that is passed to the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> funtion. The code example below provides an example of how to initialize an audio device to be a part of a composite device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// These should be initialized with valid values for each class.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="n">tUSBDAudioDevice</span> <span class="n">g_sAudioDevice</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">pvAudioDevice</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The array of composite device entries.</span>
<span class="c1">//</span>
<span class="n">tCompositeEntry</span> <span class="n">psCompEntries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Allocate the device data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series PID for composite serial device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_COMPOSITE_PID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments so 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Composite event handler.</span>
    <span class="c1">//</span>
    <span class="n">EventHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pui8StringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">g_psCompEntries</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// The OTHER_SIZES here are the sizes of the descriptor data for other classes</span>
<span class="c1">// that are part of the composite device.</span>
<span class="c1">//</span>
<span class="cp">#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DAUDIO_SIZE + OTHER_SIZES)</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8DescriptorData</span><span class="p">[</span><span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Initialize the audio device and its composite entry which is entry 0.</span>
<span class="c1">//</span>
<span class="n">pvAudioDevice</span> <span class="o">=</span> <span class="n">USBDAudioCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sAudioDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psCompEntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">//</span>
<span class="c1">// Initialize other devices to add to the composite device.</span>
<span class="c1">//</span>

<span class="p">...</span>

<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">,</span>
                  <span class="n">g_pui8DescriptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>All other API calls to the USB audio device class should use the value returned by <code class="docutils literal notranslate"><span class="pre">USBDAudioCompositeInit()</span></code> when the APIs call for a pvInstance pointer. Also when using the audio device in a composite device the <strong>COMPOSITE_DAUDIO_SIZE</strong> value should be added to the size of the <code class="docutils literal notranslate"><span class="pre">g_pui8DescriptorData</span></code> array as shown in the example above.</p>
</div>
<div class="section" id="audio-device-class-events">
<h3>Audio Device Class Events<a class="headerlink" href="#audio-device-class-events" title="Permalink to this headline">¶</a></h3>
<p>The audio device class driver sends the following events to the application callback functions:</p>
<ul class="simple">
<li><p><strong>USBD_AUDIO_EVENT_IDLE</strong> - Audio interface is idle.</p></li>
<li><p><strong>USBD_AUDIO_EVENT_ACTIVE</strong> - Audio interface is active.</p></li>
<li><p><strong>USBD_AUDIO_EVENT_DATAOUT</strong> - Audio playback buffer released.</p></li>
<li><p><strong>USBD_AUDIO_EVENT_VOLUME</strong> - Audio playback volume change.</p></li>
<li><p><strong>USBD_AUDIO_EVENT_MUTE</strong> - Audio mute change.</p></li>
</ul>
</div>
</div>
<div class="section" id="bulk-device-class-driver">
<h2>Bulk Device Class Driver<a class="headerlink" href="#bulk-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>Although not offering support for a particular standard device class, the generic bulk device class driver offers a very simple method for an application to set up USB communication with a paired application running on the USB host system. The class driver offers a single bulk receive channel and a single bulk transmit channel and, when coupled with USB buffers on each channel, provides a straightforward read/write interface to the application.</p>
<p>The device supports a single interface containing bulk IN and bulk OUT endpoints. The configuration and interface descriptors published by the device contain vendor specific class identifiers so an application on the host has to communicate with the device using either a custom driver or a subsystem such as WinUSB or libusb-win32 on Windows to allow the device to be accessed. An example of this is provided in the <code class="docutils literal notranslate"><span class="pre">usb_dev_bulk</span></code> application.</p>
<p>This class driver is particularly useful for applications which intend passing high volumes of data via USB and where host-side application code is being developed in partnership with the device.</p>
<div class="figure align-default" id="id7">
<img alt="USB Generic Bulk Device" src="../../_images/usb_generic_bulk_device.png" />
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">USB Generic Bulk Device</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">usb_dev_bulk</span></code> example application makes use of this device class driver.</p>
<div class="section" id="bulk-device-class-events">
<h3>Bulk Device Class Events<a class="headerlink" href="#bulk-device-class-events" title="Permalink to this headline">¶</a></h3>
<p>The bulk device class driver sends the following events to the application callback functions:</p>
<div class="section" id="receive-channel-events">
<h4>Receive Channel Events<a class="headerlink" href="#receive-channel-events" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_RX_AVAILABLE</strong></p></li>
<li><p><strong>USB_EVENT_ERROR</strong></p></li>
<li><p><strong>USB_EVENT_CONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong></p></li>
<li><p><strong>USB_EVENT_RESUME</strong></p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not be reported to the application if the MCU’s PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
</div>
<div class="section" id="transmit-channel-events">
<h4>Transmit Channel Events<a class="headerlink" href="#transmit-channel-events" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_TX_COMPLETE</strong></p></li>
</ul>
</div>
</div>
<div class="section" id="using-the-generic-bulk-device-class">
<h3>Using the Generic Bulk Device Class<a class="headerlink" href="#using-the-generic-bulk-device-class" title="Permalink to this headline">¶</a></h3>
<p>To add USB bulk data transmit and receive capability to your application via the Generic Bulk Device Class Driver, take the following steps.</p>
<ul class="simple">
<li><p>Add the following header files to the source file(s) which are to support USB:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdbulk.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define the 5 entry string table which is used to describe various features of your new device to the host system. The following is the string table taken from the <code class="docutils literal notranslate"><span class="pre">usb_dev_bulk</span></code> example application. Edit the actual strings to suit your application and take care to ensure that you also update the length field (the first byte) of each descriptor to correctly reflect the length of the string and descriptor header. The number of strings you include must be 5 * (number of languages listed in string descriptor 0, <code class="docutils literal notranslate"><span class="pre">g_pLangDescriptor</span></code>, and the strings for each language must be grouped together with all the language 1 strings before all the language 2 strings and so on.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The languages supported by this device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8LangDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">4</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_LANG_EN_US</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The manufacturer string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ManufacturerString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The product string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ProductString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">19</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;k&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;v&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The serial number string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SerialNumberString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The data interface description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8DataInterfaceString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">19</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;k&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The configuration description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ConfigString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">23</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;k&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The descriptor string table.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppui8StringDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pui8LangDescriptor</span><span class="p">,</span>
    <span class="n">g_pui8ManufacturerString</span><span class="p">,</span>
    <span class="n">g_pui8ProductString</span><span class="p">,</span>
    <span class="n">g_pui8SerialNumberString</span><span class="p">,</span>
    <span class="n">g_pui8DataInterfaceString</span><span class="p">,</span>
    <span class="n">g_pui8ConfigString</span>
<span class="p">};</span>

<span class="cp">#define NUM_STRING_DESCRIPTORS (sizeof(g_ppui8StringDescriptors) /            \</span>
<span class="cp">                                sizeof(uint8_t *))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDBulkDevice</span></code> structure and initialize all fields as required for your application. The following example illustrates a simple case where no USB buffers are in use. For an example using USB buffers, see the source file <code class="docutils literal notranslate"><span class="pre">usb_bulk_structs.c</span></code> in the <code class="docutils literal notranslate"><span class="pre">usb_dev_bulk</span></code> example application.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDBulkDevice</span> <span class="n">g_sBulkDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your receive callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBReceiveEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the receive callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your transmit callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBTransmitEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the transmit callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_ppui8StringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table.</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Add a receive event handler function, YourUSBReceiveEventCallback in the previous example, to your application taking care to handle all messages which require a particular response. For the generic bulk device class, only the <strong>USB_EVENT_RX_AVAILABLE</strong> MUST be handled by the receive event handler. In response to <strong>USB_EVENT_RX_AVAILABLE</strong>, your handler should check the amount of data received by calling <code class="docutils literal notranslate"><span class="pre">USBDBulkRxPacketAvailable()</span></code> then read it using a call to <code class="docutils literal notranslate"><span class="pre">USBDBulkPacketRead()</span></code>. This causes the newly received data to be acknowledged to the host and instructs the host that it may now transmit another packet. If you are unable to read the data immediately, return 0 from the callback handler and you are called back once again a few milliseconds later. Although no other events must be handled, <strong>USB_EVENT_CONNECTED</strong> and <strong>USB_EVENT_DISCONNECTED</strong> is typically required since these indicate when a host connects or disconnects and allow the application to flush any
buffers or reset state as required. Attempts to send data when the host is disconnected result in an immediate failure.</p></li>
<li><p>Add a transmit event handler function, YourUSBTransmitEventCallback in the previous example, to your application taking care to handle all messages which require a particular response. For the generic bulk device class, there are no events sent to the transmit callback which MUST be handled but applications usually want to note <strong>USB_EVENT_TX_COMPLETE</strong> since this is an interlock message indicating that the previous packet sent has been acknowledged by the host and a new packet can now be sent.</p></li>
<li><p>From your main initialization function call the generic bulk device class driver initialization function to configure the USB controller and place the device on the bus.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDBulkInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sBulkDevice</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, your receive event handler is sent <strong>USB_EVENT_CONNECTED</strong> and the first packet of data may be sent to the host using <code class="docutils literal notranslate"><span class="pre">USBDBulkPacketWrite()</span></code> with following packets transmitted as soon as <strong>USB_EVENT_TX_COMPLETE</strong> is received.</p></li>
</ul>
</div>
<div class="section" id="using-the-bulk-device-class-in-a-composite-device">
<h3>Using the Bulk Device Class in a Composite Device<a class="headerlink" href="#using-the-bulk-device-class-in-a-composite-device" title="Permalink to this headline">¶</a></h3>
<p>When using the bulk device class in a composite device, the configuration of the device is very similar to how it is configured as a non-composite device. Follow all of the configuration steps in the previous section with the exception of calling <code class="docutils literal notranslate"><span class="pre">USBDBulkCompositeInit()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">USBDBulkInit()</span></code>. This prepares an instance of the bulk device class to be enumerated as part of a composite device. The <code class="docutils literal notranslate"><span class="pre">USBDBulkCompositeInit()</span></code> function takes the bulk device structure and a pointer to a tCompositeEntry value so that it can properly initialize the bulk device and the composite entry that is passed to the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> funtion. The code example below provides an example of how to initialize a bulk device to be a part of a composite device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// These should be initialized with valid values for each class.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="n">tUSBDBulkDevice</span> <span class="n">g_sBulkDevice</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">pvBulkDevice</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The array of composite devices.</span>
<span class="c1">//</span>
<span class="n">tCompositeEntry</span> <span class="n">psCompEntries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Allocate the device data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series PID for composite serial device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_COMPOSITE_PID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments so 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Composite event handler.</span>
    <span class="c1">//</span>
    <span class="n">EventHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pui8StringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">g_psCompEntries</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// The OTHER_SIZES here are the sizes of the descriptor data for other classes</span>
<span class="c1">// that are part of the composite device.</span>
<span class="c1">//</span>
<span class="cp">#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DBULK_SIZE + OTHER_SIZES)</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8DescriptorData</span><span class="p">[</span><span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Initialize the bulk device and its composite entry.</span>
<span class="c1">//</span>
<span class="n">pvBulkDevice</span> <span class="o">=</span> <span class="n">USBDBulkCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sBulkDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psCompEntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">//</span>
<span class="c1">// Initialize other devices to add to the composite device.</span>
<span class="c1">//</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB controller as a composite device.</span>
<span class="c1">//</span>
<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">,</span>
                  <span class="n">g_pui8DescriptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>All other API calls to the USB bulk device class should use the value returned by <code class="docutils literal notranslate"><span class="pre">USBDBulkCompositeInit()</span></code> when the API calls for a pvInstance pointer. Also when using the bulk device in a composite device the <strong>COMPOSITE_DBULK_SIZE</strong> value should be added to the size of the <code class="docutils literal notranslate"><span class="pre">g_pui8DescriptorData</span></code> array as shown in the example above.</p>
</div>
<div class="section" id="windows-drivers-for-generic-bulk-devices">
<h3>Windows Drivers for Generic Bulk Devices<a class="headerlink" href="#windows-drivers-for-generic-bulk-devices" title="Permalink to this headline">¶</a></h3>
<p>Since generic bulk devices appear to a host operating system as vendor-specific devices, no device drivers on the host system is able to communicate with them without some help from the device developer. This help may involve writing a specific Windows kernel driver for the device or, if kernel driver programming is too daunting, steering Windows to use one of several possible generic kernel drivers that can manage the device on behalf of a user mode application.</p>
<p>Using this second model, a device developer need not write any Windows driver code but would need to write an application or DLL that interfaces with the device via the user-mode API offered by whichever USB subsystem they chose to manage their device. The developer is also responsible for producing a suitable INF file to allow Windows to associate the device (identified via its VID/PID combination) with a particular driver.</p>
<p>A least two suitable USB subsystems are available for Windows - WinUSB from Microsoft or open-source project libusb-win32 available from SourceForge.</p>
<p>WinUSB supports WindowsXP, Windows Vista and Windows7 systems. Further information can be obtained from MSDN at <a class="reference external" href="http://msdn.microsoft.com/en-us/library/aa476426.aspx">http://msdn.microsoft.com/en-us/library/aa476426.aspx</a>. To develop applications using the WinUSB interface, the Windows Driver Development Kit (DDK) must be installed on your build PC.</p>
<p>libusb-win32 supports Windows98SE, Windows2000, WindowsNT and WindowsXP and can be downloaded from <a class="reference external" href="http://libusb-win32.sourceforge.net/">http://libusb-win32.sourceforge.net/</a>. It offers a straightforward method of accessing the device and also provides a very helpful INF file generator.</p>
<div class="section" id="sample-winusb-inf-file">
<h4>Sample WinUSB INF file<a class="headerlink" href="#sample-winusb-inf-file" title="Permalink to this headline">¶</a></h4>
<p>This file illustrates how to build an INF to associate your device with the WinUSB subsystem on WindowsXP or Vista. Note that the driver package for the device must include not only this INF file but the Microsoft-supplied coinstallers listed in the files section. These can be found within the Windows Driver Development Kit (DDK).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>; -----------------------------------------------------------------------------
;
; USBLib Generic Bulk USB device driver installer
;
; This INF file may be used as a template when creating customized applications
; based on the USBLib generic bulk devices. Areas of the file requiring
; customization for a new device are commented with NOTEs.
;
; -----------------------------------------------------------------------------

; NOTE: When you customize this INF for your own device, create a new class
; name (Class) and a new GUID (ClassGuid). GUIDs may be created using the
; guidgen tool from Windows Visual Studio.

[Version]
Signature = &quot;$Windows NT$&quot;
Class = USBLibBulkDeviceClass
ClassGuid={F5450C06-EB58-420e-8F98-A76C5D4AFB18}
Provider = %ProviderName%
CatalogFile=MyCatFile.cat

; ========== Manufacturer/Models sections ===========

[Manufacturer]
%ProviderName% = USBLibBulkDevice_WinUSB,NTx86,NTamd64

; NOTE: Replace the VID and PID in the following two sections with the
; correct values for your device.

[USBLibBulkDevice_WinUSB.NTx86]
%USB\USBLibBulkDevice.DeviceDesc% =USB_Install, USB\VID_1CBE&amp;PID_0003

[USBLibBulkDevice_WinUSB.NTamd64]
%USB\USBLibBulkDevice.DeviceDesc% =USB_Install, USB\VID_1CBE&amp;PID_0003

; =================== Installation ===================

[ClassInstall32]
AddReg=AddReg_ClassInstall

[AddReg_ClassInstall]
HKR,,,,&quot;%DeviceClassDisplayName%&quot;
HKR,,Icon,,&quot;-20&quot;

[USB_Install]
Include=winusb.inf
Needs=WINUSB.NT

[USB_Install.Services]
Include=winusb.inf
AddService=WinUSB,0x00000002,WinUSB_ServiceInstall

[WinUSB_ServiceInstall]
DisplayName     = %WinUSB_SvcDesc%
ServiceType     = 1
StartType       = 3
ErrorControl    = 1
ServiceBinary   = %12%\WinUSB.sys

[USB_Install.Wdf]
KmdfService=WINUSB, WinUsb_Install

[WinUSB_Install]
KmdfLibraryVersion=1.5

[USB_Install.HW]
AddReg=Dev_AddReg

; NOTE: Create a new GUID for your interface and replace the following one
; when customizing for a new device.

[Dev_AddReg]
HKR,,DeviceInterfaceGUIDs,0x10000,&quot;{6E45736A-2B1B-4078-B772-B3AF2B6FDE1C}&quot;

[USB_Install.CoInstallers]
AddReg=CoInstallers_AddReg
CopyFiles=CoInstallers_CopyFiles

[CoInstallers_AddReg]
HKR,,CoInstallers32,0x00010000,&quot;WdfCoInstaller01005.dll,WdfCoInstaller&quot;,&quot;WinUSBCoInstaller.dll&quot;

[CoInstallers_CopyFiles]
WinUSBCoInstaller.dll
WdfCoInstaller01005.dll

[DestinationDirs]
CoInstallers_CopyFiles=11

; ================= Source Media Section =====================

[SourceDisksNames]
1 = %DISK_NAME%,,,\i386
2 = %DISK_NAME%,,,\amd64

[SourceDisksFiles.x86]
WinUSBCoInstaller.dll=1
WdfCoInstaller01005.dll=1

[SourceDisksFiles.amd64]
WinUSBCoInstaller.dll=2
WdfCoInstaller01005.dll=2

; =================== Strings ===================

; Note: Replace these as appropriate to describe your device.

[Strings]
ProviderName=&quot;Texas Instruments&quot;
USB\USBLibBulkDevice.DeviceDesc=&quot;Generic Bulk Device&quot;
WinUSB_SvcDesc=&quot;WinUSB&quot;
DISK_NAME=&quot;USBLib Install Disk&quot;
DeviceClassDisplayName=&quot;USBLib Bulk Devices&quot;
</pre></div>
</div>
</div>
<div class="section" id="sample-libusb-win32-inf-file">
<h4>Sample libusb-win32 INF File<a class="headerlink" href="#sample-libusb-win32-inf-file" title="Permalink to this headline">¶</a></h4>
<p>The following is an example of an INF file that can be used to associate the <code class="docutils literal notranslate"><span class="pre">usb_dev_bulk</span></code> example device with the libusb-win32 subsystem on Windows systems and to install the necessary drivers. This was created using the “INF Wizard” application which is included in the libusb-win32 download package.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Version</span><span class="p">]</span>
<span class="n">Signature</span> <span class="o">=</span> <span class="s2">&quot;$Chicago$&quot;</span>
<span class="n">provider</span>  <span class="o">=</span> <span class="o">%</span><span class="n">manufacturer</span><span class="o">%</span>
<span class="n">DriverVer</span> <span class="o">=</span> <span class="mi">03</span><span class="o">/</span><span class="mi">20</span><span class="o">/</span><span class="mi">2007</span><span class="p">,</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">12.1</span>
<span class="n">CatalogFile</span> <span class="o">=</span> <span class="n">usb_dev_bulk_libusb</span><span class="o">.</span><span class="n">cat</span>
<span class="n">CatalogFile</span><span class="o">.</span><span class="n">NT</span> <span class="o">=</span> <span class="n">usb_dev_bulk_libusb</span><span class="o">.</span><span class="n">cat</span>
<span class="n">CatalogFile</span><span class="o">.</span><span class="n">NTAMD64</span> <span class="o">=</span> <span class="n">usb_dev_bulk_libusb_x64</span><span class="o">.</span><span class="n">cat</span>

<span class="n">Class</span> <span class="o">=</span> <span class="n">LibUsbDevices</span>
<span class="n">ClassGUID</span> <span class="o">=</span> <span class="p">{</span><span class="n">EB781AAF</span><span class="o">-</span><span class="mi">9</span><span class="n">C70</span><span class="o">-</span><span class="mi">4523</span><span class="o">-</span><span class="n">A5DF</span><span class="o">-</span><span class="mi">642</span><span class="n">A87ECA567</span><span class="p">}</span>

<span class="p">[</span><span class="n">ClassInstall</span><span class="p">]</span>
<span class="n">AddReg</span><span class="o">=</span><span class="n">libusb_class_install_add_reg</span>

<span class="p">[</span><span class="n">ClassInstall32</span><span class="p">]</span>
<span class="n">AddReg</span><span class="o">=</span><span class="n">libusb_class_install_add_reg</span>

<span class="p">[</span><span class="n">libusb_class_install_add_reg</span><span class="p">]</span>
<span class="n">HKR</span><span class="p">,,,,</span><span class="s2">&quot;LibUSB-Win32 Devices&quot;</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">Icon</span><span class="p">,,</span><span class="s2">&quot;-20&quot;</span>

<span class="p">[</span><span class="n">Manufacturer</span><span class="p">]</span>
<span class="o">%</span><span class="n">manufacturer</span><span class="o">%=</span><span class="n">Devices</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="n">NTAMD64</span>

<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>
<span class="p">;</span> <span class="n">Files</span>
<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">SourceDisksNames</span><span class="p">]</span>
<span class="mi">1</span> <span class="o">=</span> <span class="s2">&quot;Libusb-Win32 Driver Installation Disk&quot;</span><span class="p">,,</span>

<span class="p">[</span><span class="n">SourceDisksFiles</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">sys</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,,</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">dll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,,</span>
<span class="n">libusb0_x64</span><span class="o">.</span><span class="n">sys</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,,</span>
<span class="n">libusb0_x64</span><span class="o">.</span><span class="n">dll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,,</span>

<span class="p">[</span><span class="n">DestinationDirs</span><span class="p">]</span>
<span class="n">libusb_files_sys</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">system32</span>\<span class="n">drivers</span>
<span class="n">libusb_files_sys_x64</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">system32</span>\<span class="n">drivers</span>
<span class="n">libusb_files_dll</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">system32</span>
<span class="n">libusb_files_dll_wow64</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">syswow64</span>
<span class="n">libusb_files_dll_x64</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span><span class="n">system32</span>

<span class="p">[</span><span class="n">libusb_files_sys</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">sys</span>

<span class="p">[</span><span class="n">libusb_files_sys_x64</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">sys</span><span class="p">,</span><span class="n">libusb0_x64</span><span class="o">.</span><span class="n">sys</span>

<span class="p">[</span><span class="n">libusb_files_dll</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">dll</span>

<span class="p">[</span><span class="n">libusb_files_dll_wow64</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">dll</span>

<span class="p">[</span><span class="n">libusb_files_dll_x64</span><span class="p">]</span>
<span class="n">libusb0</span><span class="o">.</span><span class="n">dll</span><span class="p">,</span><span class="n">libusb0_x64</span><span class="o">.</span><span class="n">dll</span>

<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>
<span class="p">;</span> <span class="n">Device</span> <span class="n">driver</span>
<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="p">]</span>
<span class="n">CopyFiles</span> <span class="o">=</span> <span class="n">libusb_files_sys</span><span class="p">,</span> <span class="n">libusb_files_dll</span>
<span class="n">AddReg</span>    <span class="o">=</span> <span class="n">libusb_add_reg</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NT</span><span class="p">]</span>
<span class="n">CopyFiles</span> <span class="o">=</span> <span class="n">libusb_files_sys</span><span class="p">,</span> <span class="n">libusb_files_dll</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NTAMD64</span><span class="p">]</span>
<span class="n">CopyFiles</span> <span class="o">=</span> <span class="n">libusb_files_sys_x64</span><span class="p">,</span> <span class="n">libusb_files_dll_wow64</span><span class="p">,</span> <span class="n">libusb_files_dll_x64</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">HW</span><span class="p">]</span>
<span class="n">DelReg</span> <span class="o">=</span> <span class="n">libusb_del_reg_hw</span>
<span class="n">AddReg</span> <span class="o">=</span> <span class="n">libusb_add_reg_hw</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NT</span><span class="o">.</span><span class="n">HW</span><span class="p">]</span>
<span class="n">DelReg</span> <span class="o">=</span> <span class="n">libusb_del_reg_hw</span>
<span class="n">AddReg</span> <span class="o">=</span> <span class="n">libusb_add_reg_hw</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NTAMD64</span><span class="o">.</span><span class="n">HW</span><span class="p">]</span>
<span class="n">DelReg</span> <span class="o">=</span> <span class="n">libusb_del_reg_hw</span>
<span class="n">AddReg</span> <span class="o">=</span> <span class="n">libusb_add_reg_hw</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NT</span><span class="o">.</span><span class="n">Services</span><span class="p">]</span>
<span class="n">AddService</span> <span class="o">=</span> <span class="n">libusb0</span><span class="p">,</span> <span class="mh">0x00000002</span><span class="p">,</span> <span class="n">libusb_add_service</span>

<span class="p">[</span><span class="n">LIBUSB_DEV</span><span class="o">.</span><span class="n">NTAMD64</span><span class="o">.</span><span class="n">Services</span><span class="p">]</span>
<span class="n">AddService</span> <span class="o">=</span> <span class="n">libusb0</span><span class="p">,</span> <span class="mh">0x00000002</span><span class="p">,</span> <span class="n">libusb_add_service</span>

<span class="p">[</span><span class="n">libusb_add_reg</span><span class="p">]</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">DevLoader</span><span class="p">,,</span><span class="o">*</span><span class="n">ntkern</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">NTMPDriver</span><span class="p">,,</span><span class="n">libusb0</span><span class="o">.</span><span class="n">sys</span>

<span class="p">;</span> <span class="n">Older</span> <span class="n">versions</span> <span class="n">of</span> <span class="n">this</span> <span class="o">.</span><span class="n">inf</span> <span class="n">file</span> <span class="n">installed</span> <span class="nb">filter</span> <span class="n">drivers</span><span class="o">.</span> <span class="n">They</span> <span class="n">are</span> <span class="ow">not</span>
<span class="p">;</span> <span class="n">needed</span> <span class="nb">any</span> <span class="n">more</span> <span class="ow">and</span> <span class="n">must</span> <span class="n">be</span> <span class="n">removed</span>
<span class="p">[</span><span class="n">libusb_del_reg_hw</span><span class="p">]</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">LowerFilters</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">UpperFilters</span>

<span class="p">;</span> <span class="n">Device</span> <span class="n">properties</span>
<span class="p">[</span><span class="n">libusb_add_reg_hw</span><span class="p">]</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">SurpriseRemovalOK</span><span class="p">,</span> <span class="mh">0x00010001</span><span class="p">,</span> <span class="mi">1</span>

<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>
<span class="p">;</span> <span class="n">Services</span>
<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">libusb_add_service</span><span class="p">]</span>
<span class="n">DisplayName</span>    <span class="o">=</span> <span class="s2">&quot;LibUsb-Win32 - Kernel Driver 03/20/2007, 0.1.12.1&quot;</span>
<span class="n">ServiceType</span>    <span class="o">=</span> <span class="mi">1</span>
<span class="n">StartType</span>      <span class="o">=</span> <span class="mi">3</span>
<span class="n">ErrorControl</span>   <span class="o">=</span> <span class="mi">0</span>
<span class="n">ServiceBinary</span>  <span class="o">=</span> <span class="o">%</span><span class="mi">12</span><span class="o">%</span>\<span class="n">libusb0</span><span class="o">.</span><span class="n">sys</span>

<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>
<span class="p">;</span> <span class="n">Devices</span>
<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">Devices</span><span class="p">]</span>
<span class="s2">&quot;Generic Bulk Device&quot;</span><span class="o">=</span><span class="n">LIBUSB_DEV</span><span class="p">,</span> <span class="n">USB</span>\<span class="n">VID_1cbe</span><span class="o">&amp;</span><span class="n">PID_0003</span>

<span class="p">[</span><span class="n">Devices</span><span class="o">.</span><span class="n">NT</span><span class="p">]</span>
<span class="s2">&quot;Generic Bulk Device&quot;</span><span class="o">=</span><span class="n">LIBUSB_DEV</span><span class="p">,</span> <span class="n">USB</span>\<span class="n">VID_1cbe</span><span class="o">&amp;</span><span class="n">PID_0003</span>

<span class="p">[</span><span class="n">Devices</span><span class="o">.</span><span class="n">NTAMD64</span><span class="p">]</span>
<span class="s2">&quot;Generic Bulk Device&quot;</span><span class="o">=</span><span class="n">LIBUSB_DEV</span><span class="p">,</span> <span class="n">USB</span>\<span class="n">VID_1cbe</span><span class="o">&amp;</span><span class="n">PID_0003</span>


<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>
<span class="p">;</span> <span class="n">Strings</span>
<span class="p">;</span><span class="o">--------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">Strings</span><span class="p">]</span>
<span class="n">manufacturer</span> <span class="o">=</span> <span class="s2">&quot;Texas Instruments&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="cdc-device-class-driver">
<h2>CDC Device Class Driver<a class="headerlink" href="#cdc-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>The USB Communication Device Class (CDC) class driver supports the CDC Abstract Control Model variant and allows a client application to be seen as a virtual serial port to the USB host system. The driver provides two channels, one transmit and one receive. The channels may be used in conjunction with USB buffers to provide a simple read/write interface for data transfer to and from the host. Additional APIs and events are used to support serial-link-specific operations such as notification of UART errors, sending break conditions and setting communication line parameters.</p>
<p>The data transmission capabilities of this device class driver are very similar to the generic bulk class but, since this is a standard device class, the host operating system is likely able to access the device without the need for any special additional device drivers. On Windows, for example, a simple INF file is all that is required to make the USB device appear as a COM port which can be accessed by any serial terminal application.</p>
<div class="figure align-default" id="id8">
<img alt="USB CDC Device" src="../../_images/usb_cdc_device.png" />
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">USB CDC Device</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>This device class uses three endpoints in addition to endpoint zero. Two bulk endpoints carry data to and from the host and an interrupt IN endpoint is used to signal any serial errors such as break, framing error or parity error detected by the device. Endpoint zero carries standard USB requests and also CDC-specific requests which translate to events passed to the application via the control channel callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">usb_dev_serial</span></code> example application makes use of this device class driver.</p>
<div class="section" id="cdc-device-class-events">
<h3>CDC Device Class Events<a class="headerlink" href="#cdc-device-class-events" title="Permalink to this headline">¶</a></h3>
<p>The CDC device class driver sends the following events to the application callback functions:</p>
<div class="section" id="id1">
<h4>Receive Channel Events<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_RX_AVAILABLE</strong></p></li>
<li><p><strong>USB_EVENT_DATA_REMAINING</strong></p></li>
<li><p><strong>USB_EVENT_ERROR</strong></p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>Transmit Channel Events<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_TX_COMPLETE</strong></p></li>
</ul>
</div>
<div class="section" id="control-channel-events">
<h4>Control Channel Events<a class="headerlink" href="#control-channel-events" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong></p></li>
<li><p><strong>USB_EVENT_RESUME</strong></p></li>
<li><p><strong>USBD_CDC_EVENT_SEND_BREAK</strong></p></li>
<li><p><strong>USBD_CDC_EVENT_CLEAR_BREAK</strong></p></li>
<li><p><strong>USBD_CDC_EVENT_SET_LINE_CODING</strong></p></li>
<li><p><strong>USBD_CDC_EVENT_GET_LINE_CODING</strong></p></li>
<li><p><strong>USBD_CDC_EVENT_SET_CONTROL_LINE_STATE</strong></p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not reported to the application if the MCU’s PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
</div>
</div>
<div class="section" id="using-the-cdc-device-class-driver">
<h3>Using the CDC Device Class Driver<a class="headerlink" href="#using-the-cdc-device-class-driver" title="Permalink to this headline">¶</a></h3>
<p>To add USB CDC data transmit and receive capability to your application via the CDC Device Class Driver, take the following steps.</p>
<ul class="simple">
<li><p>Add the following header files to the source file(s) which are to support USB:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdcdc.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define the 6 entry string descriptor table which is used to describe various features of your new device to the host system. The following is the string table taken from the <code class="docutils literal notranslate"><span class="pre">usb_dev_serial</span></code> example application. Edit the actual strings to suit your application and take care to ensure that you also update the length field (the first byte) of each descriptor to correctly reflect the length of the string and descriptor header. The number of string descriptors you include must be (1 + (5 * num languages)) where the number of languages agrees with the list published in string descriptor 0, <code class="docutils literal notranslate"><span class="pre">g_pLangDescriptor</span></code>. The strings for each language must be grouped together with all the language 1 strings before all the language 2 strings and so on.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The languages supported by this device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8LangDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">4</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_LANG_EN_US</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The manufacturer string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ManufacturerString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The product string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ProductString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;O&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The serial number string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SerialNumberString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The control interface description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ControlInterfaceString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">21</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The configuration description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ConfigString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">26</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;S&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The descriptor string table.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppui8StringDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pui8LangDescriptor</span><span class="p">,</span>
    <span class="n">g_pui8ManufacturerString</span><span class="p">,</span>
    <span class="n">g_pui8ProductString</span><span class="p">,</span>
    <span class="n">g_pui8SerialNumberString</span><span class="p">,</span>
    <span class="n">g_pui8ControlInterfaceString</span><span class="p">,</span>
    <span class="n">g_pui8ConfigString</span>
<span class="p">};</span>

<span class="cp">#define NUM_STRING_DESCRIPTORS (sizeof(g_ppui8StringDescriptors) /            \</span>
<span class="cp">                                sizeof(uint8_t *))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDCDCDevice</span></code> structure and initialize all fields as required for your application. The following example illustrates a simple case where no USB buffers are in use. For an example using USB buffers, see the source file <code class="docutils literal notranslate"><span class="pre">usb_bulk_structs.c</span></code> in the <code class="docutils literal notranslate"><span class="pre">usb_dev_serial</span></code> example application.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your control callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBControlEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the control callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your receive callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBReceiveEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the receive callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your transmit callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBTransmitEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the transmit callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_ppui8StringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table.</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Add a receive event handler function, YourUSBReceiveEventCallback in the previous example, to your application taking care to handle all messages which require a particular response. For the CDC device class, <strong>USB_EVENT_RX_AVAILABLE</strong> and <strong>USB_EVENT_DATA_REMAINING</strong> MUST be handled by the receive event handler. In response to <strong>USB_EVENT_RX_AVAILABLE</strong>, your handler should check the amount of data received by calling <code class="docutils literal notranslate"><span class="pre">USBDCDCRxPacketAvailable()</span></code> then read it using a call to <code class="docutils literal notranslate"><span class="pre">USBDCDCPacketRead()</span></code>. This causes the newly received data to be acknowledged to the host and instructs the host that it may now transmit another packet. If you are unable to read the data immediately, return 0 from the callback handler and you is called back once again a few milliseconds later. On <strong>USB_EVENT_DATA_REMAINING</strong> the application should return the number of bytes of data it currently has buffered. This event controls timing of some incoming requests to, for example, send break
conditions or change line transmission parameters. These requests are held off until all previously received data has been processed so it is important to ensure that this event returns 0 only once any application buffers are empty. Although no other events must be handled, <strong>USB_EVENT_CONNECTED</strong> and <strong>USB_EVENT_DISCONNECTED</strong> is typically required since these indicate when a host connects or disconnects and allow the application to flush any buffers or reset state as required. Attempts to send data when the host is disconnected result in an immediate failure.</p></li>
<li><p>Add a transmit event handler function, YourUSBTransmitEventCallback in the previous example, to your application taking care to handle all messages which require a particular response. For the CDC device class, there are no events sent to the transmit callback which MUST be handled but applications usually want to note <strong>USB_EVENT_TX_COMPLETE</strong> since this is an interlock message indicating that the previous packet sent has been acknowledged by the host and a new packet can now be sent.</p></li>
<li><p>Add a control event handler function, YourUSBControlEventCallback in the previous example, to your application and ensure that you handle <strong>USBD_CDC_EVENT_GET_LINE_CODING</strong>, returning a valid line coding configuration even if your device is not actually driving a UART. Handle the other control events as required for your application.</p></li>
<li><p>From your main initialization function call the CDC device class driver initialization function to configure the USB controller and place the device on the bus.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDCDCInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCDCDevice</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, your control event handler is sent <strong>USB_EVENT_CONNECTED</strong> and the first packet of data may be sent to the host using <code class="docutils literal notranslate"><span class="pre">USBDCDCPacketWrite()</span></code> with following packets transmitted as soon as <strong>USB_EVENT_TX_COMPLETE</strong> is received via the transmit event handler.</p></li>
</ul>
</div>
<div class="section" id="using-the-composite-cdc-serial-device-class">
<h3>Using the Composite CDC Serial Device Class<a class="headerlink" href="#using-the-composite-cdc-serial-device-class" title="Permalink to this headline">¶</a></h3>
<p>When using the CDC serial device class in a composite, the configuration of the device is very similar to how it is configured as a non-composite device. Follow all of the configuration steps in the previous section with the exception of calling <code class="docutils literal notranslate"><span class="pre">USBDCDCCompositeInit()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">USBDCDCInit()</span></code>. This prepares an instance of the CDC serial device class to be enumerated as part of a composite device. The <code class="docutils literal notranslate"><span class="pre">USBDCDCCompositeInit()</span></code> function takes the CDC serial device structure and a pointer to a tCompositeEntry value so that it can properly initialize the CDC serial device and the composite entry that is passed to the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> funtion. The code example below provides an example of how to initialize an CDC serial device to be a part of a composite device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// These should be initialized with valid values for each class.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDevice</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">pvCDCDevice</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The array of composited devices.</span>
<span class="c1">//</span>
<span class="n">tCompositeEntry</span> <span class="n">psCompEntries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Allocate the device data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series PID for composite serial device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_COMPOSITE_PID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments so 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Composite event handler.</span>
    <span class="c1">//</span>
    <span class="n">EventHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pui8StringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">g_psCompEntries</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// The OTHER_SIZES here are the sizes of the descriptor data for other classes</span>
<span class="c1">// that are part of the composite device.</span>
<span class="c1">//</span>
<span class="cp">#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DCDC_SIZE + OTHER_SIZES)</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8DescriptorData</span><span class="p">[</span><span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Save the instance data for this CDC serial device.</span>
<span class="c1">//</span>
<span class="n">pvCDCDevice</span> <span class="o">=</span> <span class="n">USBDCDCCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCDCDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psCompEntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB controller as a composite device.</span>
<span class="c1">//</span>
<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">,</span>
                      <span class="n">g_pui8DescriptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>All other API calls to the USB CDC serial device class should use the value returned by <code class="docutils literal notranslate"><span class="pre">USBDCDCCompositeInit()</span></code> when the API calls for a pvInstance pointer. Also when using the CDC serial device in a composite device the <strong>COMPOSITE_DCDC_SIZE</strong> value should be added to the size of the <code class="docutils literal notranslate"><span class="pre">g_pui8DescriptorData</span></code> array as shown in the example above.</p>
</div>
<div class="section" id="windows-drivers-for-cdc-serial-devices">
<h3>Windows Drivers for CDC Serial Devices<a class="headerlink" href="#windows-drivers-for-cdc-serial-devices" title="Permalink to this headline">¶</a></h3>
<p>Making your CDC serial) device visible as a virtual COM port on a Windows system is very straightforward since Windows already includes a device driver supporting USB CDC devices. The device developer must merely provide a single INF file to associate the VID and PID of the new device with the Windows USB CDC driver, <code class="docutils literal notranslate"><span class="pre">usbser.sys</span></code>. When using the serial device in a composite device it is important to remember to append &amp;MI_xx value to the VID/PID entry as shown in the example below. The actual number used with the MI_* value is the interface number assigned to the serial device. An example INF file is provided below. Unlike the case for the generic bulk device class, no additional installation files are necessary since the CDC serial driver is already installed by default and does not, therefore, have to be redistributed by the device developer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">;</span>
<span class="p">;</span>   <span class="n">Texas</span> <span class="n">Instruments</span> <span class="n">USBLib</span> <span class="n">USB</span> <span class="n">CDC</span> <span class="p">(</span><span class="n">serial</span><span class="p">)</span> <span class="n">driver</span> <span class="n">installation</span> <span class="n">file</span><span class="o">.</span>
<span class="p">;</span>
<span class="p">[</span><span class="n">Version</span><span class="p">]</span>
<span class="n">Signature</span><span class="o">=</span><span class="s2">&quot;$Windows NT$&quot;</span>
<span class="n">Class</span><span class="o">=</span><span class="n">Ports</span>
<span class="n">ClassGuid</span><span class="o">=</span><span class="p">{</span><span class="mi">4</span><span class="n">D36E978</span><span class="o">-</span><span class="n">E325</span><span class="o">-</span><span class="mi">11</span><span class="n">CE</span><span class="o">-</span><span class="n">BFC1</span><span class="o">-</span><span class="mi">08002</span><span class="n">BE10318</span><span class="p">}</span>
<span class="n">Provider</span><span class="o">=%</span><span class="n">MFGNAME</span><span class="o">%</span>
<span class="n">LayoutFile</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">inf</span>
<span class="n">DriverVer</span><span class="o">=</span><span class="mi">08</span><span class="o">/</span><span class="mi">17</span><span class="o">/</span><span class="mi">2001</span><span class="p">,</span><span class="mf">5.1</span><span class="o">.</span><span class="mf">2600.0</span>

<span class="p">[</span><span class="n">Manufacturer</span><span class="p">]</span>
<span class="o">%</span><span class="n">MFGNAME</span><span class="o">%=</span><span class="n">DeviceList</span>

<span class="p">[</span><span class="n">DestinationDirs</span><span class="p">]</span>
<span class="n">DefaultDestDir</span><span class="o">=</span><span class="mi">12</span>

<span class="p">[</span><span class="n">SourceDisksFiles</span><span class="p">]</span>

<span class="p">[</span><span class="n">SourceDisksNames</span><span class="p">]</span>

<span class="p">;</span>
<span class="p">;</span> <span class="n">NOTE</span><span class="p">:</span> <span class="n">Change</span> <span class="n">the</span> <span class="n">VID</span> <span class="ow">and</span> <span class="n">PID</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">following</span> <span class="n">section</span> <span class="n">to</span> <span class="n">match</span> <span class="n">your</span> <span class="n">device</span><span class="o">.</span>
<span class="p">;</span> <span class="n">The</span> <span class="n">values</span> <span class="k">with</span> <span class="n">the</span> <span class="o">&amp;</span><span class="n">MI_xx</span> <span class="n">values</span> <span class="n">are</span> <span class="k">for</span> <span class="n">the</span> <span class="n">composite</span> <span class="n">serial</span> <span class="n">devices</span>
<span class="p">;</span> <span class="n">examples</span><span class="o">.</span>
<span class="p">;</span>

<span class="p">[</span><span class="n">DeviceList</span><span class="p">]</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">entry</span> <span class="ow">is</span> <span class="k">for</span> <span class="n">the</span> <span class="n">single</span> <span class="n">serial</span> <span class="n">port</span> <span class="n">example</span> <span class="n">usb_dev_serial</span><span class="o">.</span>
<span class="p">;</span>
<span class="o">%</span><span class="n">DESCRIPTION_0</span><span class="o">%=</span><span class="n">DriverInstall</span><span class="p">,</span><span class="n">USB</span>\<span class="n">VID_1CBE</span><span class="o">&amp;</span><span class="n">PID_0002</span>

<span class="p">;</span>
<span class="p">;</span> <span class="n">These</span> <span class="n">entries</span> <span class="n">are</span> <span class="k">for</span> <span class="n">the</span> <span class="n">dual</span> <span class="n">serial</span> <span class="n">port</span> <span class="n">composite</span> <span class="n">example</span> <span class="n">usb_dev_cserial</span><span class="o">.</span>
<span class="p">;</span>
<span class="o">%</span><span class="n">DESCRIPTION_0</span><span class="o">%=</span><span class="n">DriverInstall</span><span class="p">,</span><span class="n">USB</span>\<span class="n">VID_1CBE</span><span class="o">&amp;</span><span class="n">PID_0007</span><span class="o">&amp;</span><span class="n">MI_00</span>
<span class="o">%</span><span class="n">DESCRIPTION_1</span><span class="o">%=</span><span class="n">DriverInstall</span><span class="p">,</span><span class="n">USB</span>\<span class="n">VID_1CBE</span><span class="o">&amp;</span><span class="n">PID_0007</span><span class="o">&amp;</span><span class="n">MI_01</span>

<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">entry</span> <span class="ow">is</span> <span class="k">for</span> <span class="n">the</span> <span class="n">composite</span> <span class="n">hid</span><span class="o">/</span><span class="n">serial</span> <span class="n">device</span> <span class="n">usb_dev_chidcdc</span><span class="o">.</span>  <span class="n">Notice</span>
<span class="p">;</span> <span class="n">that</span> <span class="n">the</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">MI_01</span> <span class="n">because</span> <span class="n">the</span> <span class="n">serial</span> <span class="n">device</span> <span class="ow">is</span> <span class="n">on</span> <span class="n">interface</span> <span class="mf">1.</span>
<span class="p">;</span>
<span class="o">%</span><span class="n">DESCRIPTION_1</span><span class="o">%=</span><span class="n">DriverInstall</span><span class="p">,</span><span class="n">USB</span>\<span class="n">VID_1CBE</span><span class="o">&amp;</span><span class="n">PID_0009</span><span class="o">&amp;</span><span class="n">MI_01</span>

<span class="p">;</span><span class="o">------------------------------------------------------------------------------</span>
<span class="p">;</span>  <span class="n">Windows</span> <span class="n">XP</span><span class="o">/</span><span class="mi">2000</span> <span class="n">Sections</span>
<span class="p">;</span><span class="o">------------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">DriverInstall</span><span class="o">.</span><span class="n">nt</span><span class="p">]</span>
<span class="n">CopyFiles</span><span class="o">=</span><span class="n">DriverCopyFiles</span>
<span class="n">AddReg</span><span class="o">=</span><span class="n">DriverInstall</span><span class="o">.</span><span class="n">nt</span><span class="o">.</span><span class="n">AddReg</span>

<span class="p">[</span><span class="n">DriverCopyFiles</span><span class="p">]</span>
<span class="n">usbser</span><span class="o">.</span><span class="n">sys</span><span class="p">,,,</span><span class="mh">0x20</span>

<span class="p">[</span><span class="n">DriverInstall</span><span class="o">.</span><span class="n">nt</span><span class="o">.</span><span class="n">AddReg</span><span class="p">]</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">DevLoader</span><span class="p">,,</span><span class="o">*</span><span class="n">ntkern</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">NTMPDriver</span><span class="p">,,</span><span class="n">usbser</span><span class="o">.</span><span class="n">sys</span>
<span class="n">HKR</span><span class="p">,,</span><span class="n">EnumPropPages32</span><span class="p">,,</span><span class="s2">&quot;MsPorts.dll,SerialPortPropPageProvider&quot;</span>

<span class="p">[</span><span class="n">DriverInstall</span><span class="o">.</span><span class="n">nt</span><span class="o">.</span><span class="n">Services</span><span class="p">]</span>
<span class="n">AddService</span><span class="o">=</span><span class="n">usbser</span><span class="p">,</span> <span class="mh">0x00000002</span><span class="p">,</span> <span class="n">DriverService</span>

<span class="p">[</span><span class="n">DriverService</span><span class="p">]</span>
<span class="n">DisplayName</span><span class="o">=%</span><span class="n">SERVICE</span><span class="o">%</span>
<span class="n">ServiceType</span><span class="o">=</span><span class="mi">1</span>
<span class="n">StartType</span><span class="o">=</span><span class="mi">3</span>
<span class="n">ErrorControl</span><span class="o">=</span><span class="mi">1</span>
<span class="n">ServiceBinary</span><span class="o">=%</span><span class="mi">12</span><span class="o">%</span>\<span class="n">usbser</span><span class="o">.</span><span class="n">sys</span>

<span class="p">;</span><span class="o">------------------------------------------------------------------------------</span>
<span class="p">;</span>  <span class="n">String</span> <span class="n">Definitions</span> <span class="p">(</span><span class="n">change</span> <span class="k">for</span> <span class="n">your</span> <span class="n">device</span><span class="p">)</span>
<span class="p">;</span><span class="o">------------------------------------------------------------------------------</span>

<span class="p">[</span><span class="n">Strings</span><span class="p">]</span>
<span class="n">MFGNAME</span>       <span class="o">=</span> <span class="s2">&quot;Texas Instruments&quot;</span>
<span class="n">DESCRIPTION_0</span> <span class="o">=</span> <span class="s2">&quot;USB Serial Port&quot;</span>
<span class="n">DESCRIPTION_1</span> <span class="o">=</span> <span class="s2">&quot;USB Serial Command Port&quot;</span>
<span class="n">SERVICE</span>       <span class="o">=</span> <span class="s2">&quot;USB CDC serial port&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="composite-device-class-driver">
<h2>Composite Device Class Driver<a class="headerlink" href="#composite-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>The USB composite device class allows classes that are already defined in the USB library to be combined into a single composite device. The device configuration descriptors for the included device classes are merged at run time and returned to the USB host controller during device enumeration as a single composite USB device. Since each device class requires some unique initialization, the device classes provide a separate initialization API that does not touch the USB controller but does perform all other initialization. The initialization of the USB controller is deferred until the USB composite device is initialized and has merged the multiple device configuration descriptors into a single configuration descriptor so that it can properly initialize the USB controller. The endpoint numbers, interface numbers, and string indexes that are included in the device configuration descriptors are modified by the USB composite device class so that the values are valid in the composite device
configuration descriptor.</p>
<div class="section" id="defining-a-composite-device">
<h3>Defining a Composite Device<a class="headerlink" href="#defining-a-composite-device" title="Permalink to this headline">¶</a></h3>
<p>The USB composite device class is defined at the top level in the <code class="docutils literal notranslate"><span class="pre">tUSBDCompositeDevice</span></code> structure which is used to describe the class to the USB library. In order for the USB composite device to enumerate and function properly, all members of this structure must be filled with valid information. The usVID and usPID values should have valid Vendor ID and Product ID values for the composite device. The power requirements for the device as specified in the usMaxPowermA and ucPwrAttributes and should take into account the power requirements and settings for all devices classes that the composite device is using. The only truly optional member of the <code class="docutils literal notranslate"><span class="pre">tUSBDCompositeDevice</span></code> structure is the pfnCallback function which provides notifications to the application that are not handled by the individual device classes. The device specific strings should be included in the ppui8StringDescriptors and <code class="docutils literal notranslate"><span class="pre">ui32NumStringDescriptors</span></code> members. This list of strings should include the following three
strings in the following order: Manufacturer, Product, and Product serial number. All other strings used by the classes are specified and are sourced from the included device classes. The psPrivateData should be set to point to a tCompositeInstance structure which provides the composite class with memory for its instance data.</p>
<p><strong>Note</strong>: It is important to insure that the microcontroller has enough endpoints to satisfy the number of devices included in the composite class.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">g_pui32CompWorkspace</span><span class="p">[</span><span class="n">NUM_DEVICES</span><span class="p">];</span>

<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Vendor ID.</span>
    <span class="c1">//</span>
    <span class="n">VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Product ID.</span>
    <span class="c1">//</span>
    <span class="n">VENDOR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments or 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Generic USB handler for the composite device.</span>
    <span class="c1">//</span>
    <span class="n">CompositeHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of device classes in the composite entry array.</span>
    <span class="c1">//</span>
    <span class="n">NUM_DEVICES</span><span class="p">,</span>
    <span class="n">g_psCompDevices</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="allocating-memory">
<h3>Allocating Memory<a class="headerlink" href="#allocating-memory" title="Permalink to this headline">¶</a></h3>
<p>The USB composite device class requires three different types of memory allocated to properly enumerate and function with the included device classes. The main allocation is a block of memory that is used to build up the combined device configuration descriptor for the combination of the desired device classes. The individual device classes provides a size in a __COMPOSITE_*_SIZE__ macro that indicates the size in bytes required to hold the configuration descriptor for the device class. This allows the application to provide a large enough buffer to the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> function for merging the device descriptors.</p>
<div class="section" id="defining-device-class-instances">
<h4>Defining Device Class Instances<a class="headerlink" href="#defining-device-class-instances" title="Permalink to this headline">¶</a></h4>
<p>When defining a composite device the application must determine the size of the buffer that is passed into the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> function. For example, if a composite device is made up of two serial devices then a buffer of size (<strong>COMPOSITE_DCDC_SIZE</strong> * 2) should be passed into the initialization routine and an array of that size should be declared in the application.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">pucDesciptorData</span><span class="p">[</span><span class="n">COMPOSITE_DCDC_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>The application must also allocate separate serial device structure for each instance of the devices that are included in a composite device. This is true even when including two devices classes of the same type are added so that the instances can be differentiated by the USB library. The USB composite device class can determine which instance to use based on the interface number that is accessed by the host controller. The application initializes the data in the array of <code class="docutils literal notranslate"><span class="pre">tCompositeEntry</span></code> structures passed into the composite initialization for the class.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDeviceA</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDeviceB</span><span class="p">;</span>

<span class="n">tCompositeEntry</span> <span class="n">g_psDevices</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="interface-handling">
<h4>Interface Handling<a class="headerlink" href="#interface-handling" title="Permalink to this headline">¶</a></h4>
<p>The device class interfaces are merged into the composite device descriptor and the composite class modifies the default interface assignments to insure monotonically increasing indexes for all of the included interfaces. In the example above for the two serial ports, the first serial device would be interface 0 and the second would enumerate as interface 1.</p>
</div>
<div class="section" id="string-handling">
<h4>String Handling<a class="headerlink" href="#string-handling" title="Permalink to this headline">¶</a></h4>
<p>The device class strings are merged into the composite device descriptor which requires that the composite class modify the default string indexes. In doing this it always ignores the three default string indexes in the device descriptor. The remaining string indexes are modified to match in the configuration descriptor.</p>
</div>
</div>
<div class="section" id="example-composite-device">
<h3>Example Composite Device<a class="headerlink" href="#example-composite-device" title="Permalink to this headline">¶</a></h3>
<p>This section continues with the example above that used two USB device serial classes in a single device. This includes more detailed examples and code that demonstrate the configuration and setup needed for a composite serial device.</p>
<div class="section" id="composite-device-instance">
<h4>Composite Device Instance<a class="headerlink" href="#composite-device-instance" title="Permalink to this headline">¶</a></h4>
<p>The application must first allocate two serial device structures and pass them into the composite initialization function for the USB serial CDC device. The allocation and initialization are shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Buffers for serial device A.</span>
<span class="c1">//</span>
<span class="k">const</span> <span class="n">tUSBBuffer</span> <span class="n">g_sTxBufferA</span><span class="p">;</span>
<span class="k">const</span> <span class="n">tUSBBuffer</span> <span class="n">g_sRxBufferA</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Buffers for serial device B.</span>
<span class="c1">//</span>
<span class="k">const</span> <span class="n">tUSBBuffer</span> <span class="n">g_sTxBufferB</span><span class="p">;</span>
<span class="k">const</span> <span class="n">tUSBBuffer</span> <span class="n">g_sRxBufferB</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Device description for Serial Device A.</span>
<span class="c1">//</span>
<span class="k">const</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDeviceA</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>
    <span class="n">USB_PID_SERIAL</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>
    <span class="n">ControlHandler</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sCDCDeviceA</span><span class="p">,</span>
    <span class="n">USBBufferEventCallback</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sRxBufferA</span><span class="p">,</span>
    <span class="n">USBBufferEventCallback</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sTxBufferA</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// Device description for Serial Device B.</span>
<span class="c1">//</span>
<span class="k">const</span> <span class="n">tUSBDCDCDevice</span> <span class="n">g_sCDCDeviceB</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>
    <span class="n">USB_PID_SERIAL</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>
    <span class="n">ControlHandler</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sCDCDeviceB</span><span class="p">,</span>
    <span class="n">USBBufferEventCallback</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sRxBufferB</span><span class="p">,</span>
    <span class="n">USBBufferEventCallback</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sTxBufferB</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now the application must allocate the device array so that it is provided to the USB composite device class. The following code shows the allocation of the composite device array that holds the data for the two serial devices.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">tCompositeEntry</span> <span class="n">g_psDevices</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Once the array of devices has been allocated, this array is included in the USB composite device structure when the device structure is allocated and initialized. The code below shows this allocation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Initialize the USB composite device structure.</span>
<span class="c1">//</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TI USBLib VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// PID for the composite serial device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_COMP_SERIAL</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments so 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Generic USB handler for the composite device.</span>
    <span class="c1">//</span>
    <span class="n">CompositeHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Include the array of composite devices.</span>
    <span class="c1">//</span>
    <span class="n">NUM_DEVICES</span><span class="p">,</span>
    <span class="n">g_psCompDevices</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The last bit of memory that needs to be allocated is the USB composite device descriptor workspace which is provided at Initialization time. The allocation for two serial devices is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">pucDesciptorData</span><span class="p">[</span><span class="n">COMPOSITE_DCDC_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Once all of the memory has been initialized and the appropriate memory allocated, the application must call the initialization functions for each device instance. In the case of the serial ports, the USB buffers used must also first be initialized before completing initialization.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Initialize the transmit and receive buffers.</span>
<span class="c1">//</span>
<span class="n">USBBufferInit</span><span class="p">((</span><span class="n">tUSBBuffer</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sTxBufferA</span><span class="p">);</span>
<span class="n">USBBufferInit</span><span class="p">((</span><span class="n">tUSBBuffer</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sRxBufferA</span><span class="p">);</span>
<span class="n">USBBufferInit</span><span class="p">((</span><span class="n">tUSBBuffer</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sTxBufferB</span><span class="p">);</span>
<span class="n">USBBufferInit</span><span class="p">((</span><span class="n">tUSBBuffer</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sRxBufferB</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the two serial port instances that are part of this composite</span>
<span class="c1">// device.</span>
<span class="c1">//</span>
<span class="n">pvSerialDeviceA</span> <span class="o">=</span>
    <span class="n">USBDCDCCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCDCDeviceA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_psCompDevices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">pvSerialDeviceB</span> <span class="o">=</span>
    <span class="n">USBDCDCCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCDCDeviceB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_psCompDevices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="c1">//</span>
<span class="c1">// Pass the device information to the USB library and place the device</span>
<span class="c1">// on the bus.</span>
<span class="c1">//</span>
<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">COMPOSITE_DCDC_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
                  <span class="n">pucDesciptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>When calling the USB device classes that are included with a composite device, the instance data for that class should be passed into the API. In the composite serial example that is being described in this section, the USB serial device classes provide the same callback function, <code class="docutils literal notranslate"><span class="pre">ControlHandler()</span></code>. The callback information for this was the device class structure which was specified as <code class="docutils literal notranslate"><span class="pre">g_sCDCDeviceA</span></code> or <code class="docutils literal notranslate"><span class="pre">g_sCDCDeviceB</span></code> for the serial devices. Since the device instance is different for each serial device, the application can simply cast the pointer to a pointer of type <code class="docutils literal notranslate"><span class="pre">tUSBDCDCDevice</span></code> and use the data directly as shown below and only access the requested device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int32_t</span>
<span class="nf">ControlHandler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pvCBData</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
               <span class="kt">uint32_t</span> <span class="n">ui32MsgValue</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tUSBDCDCDevice</span> <span class="n">pCDCDevice</span><span class="p">;</span>

    <span class="n">pCDCDevice</span> <span class="o">=</span> <span class="p">(</span><span class="n">tUSBDCDCDevice</span> <span class="o">*</span><span class="p">)</span><span class="n">pvCBData</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Which event are we being asked to process?</span>
    <span class="c1">//</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">ui32Event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="device-firmware-upgrade-device-class-driver">
<h2>Device Firmware Upgrade Device Class Driver<a class="headerlink" href="#device-firmware-upgrade-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>Although USB Device Firmware Upgrade functionality is provided primarily by the USB boot loader (<code class="docutils literal notranslate"><span class="pre">boot_usb</span></code>), applications which want to support DFU funcionality should publicize this in their configuration descriptor and be able to receive a request from the host indicating that they should switch into DFU mode to receive an upgrade.</p>
<p>The DFU device class supports this runtime DFU capability, providing a simple method for an application to indicate to the host that it is DFU-capable and to be signalled that a USB-based firmware upgrade is being requested. The device class is unusual in that it must be used as part of a composite device. Runtime DFU capability makes no sense on its own since it is basically only an indication that the DFU USB boot loader is present and usable.</p>
<p>The USB boot loader must also be used by any device supporting the DFU runtime device class since it implements all DFU mode operation and performs the actual upgrade operation. The runtime device class adds two sections to the configuration descriptor for the main application - a DFU Interface Descriptor and a DFU Functional Descriptor. Standard DFU DETACH requests sent to the DFU interface from the host result in a callback being made to the client application indicating that it must transfer control back to the USB boot loader (via the <code class="docutils literal notranslate"><span class="pre">USBDDFUUpdateBegin()</span></code> function. This function removes the application’s existing device from the USB bus then reenters the boot loader which, in turn, publishes DFU mode descriptors and reconnects to the bus as a pure DFU device capable of downloading or uploading application images from the host.</p>
<div class="section" id="using-the-dfu-device-class">
<h3>Using the DFU Device Class<a class="headerlink" href="#using-the-dfu-device-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">boot_demo_usb</span></code> application provides an example of an application using the Device Firmware Upgrade class. To support DFU in your application, do the following:</p>
<ol class="arabic">
<li><p>Ensure that your application is built to run alongside the USB boot loader (<code class="docutils literal notranslate"><span class="pre">boot_usb</span></code>). This requires that it is linked to run from the address defined in label <strong>APP_START_ADDRESS</strong> defined in the <code class="docutils literal notranslate"><span class="pre">bl_config.h</span></code> used to build the boot loader. Typically, for the USB boot loader, this is 0x1800.</p></li>
<li><p>Add a function to your application following the prototype:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">DFUDetachCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pvCBData</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
                       <span class="kt">uint32_t</span> <span class="n">ui32MsgData</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
</pre></div>
</div>
<p>This function need only check <code class="docutils literal notranslate"><span class="pre">ui32Event</span></code> and, if it is <strong>USBD_DFU_EVENT_DETACH</strong>, signal the application main loop that it should exit and pass control back to the USB boot loader in preparation for a firmware upgrade.</p>
</li>
<li><p>Add a mechanism in your application main loop to detect the signal set in your DFUDetachCallback function and call the <code class="docutils literal notranslate"><span class="pre">USBDDFUUpdateBegin()</span></code> function. This function tidies up and passes control to the boot loader.</p></li>
<li><p>Define a structure of type <code class="docutils literal notranslate"><span class="pre">tDFUInstance</span></code>, ensuring that the linker places it in SRAM. This is used as workspace by the DFU class driver.</p></li>
<li><p>Define a structure of type <code class="docutils literal notranslate"><span class="pre">tUSBDFUDevice</span></code> and initialize it to contain a pointer to your callback function and instance data workspace.</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The DFU runtime interface initialization and customization structures</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="n">tUSBDDFUDevice</span> <span class="n">g_sDFUDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">DFUDetachCallback</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sDFUDevice</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li><p>Create an array of structures of type <code class="docutils literal notranslate"><span class="pre">tCompositeEntry</span></code> which define the individual device class instances that are to be used in the composite device. A structure defining a composite device containing a HID interface and the DFU runtime interface would look like the following:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The number of device class instances that this composite device uses.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="cp">#define NUM_DEVICES         2</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The array of devices supported by this composite device.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="n">tCompositeEntry</span> <span class="n">g_psCompDevices</span><span class="p">[</span><span class="n">NUM_DEVICES</span><span class="p">];</span>
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li><p>Define the additional structures and storage required by the composite device class. For the HID/DFU device described above, this would look like:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// Allocate the Device Data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TI USBLib VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// PID for composite HID/DFU device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_COMP_HID_DFU</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in milliamps.</span>
    <span class="c1">//</span>
    <span class="mi">500</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Device event handler function pointer (receives connect, disconnect</span>
    <span class="c1">// and other device-level notifications).</span>
    <span class="c1">//</span>
    <span class="n">DeviceHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.  This is the string table for the main device (no DFU</span>
    <span class="c1">// strings are required).</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="n">NUM_DEVICES</span><span class="p">,</span>
    <span class="n">g_psCompDevices</span>
<span class="p">};</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// A buffer into which the composite device can write the combined config</span>
<span class="c1">// descriptor.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8cDescriptorBuffer</span><span class="p">[</span><span class="n">COMPOSITE_DDFU_SIZE</span> <span class="o">+</span> <span class="n">COMPOSITE_DHID_SIZE</span><span class="p">];</span>
</pre></div>
</div>
<ol class="arabic simple" start="8">
<li><p>Rework the USB library initialization function calls to use the composite device. Again, following the HID/DFU example:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Initialize each of the device instances that forms our composite</span>
<span class="c1">// USB device.</span>
<span class="c1">//</span>
<span class="n">pvMouseDevice</span> <span class="o">=</span>
    <span class="n">USBDHIDMouseCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sMouseDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_psCompDevices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">pvDFUDevice</span> <span class="o">=</span>
    <span class="n">USBDDFUCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sDFUDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_psCompDevices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="c1">//</span>
<span class="c1">// Pass the USB library our device information, initialize the USB</span>
<span class="c1">// controller and connect the device to the bus.</span>
<span class="c1">//</span>
<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_BUFFER_SIZE</span><span class="p">,</span>
                  <span class="n">g_pcDescriptorBuffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="windows-drivers-for-dfu-devices">
<h3>Windows Drivers for DFU Devices<a class="headerlink" href="#windows-drivers-for-dfu-devices" title="Permalink to this headline">¶</a></h3>
<p>Since DFU presents itself as another interface on the USB device, a device driver is required even though the interface is essentially static and does nothing other than listen for a single request while in runtime mode. No version of Microsoft Windows includes a generic Device Firmware Upgrade driver so any application supporting DFU must provide a suitable driver.</p>
<p>The DFU driver is common between the USB boot loader (<code class="docutils literal notranslate"><span class="pre">boot_usb</span></code>) and the runtime DFU interface provided by the DFU device class. It consists of two USBLib-specific DLLs along with the Microsoft-supplied co-installers for the WinUSB subsystem. Support is provided for WindowsXP, Windows Vista and Windows7 in both 32 bit and 64 bit flavors. The two DLLs are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>dll name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmusbdll.dll</span></code></p></td>
<td><p>A low level interface above WinUSB which provides simple packet transmission and reception and the ability to perform a control transaction on endpoint 0. Applications may be built using this interface without the need to download and install the Windows Device Driver Kit. The DLL itself requires the Windows DDK to build since WinUSB headers are not provided in the Windows SDK.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmdfu.dll</span></code></p></td>
<td><p>A high level API above the DFU function. This DLL allows DFU-capable devices to be found on the bus and application images to be downloaded to or uploaded from those devices.</p></td>
</tr>
</tbody>
</table>
<p>To create a driver for your DFU-enabled device, either create a new .INF file from the <code class="docutils literal notranslate"><span class="pre">boot_usb.inf</span></code> example, substituting your device’s VID, PID and DFU interface number for those in the original file or merge the content of this .inf (with the same changes) into a combined .inf for your composite device.</p>
<p>Note that the device publishs PID 0x00FF when in DFU mode so you must ensure that your driver .INF file contains an entry to install the driver for devices publishing this PID in addition to your composite device’s standard PID.</p>
</div>
</div>
<div class="section" id="hid-device-class-driver">
<h2>HID Device Class Driver<a class="headerlink" href="#hid-device-class-driver" title="Permalink to this headline">¶</a></h2>
<p>The USB Human Interface Class device class is an enormously versatile architecture for supporting a wide variety of input/output devices regardless of whether or not they actually deal with “Human Interfaces”. Although typically thought of in the context of keyboards, mice and joysticks, the specification can cover practically any device offering user controls or data gathering capabilities.</p>
<p>Communication between the HID device and host is via a collection of “report” structures which are defined by the device in HID report descriptors which the host can query. Reports are defined both for communication of device input to the host and for output and feature selection from the host.</p>
<p>In addition to the flexibility offered by the basic architecture, HID devices also benefit from excellent operating system support for the class, meaning that no driver writing is necessary and, in the case of standard devices such as keyboards and joysticks, the device can connect to and operate with the host system without any new host software having to be written. Even in the case of a non-standard or vendor-specific HID device, the operating system support makes writing the host-side software very much more straightforward than developing the device using a vendor-specific class.</p>
<p>Despite these advantages, there is one downside to using HID. The interface is limited in the amount of data that can be transferred so is not suitable for use by devices which expect to use a high percentage of the USB bus bandwidth. Devices are limited to a maximum of 64KB of data per second for each report they support. Multiple reports can be used if necessary but high bandwidth devices may be better implemented using a class which supports bulk rather than interrupt endpoints (such as CDC or the generic bulk device class).</p>
<div class="figure align-default" id="id9">
<img alt="USB HID Device" src="../../_images/usb_hid_device.png" />
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">USB HID Device</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>This device class uses one or, optionally, two endpoints in addition to endpoint zero. One interrupt IN endpoint carries HID input reports from the device to the host. Output and Feature reports from the host to the device are typically carried via endpoint zero but devices which expect high host-to-device data rates can select to offer an independent interrupt OUT endpoint to carry these. Endpoint zero carries standard USB requests and also HID-specific descriptor requests.</p>
<p>The HID mouse and keyboard device APIs described later in this document are both implemented above the HID Device Class Driver API.</p>
<div class="section" id="hid-device-class-events">
<h3>HID Device Class Events<a class="headerlink" href="#hid-device-class-events" title="Permalink to this headline">¶</a></h3>
<p>The HID device class driver sends the following events to the application callback functions:</p>
<div class="section" id="id3">
<h4>Receive Channel Events<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_RX_AVAILABLE</strong></p></li>
<li><p><strong>USB_EVENT_ERROR</strong></p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong></p></li>
<li><p><strong>USB_EVENT_RESUME</strong></p></li>
<li><p><strong>USBD_HID_EVENT_IDLE_TIMEOUT</strong></p></li>
<li><p><strong>USBD_HID_EVENT_GET_REPORT_BUFFER</strong></p></li>
<li><p><strong>USBD_HID_EVENT_GET_REPORT</strong></p></li>
<li><p><strong>USBD_HID_EVENT_SET_PROTOCOL</strong></p></li>
<li><p><strong>USBD_HID_EVENT_GET_PROTOCOL</strong></p></li>
<li><p><strong>USBD_HID_EVENT_SET_REPORT</strong></p></li>
<li><p><strong>USBD_HID_EVENT_REPORT_SENT</strong></p></li>
</ul>
<p><strong>Note:</strong> The USB_EVENT_DISCONNECTED event is not be reported to the application if the MCU’s PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
</div>
<div class="section" id="id4">
<h4>Transmit Channel Events<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>USB_EVENT_TX_COMPLETE</strong></p></li>
</ul>
</div>
</div>
<div class="section" id="using-the-hid-device-class-driver">
<h3>Using the HID Device Class Driver<a class="headerlink" href="#using-the-hid-device-class-driver" title="Permalink to this headline">¶</a></h3>
<p>To add a USB HID interface to your application using the HID Device Class Driver, take the following steps.</p>
<ul class="simple">
<li><p>Add the following header files to the source file(s) which are to support USB:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usbhid.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhid.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define the string table which is used to describe various features of your new device to the host system. The following is the string table taken from the <code class="docutils literal notranslate"><span class="pre">usb_dev_mouse</span></code> example application. Edit the actual strings to suit your application and take care to ensure that you also update the length field (the first byte) of each descriptor to correctly reflect the length of the string and descriptor header. The number of strings included varies depending upon the device but must be at least 5. HID report descriptors may refer to string IDs and, if the descriptor for your device includes these, additional strings are required. Also, if multiple languages are reported in string descriptor 0, you must ensure that you have strings available for each language with all language 1 strings occurring in order in a block before all language 2 strings and so on.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The languages supported by this device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8LangDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">4</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_LANG_EN_US</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The manufacturer string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ManufacturerString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The product string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ProductString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;E&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The serial number string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SerialNumberString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The interface description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8HIDInterfaceString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">19</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The configuration description string.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ConfigString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">23</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The descriptor string table.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_pStringDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pLangDescriptor</span><span class="p">,</span>
    <span class="n">g_pManufacturerString</span><span class="p">,</span>
    <span class="n">g_pProductString</span><span class="p">,</span>
    <span class="n">g_pSerialNumberString</span><span class="p">,</span>
    <span class="n">g_pHIDInterfaceString</span><span class="p">,</span>
    <span class="n">g_pConfigString</span>
<span class="p">};</span>

<span class="cp">#define NUM_STRING_DESCRIPTORS (sizeof(g_pStringDescriptors) /                \</span>
<span class="cp">                                sizeof(uint8_t *))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Develop the HID report descriptors and, if required, physical descriptors for your device and, from these, the HID descriptor itself. Details of how to do this are beyond the scope of this document other than to say that macros in header file <code class="docutils literal notranslate"><span class="pre">usbdhid.h</span></code> are included to help add the various tags required in the descriptor. For information on how these descriptors are constructed, please see the “USB Device Class Definition for Human Interface Devices, version 1.11” which can be downloaded from <a class="reference external" href="http://www.usb.org/developers/devclass_docs/HID1_11.pdf">http://www.usb.org/developers/devclass_docs/HID1_11.pdf</a>. The required structures for a BIOS-compatible HID mouse are:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The report descriptor for the BIOS mouse class device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ucMouseReportDescriptor</span><span class="p">[]</span><span class="o">=</span>
<span class="p">{</span>
    <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_GENERIC_DESKTOP</span><span class="p">),</span>
    <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_MOUSE</span><span class="p">),</span>
    <span class="n">Collection</span><span class="p">(</span><span class="n">USB_HID_APPLICATION</span><span class="p">),</span>
        <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_POINTER</span><span class="p">),</span>
        <span class="n">Collection</span><span class="p">(</span><span class="n">USB_HID_PHYSICAL</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// The buttons.</span>
            <span class="c1">//</span>
            <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_BUTTONS</span><span class="p">),</span>
            <span class="n">UsageMinimum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">UsageMaximum</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 3 - 1 bit values for the buttons.</span>
            <span class="c1">//</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 1 - 5 bit unused constant value to fill the 8 bits.</span>
            <span class="c1">//</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ARRAY</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// The X and Y axis.</span>
            <span class="c1">//</span>
            <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_GENERIC_DESKTOP</span><span class="p">),</span>
            <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_X</span><span class="p">),</span>
            <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_Y</span><span class="p">),</span>
            <span class="n">LogicalMinimum</span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="p">),</span>
            <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">127</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 2 - 8 bit Values for x and y.</span>
            <span class="c1">//</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_RELATIVE</span><span class="p">),</span>
        <span class="n">EndCollection</span><span class="p">,</span>
    <span class="n">EndCollection</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The HID class descriptor table. For the mouse class, we have only a single</span>
<span class="c1">// report descriptor.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_pMouseClassDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pucMouseReportDescriptor</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The HID descriptor for the mouse device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">tHIDDescriptor</span> <span class="n">g_sMouseHIDDescriptor</span> <span class="o">=</span>
<span class="p">{</span>
     <span class="mi">9</span><span class="p">,</span>                                 <span class="c1">// bLength</span>
     <span class="n">USB_HID_DTYPE_HID</span><span class="p">,</span>                 <span class="c1">// bDescriptorType</span>
     <span class="mh">0x111</span><span class="p">,</span>                             <span class="c1">// bcdHID (version 1.11 compliant)</span>
     <span class="mi">0</span><span class="p">,</span>                                 <span class="c1">// bCountryCode (not localized)</span>
     <span class="mi">1</span><span class="p">,</span>                                 <span class="c1">// bNumDescriptors</span>
     <span class="n">USB_HID_DTYPE_REPORT</span><span class="p">,</span>              <span class="c1">// Report descriptor</span>
     <span class="k">sizeof</span><span class="p">(</span><span class="n">g_pucMouseReportDescriptor</span><span class="p">)</span> <span class="c1">// Size of report descriptor</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define an array of <code class="docutils literal notranslate"><span class="pre">tHIDReportIdle</span></code> structures in RAM with one entry for each input report your device supports. Initialize the <code class="docutils literal notranslate"><span class="pre">ucDuration4mS</span></code> and <code class="docutils literal notranslate"><span class="pre">ucReportID</span></code> fields in each of the entries to set the default idle report time for each input report. Note that <code class="docutils literal notranslate"><span class="pre">ucDuration4mS</span></code> defines the idle time in 4mS increments as used in the USB HID Set_Idle and Get_Idle requests. The times defined in these structures are used to determine how often a given input report is resent to the host in the absence of any device state change. For example, a device supporting two input reports with IDs 1 and 2 may initialize the array as follows:</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="p">{</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="c1">// Report 1 polled every 500mS (4 * 125).</span>
    <span class="p">{</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>   <span class="c1">// Report 2 is not polled (0mS timeout)</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDHIDDevice</span></code> structure and initialize all fields as required for your application. The following example shows a structure suitable for a BIOS-compatible mouse device which publishes a single input report.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDHIDDevice</span> <span class="n">g_sHIDMouseDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This mouse supports the boot subclass.</span>
    <span class="c1">//</span>
    <span class="n">USB_HID_SCLASS_BOOT</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This device supports the BIOS mouse report protocol.</span>
    <span class="c1">//</span>
    <span class="n">USB_HID_PROTOCOL_MOUSE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The device has a single input report.</span>
    <span class="c1">//</span>
    <span class="mi">1</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to our array of tHIDReportIdle structures. For this device,</span>
    <span class="c1">// the array must have 1 element (matching the value of the previous field).</span>
    <span class="c1">//</span>
    <span class="n">g_psMouseReportIdle</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your receive callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBReceiveEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the receive callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your transmit callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourUSBTransmitEventCallback</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the transmit callback alongside every</span>
    <span class="c1">// event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This device does not want to use a dedicated interrupt OUT endpoint</span>
    <span class="c1">// since there are no output or feature reports required.</span>
    <span class="c1">//</span>
    <span class="nb">false</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the HID descriptor for the device.</span>
    <span class="c1">//</span>
    <span class="o">&amp;</span><span class="n">g_sMouseHIDDescriptor</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the array of HID class descriptor pointers for this device.</span>
    <span class="c1">// The number of elements in this array and their order must match the</span>
    <span class="c1">// information in the HID descriptor provided above.</span>
    <span class="c1">//</span>
    <span class="n">g_pMouseClassDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table. This must equal</span>
    <span class="c1">// (1 + (5 + (num HID strings)) * (num languages)).</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p>Add a receive event handler function, YourUSBReceiveEventCallback in the previous example, to your application taking care to handle all messages which require a particular response. For the HID device class the following receive callback events MUST be handled by the application:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_RX_AVAILABLE</strong></p></li>
<li><p><strong>USBD_HID_EVENT_IDLE_TIMEOUT</strong></p></li>
<li><p><strong>USBD_HID_EVENT_GET_REPORT_BUFFER</strong></p></li>
<li><p><strong>USBD_HID_EVENT_GET_REPORT</strong></p></li>
<li><p><strong>USBD_HID_EVENT_SET_PROTOCOL</strong> (for BIOS protocol devices)</p></li>
<li><p><strong>USBD_HID_EVENT_GET_PROTOCOL</strong> (for BIOS protocol devices)</p></li>
<li><p><strong>USBD_HID_EVENT_SET_REPORT</strong> Although no other events must be handled, <strong>USB_EVENT_CONNECTED</strong> and <strong>USB_EVENT_DISCONNECTED</strong> is typically be required since these indicate when a host connects or disconnects and allow the application to flush any buffers or reset state as required. Attempts to send data when the host is disconnected are ignored and result in an error.</p></li>
</ul>
</li>
<li><p>Add a transmit event handler function, YourUSBTransmitEventCallback in the previous example, to your application and use <strong>USB_EVENT_TX_COMPLETE</strong> to indicate when a new report may be scheduled for transmission. While a report is being transmitted, attempts to send another report via <code class="docutils literal notranslate"><span class="pre">USBDHIDReportWrite()</span></code> are ignored and results in an error.</p></li>
<li><p>From your main initialization function call the HID device class driver initialization function to configure the USB controller and place the device on the bus.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDHIDMouseInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sHIDMouseDevice</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, your control event handler is sent <code class="docutils literal notranslate"><span class="pre">USB_EVENT_CONNECTED</span></code> and the first input report may be sent to the host using <code class="docutils literal notranslate"><span class="pre">USBDHIDReportWrite()</span></code> with following packets transmitted as soon as <strong>USB_EVENT_TX_COMPLETE</strong> is received via the transmit event handler.</p></li>
</ul>
</div>
<div class="section" id="using-the-composite-hid-mouse-device-class">
<h3>Using the Composite HID Mouse Device Class<a class="headerlink" href="#using-the-composite-hid-mouse-device-class" title="Permalink to this headline">¶</a></h3>
<p>When using the HID mouse device class in a composite device, the configuration of the device is very similar to how it is configured as a non-composite device. Follow all of the configuration steps in the previous section with the exception of calling <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseCompositeInit()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseInit()</span></code>. This prepares an instance of the HID mouse device class to be enumerated as part of a composite device. The <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseCompositeInit()</span></code> function takes the mouse device structure and a pointer to a <code class="docutils literal notranslate"><span class="pre">tCompositeEntry</span></code> value so that it can properly initialize the mouse device and the composite entry that is later be passed to the <code class="docutils literal notranslate"><span class="pre">USBDCompositeInit()</span></code> function. The code example below provides an example of how to initialize a mouse device to be a part of a composite device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// These should be initialized with valid values for each class.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="n">tUSBDHIDMouseDevice</span> <span class="n">g_sHIDMouseDevice</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The array of composited devices.</span>
<span class="c1">//</span>
<span class="n">tCompositeEntry</span> <span class="n">psCompEntries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// Allocate the Device Data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TI USBLib VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// PID for composite HID/DFU device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_COMP_HID_DFU</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in milliamps.</span>
    <span class="c1">//</span>
    <span class="mi">500</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Device event handler function pointer (receives connect, disconnect</span>
    <span class="c1">// and other device-level notifications).</span>
    <span class="c1">//</span>
    <span class="n">DeviceHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.  This is the string table for the main device (no DFU</span>
    <span class="c1">// strings are required).</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="n">NUM_DEVICES</span><span class="p">,</span>
    <span class="n">g_psCompDevices</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// The OTHER_SIZES here are the sizes of the descriptor data for other classes</span>
<span class="c1">// that are part of the composite device.</span>
<span class="c1">//</span>
<span class="cp">#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DHID_SIZE + OTHER_SIZES)</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8DescriptorData</span><span class="p">[</span><span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Initialize the HID mouse and its composite entry.</span>
<span class="c1">//</span>
<span class="n">pvMouseDevice</span> <span class="o">=</span> <span class="n">USBDHIDMouseCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sHIDMouseDevice</span><span class="p">,</span>
                                          <span class="o">&amp;</span><span class="n">psCompEntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="p">...</span>

<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">,</span>
                  <span class="n">g_pui8DescriptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>All other API calls to the USB HID mose device class should use the value returned by <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseCompositeInit()</span></code> when the API calls for a pvInstance pointer. Also when using the audio device in a composite device the <strong>COMPOSITE_DHID_SIZE</strong> value should be added to the size of the g_pui8DescriptorData array as shown in the example above.</p>
</div>
<div class="section" id="handling-hid-reports">
<h3>Handling HID Reports<a class="headerlink" href="#handling-hid-reports" title="Permalink to this headline">¶</a></h3>
<p>Communication between a HID device and host takes place using data structures known as “reports”.</p>
<p>Input reports are sent from the device to the host in response to device state changes, queries from the host or a configurable timeout. In the case of a state change, the device sends a new copy of the relevant input report to the host via the interrupt IN endpoint. This is accomplished by calling <code class="docutils literal notranslate"><span class="pre">USBDHIDReportWrite()</span></code>. Whereas other USB device class drivers require that the application send no more than 1 packet of data in each call to the driver’s “PacketWrite” function, the HID device class driver allows a complete report to be sent. If the report passed is longer than the maximum packet size for the endpoint, the class driver handles the process of breaking it up into multiple USB packets. Once a full report has been transmitted to the host and acknowledged, the application’s transmit event handler receives <strong>USB_EVENT_TX_COMPLETE</strong> indicating that the application is free to send another report.</p>
<p>The host may also poll for the latest version of an input report. This procedure involves a request on endpoint zero and results in a sequence of events that the application must respond to. On receipt of the Get_Report request, the HID device class driver sends <strong>USBD_HID_EVENT_GET_REPORT</strong> to the application receive callback. The application must respond to this by returning a pointer to the latest version of the requested report and the size of the report in bytes. This data is then returned to the host via endpoint zero and successful completion of the transmission is notified to the application using <strong>USBD_HID_EVENT_REPORT_SENT</strong> passed to the receive callback.</p>
<p>One other condition may cause an input report to be sent. Each input report has a timeout associated with it and, when this time interval expires, the report must be returned to the host regardless of whether or not the device state has changed. The timeout is set using a Set_Idle request from the host and may be completely disabled (as is typically done for mice and keyboards when communicating with a Windows PC, for example) by setting the timeout to 0.</p>
<p>The HID device class driver internally tracks the required timeouts for each input report. When a timer expires, indicating that the report must be resent, <strong>USBD_HID_EVENT_IDLE_TIMEOUT</strong> is sent to the application receive callback. As in the previous case, the application must respond with a pointer to the appropriate report and its length in bytes. In this case, the returned report is transmitted to the host using the interrupt IN endpoint and the successful completion of the transmission is notified to the application using <strong>USB_EVENT_TX_COMPLETE</strong> sent to the transmit callback. Note that the application returns information on the location and size of the report and MUST NOT call <code class="docutils literal notranslate"><span class="pre">USBDHIDReportWrite()</span></code> in response to this event.</p>
<p>Output and Feature reports are sent from the host to the device to instruct it to set various parameters and options. A device can chose whether all host-to-device report communication takes place via endpoint zero or whether a dedicated interrupt OUT endpoint is used. Typically host-to-device traffic is low bandwidth and endpoint zero communication can be used but, if a dedicated endpoint is required, the field <code class="docutils literal notranslate"><span class="pre">bUseOutEndpoint</span></code> in the <code class="docutils literal notranslate"><span class="pre">tUSBDHIDDevice</span></code> structure for the device should be set to <strong>true</strong>.</p>
<p>If using a dedicated endpoint for output and feature reports, the application receive callback is called with <strong>USB_EVENT_RX_AVAILABLE</strong> whenever a report packet is available. During this callback, the application can call <code class="docutils literal notranslate"><span class="pre">USBDHIDPacketRead()</span></code> to retrieve the packet. If it is not possible to read the packet immediately, the HID device class driver calls the application back later to give it another opportunity. Until the packet is read, NAK is sent to the host preventing more data from being sent.</p>
<p>In the more typical case where endpoint zero is used to transfer output and feature reports, the application can expect the following sequence of events on the receive callback.</p>
<ul class="simple">
<li><p><strong>USBD_HID_EVENT_GET_REPORT_BUFFER</strong> indicates that a Set_Report request has been received from the host and the device class driver is requesting a buffer into which the received report can be written. The application must return a pointer to a buffer which is at least as large as required to store the report.</p></li>
<li><p><strong>USBD_HID_EVENT_SET_REPORT</strong> follows next once the report data has been read from endpoint zero into the buffer supplied on the earlier <strong>USBD_HID_EVENT_GET_REPORT_BUFFER</strong> callback. The device class driver does not access the report buffer after this event is sent and the application may handle the memory as it wishes following this point.</p></li>
</ul>
</div>
</div>
<div class="section" id="hid-mouse-device-class-api">
<h2>HID Mouse Device Class API<a class="headerlink" href="#hid-mouse-device-class-api" title="Permalink to this headline">¶</a></h2>
<p>The USB HID device class is extremely versatile but somewhat daunting. For applications which want to offer a mouse-like appearance to a USB host, however, the HID Mouse Device Class API may be used without the need to develop any HID-specific software. This high-level interface completely encapsulates the USB stack and USB HID device class driver and allows an application to simply instantiate a USB mouse device and call a single function to notify the USB host of mouse movement and button presses.</p>
<p>The USB mouse device uses the BIOS mouse subclass and protocol so is recognized by the vast majority of host operating systems and BIOSs without the need for additional host-side software. The mouse provides two axis movement (reported to the host in terms of relative position changes) and up to three buttons which may be either pressed or released.</p>
<div class="figure align-default" id="id10">
<img alt="USB HID Mouse Device" src="../../_images/usb_hid_mouse_device.png" />
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">USB HID Mouse Device</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">usb_dev_mouse</span></code> example application makes use of this device class API.</p>
<div class="section" id="hid-mouse-device-api-events">
<h3>HID Mouse Device API Events<a class="headerlink" href="#hid-mouse-device-api-events" title="Permalink to this headline">¶</a></h3>
<p>The HID mouse device API sends the following events to the application callback function:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_TX_COMPLETE</strong></p></li>
<li><p><strong>USB_EVENT_ERROR</strong></p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong></p></li>
<li><p><strong>USB_EVENT_RESUME</strong></p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not be reported to the application if the MCU’s USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
</div>
<div class="section" id="using-the-hid-mouse-device-class-api">
<h3>Using the HID Mouse Device Class API<a class="headerlink" href="#using-the-hid-mouse-device-class-api" title="Permalink to this headline">¶</a></h3>
<p>To add a USB HID mouse interface to your application using the HID Mouse Device Class API, take the following steps.</p>
<ul>
<li><p>Add the following header files to the source file(s) which are to support USB:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;src/usb.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;usblib/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;usblib/device/usbdhidmouse.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</li>
<li><p>Define the string table which is used to describe various features of your new device to the host system. An example of a suitable string table for a mouse device can be found in using_the_hid_device. This table must include a minimum of 6 entries - string descriptor 0 defining the language(s) available and 5 strings for each supported language.</p></li>
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDHIDMouseDevice</span></code> structure and initialize all fields as required for your application.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDHIDMouseDevice</span> <span class="n">g_sMouseDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your mouse callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourMouseHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the callback alongside every event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table. This must equal</span>
    <span class="c1">// (1 + (5 * (num languages))).</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p>Add a mouse event handler function, YourMouseHandler in the previous example, to your application. A minimal implementation can ignore all events though <strong>USB_EVENT_TX_COMPLETE</strong> can be used to ensure that mouse messages are not sent when a previous report is still in transit to the host. Attempts to send a new mouse report when the previous report has not yet been acknowledged results in return code <strong>MOUSE_ERR_TX_ERROR</strong> from <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseStateChange()</span></code>.</p></li>
<li><p>From your main initialization function call the HID mouse device API initialization function to configure the USB controller and place the device on the bus.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDHIDMouseInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sMouseDevice</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your mouse device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, your mouse event handler is sent <strong>USB_EVENT_CONNECTED</strong> after which calls can be made to <code class="docutils literal notranslate"><span class="pre">USBDHIDMouseStateChange()</span></code> to inform the host of mouse position and button state changes.</p></li>
</ul>
</div>
</div>
<div class="section" id="hid-keyboard-device-class-api">
<h2>HID Keyboard Device Class API<a class="headerlink" href="#hid-keyboard-device-class-api" title="Permalink to this headline">¶</a></h2>
<p>As with the HID Mouse Device Class API described above, the HID Keyboard Device Class API provides an easy-to-use high-level interface for applications wishing to appear to the USB host as a BIOS-compatible keyboard. The keyboard supports up to 6 simultaneously pressed, non-modifier keys and up to 5 state indication LEDs.</p>
<p>Key press and release notifications along with the state of the modifier keys (Shift, Ctrl, Alt, etc.) are passed to the API in a single API call and a callback informs the application whenever the host requests that the LED states be changed.</p>
<p>Keys are identified to the API by means of USB HID key usage codes. A subset of these are defined in the header file <code class="docutils literal notranslate"><span class="pre">usbhid.h</span></code> and the full set can be found in the document “Universal Serial Bus (USB) HID Usage Tables” which can be downloaded from <a class="reference external" href="http://www.usb.org/developers/devclass_docs/Hut1_12.pdf">http://www.usb.org/developers/devclass_docs/Hut1_12.pdf</a>.</p>
<div class="figure align-default" id="id11">
<img alt="USB HID Keyboard Device" src="../../_images/usb_hid_keyboard_device.png" />
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">USB HID Keyboard Device</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">usb_dev_keyboard</span></code> example application makes use of this device class API.</p>
<div class="section" id="hid-keyboard-device-api-events">
<h3>HID Keyboard Device API Events<a class="headerlink" href="#hid-keyboard-device-api-events" title="Permalink to this headline">¶</a></h3>
<p>The HID keyboard device API sends the following events to the application callback function:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong></p></li>
<li><p><strong>USB_EVENT_TX_COMPLETE</strong></p></li>
<li><p><strong>USB_EVENT_ERROR</strong></p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong></p></li>
<li><p><strong>USB_EVENT_RESUME</strong></p></li>
<li><p><strong>USBD_HID_KEYB_EVENT_SET_LEDS</strong></p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not reported to the application if the MCU’s PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
<ul>
<li><p>Add the following header files to the source file(s) which are to support USB:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhidkeyb.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</li>
<li><p>Define the string table which is used to describe various features of your new device to the host system. The string table found in using_the_hid_device illustrates the format required. This table must include a minimum of 6 entries - string descriptor 0 defining the language(s) available and 5 strings for each supported language.</p></li>
<li><p>Define a <code class="docutils literal notranslate"><span class="pre">tUSBDHIDKeyboardDevice</span></code> structure and initialize all fields as required for your application.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDHIDKeyboardDevice</span> <span class="n">g_sKeyboardDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID you have been assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The product ID you have assigned for this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of your device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The value to be passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your keyboard callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourKeyboardHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that you want passed to the callback alongside every event.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to your string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table. This must equal</span>
    <span class="c1">// (1 + (5 * (num languages))).</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p>Add a keyboard event handler function, YourKeyboardHandler in the previous example, to your application. A minimal implementation can ignore all events since key information is buffered in the API and sent later if <code class="docutils literal notranslate"><span class="pre">USBDHIDKeyboardKeyStateChange()</span></code> is called while a previous report transmission remains unacknowledged.</p></li>
<li><p>From your main initialization function call the HID keyboard device API initialization function to configure the USB controller and place the device on the bus.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pvDevice</span> <span class="o">=</span> <span class="n">USBDHIDKeyboardInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sKeyboardDevice</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Assuming <code class="docutils literal notranslate"><span class="pre">pvDevice</span></code> returned is not NULL, your keyboard device is now ready to communicate with a USB host.</p></li>
<li><p>Once the host connects, your keyboard event handler is sent <strong>USB_EVENT_CONNECTED</strong> after which calls can be made to <code class="docutils literal notranslate"><span class="pre">USBDHIDKeyboardKeyStateChange()</span></code> to inform the host of key press and release events.</p></li>
</ul>
</div>
</div>
<div class="section" id="hid-gamepad-device-class-api">
<h2>HID Gamepad Device Class API<a class="headerlink" href="#hid-gamepad-device-class-api" title="Permalink to this headline">¶</a></h2>
<p>The HID Gamepad Device Class API provides an interface for applications to provide USB gamepad support to a USB host. The default gamepad supports 3 8-bit signed axis values (X, Y, and Z) and 8 buttons. The USB gamepad is configured to allow the host to poll at 1ms rate for the values. The application calls the <code class="docutils literal notranslate"><span class="pre">USBDHIDGamepadSendReport()</span></code> function to provide data to the USB library.</p>
<div class="section" id="defining-a-hid-gamepad-device">
<h3>Defining a HID Gamepad Device<a class="headerlink" href="#defining-a-hid-gamepad-device" title="Permalink to this headline">¶</a></h3>
<p>In order to properly configure an application to function as a HID Gamepad device, there are a few structures that the application must properly declare and pass to the USB library. These include declaring the strings that are passed back to the USB host, the basic configuration of the device and an optional report descriptor to customize the data that is sent back to the USB host.</p>
<p>The following header files are needed to properly define all of the structures needed to implement a USB gamepad device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usbhid.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhid.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhidgamepad.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The application must first define the string table that is used to describe various features of the device to the host system. A detailed description of how to declare a string table is found in the using_the_hid_device section of this document. This table must include a minimum of 6 entries with the following meanings: languages available, manufacturer name, product description, serial number, HID interface description, and a configuration description.</p>
<p>The application must also provide a gamepad event handler function. This function responds to the <strong>USB_EVENTS</strong>_ parameter passed to the application when events occur. The HID gamepad device API sends the following events to the application callback function:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong> - USB connection event occurred.</p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong> - USB disconnect event occurred.</p></li>
<li><p><strong>USB_EVENT_TX_COMPLETE</strong> - A previously scheduled transmit request completed.</p></li>
<li><p><strong>USB_EVENT_ERROR</strong> - An error prevented the call from completing successfully.</p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong> - A USB suspend event occurred.</p></li>
<li><p><strong>USB_EVENT_RESUME</strong> - A USB resume event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_RESUME</strong> - A USB LPM resume event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_SLEEP</strong> - A USB LPM sleep event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_ERROR</strong> - A USB LPM error occurred.</p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not reported to the application if the MCU’s USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode using the <code class="docutils literal notranslate"><span class="pre">USBStackModeSet()</span></code> function.</p>
<p><strong>Note:</strong> The __USB_EVENT_LPM_*__ events are not supported on all microcontrollers. Please check the device’s data sheet to see if USB LPM is supported on the device that is in use.</p>
<p>The string table and event handler function are used in the final required structure to complete the definition of the USB game device to the host. The application must define a <code class="docutils literal notranslate"><span class="pre">tUSBDHIDGamepadDevice</span></code> structure and initialize all fields so that the USB library can enumerate the device to the host.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDHIDGamepadDevice</span> <span class="n">g_sGamepadDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Product ID assigned to this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of the device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This value is passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the gamepad callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourGamepadHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that the application passes to the gamepad callback function.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the string table for the device.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table, which must equal</span>
    <span class="c1">// (1 + (5 * (number of languages))).</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// An optional override HID descriptor for the gamepad, the value of which</span>
    <span class="c1">// can be 0 if the application is using the default gamepad descriptor.</span>
    <span class="c1">//</span>
    <span class="n">g_pui8GameReportDescriptor</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The size of the optional override HID descriptor for the</span>
    <span class="c1">// gamepad, which must be 0 if the application is using the default</span>
    <span class="c1">// gamepad descriptor or the size of the custom report descriptor in bytes.</span>
    <span class="c1">//</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_pui8GameReportDescriptor</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, to initialize a single gamepad device, the application must call the HID gamepad device API initialization function, <code class="docutils literal notranslate"><span class="pre">USBDHIDGamepadInit()</span></code>, to configure the USB controller and prepare the device to be connected to the host. Assuming the <code class="docutils literal notranslate"><span class="pre">psGamepad</span></code> returned is not NULL, the gamepad device is now ready to communicate with a USB host.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Initialize a gamepad HID instance.</span>
<span class="c1">//</span>
<span class="n">psGamepad</span> <span class="o">=</span> <span class="n">USBDHIDGamepadInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sGamepadDevice</span><span class="p">);</span>
</pre></div>
</div>
<p>Once the host connects, your gamepad event handler is sent the <strong>USB_EVENT_CONNECTED</strong> event after which calls can be made to <code class="docutils literal notranslate"><span class="pre">USBDHIDGamepadSendReport()</span></code> to provide up to date information from the application to the USB host. After a successful call to <code class="docutils literal notranslate"><span class="pre">USBDHIDGamepadSendReport()</span></code>, the application must wait for a <strong>USB_EVENT_TX_COMPLETE</strong> event before sending more data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">tGamepadReport</span> <span class="n">sReport</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Send a gamepad HID report.</span>
<span class="c1">//</span>
<span class="n">USBDHIDGamepadSendReport</span><span class="p">(</span><span class="n">psGamepad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sReport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sReport</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-a-custom-hid-gamepad-report">
<h3>Defining a Custom HID Gamepad Report<a class="headerlink" href="#defining-a-custom-hid-gamepad-report" title="Permalink to this headline">¶</a></h3>
<p>This section handles some of the considerations when defining an application-supplied report descriptor. HID report descriptors are infinitely configurable and can be confusing to define properly, so a good understanding of the USB HID specification is required. The USB HID class supported by the USB library is based on the USB HID 1.11 specification available from usb.org, which should be reviewed before attempting to declare a custom report descriptor. The definition of the structure is as similiar as possible to the USB specification to make it as easy as possible to properly define a structure similar to the USB specification.</p>
<p>The example below defines a more complicated 12-bit four-axis controller with 16 buttons. Each of the 4 12-bit values are padded with a single 4-bit constant so that the values are easily accessed by the application. This padding is not required, but does make sending the data much more convenient for the application by allowing a structure like the tCustomReport in the example below. The final value in the report is a single 16-bit value containing the state of all 16 buttons as individual bits.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The following is the HID report structure definition that is passed back</span>
<span class="c1">// to the host.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8GameReportDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_GENERIC_DESKTOP</span><span class="p">),</span>
    <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_JOYSTICK</span><span class="p">),</span>
    <span class="n">Collection</span><span class="p">(</span><span class="n">USB_HID_APPLICATION</span><span class="p">),</span>

        <span class="c1">//</span>
        <span class="c1">// The axis for the controller.</span>
        <span class="c1">//</span>
        <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_GENERIC_DESKTOP</span><span class="p">),</span>
        <span class="n">Usage</span> <span class="p">(</span><span class="n">USB_HID_POINTER</span><span class="p">),</span>
        <span class="n">Collection</span> <span class="p">(</span><span class="n">USB_HID_PHYSICAL</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// The X, Y, RX, and RY values, which are specified as 8-bit</span>
            <span class="c1">// absolute position values.</span>
            <span class="c1">//</span>
            <span class="n">Usage</span> <span class="p">(</span><span class="n">USB_HID_X</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 12-bit absolute X value.</span>
            <span class="c1">//</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 4-bit padding to 16 bits.</span>
            <span class="c1">//</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 12-bit absolute Y value.</span>
            <span class="c1">//</span>
            <span class="n">Usage</span> <span class="p">(</span><span class="n">USB_HID_Y</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 4-bit padding to 16 bits.</span>
            <span class="c1">//</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 12-bit absolute RX value.</span>
            <span class="c1">//</span>
            <span class="n">Usage</span> <span class="p">(</span><span class="n">USB_HID_RX</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 4-bit padding to 16 bits.</span>
            <span class="c1">//</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 12-bit absolute RY value.</span>
            <span class="c1">//</span>
            <span class="n">Usage</span> <span class="p">(</span><span class="n">USB_HID_RY</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 4-bit padding to 16 bits.</span>
            <span class="c1">//</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// The 16 buttons.</span>
            <span class="c1">//</span>
            <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_BUTTONS</span><span class="p">),</span>
            <span class="n">UsageMinimum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">UsageMaximum</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
            <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">PhysicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">PhysicalMaximum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>

            <span class="c1">//</span>
            <span class="c1">// 16 1-bit values for the buttons.</span>
            <span class="c1">//</span>
            <span class="n">ReportSize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ReportCount</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
            <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span>
                  <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

        <span class="n">EndCollection</span><span class="p">,</span>
    <span class="n">EndCollection</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The packed custom report structure that is sent to the host to match the</span>
<span class="c1">// report descriptor defined above.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">i16XPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16YPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16RXPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16RYPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">ui16Buttons</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">PACKED</span> <span class="n">tCustomReport</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hid-sensor-device-class-api">
<h2>HID Sensor Device Class API<a class="headerlink" href="#hid-sensor-device-class-api" title="Permalink to this headline">¶</a></h2>
<p>The HID Sensor Device Class API provides an interface for applications to provide USB sensor support to a USB host. Since there are many types of Sensors, the included example represents a Temperature Sensor device. The temperature sensor sends information on its internal temperature, its event and its state. The temperature sensor is configured to allow the host to poll its IN endpoint at 1ms rate for the values. The Sensor device application calls the <code class="docutils literal notranslate"><span class="pre">USDHIDSensorSendReport()</span></code>function to send the data to its buffer.</p>
<div class="section" id="defining-a-hid-sensor-device">
<h3>Defining a HID Sensor Device<a class="headerlink" href="#defining-a-hid-sensor-device" title="Permalink to this headline">¶</a></h3>
<p>In order to properly configure an application to function as a HID Sensor device, there are a few structures that the application must properly declare and pass to the USB library. These include declaring the strings that are passed back to the USB host, the basic configuration of the device and an optional report descriptor to customize the data that is sent back to the USB host.</p>
<p>The following header files are needed to properly define all of the structures needed to implement a USB sensor device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usblib.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/usbhid.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdevice.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhid.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;ti/usblib/msp432e4/device/usbdhidsensor.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The application must first define the string table that is used to describe various features of the device to the host system. A detailed description of how to declare a string table is found in the using_the_hid_device section of this document. This table must include a minimum of 6 entries with the following meanings: languages available, manufacturer name, product description, serial number, HID interface description, and a configuration description.</p>
<p>The application must also provide a sensor event handler function. This function responds to the <strong>USB_EVENTS</strong>_ parameter passed to the application when events occur. The HID sensor device API sends the following events to the application callback function:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong> - USB connection event occurred.</p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong> - USB disconnect event occurred.</p></li>
<li><p><strong>USB_EVENT_TX_COMPLETE</strong> - A previously scheduled transmit request completed.</p></li>
<li><p><strong>USB_EVENT_ERROR</strong> - An error prevented the call from completing successfully.</p></li>
<li><p><strong>USB_EVENT_SUSPEND</strong> - A USB suspend event occurred.</p></li>
<li><p><strong>USB_EVENT_RESUME</strong> - A USB resume event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_RESUME</strong> - A USB LPM resume event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_SLEEP</strong> - A USB LPM sleep event occurred.</p></li>
<li><p><strong>USB_EVENT_LPM_ERROR</strong> - A USB LPM error occurred.</p></li>
</ul>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not reported to the application if the MCU’s USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode using the <code class="docutils literal notranslate"><span class="pre">USBStackModeSet()</span></code> function.</p>
<p>The string table and event handler function are used in the final required structure to complete the definition of the USB sensor device to the host. The application must define a <code class="docutils literal notranslate"><span class="pre">tUSBDHIDSensorDevice</span></code> structure and initialize all fields so that the USB library can enumerate the device to the host.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDHIDSensorDevice</span> <span class="n">g_sSensorDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// The Vendor ID assigned by USB-IF.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_YOUR_VENDOR_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Product ID assigned to this device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_PRODUCT_ID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The power consumption of the device in milliamps.</span>
    <span class="c1">//</span>
    <span class="n">POWER_CONSUMPTION_MA</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This value is passed to the host in the USB configuration descriptor&#39;s</span>
    <span class="c1">// bmAttributes field.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the sensor callback event handler.</span>
    <span class="c1">//</span>
    <span class="n">YourSensorHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A value that the application passes to the sensor callback function.</span>
    <span class="c1">//</span>
    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sYourInstanceData</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A pointer to the string table for the device.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The number of entries in your string table, which must equal</span>
    <span class="c1">// (1 + (5 * (number of languages))).</span>
    <span class="c1">//</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>


<span class="p">};</span>
</pre></div>
</div>
<p>Finally, to initialize a single sensor device, the application must call the HID sensor device API initialization function, <code class="docutils literal notranslate"><span class="pre">USBDHIDSensorInit()</span></code>, to configure the USB controller and prepare the device to be connected to the host. Assuming the <code class="docutils literal notranslate"><span class="pre">psSensor</span></code> returned is not NULL, the sensor device is now ready to communicate with a USB host.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Initialize a sensor HID instance.</span>
<span class="c1">//</span>
<span class="n">psSensor</span> <span class="o">=</span> <span class="n">USBDHIDSensorInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sSensorDevice</span><span class="p">);</span>
</pre></div>
</div>
<p>Once the host connects, your sensor event handler is sent the <strong>USB_EVENT_CONNECTED</strong> event after which calls can be made to <code class="docutils literal notranslate"><span class="pre">USBDHIDSensorSendReport()</span></code> to provide up-to-date information from the application to the USB host. After a successful call to <code class="docutils literal notranslate"><span class="pre">USBDHIDSensorSendReport()</span></code>, the application must wait for a <strong>USB_EVENT_TX_COMPLETE</strong> event before sending more data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">tGamepadReport</span> <span class="n">sReport</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Send a sensor HID report.</span>
<span class="c1">//</span>
<span class="n">USBDHIDSensorSendReport</span><span class="p">(</span><span class="n">psSensor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sReport</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sReport</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-a-sensor-hid-report">
<h3>Defining a Sensor HID Report<a class="headerlink" href="#defining-a-sensor-hid-report" title="Permalink to this headline">¶</a></h3>
<p>This section handles some of the considerations when defining an application-supplied report descriptor. HID report descriptors are infinitely configurable and can be confusing to define properly, so a good understanding of the USB HID specification is required. The USB HID class supported by the USB library is based on the USB HID 1.11 specification available from usb.org, which should be reviewed before attempting to declare a report descriptor. The definition of the structure is as similiar as possible to the USB specification to make it as easy as possible to properly define a structure similar to the USB specification.</p>
<p>The example below defines a Temperature sensor device which sends to the host sensor temperature, sensor state and sensor event as part of an Input report. Sensor temperature is defined as a 16-bit value while both sensor state and event are defined as two 8 bit values. These values are defined in the structure <code class="docutils literal notranslate"><span class="pre">tSensorTemperatureReport())</span></code></p>
<div class="line-block">
<div class="line"><strong>Note:</strong> The out-of-the-box HID Sensor example is set to run as a Generic HID device when UsagePage(Vendor Defined) was specified in the report descriptor. This setting allows for the HidDemo tool to communicate with the device on both Windows 7 and Windows 10.</div>
<div class="line">In order for Windows 10 to see the device as a ‘Sensor’ device, UsagePage(USB_HDI_SENSOR) needs to be defined instead of UsagePage(Vendor Defined). When Windows 10 identifies the device as a ‘Sensor’ a custom HID tool will need to be created for communicating with the Sensor device.</div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The following is the HID report structure definition that is passed back</span>
<span class="c1">// to the host.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SensorReportDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
     <span class="c1">//UsagePage(USB_HID_SENSOR),               // uncomment this line and comment</span>
                                                <span class="c1">// the vendor defined usage page to</span>
                                                <span class="c1">// identify the device as a sensor</span>
                                                <span class="c1">// in Windows 10.</span>

     <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>                          <span class="c1">//UsagePage(Vendor Defined)</span>
     <span class="n">Usage</span><span class="p">(</span><span class="n">USB_HID_ENVIRONMENTAL_TEMPERATURE</span><span class="p">),</span>
     <span class="n">Collection</span><span class="p">(</span><span class="n">USB_HID_PHYSICAL</span><span class="p">),</span>
<span class="c1">//     0x85, 0x01,    // Report ID (Vendor Defined)</span>

     <span class="n">UsagePage</span><span class="p">(</span><span class="n">USB_HID_SENSOR</span><span class="p">),</span>
     <span class="n">HidUsageSensorPropertyReportingState</span><span class="p">,</span>           <span class="c1">//HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">Feature</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ARRAY</span> <span class="o">|</span><span class="n">USB_HID_INPUT_ABS</span> <span class="p">),</span>   <span class="c1">//Data_Arr_Abs</span>

     <span class="n">HidUsageSensorPropertySensorStatus</span><span class="p">,</span>                            <span class="c1">//HID_USAGE_SENSOR_PROPERTY_SENSOR_STATUS,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMaximum32</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">Feature</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>   <span class="c1">// Data_Var_Abs up to VT_UI4 worth of status info</span>

     <span class="n">HidUsageSensorPropertyReportInterval</span><span class="p">,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMaximum32</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">UnitExponent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">Feature</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

     <span class="mh">0x0A</span><span class="p">,</span><span class="mh">0x0F</span><span class="p">,</span><span class="mh">0x03</span><span class="p">,</span>                            <span class="c1">//HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_ABS,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMinimum16</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">UnitExponent</span><span class="p">(</span><span class="mh">0x0E</span><span class="p">),</span> <span class="c1">// scale default unit “Celsius” to provide 2 digits past the decimal point</span>
     <span class="n">Feature</span><span class="p">(</span><span class="n">USB_HID_INPUT_DATA</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>    <span class="c1">//Data_Var_Abs</span>

     <span class="c1">//UsagePage(USB_HID_SENSOR),                //uncomment this line and comment</span>
                                                 <span class="c1">// the vendor defined usage page to</span>
                                                 <span class="c1">// identify the device as a sensor</span>
                                                 <span class="c1">// in Windows 10.</span>
     <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>                           <span class="c1">//UsagePage(Vendor Defined)</span>
     <span class="n">HidUsageSensorState</span><span class="p">,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ARRAY</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

     <span class="n">HidUsageSensorEvent</span><span class="p">,</span>
     <span class="n">LogicalMinimum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
     <span class="n">LogicalMaximum</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ARRAY</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>

     <span class="n">HidUsageSensorDataEnvironmentalTemperature</span><span class="p">,</span>
     <span class="n">LogicalMinimum16</span><span class="p">(</span><span class="mo">01</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">),</span>  <span class="c1">// LOGICAL_MINIMUM (-32767)</span>
     <span class="n">LogicalMaximum16</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0x7F</span><span class="p">),</span>   <span class="c1">// LOGICAL_MAXIMUM (32767)</span>
     <span class="n">ReportSize</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
     <span class="n">ReportCount</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">UnitExponent</span><span class="p">(</span><span class="mh">0x0E</span><span class="p">),</span>  <span class="c1">// scale default unit “Celsius” to provide 2 digits past the decimal point</span>
     <span class="n">Input</span><span class="p">(</span><span class="n">USB_HID_INPUT_CONSTANT</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_VARIABLE</span> <span class="o">|</span> <span class="n">USB_HID_INPUT_ABS</span><span class="p">),</span>
     <span class="n">EndCollection</span>


<span class="p">};</span>


<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The packed custom report structure that is sent to the host to match the</span>
<span class="c1">// report descriptor defined above.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">i16XPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16YPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16RXPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">i16RYPos</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">ui16Buttons</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">PACKED</span> <span class="n">tCustomReport</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mass-storage-device-class-api">
<h2>Mass Storage Device Class API<a class="headerlink" href="#mass-storage-device-class-api" title="Permalink to this headline">¶</a></h2>
<p>The USB mass storage device class allows an application to act as a physical storage device for use by another USB application or for a host operating system. Because the type of storage can vary per application, the mass storage class abstracts the storage with a set of block based APIs that are provided by the application to the USB library. These APIs allow the USB mass storage class to call an external set of functions that actually perform the operations on the physical storage media. The storage APIs are given to the USB library’s mass storage device class initialization function and are called by the USB library whenever it needs to access the physical media. The mass storage class implementation does not require any run time calls once it is initialized. This is because all interaction with the mass storage class occur through the callback function that is provided to the USB library’s mass storage class interface. The callback function is used to notify the application when
the device is being read, written or has gone idle. Depending on the operating system and how it accesses the mass storage device, these callbacks may occur at a very rapid rate (once per block) or slower (once per file). The USB library’s mass storage class also provides an interface to inform the USB library when the media status has changed in case the physical media can be ejected. This is important for devices like SD cards that can be removed before the device is connected or even while the device is running.</p>
<p>Some care must be taken by the application if it wishes to share the media with the mass storage class. Proper access protection must be in place as the mass storage class may be using the media access functions during the USB interrupt.</p>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p>The USB library’s mass storage class provides a simple interface to initialize the mass storage class and pass it the needed functions to access a device without having any knowledge of the physical media. The <code class="docutils literal notranslate"><span class="pre">USBDMSCInit()</span></code> function is the only initialization required by the mass storage class and it uses the structure <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span></code> to hold all customizable values for the mass storage class.</p>
</div>
<div class="section" id="customization">
<h3>Customization<a class="headerlink" href="#customization" title="Permalink to this headline">¶</a></h3>
<p>The USB library’s mass storage class provides the ability to customize how the device is reported to the USB host controller in the <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span></code> structure. The members of this structure contain all of the customizable parameters.</p>
<div class="section" id="vid-and-pid">
<h4>VID and PID<a class="headerlink" href="#vid-and-pid" title="Permalink to this headline">¶</a></h4>
<p>The VID and PID values reported to the host controller are provided in the usVID and usPID members of the <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span></code> structure and should be valid for the application and unique for all vendors and devices. The mass storage device class also reports some class specific strings to the operating system which can be customized in the pucVendor, pucProduct, and pucVersion structure members. These strings may or may not be requested by the USB host controller, however they are required. The pucVendor member is an 8 byte character string for the Vendor, and should be exactly 8 bytes padded with spaces(for example: “TI “). The pucProduct member is a 16 character string that indicates the product type and it too should be padded out with spaces to 16 bytes(for example: “Mass Storage “). The last customizable mass storage string is contained in pucVersion member and is a character based version which should be a 4 bytes padded with spaces (for example: “1.00”).</p>
</div>
<div class="section" id="power-configuration">
<h4>Power Configuration<a class="headerlink" href="#power-configuration" title="Permalink to this headline">¶</a></h4>
<p>The power configuration for the mass storage class device is held in two of the <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span></code> members variables, <code class="docutils literal notranslate"><span class="pre">usMaxPowermA</span></code> and <code class="docutils literal notranslate"><span class="pre">ucPwrAttributes</span></code>. The <code class="docutils literal notranslate"><span class="pre">usMaxPowermA</span></code> variable holds the maximum power consumption for the device and is expressed in milliamps. The power configuration is held in the ucPwrAttributes member variable and indicates whether the device is self or bus powered. Valid values are <strong>USB_CONF_ATTR_SELF_PWR</strong> or <strong>USB_CONF_ATTR_BUS_PWR</strong>.</p>
</div>
<div class="section" id="device-strings">
<h4>Device Strings<a class="headerlink" href="#device-strings" title="Permalink to this headline">¶</a></h4>
<p>The remaining USB strings are contained in the <code class="docutils literal notranslate"><span class="pre">ppui8StringDescriptors</span></code> and are just like the strings that are used in every other device class in the USB library. The <code class="docutils literal notranslate"><span class="pre">ppui8StringDescriptors</span></code> is a pointer to the string descriptor array for this device. This array must contain the following string descriptor pointers in this order. Language descriptor, Manufacturer name string (language 1), Product name string (language 1), Serial number string (language 1), MSC Interface description string (language 1), Configuration description string (language 1). If the device is supporting more than 1 language, the descriptor block (except for string descriptor 0) must be repeated for each language defined in the language descriptor. The number of descriptors provided in the <code class="docutils literal notranslate"><span class="pre">ppui8StringDescriptors</span></code> array must be ((5 + (num MSC strings)) * (num languages)) + 1.</p>
</div>
<div class="section" id="media-access-functions">
<h4>Media Access Functions<a class="headerlink" href="#media-access-functions" title="Permalink to this headline">¶</a></h4>
<p>The media access functions are passed in to the USB mass storage device class in the sMediaFunctions member variable. This structure holds the access functions for the media used by this instance of the mass storage class device. All of the functions in this structure are required to be filled out with valid functions. These function is called by the USB mass storage device class whenever it needs to read or write the physical media an</p>
</div>
<div class="section" id="event-callbacks">
<h4>Event Callbacks<a class="headerlink" href="#event-callbacks" title="Permalink to this headline">¶</a></h4>
<p>In some cases the application may need to be informed when the state of the mass storage device has changed. The <code class="docutils literal notranslate"><span class="pre">pfnEventCallback</span></code> member of the <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span></code> structure provides event notification to applications for the following events: <strong>USBD_MSC_EVENT_IDLE</strong>, <strong>USBD_MSC_EVENT_READING</strong>, and <strong>USBD_MSC_WRITING</strong>. When the function of type <code class="docutils literal notranslate"><span class="pre">tUSBCallback</span></code> is called, only the first two parameters <code class="docutils literal notranslate"><span class="pre">pvCBData</span></code> and <code class="docutils literal notranslate"><span class="pre">ui32Event</span></code> parameters are valid. The <code class="docutils literal notranslate"><span class="pre">pvCBData</span></code> is the value that was returned when the application called USBDMSCInit() and can be used with other APIs. The ui32Event parameter is one of the __USBD_MSC_EVENT_*__ values.</p>
</div>
</div>
<div class="section" id="using-the-mass-storage-device-class">
<h3>Using the Mass Storage Device Class<a class="headerlink" href="#using-the-mass-storage-device-class" title="Permalink to this headline">¶</a></h3>
<p>The following sections has some coding examples for the initialization of the mass storage class structures as well as how to call the initialization function itself.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBDMSCDevice</span> <span class="n">g_sMSCDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Vendor ID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Product ID.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_MSC</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Vendor Information.</span>
    <span class="c1">//</span>
    <span class="s">&quot;TI      &quot;</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Product Identification.</span>
    <span class="c1">//</span>
    <span class="s">&quot;Mass Storage    &quot;</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Revision.</span>
    <span class="c1">//</span>
    <span class="s">&quot;1.00&quot;</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// 500mA.</span>
    <span class="mi">500</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus Powered.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// A list of string descriptors and the number of descriptors.</span>
    <span class="c1">//</span>
    <span class="n">g_pStringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The media access functions.</span>
    <span class="c1">//</span>
    <span class="p">{</span>
        <span class="n">USBDMSCStorageOpen</span><span class="p">,</span>
        <span class="n">USBDMSCStorageClose</span><span class="p">,</span>
        <span class="n">USBDMSCStorageRead</span><span class="p">,</span>
        <span class="n">USBDMSCStorageWrite</span><span class="p">,</span>
        <span class="n">USBDMSCStorageNumBlocks</span>
    <span class="p">},</span>

    <span class="c1">//</span>
    <span class="c1">// The event notification call back function.</span>
    <span class="c1">//</span>
    <span class="n">USBMSCDEventCallback</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The initialization and configuration calls for the USB library’s mass storage device class are handled by a single call that passes in the <code class="docutils literal notranslate"><span class="pre">tUSBDMSCDevice</span> <span class="pre">structure</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Pass our device information to the USB library and place the device</span>
<span class="c1">// on the bus.</span>
<span class="c1">//</span>
<span class="n">USBDMSCInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">tUSBDMSCDevice</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sMSCDevice</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Drop into the main loop.</span>
<span class="c1">//</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The application’s event call back function provides the application with notifications of changes in the USB mass storage class. The application can use this information to update it’s own state. The events may occur in rapid succession and the application must be careful not to spend much time in this function as it is called from a interrupt handler. The application should expect many calls to this function during USB transfers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span>
<span class="nf">USBDMSCEventCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pvCBData</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
                     <span class="kt">uint32_t</span> <span class="n">ui32MsgParam</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">ui32Event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Writing to the device.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USBD_MSC_EVENT_WRITING</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">//  Handle write case.</span>
            <span class="c1">//</span>

            <span class="p">...</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// Reading from the device.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USBD_MSC_EVENT_READING</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">//  Handle read case.</span>
            <span class="c1">//</span>

            <span class="p">...</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBD_MSC_EVENT_IDLE</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">//  Handle idle case.</span>
            <span class="c1">//</span>

            <span class="p">...</span>

        <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-composite-mass-storage-device-class">
<h3>Using the Composite Mass Storage Device Class<a class="headerlink" href="#using-the-composite-mass-storage-device-class" title="Permalink to this headline">¶</a></h3>
<p>When using the mass storage device class in a composite device, the configuration of the device is very similar to how it is configured as a non-composite device. Follow all of the configuration steps in the previous section with the exception of calling <code class="docutils literal notranslate"><span class="pre">USBDMSCCompositeInit()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">USBDMSCInit()</span></code>. This prepares an instance of the mass storage device class to be enumerated as part of a composite device. The return value from the <code class="docutils literal notranslate"><span class="pre">USBDMSCCompositeInit()</span></code> function should be placed in the pvInstance member of the <code class="docutils literal notranslate"><span class="pre">tCompositeEntry</span></code> structure for the mass storage device. The code example below provides an example of how to initialize some of the structures necessary to use the USB mass storage device class in a composite device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// These should be initialized with valid values for each class.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="n">tUSBDMSCDevice</span> <span class="n">g_sMSCDevice</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The array of composite device entries.</span>
<span class="c1">//</span>
<span class="n">tCompositeEntry</span> <span class="n">psCompEntries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Allocate the device data for the top level composite device class.</span>
<span class="c1">//</span>
<span class="n">tUSBDCompositeDevice</span> <span class="n">g_sCompDevice</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series VID.</span>
    <span class="c1">//</span>
    <span class="n">USB_VID_TI_1CBE</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Texas Intruments C-Series PID for composite serial device.</span>
    <span class="c1">//</span>
    <span class="n">USB_PID_YOUR_COMPOSITE_PID</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// This is in 2mA increments so 500mA.</span>
    <span class="c1">//</span>
    <span class="mi">250</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Bus powered device.</span>
    <span class="c1">//</span>
    <span class="n">USB_CONF_ATTR_BUS_PWR</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// Composite event handler.</span>
    <span class="c1">//</span>
    <span class="n">EventHandler</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The string table.</span>
    <span class="c1">//</span>
    <span class="n">g_pui8StringDescriptors</span><span class="p">,</span>
    <span class="n">NUM_STRING_DESCRIPTORS</span><span class="p">,</span>

    <span class="c1">//</span>
    <span class="c1">// The Composite device array.</span>
    <span class="c1">//</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">g_psCompEntries</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// The OTHER_SIZES here are the sizes of the descriptor data for other classes</span>
<span class="c1">// that are part of the composite device.</span>
<span class="c1">//</span>
<span class="cp">#define DESCRIPTOR_DATA_SIZE    (COMPOSITE_DMSC_SIZE + OTHER_SIZES)</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8DescriptorData</span><span class="p">[</span><span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// Save the instance data for this mass storage device.</span>
<span class="c1">//</span>
<span class="n">pvAudioDevice</span> <span class="o">=</span> <span class="n">USBDMSCCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sMSCDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psCompEntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB controller as a composite device.</span>
<span class="c1">//</span>
<span class="n">USBDCompositeInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sCompDevice</span><span class="p">,</span> <span class="n">DESCRIPTOR_DATA_SIZE</span><span class="p">,</span>
                  <span class="n">g_pui8DescriptorData</span><span class="p">);</span>
</pre></div>
</div>
<p>All other API calls to the USB mass storage device class should use the value returned by <code class="docutils literal notranslate"><span class="pre">USBDAudioCompositeInit()</span></code> when the API calls for a pvInstance pointer. Also when using the audio device in a composite device the <strong>COMPOSITE_DMSC_SIZE</strong> value should be added to the size of the <code class="docutils literal notranslate"><span class="pre">g_pui8DescriptorData</span></code> array as shown in the example above.</p>
</div>
</div>
<div class="section" id="using-the-usb-device-api">
<h2>Using the USB Device API<a class="headerlink" href="#using-the-usb-device-api" title="Permalink to this headline">¶</a></h2>
<p>If an existing USB Device Class Driver is not suitable for your application, you may choose to develop your device using the lower-level USB Device API instead. This offers greater flexibility but involves somewhat more work. Creating a device application using the USB Device API involves several steps:</p>
<ul class="simple">
<li><p>Build device, configuration, interface and endpoint descriptor structures to describe your device.</p></li>
<li><p>Write handlers for each of the USB events your device is interested in receiving from the USB library.</p></li>
<li><p>Call the USB Device API to connect the device to the bus and manage standard host interaction on your behalf.</p></li>
</ul>
<p>The following sections walk through each of these steps offering code examples to illustrate the process. Working examples illustrating use of the library can also be found in the DriverLib release for your USB-capable evaluation kit.</p>
<p>The term “device code” used in the following sections describes all class specific code written above the USB Device API to implement a particular USB device application. This may be either application code or a USB device class driver.</p>
<div class="section" id="building-descriptors">
<h3>Building Descriptors<a class="headerlink" href="#building-descriptors" title="Permalink to this headline">¶</a></h3>
<p>The USB Device API manages all standard USB descriptors on behalf of the device. These descriptors are provided to the library via four fields in the <code class="docutils literal notranslate"><span class="pre">tDeviceInfo</span></code> structure which is passed on a call to <code class="docutils literal notranslate"><span class="pre">USBDCDInit()</span></code>. The relevant fields are:</p>
<ul class="simple">
<li><p>psDeviceDescriptor</p></li>
<li><p>ppui8ConfigDescriptors</p></li>
<li><p>ppui8StringDescriptors</p></li>
<li><p>ui32NumStringDescriptors</p></li>
</ul>
<p>All descriptors are provided as pointers to arrays of uint8_tacters where the contents of the individual descriptor arrays are USB 2.0-compliant descriptors of the appropriate type. For examples of particular descriptors, see the main source files for each of the USB device class drivers (for example <code class="docutils literal notranslate"><span class="pre">device/usbdbulk.c</span></code> for the generic bulk device class driver) or the file <code class="docutils literal notranslate"><span class="pre">usbdescriptors.c</span></code> in the <code class="docutils literal notranslate"><span class="pre">qs-scope</span></code> example application.</p>
<div class="section" id="tdeviceinfo-pdevicedescriptor">
<h4>tDeviceInfo.pDeviceDescriptor<a class="headerlink" href="#tdeviceinfo-pdevicedescriptor" title="Permalink to this headline">¶</a></h4>
<p>This array must hold the device descriptor that the USB Device API returns to the host in response to a GET_DESCRIPTOR(DEVICE) request. The following example contains the device descriptor provided by a USB HID keyboard device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8DeviceDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">18</span><span class="p">,</span>                         <span class="c1">// Size of this structure.</span>
    <span class="n">USB_DTYPE_DEVICE</span><span class="p">,</span>           <span class="c1">// Type of this structure.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="mh">0x200</span><span class="p">),</span>            <span class="c1">// USB version 2.0.</span>
    <span class="n">USB_CLASS_DEVICE</span><span class="p">,</span>           <span class="c1">// USB Device Class.</span>
    <span class="mi">0</span><span class="p">,</span>                          <span class="c1">// USB Device Sub-class.</span>
    <span class="n">USB_HID_PROTOCOL_NONE</span><span class="p">,</span>      <span class="c1">// USB Device protocol.</span>
    <span class="mi">64</span><span class="p">,</span>                         <span class="c1">// Maximum packet size for default pipe.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_VID_TI_1CBE</span><span class="p">),</span> <span class="c1">// Vendor ID (VID).</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_PID_KEYBOARD</span><span class="p">),</span> <span class="c1">// Product ID (PID).</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="mh">0x100</span><span class="p">),</span>            <span class="c1">// Device Version BCD.</span>
    <span class="mi">1</span><span class="p">,</span>                          <span class="c1">// Manufacturer string identifier.</span>
    <span class="mi">2</span><span class="p">,</span>                          <span class="c1">// Product string identifier.</span>
    <span class="mi">3</span><span class="p">,</span>                          <span class="c1">// Product serial number.</span>
    <span class="mi">1</span>                           <span class="c1">// Number of configurations.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Header file <code class="docutils literal notranslate"><span class="pre">usblib.h</span></code> contains macros and labels to help in the construction of descriptors and individual device class header files, such as <code class="docutils literal notranslate"><span class="pre">usbhid.h</span></code> and <code class="docutils literal notranslate"><span class="pre">device/usbdhid.h</span></code> for the Human Interface Device class, provide class specific values and labels.</p>
</div>
<div class="section" id="tdeviceinfo-ppui8configdescriptors">
<h4>tDeviceInfo.ppui8ConfigDescriptors<a class="headerlink" href="#tdeviceinfo-ppui8configdescriptors" title="Permalink to this headline">¶</a></h4>
<p>While only a single device descriptor is required, multiple configuration descriptors may be offered so the <code class="docutils literal notranslate"><span class="pre">ppui8ConfigDescriptors</span></code> field is an array of pointers to <code class="docutils literal notranslate"><span class="pre">tConfigHeader</span></code> structures, each defining the descriptor for a single configuration. The number of entries in this array must agree with the number of configurations specified in the final byte of the device descriptor provided in the <code class="docutils literal notranslate"><span class="pre">psDeviceDescriptor</span></code> field.</p>
<p>To allow flexibility when defining composite devices, individual configuration descriptors are also defined in terms of an array of structures. In this case, the <code class="docutils literal notranslate"><span class="pre">tConfigHeader</span></code> structure contains a count and a pointer to an array of <code class="docutils literal notranslate"><span class="pre">tConfigSection</span></code> structures each of which contains a pointer to a block of bytes and a size indicating the number of bytes in the section. The sections described in this array are concatenated to generate the full config descriptor published to the host.</p>
<p>Config descriptors are somewhat more complex than device descriptors due to the amount of additional information passed alongside the basic configuration descriptor. In addition to USB 2.0 standard descriptors for the configuration, interfaces and endpoints in use, additional, class specific, descriptors may also be included.</p>
<p>The USB Device API imposes one restriction on configuration descriptors that devices must be aware of. While the USB 2.0 specification does not restrict the values that can be specified in the <code class="docutils literal notranslate"><span class="pre">bConfigurationValue</span></code> field (byte 6) of the configuration descriptor, the USB Device API requires that individual configurations are numbered consecutively starting at 1 for the first configuration.</p>
<p>The following example contains the configuration descriptor structures provided for a USB HID keyboard. This example offers a single configuration containing one interface and using a single interrupt endpoint. In this case, in addition to the standard portions of the descriptor, a Human Interface Device (HID) class descriptor is also included. Due to the use of a standard format for descriptor headers, the USB Device API is capable of safely skipping device specific descriptors when parsing these structures.</p>
<p>In this example, we illustrate the use of multiple sections to build the configuration descriptor. The content of the config descriptor given here is, however, static so it could easily have been defined in terms of a single <code class="docutils literal notranslate"><span class="pre">tConfigSection</span></code> entry instead. The label <code class="docutils literal notranslate"><span class="pre">g_pucReportDescriptor</span></code> is assumed to be a pointer to a HID-specific report descriptor for the keyboard.</p>
<p>Note that the value used to initialize the <code class="docutils literal notranslate"><span class="pre">wTotalLength</span></code> field of the configuration descriptor is irrelevant since the USB library calculates this based on the content of the sections that are concatenated to build the final descriptor.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// HID keyboard device configuration descriptor.</span>
<span class="c1">//</span>
<span class="c1">// It is vital that the configuration descriptor bConfigurationValue field</span>
<span class="c1">// (byte 6) is 1 for the first configuration and increments by 1 for each</span>
<span class="c1">// additional configuration defined here.  This relationship is assumed in the</span>
<span class="c1">// device stack for simplicity even though the USB 2.0 specification imposes</span>
<span class="c1">// no such restriction on the bConfigurationValue values.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8KeyboardDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Configuration descriptor header.</span>
    <span class="c1">//</span>
    <span class="mi">9</span><span class="p">,</span>                          <span class="c1">// Size of the configuration descriptor.</span>
    <span class="n">USB_DTYPE_CONFIGURATION</span><span class="p">,</span>    <span class="c1">// Type of this descriptor.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="mi">34</span><span class="p">),</span>               <span class="c1">// The total size of this full structure</span>
                                <span class="c1">// (Value is patched by the USB library so is</span>
                                <span class="c1">// not important here)</span>
    <span class="mi">1</span><span class="p">,</span>                          <span class="c1">// The number of interfaces in this</span>
                                <span class="c1">// configuration.</span>
    <span class="mi">1</span><span class="p">,</span>                          <span class="c1">// The unique value for this configuration.</span>
    <span class="mi">5</span><span class="p">,</span>                          <span class="c1">// The string identifier that describes this</span>
                                <span class="c1">// configuration.</span>
    <span class="n">USB_CONF_ATTR_SELF_PWR</span><span class="p">,</span>     <span class="c1">// Bus Powered, Self Powered, remote wakeup.</span>
    <span class="mi">125</span><span class="p">,</span>                        <span class="c1">// The maximum power in 2mA increments.</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The interface and HID descriptors for the keyboard device.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8HIDInterface</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// HID Device Class Interface Descriptor.</span>
    <span class="c1">//</span>
    <span class="mi">9</span><span class="p">,</span>                          <span class="c1">// Size of the interface descriptor.</span>
    <span class="n">USB_DTYPE_INTERFACE</span><span class="p">,</span>        <span class="c1">// Type of this descriptor.</span>
    <span class="mi">0</span><span class="p">,</span>                          <span class="c1">// The index for this interface.</span>
    <span class="mi">0</span><span class="p">,</span>                          <span class="c1">// The alternate setting for this interface.</span>
    <span class="mi">1</span><span class="p">,</span>                          <span class="c1">// The number of endpoints used by this</span>
                                <span class="c1">// interface.</span>
    <span class="n">USB_CLASS_HID</span><span class="p">,</span>              <span class="c1">// The interface class</span>
    <span class="n">USB_HID_SCLASS_BOOT</span><span class="p">,</span>        <span class="c1">// The interface sub-class.</span>
    <span class="n">USB_HID_PROTOCOL_KEYB</span><span class="p">,</span>      <span class="c1">// The interface protocol for the sub-class</span>
                                <span class="c1">// specified above.</span>
    <span class="mi">4</span><span class="p">,</span>                          <span class="c1">// The string index for this interface.</span>

    <span class="c1">//</span>
    <span class="c1">// HID Descriptor.</span>
    <span class="c1">//</span>
    <span class="mi">9</span><span class="p">,</span>                          <span class="c1">// Size of this HID descriptor.</span>
    <span class="n">USB_HID_DTYPE_HID</span><span class="p">,</span>          <span class="c1">// HID descriptor type.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="mh">0x101</span><span class="p">),</span>            <span class="c1">// Version is 1.1.</span>
    <span class="mi">0</span><span class="p">,</span>                          <span class="c1">// Country code is not specified.</span>
    <span class="mi">1</span><span class="p">,</span>                          <span class="c1">// Number of descriptors.</span>
    <span class="n">USB_HID_DTYPE_REPORT</span><span class="p">,</span>       <span class="c1">// Type of this descriptor.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">g_pucReportDescriptor</span><span class="p">)),</span>
                                <span class="c1">// Length of the Descriptor.</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The interrupt IN endpoint descriptor for the HID keyboard.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8HIDInEndpoint</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Interrupt IN endpoint descriptor</span>
    <span class="c1">//</span>
    <span class="mi">7</span><span class="p">,</span>                               <span class="c1">// The size of the endpoint descriptor.</span>
    <span class="n">USB_DTYPE_ENDPOINT</span><span class="p">,</span>              <span class="c1">// Descriptor type is an endpoint.</span>
    <span class="n">USB_EP_DESC_IN</span> <span class="o">|</span> <span class="n">USB_EP_TO_INDEX</span><span class="p">(</span><span class="n">INT_IN_ENDPOINT</span><span class="p">),</span>
    <span class="n">USB_EP_ATTR_INT</span><span class="p">,</span>                 <span class="c1">// Endpoint is an interrupt endpoint.</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">INT_IN_EP_MAX_SIZE</span><span class="p">),</span>    <span class="c1">// The maximum packet size.</span>
    <span class="mi">16</span><span class="p">,</span>                              <span class="c1">// The polling interval for this endpoint.</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The HID keyboard config descriptor is defined using three sections:</span>
<span class="c1">//</span>
<span class="c1">// 1. The 9 byte configuration descriptor.</span>
<span class="c1">// 2. The interface and HID report descriptors.</span>
<span class="c1">// 4. The mandatory interrupt IN endpoint descriptor (FLASH).</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="n">tConfigSection</span> <span class="n">g_sKeyboardConfigSection</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_pKeyboardDescriptor</span><span class="p">),</span>
    <span class="n">g_pKeyboardDescriptor</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">tConfigSection</span> <span class="n">g_sHIDInterfaceSection</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_pHIDInterface</span><span class="p">),</span>
    <span class="n">g_pHIDInterface</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">tConfigSection</span> <span class="n">g_sHIDInEndpointSection</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_pHIDInEndpoint</span><span class="p">),</span>
    <span class="n">g_pHIDInEndpoint</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// This array lists all the sections that must be concatenated to make a</span>
<span class="c1">// single, complete HID keyboard configuration descriptor.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="n">tConfigSection</span> <span class="o">*</span><span class="n">g_psKeyboardSections</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">g_sKeyboardConfigSection</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sHIDInterfaceSection</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sHIDInEndpointSection</span>
<span class="p">};</span>

<span class="cp">#define NUM_KEYBOARD_SECTIONS (sizeof(g_psKeyboardSections) /                 \</span>
<span class="cp">                               sizeof(tConfigSection *))</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The header for the single configuration we support. This is the root of</span>
<span class="c1">// the data structure that defines all the bits and pieces that are pulled</span>
<span class="c1">// together to generate the HID keyboard&#39;s config descriptor.  A pointer to</span>
<span class="c1">// this structure is used to initialize the ppui8ConfigDescriptors field of</span>
<span class="c1">// the tDeviceInfo structure passed to USBDCDInit().</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">const</span> <span class="n">tConfigHeader</span> <span class="n">g_sKeyboardConfigHeader</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">NUM_KEYBOARD_SECTIONS</span><span class="p">,</span>
    <span class="n">g_psKeyboardSections</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="tdeviceinfo-ppui8stringdescriptors-and-tdeviceinfo-ui32numstringdescriptors">
<h4>tDeviceInfo.ppui8StringDescriptors and tDeviceInfo.ui32NumStringDescriptors<a class="headerlink" href="#tdeviceinfo-ppui8stringdescriptors-and-tdeviceinfo-ui32numstringdescriptors" title="Permalink to this headline">¶</a></h4>
<p>Descriptive strings referenced by device and configuration descriptors are provided to the USB Device API as an array of string descriptors containing the basic descriptor length and type header followed by a Unicode string. The various string identifiers passed in other descriptors are indexes into the <code class="docutils literal notranslate"><span class="pre">pStringDescriptor</span></code> array. The first entry of the string descriptor array has a special format and indicates the languages supported by the device.</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">ui32NumStringDescriptors</span></code> indicates the number of individual string descriptors in the <code class="docutils literal notranslate"><span class="pre">ppui8StringDescriptors</span></code> array.</p>
<p>The string descriptor array provided to the USB Device API for a USB HID keyboard follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The languages supported by this device.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8LangDescriptor</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">4</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="n">USBShort</span><span class="p">(</span><span class="n">USB_LANG_EN_US</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The manufacturer string.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ManufacturerString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The product string.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8ProductString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;K&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="sc">&#39;E&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The serial number string.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">g_pui8SerialNumberString</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">USB_DTYPE_STRING</span><span class="p">,</span>
    <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="c1">//****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The array of string descriptors needed by the enumeration code.</span>
<span class="c1">//</span>
<span class="c1">//****************************************************************************</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppui8StringDescriptors</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">g_pui8LangDescriptor</span><span class="p">,</span>
    <span class="n">g_pui8ManufacturerString</span><span class="p">,</span>
    <span class="n">g_pui8ProductString</span><span class="p">,</span>
    <span class="n">g_pui8SerialNumberString</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">ppui8StringDescriptors</span></code> member of the <code class="docutils literal notranslate"><span class="pre">tDeviceInfo</span></code> structure would be initialized with the value <code class="docutils literal notranslate"><span class="pre">g_ppui8StringDescriptors</span></code> and the <code class="docutils literal notranslate"><span class="pre">ui32NumStringDescriptors</span></code> member would be set to the number of elements in the <code class="docutils literal notranslate"><span class="pre">g_ppui8StringDescriptors</span></code> array.</p>
</div>
</div>
<div class="section" id="usb-event-handlers">
<h3>USB Event Handlers<a class="headerlink" href="#usb-event-handlers" title="Permalink to this headline">¶</a></h3>
<p>The majority of the work in a USB device application is carried out either in the context of, or in response to callbacks from the USB Device API. These callback functions are made available to the USB Device API in the <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> field of the <code class="docutils literal notranslate"><span class="pre">tDeviceInfo</span></code> structure passed in a call to <code class="docutils literal notranslate"><span class="pre">USBDCDInit()</span></code>.</p>
<p>Field <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is a structure of type <code class="docutils literal notranslate"><span class="pre">tCustomHandlers</span></code> which contains a function pointer for each USB event. The application must populate the table with valid function pointers for each event that it wishes to be informed of. Setting any function pointer to NULL disables notification for that event.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tCustomHandlers</span></code> structure contains the following fields: * pfnGetDescriptor * pfnRequestHandler * pfnInterfaceChange * pfnConfigChange * pfnDataReceived * pfnDataSent * pfnResetHandler * pfnSuspendHandler * pfnResumeHandler * pfnDisconnectHandler * pfnEndpointHandler * pfnDeviceHandler</p>
<p>Note that all callbacks except the <code class="docutils literal notranslate"><span class="pre">pfnDeviceHandler</span></code> entry are made in interrupt context. It is, therefore, vital that handlers do not block or make calls to functions which cannot safely be made in an interrupt handler.</p>
<div class="section" id="pfngetdescriptor">
<h4>pfnGetDescriptor<a class="headerlink" href="#pfngetdescriptor" title="Permalink to this headline">¶</a></h4>
<p>Standard USB device, configuration and string descriptors are handled by the USB Device API internally but some device classes also define additional, class specific descriptors. In cases where the host requests one of these non-standard descriptors, this callback is made to give the device code an opportunity to provide its own descriptor to satisfy the request.</p>
<p>If the device can satisfy the request, it must call <code class="docutils literal notranslate"><span class="pre">USBDCDSendDataEP0()</span></code> to provide the requested descriptor data to the host. If the request cannot be satisfied, the device should call <code class="docutils literal notranslate"><span class="pre">USBDCDStallEP0()</span></code> to indicate that the descriptor request is not supported.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API stalls endpoint zero whenever it receives a request for a non-standard descriptor.</p>
</div>
<div class="section" id="pfnrequesthandler">
<h4>pfnRequestHandler<a class="headerlink" href="#pfnrequesthandler" title="Permalink to this headline">¶</a></h4>
<p>The USB Device API contains handlers for all standard USB requests (as defined in Table 9-3 of the USB 2.0 specification) where a standard request is indicated by bits 5 and 6 of the request structure <code class="docutils literal notranslate"><span class="pre">bmRequestType</span></code> field being clear. If a request is received with a non-standard request type, this callback is made to give the device code an opportunity to satisfy the request.</p>
<p>The callback function receives a pointer to a standard, 8 byte request structure of type <code class="docutils literal notranslate"><span class="pre">tUSBRequest</span></code> containing information on the request type, the request identifier and various request-specific parameters. The structure also contains a length field, <code class="docutils literal notranslate"><span class="pre">wLength</span></code>, which indicates how much (if any) data follows in the data stage of the USB transaction. Note that this data is not available at the time the callback is made and the device code is responsible for requesting it using a call to <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> if required.</p>
<p>The sequence required when additional data is attached to the request is as follows:</p>
<ul class="simple">
<li><p>Parse the request to determine the request type and verify that it is handled by the device. If not, call <code class="docutils literal notranslate"><span class="pre">USBDCDStallEP0()</span></code> to indicate the problem.</p></li>
<li><p>If the request is to be handled and <code class="docutils literal notranslate"><span class="pre">wLength</span></code> is non-zero, indicating that additional data is required, call <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> passing a pointer to the buffer into which the data is to be written and the number of bytes of data to receive.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">USBDevEndpointDataAck()</span></code> to acknowledge reception of the initial request transmission. This function is found in the Driver Library USB driver API.</p></li>
</ul>
<p>Note that it is important to call <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> prior to acknowledging the initial request since the acknowledgment frees the host to send the additional data. By making the calls in this order, the USB Device API is guaranteed to be in the correct state to receive the data when it arrives. Making the calls in the opposite order, creates a race condition which could result in loss of data.</p>
<p>Data received as a result of a call to <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> is delivered asynchronously via the <code class="docutils literal notranslate"><span class="pre">pfnDataReceived</span></code> callback described below.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API stalls endpoint zero whenever it receives a non-standard request.</p>
</div>
<div class="section" id="pfninterfacechange">
<h4>pfnInterfaceChange<a class="headerlink" href="#pfninterfacechange" title="Permalink to this headline">¶</a></h4>
<p>Based on the configuration descriptor published by the device code, several different alternate interface settings may be supported. In cases where the host wishes to change from the default interface configuration and the USB library determines that the requested alternate setting is supported, this callback is made to inform the device code of the change. The parameters passed provide the new alternate interface (<code class="docutils literal notranslate"><span class="pre">ucAlternateSetting</span></code> and the interface number (<code class="docutils literal notranslate"><span class="pre">ucInterfaceNum</span></code>).</p>
<p>This callback is only made once the USB Device API has validated the requested alternate setting. If the requested setting is not available in the published configuration descriptor, the USB Device API stalls endpoint zero to indicate the error to the host and make no callback to the device code.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API notes the interface change internally but not report it to the device code.</p>
</div>
<div class="section" id="pfnconfigchange">
<h4>pfnConfigChange<a class="headerlink" href="#pfnconfigchange" title="Permalink to this headline">¶</a></h4>
<p>When the host enumerates a device, it ultimately selects the configuration that is to be used and send a SET_CONFIGURATION request to the device. When this occurs, the USB Device API validates the configuration number passed against the device code’s published configuration descriptors then calls the <code class="docutils literal notranslate"><span class="pre">pfnConfigChange</span></code> callback to inform the device code of the configuration that is to be used.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API notes the configuration change internally but not report it to the device code.</p>
</div>
<div class="section" id="pfndatareceived">
<h4>pfnDataReceived<a class="headerlink" href="#pfndatareceived" title="Permalink to this headline">¶</a></h4>
<p>This callback informs the device code of the arrival of data following an earlier call to <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code>. On this callback, the received data has been written into the buffer provided to the USB Device API in the <code class="docutils literal notranslate"><span class="pre">pucData</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code>.</p>
<p>The callback handler does not need to acknowledge the data using a call to <code class="docutils literal notranslate"><span class="pre">USBDevEndpointDataAck()</span></code> in this case since this acknowledgment is performed within the USB Device API itself.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API reads endpoint zero data requested via <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> but not report its availability to the device code. Devices making use of the <code class="docutils literal notranslate"><span class="pre">USBDCDRequestDataEP0()</span></code> call must, therefore, ensure that they supply a <code class="docutils literal notranslate"><span class="pre">pfnDataReceived</span></code> handler.</p>
</div>
<div class="section" id="pfndatasent">
<h4>pfnDataSent<a class="headerlink" href="#pfndatasent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">USBDCDSendDataEP0()</span></code> function allows device code to send an arbitrarily-sized block of data to the host via endpoint zero. The maximum packet size that can be sent via endpoint zero is, however, 64 bytes so larger blocks of data are sent in multiple packets. This callback function is used by the USB Device API to inform the device code when all data provided in the buffer passed to <code class="docutils literal notranslate"><span class="pre">USBDCDSendDataEP0()</span></code> has been consumed and scheduled for transmission to the host. On reception of this callback, the device code is free to reuse the outgoing data buffer if required.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API does not inform the device code when a block of EP0 data is sent.</p>
</div>
<div class="section" id="pfnresethandler">
<h4>pfnResetHandler<a class="headerlink" href="#pfnresethandler" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">pfnResetHandler</span></code> callback is made by the USB Device API whenever a bus reset is detected. This typically occurs during enumeration. The device code may use this notification to perform any housekeeping required in preparation for a new configuration being set.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API does not inform the device code when a bus reset occurs.</p>
</div>
<div class="section" id="pfnsuspendhandler">
<h4>pfnSuspendHandler<a class="headerlink" href="#pfnsuspendhandler" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">pfnSuspendHandler</span></code> callback is made whenever the USB Device API detects that suspend has been signaled on the bus. Device code may make use of this notification to, for example, set appropriate power saving modes.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API does not inform the device code when a bus suspend occurs.</p>
</div>
<div class="section" id="pfnresumehandler">
<h4>pfnResumeHandler<a class="headerlink" href="#pfnresumehandler" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">pfnResumeHandler</span></code> callback is made whenever the USB Device API detects that resume has been signaled on the bus. Device code may make use of this notification to undo any changes made in response to an earlier call to the <code class="docutils literal notranslate"><span class="pre">pfnSuspendHandler</span></code> callback.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API does not inform the device code when a bus resume occurs.</p>
</div>
<div class="section" id="pfndisconnecthandler">
<h4>pfnDisconnectHandler<a class="headerlink" href="#pfndisconnecthandler" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">pfnDisconnectHandler</span></code> callback is made whenever the USB Device API detects that the device has been disconnected from the bus.</p>
<p>If this member of <code class="docutils literal notranslate"><span class="pre">sCallbacks</span></code> is set to NULL, the USB Device API does not inform the device code when a disconnection event occurs.</p>
<p><strong>Note:</strong> The <strong>USB_EVENT_DISCONNECTED</strong> event is not reported to the application if the MCU’s PB1/USB0VBUS pin is connected to a fixed +5 Volts rather than directly to the VBUS pin on the USB connector or if the USB controller is configured to force device mode.</p>
</div>
<div class="section" id="pfnendpointhandler">
<h4>pfnEndpointHandler<a class="headerlink" href="#pfnendpointhandler" title="Permalink to this headline">¶</a></h4>
<p>While the use of endpoint zero is standardized and supported via several of the other callbacks already listed (<code class="docutils literal notranslate"><span class="pre">pfnDataSent</span></code>, <code class="docutils literal notranslate"><span class="pre">pfnDataReceived</span></code>, <code class="docutils literal notranslate"><span class="pre">pfnGetDescriptor</span></code>, <code class="docutils literal notranslate"><span class="pre">pfnRequestHandler</span></code>, <code class="docutils literal notranslate"><span class="pre">pfnInterfaceChange</span></code> and <code class="docutils literal notranslate"><span class="pre">pfnConfigChange</span></code>), the use of other endpoints is entirely dependent upon the device class being implemented. The <code class="docutils literal notranslate"><span class="pre">pfnEndpointHandler</span></code> callback is, therefore, made to notify the device code of all activity on any endpoint other than endpoint zero and it is the device code’s responsibility to determine the correct action to take in response to each callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ulStatus</span></code> parameter passed to the handler provides information on the actual endpoint for which the callback is being made and allows the handler to determine if the event is due to transmission (if an IN endpoint event occurs) or reception (if an OUT endpoint event occurs) of data.</p>
<p>Having determined the endpoint sourcing the event, the device code can determine the actual event by calling <code class="docutils literal notranslate"><span class="pre">USBEndpointStatus()</span></code> for the appropriate endpoint then clear the status by calling <code class="docutils literal notranslate"><span class="pre">USBDevEndpointStatusClear()</span></code>.</p>
<p>When incoming data is indicated by the flag <strong>USB_DEV_RX_PKT_RDY</strong> being set in the endpoint status, data can be received using a call to <code class="docutils literal notranslate"><span class="pre">USBEndpointDataGet()</span></code> followed by a call to <code class="docutils literal notranslate"><span class="pre">USBDevEndpointDataAck()</span></code> to acknowledge the reception to the host.</p>
<p>When an event relating to an IN endpoint (data transmitted from the device to the host) is received, the status read from <code class="docutils literal notranslate"><span class="pre">USBEndpointStatus()</span></code> indicates any errors in transmission. If the value read is 0, this implies that the data was successfully transmitted and acknowledged by the host.</p>
<p>Any device whose configuration descriptor indicates that it uses any endpoint (endpoint zero use is assumed) must populate the <code class="docutils literal notranslate"><span class="pre">pfnEndpointHandler</span></code> member of <code class="docutils literal notranslate"><span class="pre">tCustomHandlers</span></code>.</p>
</div>
<div class="section" id="pfndevicehandler">
<h4>pfnDeviceHandler<a class="headerlink" href="#pfndevicehandler" title="Permalink to this headline">¶</a></h4>
<p>Unlike the other calling functions <code class="docutils literal notranslate"><span class="pre">pfnDeviceHandler</span></code> specifies a generic input handler to the device class. Callers of this function should check to insure that the class supports this entry by seeing if the <code class="docutils literal notranslate"><span class="pre">pfnDeviceHandler</span></code> is non-zero This call is provided to allow requests based on a given instance to be passed into a device. This is commonly used by a top level composite device that is using multiple instances of the same class.</p>
<p>USB device classes that need to support being part of a composite device must implement this function as the composite device class needs to call this function to inform the class of interface, endpoint, and string index changes. See the documentation on the <strong>USB_EVENT_COMP_IFACE_CHANGE</strong>, <strong>USB_EVENT_COMP_EP_CHANGE</strong>, and <strong>USB_EVENT_COMP_STR_CHANGE</strong>.</p>
</div>
</div>
<div class="section" id="interrupt-vector-selection">
<h3>Interrupt Vector Selection<a class="headerlink" href="#interrupt-vector-selection" title="Permalink to this headline">¶</a></h3>
<p>An application using the USB Device API should normally ensure that the interrupt vector for the hardware USB controller is set to call function <code class="docutils literal notranslate"><span class="pre">USB0DeviceIntHandler</span></code>.</p>
<p>If the target application is intended to allow switching between USB device and USB host mode, however, this handler should be replaced with <code class="docutils literal notranslate"><span class="pre">USB0DualModeIntHandler</span></code> to allow the USB library to perform appropriate interrupt steering depending upon the current mode of operation. Hybrid applications must also call <code class="docutils literal notranslate"><span class="pre">USBStackModeSet()</span></code> to indicate the mode they wish to operate in.</p>
</div>
<div class="section" id="passing-control-to-the-usb-device-api">
<h3>Passing Control to the USB Device API<a class="headerlink" href="#passing-control-to-the-usb-device-api" title="Permalink to this headline">¶</a></h3>
<p>When all previous setup steps have been completed, control can be passed to the USB Device API. The library enables the appropriate interrupts and connect the device to the bus in preparation for enumeration by the USB host. This operation is initiated using a call to <code class="docutils literal notranslate"><span class="pre">USBDCDInit()</span></code> passing the completed <code class="docutils literal notranslate"><span class="pre">tDeviceInfo</span></code> structure which describes the device.</p>
<p>Following this call, your device code callback functions is called when USB events specific to your device are detected by the library.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Pass the USB Device API our device information and connect the device to</span>
<span class="c1">// the bus.</span>
<span class="c1">//</span>
<span class="n">USBDCDInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_sMouseDeviceInfo</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="host_functions.html" class="btn btn-neutral float-right" title="Host Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../index.html" class="btn btn-neutral float-left" title="MSP432E4 USB Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>