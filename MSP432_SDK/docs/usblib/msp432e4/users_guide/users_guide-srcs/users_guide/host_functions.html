

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Host Functions &mdash; MSP432E4 USB Library 1.00.00.01 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="MSP432E4 USB Library" href="index.html" />
    <link rel="prev" title="Device Functions" href="device_functions.html" /> 
</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> MSP432E4 USB Library
          

          
          </a>

          
            
            
              <div class="version">
                1.00.00.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="device_functions.html">Device Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Host Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-structure">File Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#host-controller-driver">Host Controller Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#enumeration">Enumeration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usb-host-configurable-features">USB Host Configurable Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-pll-feature">USB Host PLL Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-system-clock-feature">USB Host System Clock Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-ulpi-feature">USB Host ULPI Feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-lpm-feature">USB HOST LPM Feature</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#usb-pipes">USB Pipes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-transactions">Control Transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interrupt-handling">Interrupt Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#host-class-driver">Host Class Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usb-events-driver">USB Events Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hub-class-driver">Hub Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hid-class-driver">HID Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mass-storage-class-driver">Mass Storage Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#audio-class-driver">Audio Class Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementing-custom-host-class-drivers">Implementing Custom Host Class Drivers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#host-device-interface">Host Device Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mouse-device">Mouse Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="#keyboard-device">Keyboard Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="#host-programming-examples">Host Programming Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#application-initialization">Application Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-interface">Application Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-termination">Application Termination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-application-setup">Example Application Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-hid-mouse-programming-example">Host HID Mouse Programming Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-hid-keyboard-programming-example">Host HID Keyboard Programming Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-mass-storage-programming-example">Host Mass Storage Programming Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-cdc-serial-programming-example">Host CDC Serial Programming Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">MSP432E4 USB Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_functions.html">Device Functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Host Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-structure">File Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-controller-driver">Host Controller Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enumeration">Enumeration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-configurable-features">USB Host Configurable Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-pipes">USB Pipes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-transactions">Control Transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-handling">Interrupt Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#host-class-driver">Host Class Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usb-events-driver">USB Events Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hub-class-driver">Hub Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hid-class-driver">HID Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mass-storage-class-driver">Mass Storage Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audio-class-driver">Audio Class Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-custom-host-class-drivers">Implementing Custom Host Class Drivers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#host-device-interface">Host Device Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mouse-device">Mouse Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#keyboard-device">Keyboard Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-programming-examples">Host Programming Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#application-initialization">Application Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-interface">Application Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-termination">Application Termination</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-application-setup">Example Application Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-hid-mouse-programming-example">Host HID Mouse Programming Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-hid-keyboard-programming-example">Host HID Keyboard Programming Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-mass-storage-programming-example">Host Mass Storage Programming Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-cdc-serial-programming-example">Host CDC Serial Programming Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="otg_functions.html">OTG Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="otg_functions.html">OTG Functions</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MSP432E4 USB Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Host Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="host-functions">
<h1>Host Functions<a class="headerlink" href="#host-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This chapter covers the support provided by the USB library for the USB controller in host mode. In order to simplify the application and the addition of new devices and device classes, the USB library provides a layered interface to the USB host controller. At the top layer of the USB library there are application interfaces that provide easy access to the various types of peripherals that are supported by the USB library. Below this layer are the USB host controller’s device interfaces that handle the specifics of each type of device and how to communicate with the USB host class driver. The USB host class drivers handle the basics of dealing with whole classes of devices like HID and Mass Storage Class devices. The USB host class driver layer communicates with the lowest level of the USB library which is the USB host controller driver. This lowest level directly accesses DriverLib functions to provide communications with the USB device that is connected. This communication is
provided by callbacks or direct APIs that is discussed in the rest of this chapter. Much like the USB library’s device programming interface, the host interface has the following layers:</p>
<ul class="simple">
<li><p>Device APIs (Mouse, Keyboard, Filesystem)</p></li>
<li><p>USB Class Driver APIs (HID, Mass Storage, Hub)</p></li>
<li><p>USB Host Controller APIs</p></li>
<li><p>DriverLib USB Driver APIs</p></li>
</ul>
<div class="figure align-default" id="id1">
<img alt="USB Host Block Diagram" src="../../_images/usb_host_block_diagram.png" />
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">USB Host Block Diagram</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="file-structure">
<h2>File Structure<a class="headerlink" href="#file-structure" title="Permalink to this headline">¶</a></h2>
<p>Source code and headers for the host specific USB functions can be found in the <code class="docutils literal notranslate"><span class="pre">host</span></code> directory of the USB library tree, typically <code class="docutils literal notranslate"><span class="pre">source/ti/usblib/msp432e4/host</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filename</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhost.h</span></code></p></td>
<td><p>The header file containing host mode function prototypes and data types offered by the USB library.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhostenum.c</span></code></p></td>
<td><p>The source code for the USB host enumeration functions offered by the library.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhaudio.c</span></code></p></td>
<td><p>The source code for the USB host Audio class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhaudio.h</span></code></p></td>
<td><p>The header file containing Audio class definitions specific to hosts supporting this class of device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhid.c</span></code></p></td>
<td><p>The source code for the USB host HID class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhid.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host HID class driver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhub.c</span></code></p></td>
<td><p>The source code for the USB host Hub class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhub.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host Hub class driver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhidkeyboard.c</span></code></p></td>
<td><p>The source code for the USB host HID class keyboard device.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhidkeyboard.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host HID class keyboard device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhidmouse.c</span></code></p></td>
<td><p>The source code for the USB host HID class mouse device.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhhidmouse.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host HID class mouse device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhmsc.c</span></code></p></td>
<td><p>The source code for the USB host Mass Storage class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhmsc.h</span></code></p></td>
<td><p>The header file containing Mass Storage class definitions specific to hosts supporting this class of device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhscsi.c</span></code></p></td>
<td><p>The source code for a high level SCSI interface which calls the host Mass Storage class driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhcdc.c</span></code></p></td>
<td><p>The source code for the USB host CDC class</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhcdc.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host CDC class</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">usbhcdcserial.c</span></code></p></td>
<td><p>The source code for the USB host CDC serial class</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">usbhcdcserial.h</span></code></p></td>
<td><p>The header file containing the definitions needed to interact with the USB host CDC serial device</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="host-controller-driver">
<h2>Host Controller Driver<a class="headerlink" href="#host-controller-driver" title="Permalink to this headline">¶</a></h2>
<p>The USB library host controller driver provides an interface to the host controller’s hardware register interface. This is the lowest level of the driver interface and it interacts directly with the DriverLib USB APIs. The host controller driver provides all of the functionality necessary to provide enumeration of devices regardless of the type of device that is connected. This portion of the enumeration code only enumerates the device and allows the higher level drivers to actually handle normal device operations. To allow the application to conserve code and data memory, the host controller driver provides a method to allow applications to only include the host class drivers that are needed for each type of USB device. This allows an application to handle multiple classes of devices but only include the USB library code that the application needs to communicate with the devices that the application supports. While the host controller driver handles the enumeration of devices it
relies on USB pipes, that are allocated by the higher level class drivers, as the direct communications method with a devices end points.</p>
<div class="section" id="enumeration">
<h3>Enumeration<a class="headerlink" href="#enumeration" title="Permalink to this headline">¶</a></h3>
<p>The USB host controller driver handles all of the details necessary to discover and enumerate any USB device. The USB host controller driver only performs enumeration and relies on the host class drivers to perform any other communications with USB devices including the allocation of the endpoints for the device. Most of the code used to enumerate devices is run in interrupt context and is contained in the enumeration handler. In order to complete the enumeration process, the host controller driver also requires that the application periodically call the <code class="docutils literal notranslate"><span class="pre">USBHCDMain()</span></code> function. When a host class driver or an application needs access to endpoint 0 of a device, it uses the <code class="docutils literal notranslate"><span class="pre">USBHCDControlTransfer()</span></code> interface to send data to the device or receive data from the device. During the enumeration process the host controller driver searches a list of host class drivers provided by the application in the <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> call. The details of this structure are covered in the host
class drivers section of this document. If the host controller driver finds a host class driver that matches the class of the enumerated device, it calls the open function for that host class driver. If no host class driver is found the host controller driver ignores the device and there is no notification to the application. The host controller driver or the host class driver can provide callbacks up through the USB library to inform the application of enumeration events. The host class drivers are responsible for configuring the USB pipes based on the type of device that is discovered. The application is notified of events in two ways: one is from the host class driver for the connected device and the other is from a non-device specific event driver. The class specific events come from the host class driver, while the generic connection, power and other non-device class specific events come from the host event driver if it is included in the application. The section “USB Events
Driver” covers the host events driver, the valid events and how to include the host events driver in an application.</p>
</div>
<div class="section" id="usb-host-configurable-features">
<h3>USB Host Configurable Features<a class="headerlink" href="#usb-host-configurable-features" title="Permalink to this headline">¶</a></h3>
<p>Like the USB device mode the USB host mode provides the application with the ability to set certain run-time global features of the USB library. The application uses the <code class="docutils literal notranslate"><span class="pre">USBHCDFeatureSet()</span></code> to set the configurable features of the USB host library. These features include USB clocking, enabling an external phy, and setting various power settings for the USB host library.</p>
<div class="section" id="usb-host-pll-feature">
<h4>USB Host PLL Feature<a class="headerlink" href="#usb-host-pll-feature" title="Permalink to this headline">¶</a></h4>
<p>One of the most important features used by applications informs the USB library of the of how the application has configured the main PLL. On MS class devices the USB clock is derived from the main PLL and the USB library sets up its own clock based on the value provided by the application. The <strong>USBLIB_FEATURE_USBPLL</strong> is only used on MSP432E4 class devices and defaults to 480 MHz. If the PLL is operating at a value other than 480 MHz then the application is required to call the <code class="docutils literal notranslate"><span class="pre">USBHCDFeatureSet()</span></code> function with the <strong>USBLIB_FEATURE_USBPLL</strong> feature to provide the PLL frequency to the USB library. The following is an example of setting the PLL frequency to a value other than the default 480 MHz.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32PLLFrequency</span><span class="p">;</span>

<span class="n">ui32PLLFrequency</span> <span class="o">=</span> <span class="mi">320000000</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Inform the USB library that the system is running using a 320 MHz PLL.</span>
<span class="c1">//</span>
<span class="n">USBHCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_USBPLL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32PLLFrequency</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-host-system-clock-feature">
<h4>USB Host System Clock Feature<a class="headerlink" href="#usb-host-system-clock-feature" title="Permalink to this headline">¶</a></h4>
<p>The USB library needs to know the actual operating frequency of the system clock in order to provide some rough delays that the USB library uses for some of the USB signaling. The application provides the system clock frequency using the <strong>USBLIB_FEATURE_CPUCLK</strong> feature setting. The default for this value is 120 MHz for MSP432E4 class devices. If the processor is operating at something other than one of these frequencies then the application must call the <code class="docutils literal notranslate"><span class="pre">USBHCDFeatureSet()</span></code> function with the <strong>USBLIB_FEATURE_CPUCLK</strong> feature to provide the actual system clock frequency.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32SysClock</span><span class="p">;</span>

<span class="n">ui32SysClock</span> <span class="o">=</span> <span class="mi">60000000</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Inform the USB library that the system is running at 60 MHz.</span>
<span class="c1">//</span>
<span class="n">USBHCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_CPUCLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32SysClock</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-host-ulpi-feature">
<h4>USB Host ULPI Feature<a class="headerlink" href="#usb-host-ulpi-feature" title="Permalink to this headline">¶</a></h4>
<p>The MSP432E4 class devices support using an external ULPI USB phy to allow the host to communicate with high speed devices. This feature is enabled by setting the <strong>USBLIB_FEATURE_USBULPI</strong> option combined with the desired speed. From the applications perspective this has no affect to normal USB operation other than the necessity to properly enable the USB external phy pins. The following are the possible configuration options when using ULPI:</p>
<ul class="simple">
<li><p><strong>USBLIB_FEATURE_ULPI_NONE</strong> - Disable ULPI and use the internal phy (default).</p></li>
<li><p><strong>USBLIB_FEATURE_ULPI_HS</strong> - Use an externally connected ULPI phy at high-speed.</p></li>
<li><p><strong>USBLIB_FEATURE_ULPI_FS</strong> - Use an externally connected ULPI phy at full-speed.</p></li>
</ul>
<p>The following is an example of configuring the USB library to use and external phy operating in high speed mode.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32ULPI</span><span class="p">;</span>

<span class="n">ui32ULPI</span> <span class="o">=</span> <span class="n">USBLIB_FEATURE_ULPI_HS</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Enable the use of an external USB ULPI connected phy.</span>
<span class="c1">//</span>
<span class="n">USBHCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_USBULPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32ULPI</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="usb-host-lpm-feature">
<h4>USB HOST LPM Feature<a class="headerlink" href="#usb-host-lpm-feature" title="Permalink to this headline">¶</a></h4>
<p>The MSP432E4 class devices added the ability to use the USB LPM feature. This feature is not enabled by default and therefore must be enabled by the application if it wishes to use any LPM features. Once LPM is enabled, the application can use the USB library to issue an LPM suspend transaction to a device by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDLPMSleep()</span></code> function and wake devices using the <code class="docutils literal notranslate"><span class="pre">USBHCDLPMResume()</span></code> function. There are only two options for LPM which allow the feature to be enabled or disabled with the following values:</p>
<ul class="simple">
<li><p><strong>USBLIB_FEATURE_LPM_DIS</strong> - Disable LPM transactions (default).</p></li>
<li><p><strong>USBLIB_FEATURE_LPM_EN</strong> - Enable sending and receiving LPM transactions.</p></li>
</ul>
<p>The following is an example of configuring the USB library enable LPM mode.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">ui32LPMFeature</span><span class="p">;</span>

<span class="n">ui32LPMFeature</span> <span class="o">=</span> <span class="n">USBLIB_FEATURE_LPM_EN</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Enable LPM transactions.</span>
<span class="c1">//</span>
<span class="n">USBHCDFeatureSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBLIB_FEATURE_LPM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ui32LPMFeature</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usb-pipes">
<h3>USB Pipes<a class="headerlink" href="#usb-pipes" title="Permalink to this headline">¶</a></h3>
<p>The host controller driver layer uses interfaces called USB pipes as the primary method of communications with USB devices. These USB pipes can be dynamically allocated or statically allocated by the USB class drivers during enumeration. The USB pipes are usually only used within the USB library or by host class drivers and are not usually directly accessed by applications. The USB pipes are allocated and freed by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDPipeAlloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHCDPipeFree()</span></code> functions and are initially configured by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDPipeConfig()</span></code>. The <code class="docutils literal notranslate"><span class="pre">USBHCDPipeAlloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHCDPipeConfig()</span></code> functions are used during USB device enumeration to allocate USB pipes to specific endpoints of the USB device. On disconnect, the <code class="docutils literal notranslate"><span class="pre">USBHCDPipeFree()</span></code> function is called to free up the USB pipe for use by a new USB device. While in use, the USB pipes can provide status and perform read and write operations. Calling <code class="docutils literal notranslate"><span class="pre">USBHCDPipeStatus()</span></code> allows a host class driver to check the status of a
pipe. However most access to the USB pipes occurs through <code class="docutils literal notranslate"><span class="pre">USBHCDPipeWrite()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHCDPipeRead()</span></code> and the callback function provided when the USB pipe was allocated. These are used to read or write to endpoints on USB devices on endpoints other than the control endpoint on endpoint 0. Since endpoint 0 is shared with all devices, the host controller interface does not use USB pipes for communications over endpoint 0 and instead uses the <code class="docutils literal notranslate"><span class="pre">USBHCDControlTransfer()</span></code> function.</p>
</div>
<div class="section" id="control-transactions">
<h3>Control Transactions<a class="headerlink" href="#control-transactions" title="Permalink to this headline">¶</a></h3>
<p>All USB control transactions are handled through the <code class="docutils literal notranslate"><span class="pre">USBHCDControlTransfer()</span></code> function. This function is primarily used inside the host controller driver itself during enumeration, however some devices may require using control transactions through endpoint 0. The HID class drivers are a good example of a USB class driver that uses control transactions to send data to a USB device. The <code class="docutils literal notranslate"><span class="pre">USBHCDControlTransfer()</span></code> function should not be called from within interrupt context as control transfers are a blocking operation that relies on interrupts to proceed. Since most callbacks occur in interrupt context, any calls to <code class="docutils literal notranslate"><span class="pre">USBHCDControlTransfer()</span></code> should be deferred until running outside the callback event. The USB host HID keyboard example is a good example of performing a control transaction outside of a callback function.</p>
</div>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<p>All interrupt handling is done by the USB library host controller driver and most callbacks are done in interrupt context and like interrupt handlers should defer any real processing of events to occur outside the interrupt context. The callbacks are used to notify the upper layers of events that occur during enumeration or during normal operation. Because most of enumeration code is handled by interrupt handlers the enumeration code does require that the application call the <code class="docutils literal notranslate"><span class="pre">USBHCDMain()</span></code> function in order to progress through the enumeration states without running all code in interrupt context.</p>
</div>
</div>
<div class="section" id="host-class-driver">
<h2>Host Class Driver<a class="headerlink" href="#host-class-driver" title="Permalink to this headline">¶</a></h2>
<p>The host class drivers provide access to devices that use a common USB class interface. The USB library currently supports the following two USB class drivers: Mass Storage Class(MSC) and Human Interface Device(HID). In order to use these class drivers, the application must provide a list of the host class drivers that it uses by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> function. The <code class="docutils literal notranslate"><span class="pre">g_USBHIDClassDriver</span></code> structure defines the interface for the Host HID class driver and the <code class="docutils literal notranslate"><span class="pre">g_USBHostMSCClassDriver</span></code> structure defines the interface for the Host MSC class driver.</p>
<p>The host class driver provides interfaces at its bottom layer to the USB host controller driver and device specific interfaces at it’s top layer. The lower layer interface to the USB host controller interface is the same for all USB host class drivers while the device interface layer on top is common to all USB host device interface of a given class. Thus the top layer of the of the MSC class driver does not need to match the top layer of the HID class driver, however the lower layer must be the same for both. Aside from enumeration, all communication with the host class driver is through its endpoint pipes. The host class driver parses and allocate any endpoints that it needs by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDPipeAlloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHCDPipeConfig()</span></code> functions. These USB pipes provide the methods to read/write and get callback notification from the USB host controller driver layer.</p>
<div class="section" id="usb-events-driver">
<h3>USB Events Driver<a class="headerlink" href="#usb-events-driver" title="Permalink to this headline">¶</a></h3>
<p>The USB host library includes a method to receive non-device class specific events in the application by using a USB event driver. This driver can be included in applications by declaring an instance of the USB event driver using the <code class="docutils literal notranslate"><span class="pre">DECLARE_EVENT_DRIVER()</span></code> macro and then adding the variable that is declared to the list of drivers supported by the application. This event driver allows applications to notify users that an unsupported device has been inserted or to provide notification that a power fault has occurred and power may have been shut off, depending on the settings provided to the <code class="docutils literal notranslate"><span class="pre">USBHCDPowerConfigInit()</span></code> function. Depending on configuration the following events can occur:</p>
<ul class="simple">
<li><p><strong>USB_EVENT_CONNECTED</strong> - indicates that a support device has been connected.</p></li>
<li><p><strong>USB_EVENT_UNKNOWN_CONNECTED</strong> - indicates that an unsupported device has been connected.</p></li>
<li><p><strong>USB_EVENT_DISCONNECTED</strong> - indicates that an unsupported device has been disconnected.</p></li>
<li><p><strong>USB_EVENT_POWER_FAULT</strong> - indicates that a power fault has occurred.</p></li>
<li><p><strong>USB_EVENT_POWER_ENABLE</strong> - indicates that power should be enabled by the application since it has requested to manually control the power.</p></li>
<li><p><strong>USB_EVENT_POWER_DISABLE</strong> - indicates that power should be enabled by the application since it has requested to manually control the power.</p></li>
<li><p><strong>USB_EVENT_SOF</strong> - indicates that a SOF event has occurred(default disabled).</p></li>
</ul>
<p>The USB host library provides the ability to enable or disable any of these events by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDEventEnable()</span></code> or <code class="docutils literal notranslate"><span class="pre">USBHCDEventDisable()</span></code> functions. All events except the <strong>USB_EVENT_SOF</strong> are enabled by default when the USB host library is initialized. The <strong>USB_EVENT_SOF</strong> event is left disabled by default to avoid the excess overhead because this event occurs once per millisecond.</p>
<p>Because the USB events driver reuses the interrupt handler callback that is used for a normal host controller drivers, the application is required to cast the void pointer that is passed in to the function to a pointer to a tEventInfo structure. The following code example shows a basic implementation of a USB library event driver callback function.</p>
<p>Because the USB events driver reuses the interrupt handler callback that is used for a normal host controller drivers, the application is required to cast the void pointer that is passed in to the function to a pointer to a <code class="docutils literal notranslate"><span class="pre">tEventInfo</span></code> structure. The following code example shows a basic implementation of a USB library event driver callback function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Declare the driver.</span>
<span class="c1">//</span>
<span class="n">DECLARE_EVENT_DRIVER</span><span class="p">(</span><span class="n">g_sEventDriver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USBHCDEvents</span><span class="p">)</span>

<span class="kt">void</span>
<span class="n">USBHCDEvents</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pvData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tEventInfo</span> <span class="o">*</span><span class="n">psEventInfo</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Cast this pointer to its actual type.</span>
    <span class="c1">//</span>
    <span class="n">psEventInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">tEventInfo</span> <span class="o">*</span><span class="p">)</span><span class="n">pvData</span><span class="p">;</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">psEventInfo</span><span class="o">-&gt;</span><span class="n">ui32Event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Unknown device connected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_CONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="p">...</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// Unknown device disconnected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_DISCONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="p">...</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// Power Fault detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_POWER_FAULT</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="p">...</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">default</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hub-class-driver">
<h3>Hub Class Driver<a class="headerlink" href="#hub-class-driver" title="Permalink to this headline">¶</a></h3>
<p>The USB Hub class driver provides support for a USB hub device that allows the USB controller to communicate with multiple USB devices. The maximum number of devices that are supported is controlled by the <strong>MAX_USB_DEVICES</strong> definition in usblib.h. The value defined by <strong>MAX_USB_DEVICES</strong> defaults to 5, meaning that the USB library supports one hub and four other devices. Cascaded USB hubs are not supported because the USB library only supports a single instance of a USB hub. The application-level interface to the USB hub class consists of only an initialization function and requires no additional application-level changes to handle any of the supported USB classes. When USB hub support is enabled, non-hub devices can still be directly connected to the USB controller with no special handling by the application. The next section covers the application interfaces to the USB hub class and the memory requirements when enabling the USB hub support.</p>
<p>The application layer of the USB hub class driver provides functions that an application uses to configure or disable the USB hub class driver. To initialize the USB hub class driver, the application must call <code class="docutils literal notranslate"><span class="pre">USBHHubOpen()</span></code> and provide it with a memory pool suitable to hold the configuration descriptors of the maximum number of attached devices and a hub instance structure. The memory pool allocation is very similar to how an application provides memory to the <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> function with the exception that that the amount of memory should be multiplied by the number of devices supported. This memory pool size should be the expected maximum configuration descriptor size multiplied by <strong>MAX_USB_DEVICES</strong>. The application also provides a tHubInstance structure that holds private instance data that should not be accessed by the application. In order to release an instance of a hub class driver, the application must call <code class="docutils literal notranslate"><span class="pre">USBHHubClose()</span></code>. This call to <code class="docutils literal notranslate"><span class="pre">USBHHubClose()</span></code> is only
made if the application is shutting down the USB interface or when in OTG mode, switching roles from host to device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The size of the host controller&#39;s memory pool in bytes.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="cp">#define HCD_MEMORY_SIZE         128</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The memory pool to provide to the Host controller driver.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8HCDPool</span><span class="p">[</span><span class="n">HCD_MEMORY_SIZE</span><span class="p">];</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The size of the host controller&#39;s memory pool in bytes.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="cp">#define HUB_POOL_SIZE           (HCD_MEMORY_SIZE * MAX_USB_DEVICES)</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The memory pool to provide to the hub driver.  This pool is used to hold the</span>
<span class="c1">// configuration descriptors of the devices attached to the hub.  It must be</span>
<span class="c1">// sized to be at least</span>
<span class="c1">// (MAX_USB_DEVICES * (largest expected configuration descriptor)) bytes.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8HubPool</span><span class="p">[</span><span class="n">HUB_POOL_SIZE</span><span class="p">];</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The instance data for the hub, which is internal data and should not be</span>
<span class="c1">// accessed by the application.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="n">tHubInstance</span> <span class="n">g_sHubInstance</span><span class="p">;</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The global that holds all of the host drivers in use in the application.</span>
<span class="c1">// In this case, the Mass Storage, HID, and Hub class drivers are present.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="n">tUSBHostClassDriver</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppsHostClassDrivers</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHostMSCClassDriver</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHIDClassDriver</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHubClassDriver</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sUSBEventDriver</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The global that holds the number of class drivers in the</span>
<span class="c1">// g_ppsHostClassDrivers list.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">g_ui32NumHostClassDrivers</span> <span class="o">=</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_ppsHostClassDrivers</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tUSBHostClassDriver</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB stack mode to host.</span>
<span class="c1">//</span>
<span class="n">USBStackModeSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USB_MODE_HOST</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Register the host class drivers.</span>
<span class="c1">//</span>
<span class="n">USBHCDRegisterDrivers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_ppsHostClassDrivers</span><span class="p">,</span> <span class="n">g_ui32NumHostClassDrivers</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Open the Keyboard and Mass storage interfaces.</span>
<span class="c1">//</span>
<span class="n">KeyboardOpen</span><span class="p">();</span>
<span class="n">MSCOpen</span><span class="p">();</span>

<span class="c1">//</span>
<span class="c1">// Open a hub instance and provide it with the memory required to hold</span>
<span class="c1">// configuration descriptors for each attached device and the private hub</span>
<span class="c1">// instance data.</span>
<span class="c1">//</span>
<span class="n">USBHHubOpen</span><span class="p">(</span><span class="n">HubCallback</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the power configuration by configuring the power enable signal</span>
<span class="c1">// to be active high and not enabling the power fault.</span>
<span class="c1">//</span>
<span class="n">USBHCDPowerConfigInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBHCD_VBUS_AUTO_HIGH</span> <span class="o">|</span> <span class="n">USBHCD_VBUS_FILTER</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB controller for OTG operation with a 2ms polling</span>
<span class="c1">// rate.</span>
<span class="c1">//</span>
<span class="n">HCDInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_pui8HCDPool</span><span class="p">,</span> <span class="n">HCD_MEMORY_SIZE</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HCDMain</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hid-class-driver">
<h3>HID Class Driver<a class="headerlink" href="#hid-class-driver" title="Permalink to this headline">¶</a></h3>
<p>The HID class driver provides access to any type of HID class by leaving the details of the HID device to the layer above the HID class driver. The top layer of the HID class driver provides common functions to open or close an instance of a HID device, read a device’s report descriptor so that it can be parsed by the HID device code, and get and set reports on a HID device. The lower level interface that is connected to the host controller driver is specified in the <code class="docutils literal notranslate"><span class="pre">g_USBHIDClassDriver</span></code> structure. This structure is used to register the HID class driver with the host class driver so that it is called when a HID device is connected and enumerated. The functions in the <code class="docutils literal notranslate"><span class="pre">g_USBHIDClassDriver</span></code> structure should never be called directly by and application or a host class driver as they are reserved for access by the host controller driver.</p>
<p>In the following example the generic HID class driver is registered with the USB host controller driver and then a call is made to open an instance of a mouse class device. Typically the call to <code class="docutils literal notranslate"><span class="pre">USBHHIDOpen()</span></code> is made from within a device class interface while the <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> call is made from the main application. For instance the <code class="docutils literal notranslate"><span class="pre">USBHHIDOpen()</span></code> for the mouse device provided with the USB library is made in the <code class="docutils literal notranslate"><span class="pre">USBHMouseOpen()</span></code> function which is part of the USB mouse interface.</p>
<p>At the top layer of the HID class driver, the driver has a device class interface for used by various HID devices. In order for the HID class driver to recognize a device, the device class is responsible for calling the <code class="docutils literal notranslate"><span class="pre">USBHHIDOpen()</span></code>. This call specifies the type of device and a callback for this device type so that any events related to this device type can be passed back to the device class driver. The defined classes are in the type defined values in the <code class="docutils literal notranslate"><span class="pre">tHIDSubClassProtocol</span></code> type and are passed into the <code class="docutils literal notranslate"><span class="pre">USBHHIDOpen()</span></code> call via the eDeviceType parameter. In order to release an instance of a HID class driver, the HID device class or application must call the <code class="docutils literal notranslate"><span class="pre">USBHHIDClose()</span></code> to allow a new or different type of device to be connected. In the examples provided in the USB library the report descriptors are retrieved but are not used as the examples rely on the “boot” mode of the USB keyboard and mouse to fix the format of the report descriptors. This is accomplished by using
the <code class="docutils literal notranslate"><span class="pre">USBHHIDSetReport()</span></code> interface to force the device into its boot protocol mode. As this could be limiting or not available in other types of applications or devices, the <code class="docutils literal notranslate"><span class="pre">USBHHIDGetReportDescriptor()</span></code> provides the ability of a generic HID device to query the device for its report descriptor(s). The last two remaining HID interfaces, <code class="docutils literal notranslate"><span class="pre">USBHHIDSetReport()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHHIDGetReport()</span></code>, provide access to the HID reports.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBHostClassDriver</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppsUSBHostClassDrivers</span><span class="p">[]</span> <span class="o">=</span>
 <span class="p">{</span>
     <span class="o">&amp;</span><span class="n">g_USBHIDClassDriver</span>
 <span class="p">};</span>

 <span class="c1">//</span>
 <span class="c1">// Register the host class drivers.</span>
 <span class="c1">//</span>
 <span class="n">USBHCDRegisterDrivers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_ppsUSBHostClassDrivers</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

 <span class="p">...</span>

 <span class="c1">//</span>
 <span class="c1">// Open an instance of a HID mouse class driver.</span>
 <span class="c1">//</span>
 <span class="n">psMouseInstance</span> <span class="o">=</span> <span class="n">USBHHIDOpen</span><span class="p">(</span><span class="n">USBH_HID_DEV_MOUSE</span><span class="p">,</span>
                               <span class="n">USBHMouseCallback</span><span class="p">,</span>
                               <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">g_sUSBHMouse</span><span class="p">);</span>
</pre></div>
</div>
<p>Once a HID device has been opened the first callback it receives is a <strong>USB_EVENT_CONNECTED</strong> event, indicating that a HID device of the type passed into the <code class="docutils literal notranslate"><span class="pre">USBHHIDOpen()</span></code> has been connected and the USB library host controller driver has completed enumeration of the device. When the HID device has been removed a <strong>USB_EVENT_DISCONNECTED</strong> event occurs. When shutting down or to release a device, the application should call <code class="docutils literal notranslate"><span class="pre">USBHHIDClose()</span></code> to disable callbacks. This does not actually power down the device but it stops the driver from calling the application. During normal operation the host class driver receives <strong>USB_EVENT_SCHEDULER</strong> and <strong>USB_EVENT_RX_AVAILABLE</strong> events. The <strong>USB_EVENT_SCHEDULER</strong> indicates that the HID class driver should schedule a new request if it is ready to do so. This done by calling <code class="docutils literal notranslate"><span class="pre">USBJHCDPipeSchedule()</span></code> to request that a new IN request is made on the given Interrupt IN pipe. When the <strong>USB_EVENT_RX_AVAILABLE</strong> occurs this indicates
that new data is available due to completion of the previous request for data on the Interrupt IN pipe. The <strong>USB_EVENT_RX_AVAILABLE</strong> is passed on the device class interface to allow it to request the data via a call to <code class="docutils literal notranslate"><span class="pre">USBHHIDGetReport()</span></code>. It is up to the device class driver to interpret the data in the report structure that is returned. In some cases, like the keyboard example, the device class may also need to call the host class driver to issue a set report to send data to the device. This is done by calling the <code class="docutils literal notranslate"><span class="pre">USBHHIDSetReport()</span></code> interface of the host class driver. This sends data to the device by using the correct USB OUT pipe.</p>
</div>
<div class="section" id="mass-storage-class-driver">
<h3>Mass Storage Class Driver<a class="headerlink" href="#mass-storage-class-driver" title="Permalink to this headline">¶</a></h3>
<p>The mass storage host class driver provides access to devices that support the mass storage class protocol. The most common of these devices are USB flash drives. This host class driver provides a simple block based interface to the devices that can be matched up with an application’s file system. A USB host class driver for mass storage devices is included with the USB library. It provides a simple block based interface that can be used with an application’s file system as it provides direct block interface to mass storage devices based on logical block address.</p>
<p>The mass storage host class driver provides an application API for access to USB flash drives. The API provided is meant to match with file systems that need block based read/write access to flash drives. The <code class="docutils literal notranslate"><span class="pre">USBHMSCBlockRead()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHMSCBlockWrite()</span></code> functions provide the block read and block write device access. These function performs block operations at the size specified by the flash drive. Since some flash drives require some setup time after enumeration before they are ready for drive access, the mass storage class driver provides the <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveReady()</span></code> function to check if the drive is ready for normal operation.</p>
<p>The mass storage host class driver also provides an interface to the USB library host controller driver to complete enumeration of mass storage class devices. The mass storage class driver information is held in the global structure <code class="docutils literal notranslate"><span class="pre">g_USBMSCClassDriver</span></code>. This structure should only be referenced by the application and the function pointers in this structure should never called directly by anything other than the host controller driver. The <code class="docutils literal notranslate"><span class="pre">USBHMSCOpen()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHMSCClose()</span></code> provide the interface for the host controller’s enumeration code to call when a mass storage class device is detected or removed. It is up to the mass storage host class driver to provide a callback to the file system or application for notification of the drive being removed or added. To make the the mass storage class driver visible to the host controller driver it must be added in the list of drivers provided in the <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> function call. The class enumeration constant is set to
<strong>USB_CLASS_MASS_STORAGE</strong> so any devices enumerating with value loads this class driver.</p>
<p>This next section covers how an application or file system interacts with the host mass storage class driver provided with the USB library. The application or file system must register the mass storage class driver with a call to <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> with the <code class="docutils literal notranslate"><span class="pre">g_USBHostMSCClassDriver</span></code> as a member of the array passed in to the call. Once the host mass storage class driver has been registered, the application must call <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveOpen()</span></code> to allow the application or file system to be called when a new mass storage device is connected or disconnected or any other mass storage class event occurs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tUSBHostClassDriver</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppsUSBHostClassDrivers</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHostMSCClassDriver</span>
<span class="p">};</span>

<span class="c1">//</span>
<span class="c1">// Register the host class drivers.</span>
<span class="c1">//</span>
<span class="n">USBHCDRegisterDrivers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_ppsUSBHostClassDrivers</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the mass storage class driver on controller 0 with the</span>
<span class="c1">// MSCCallback() function as the callback for events.</span>
<span class="c1">//</span>
<span class="n">USBHMSCDriveOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MSCCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>The first callback is a <strong>USB_EVENT_CONNECTED</strong> event, indicating that a mass storage class flash drive was inserted and the USB library host stack has completed enumeration of the device. This does not indicate that the flash drive is ready for read/write operations but that is has been detected. The <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveReady()</span></code> function should be called to determine when the flash drive is ready for read/write operations. When the device has been removed an <strong>USB_EVENT_DISCONNECTED</strong> event occurs. When shutting down, the application should call <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveClose()</span></code> to disable callbacks. This does not actually power down the mass storage device but it stops the driver from calling the application.</p>
<p>Once the <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveReady()</span></code> call indicates that the flash drive is ready, the application can use the <code class="docutils literal notranslate"><span class="pre">USBHMSCBlockRead()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHMSCBlockWrite()</span></code> functions to access the device. These are block based functions that use the logical block address to indicate which block to access. It is important to note that the size passed in to these functions is in blocks and not bytes and that the most common block size is 512 bytes. These calls always read or write a full block so space must be allocated appropriately. The following example shows calls for both reading and writing blocks from the mass storage class device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Read 1 block starting at logical block 0.</span>
<span class="c1">//</span>
<span class="n">USBHMSCBlockRead</span><span class="p">(</span><span class="n">ui32MSCDevice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pui8Buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Write 2 blocks starting at logical block 500.</span>
<span class="c1">//</span>
<span class="n">USBHMSCBlockWrite</span><span class="p">(</span><span class="n">ui32MSCDevice</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="n">pui8Buffer</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Since most mass storage class device adhere to the SCSI protocol for block based calls, the USB library provides SCSI functions for the mass storage class driver to communicate with flash drives. The commands and data pass over the USB pipes provided by the host controller driver. The only types of mass storage class devices that are supported are devices that use the SCSI protocol. Since flash drives only support a limited subset of the SCSI protocol, only the SCSI functions needed by mass storage class to mount and access flash drives are implemented. The <code class="docutils literal notranslate"><span class="pre">USBHSCSIRead10()</span></code> and <code class="docutils literal notranslate"><span class="pre">USBHSCSIWrite10()</span></code> functions are the two functions used for reading and writing to the mass storage class devices. The remaining SCSI functions are used to get information about the mass storage devices like the size of the blocks on the device and the number of blocks present. Others are used for error handling or testing if the device is ready for a new command.</p>
</div>
<div class="section" id="audio-class-driver">
<h3>Audio Class Driver<a class="headerlink" href="#audio-class-driver" title="Permalink to this headline">¶</a></h3>
<p>The USB audio host class driver provides access to devices that support the USB audio class protocol. This driver provides access to both audio in and audio out interfaces. The application opens an instance of the audio device by calling <code class="docutils literal notranslate"><span class="pre">USBHostAudioOpen()</span></code> and providing a callback function to receive events notifications when an audio device has been enumerated and is ready for normal operation, or when an active audio device has been disconnected. The application should not access any other APIs that use the interface returned from the <code class="docutils literal notranslate"><span class="pre">USBHostAudioOpen()</span></code> function until an <strong>USBH_AUDIO_EVENT_OPEN</strong> event is received and not after a <strong>USBH_AUDIO_EVENT_CLOSE</strong> event is received. When the application no longer needs the audio interface it can call <code class="docutils literal notranslate"><span class="pre">USBHostAudioClose()</span></code> to stop the audio device and no longer be notified of changes to the audio device. Audio output is handled by providing buffers to the host audio driver by calling <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> and including a
callback function for the buffer. The buffers are returned to the application by the callback to the application provided in the <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code>. This allows the application to gain control while the audio is being scheduled for output. The audio input is handled by providing buffers to the host audio driver by calling <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> and passing in a buffer callback as well. Buffers are then scheduled to be filled by the USB controller and returned to the application by the callback function that the application provided in the <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> call. The next section provides more detail and examples for each application level API.</p>
<p>The USB host audio application interface provides a basic method for controlling audio output, input and some volume control. Since the USB host audio provides only a small amount of buffering, it is up to the application to provide adequate buffering based on it’s other functions to keep the audio stream from starving for data.</p>
<p>The USB host audio driver requires some initial configuration by the application that is outside of the USB audio driver’s control. The first of these is to enable the uDMA controller and configure a DMA control table that includes the USB DMA channels. The application must also register the USB host audio driver by calling <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> with the <code class="docutils literal notranslate"><span class="pre">g_USBHostAudioClassDriver</span></code> structure pointer in the list of supported drivers. Finally the application must create an instance of the USB host audio device by calling the <code class="docutils literal notranslate"><span class="pre">USBHostAudioOpen()</span></code> function and provide it with a callback for basic USB audio events, saving the value returned for use with other APIs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// The instance data for the USB host audio driver.</span>
<span class="c1">//</span>
<span class="kt">uint32_t</span> <span class="n">g_psAudioInstance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The control table used by the uDMA controller.  This table must be aligned</span>
<span class="c1">// to a 1024 byte boundary.  When using USB with uDMA if it is only used for</span>
<span class="c1">// USB then only first 6 channels are needed.</span>
<span class="c1">//</span>
<span class="c1">// Note: If other DMA channels are used then the table must be large enough</span>
<span class="c1">// to hold all channels in use.</span>
<span class="c1">//</span>
<span class="n">tDMAControlTable</span> <span class="n">g_psDMAControlTable</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="c1">//</span>
<span class="c1">// The global that holds all of the host drivers in use in the application.</span>
<span class="c1">// In this case, only the host audio class is loaded.</span>
<span class="c1">//</span>
<span class="k">static</span> <span class="n">tUSBHostClassDriver</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppsHostClassDrivers</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHostAudioClassDriver</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sUSBEventDriver</span>
<span class="p">};</span>

    <span class="p">...</span>

    <span class="c1">//</span>
    <span class="c1">// Enable the uDMA controller and set up the control table base.</span>
    <span class="c1">//</span>
    <span class="n">SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_UDMA</span><span class="p">);</span>
    <span class="n">uDMAEnable</span><span class="p">();</span>
    <span class="n">uDMAControlBaseSet</span><span class="p">(</span><span class="n">g_psDMAControlTable</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// Register the host class drivers.</span>
    <span class="c1">//</span>
    <span class="n">USBHCDRegisterDrivers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_ppsHostClassDrivers</span><span class="p">,</span> <span class="n">g_ui32NumHostClassDrivers</span><span class="p">);</span>

    <span class="c1">//</span>
    <span class="c1">// Open an instance of the mass storage class driver.</span>
    <span class="c1">//</span>
    <span class="n">g_psAudioInstance</span> <span class="o">=</span> <span class="n">USBHostAudioOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">AudioCallback</span><span class="p">);</span>

    <span class="p">...</span>
</pre></div>
</div>
<p>Audio output is handled by setting the format of the audio stream and then by calling the <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> function to provide new buffers to the audio device. The callback function that is provided with this call returns the buffers when the driver is no longer using them. In order for audio output to start, the application must first set the audio format with a successful call to <code class="docutils literal notranslate"><span class="pre">USBHostAudioFormatSet()</span></code>. If the format was not supported by the audio device then this function returns a non-zero value and <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> should not be called until a valid format is selected. Once a valid format is set the application should provide audio data to the host audio driver by calling <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> and then always waiting for the callback to indicate that the buffer has been released. Calling the <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> function before the previous buffer has been released can cause the previous transfer to be interrupted or canceled. Since the USB host audio driver
provides limited buffering it is up to the application to have data ready for output. The application can safely call <code class="docutils literal notranslate"><span class="pre">USBHostAudioPlay()</span></code> function directly from the callback function to provide a new buffer to the USB audio device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">AudioOutCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pvBuffer</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Param</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Check if this was a buffer free event and provide a new buffer to the</span>
    <span class="c1">// host audio driver.</span>
    <span class="c1">//</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ui32Event</span> <span class="o">==</span> <span class="n">USB_EVENT_TX_COMPLETE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">USBHostAudioPlay</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="n">pNewBuffer</span><span class="p">,</span> <span class="n">ui32Size</span><span class="p">,</span>
                         <span class="n">AudioOutCallback</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AudioPlay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Wait for USBH_AUDIO_EVENT_OPEN event.</span>
    <span class="c1">//</span>

    <span class="p">...</span>

    <span class="c1">//</span>
    <span class="c1">// Set the audio format to 48KHz 16 bit stereo output.</span>
    <span class="c1">//</span>
    <span class="n">USBHostAudioFormatSet</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="mi">48000</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="n">USBH_AUDIO_FORMAT_OUT</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="c1">//</span>
    <span class="c1">// Start the output of the first buffer and let the callback start the</span>
    <span class="c1">// remaining buffers.</span>
    <span class="c1">//</span>
    <span class="n">USBHostAudioPlay</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="n">pBuffer</span><span class="p">,</span> <span class="n">ui32Size</span><span class="p">,</span> <span class="n">AudioOutCallback</span><span class="p">));</span>

    <span class="c1">//</span>
    <span class="c1">// Handle filling returned buffers.</span>
    <span class="c1">//</span>

    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Audio input is handled by setting the format of the audio stream and then by calling the <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> function to provide a new buffer to be filled by the host audio driver. The callback function that is provided with this call returns the buffer when the audio driver has new data available. In order for audio input to start, the application must first set the audio input format with a successful call to <code class="docutils literal notranslate"><span class="pre">USBHostAudioFormatSet()</span></code>. If the format was not supported by the audio device then this function returns a non-zero value. <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> should not be called until a valid format is selected. Once a valid format is set the application should provide an audio buffer to the host audio driver by calling <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> and wait for the callback to indicate that the buffer has been filled. Calling the <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> function before the previous buffer has been filled can cause the previous input transfer to be interrupted or lost. Since the USB
host audio driver provides limited buffering it is up to the application to handle the input buffers and provide new buffers. The application can safely call <code class="docutils literal notranslate"><span class="pre">USBHostAudioRecord()</span></code> function directly from the callback function to provide a new buffer to the USB audio device, however the same buffer should not be passed back until it has been processed or the host audio driver may overwrite the data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">AudioInCallback</span><span class="p">(</span><span class="n">tUSBHostAudioInstance</span> <span class="o">*</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
                     <span class="kt">uint32_t</span> <span class="n">ui32Param</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Check if this was a buffer full event and provide a new buffer to the</span>
    <span class="c1">// host audio driver.</span>
    <span class="c1">//</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ui32Event</span> <span class="o">==</span> <span class="n">USB_EVENT_RX_AVAILABLE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">USBHostAudioRecord</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="n">pNewBuffer</span><span class="p">,</span> <span class="n">ui32Size</span><span class="p">,</span>
                           <span class="n">AudioInCallback</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AudioRecord</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Wait for USBH_AUDIO_EVENT_OPEN event.</span>
    <span class="c1">//</span>

    <span class="p">...</span>

    <span class="c1">//</span>
    <span class="c1">// Set the audio format to 48KHz 16 bit stereo output.</span>
    <span class="c1">//</span>
    <span class="n">USBHostAudioFormatSet</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="mi">48000</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="n">USBH_AUDIO_FORMAT_IN</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="c1">//</span>
    <span class="c1">// Start the input of the first buffer and let the callback start the</span>
    <span class="c1">// remaining buffers.</span>
    <span class="c1">//</span>
    <span class="n">USBHostAudioRecord</span><span class="p">(</span><span class="n">psAudioInstance</span><span class="p">,</span> <span class="n">pBuffer</span><span class="p">,</span> <span class="n">ui32Size</span><span class="p">,</span> <span class="n">AudioInCallback</span><span class="p">));</span>

    <span class="c1">//</span>
    <span class="c1">// Handle filling returned buffers.</span>
    <span class="c1">//</span>

    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-custom-host-class-drivers">
<h3>Implementing Custom Host Class Drivers<a class="headerlink" href="#implementing-custom-host-class-drivers" title="Permalink to this headline">¶</a></h3>
<p>This next section covers how to implement a custom host class driver and how the host controller driver finds the driver. All host class drivers must provide their own driver interface that is visible to the host controller driver. As with the host class drivers that are included with the USB library, this means exposing a driver interface of the type <code class="docutils literal notranslate"><span class="pre">tUSBClassDriver</span></code>. In the example below the <code class="docutils literal notranslate"><span class="pre">USBGenericOpen()</span></code> function is called when the host controller driver enumerates a device that matches the <strong>USB_CLASS_SOMECLASS</strong> interface class. The <code class="docutils literal notranslate"><span class="pre">USBGenericClose()</span></code> function is called when the device of this class is removed. The following example shows a definition of a custom host class driver.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">tUSBClassDriver</span> <span class="n">sUSBGenericClassDriver</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">USB_CLASS_SOMECLASS</span><span class="p">,</span>
    <span class="n">USBGenericOpen</span><span class="p">,</span>
    <span class="n">USBGenericClose</span><span class="p">,</span>
    <span class="n">USBGenericIntHandler</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ulInterfaceClass</span></code> member of the <code class="docutils literal notranslate"><span class="pre">tUSBClassDriver</span></code> structure is the class read from the device’s interface descriptor during enumeration. This number is used to as the primary search value for a host class driver. If a device is connected that matches this structure member then that host class driver is loaded. The <code class="docutils literal notranslate"><span class="pre">pfnOpen</span></code> member of the tUSBClassDriver structure is called when a device with a matching interface class is detected. This function should do whatever is necessary to handle device detection and initial configuration of the device, this includes allocating any USB pipes that the device may need for communications. This requires parsing the endpoint descriptors for a device’s endpoints and then allocating the USB pipes based on the types and number of endpoints discover. The host class drivers provided with the USB library demonstrate how to parse and allocate USB pipes. This call is not at made interrupt level so it can be interrupted by other USB events. Anything
that must be done immediately before any other communications with the device should be done in the <code class="docutils literal notranslate"><span class="pre">pfnOpen</span></code> function. The <code class="docutils literal notranslate"><span class="pre">pfnOpen</span></code> member should should return a handle that is passed to the remaining functions <code class="docutils literal notranslate"><span class="pre">pfnClose</span></code> and <code class="docutils literal notranslate"><span class="pre">pfnIntHandler</span></code>. This handle should enable the host class driver to differentiate between different instances of the same type of device. The value returned can be any value as the USB library simply returns it unmodified to the other host class driver functions. The <code class="docutils literal notranslate"><span class="pre">pfnClose</span></code> structure member is called when the device that was created with <code class="docutils literal notranslate"><span class="pre">pfnOpen</span></code> call is removed from the system. All driver clean up should be done in the <code class="docutils literal notranslate"><span class="pre">pfnClose</span></code> call as no more calls are made to the host class driver. If the host class driver needs to respond to USB interrupts, an optional <code class="docutils literal notranslate"><span class="pre">pfnIntHandler</span></code> function pointer is provided. This function runs at interrupt time and called for any interrupt that occurs due to this device or for generic USB events. This function is
not required and should only be implemented if it is necessary. It is completely up to the custom USB host class driver to determine it’s own upper layer interface to applications or to other device interface layers. With the addition of hub support, the application interface layer should take into account multiple instances of a device class if multiple instances of devices are supported.</p>
</div>
</div>
<div class="section" id="host-device-interface">
<h2>Host Device Interface<a class="headerlink" href="#host-device-interface" title="Permalink to this headline">¶</a></h2>
<p>The USB library provides a set of host examples for a HID mouse, a HID keyboard, a mass storage device and a CDC serial device. The next few sections discusses each briefly and explain how their interfaces can be used by an application.</p>
</div>
<div class="section" id="mouse-device">
<h2>Mouse Device<a class="headerlink" href="#mouse-device" title="Permalink to this headline">¶</a></h2>
<p>The HID mouse device interface is controlled mainly through a callback function that is provided as part of the call to open the mouse device interface. In order to open an instance of the mouse device the application calls <code class="docutils literal notranslate"><span class="pre">USBHMouseOpen()</span></code> and passes in a callback function as well as some buffer data for use by the mouse device. The buffer provided is used internally by the mouse device and should not be used by the application. Once the device has been opened, the application should wait for a <strong>USB_EVENT_CONNECTED</strong> event to indicate that a mouse has been successfully detected and enumerated. At this point the application should call the <code class="docutils literal notranslate"><span class="pre">USBHMouseInit()</span></code> function to initialize the actual device that is connected. After this, the application can expect to start receiving the following events via the callback that was provided in the <code class="docutils literal notranslate"><span class="pre">USBHMouseOpen()</span></code> call: <strong>USBH_EVENT_HID_MS_PRESS</strong>, <strong>USBH_EVENT_HID_MS_REL</strong>, <strong>USBH_EVENT_HID_MS_X</strong>, or
<strong>USBH_EVENT_HID_MS_Y</strong>.</p>
<p><strong>USBH_EVENT_HID_MS_PRESS</strong></p>
<p>The ui32MsgParam parameter has one of the following values <strong>HID_MOUSE_BUTTON_1</strong>, <strong>HID_MOUSE_BUTTON_2</strong>, <strong>HID_MOUSE_BUTTON_3</strong> indicating which buttons have changed to the pressed state.</p>
<p><strong>USBH_EVENT_HID_MS_REL</strong></p>
<p>The ui32MsgParam parameter has one of the following values <strong>HID_MOUSE_BUTTON_1</strong>, <strong>HID_MOUSE_BUTTON_2</strong>, <strong>HID_MOUSE_BUTTON_3</strong> indicating which buttons have changed to the released state.</p>
<p><strong>USBH_EVENT_HID_MS_X</strong></p>
<p>The ui32MsgParam parameter has an 8 bit signed value indicating the delta in the X direction since the last update.</p>
<p><strong>USBH_EVENT_HID_MS_Y</strong></p>
<p>The ui32MsgParam parameter has an 8 bit signed value indicating the delta in the Y direction since the last update.</p>
<p>When the application is done using the mouse device it can call <code class="docutils literal notranslate"><span class="pre">USBHMouseClose()</span></code> to release the instance of the mouse device and free up the buffer that it passed to the mouse device.</p>
</div>
<div class="section" id="keyboard-device">
<h2>Keyboard Device<a class="headerlink" href="#keyboard-device" title="Permalink to this headline">¶</a></h2>
<p>Like the mouse, the HID keyboard device interface is controlled mainly through a callback function that is provided as part of the call to open the keyboard device interface. In order to open an instance of the keyboard device the application calls <code class="docutils literal notranslate"><span class="pre">USBHKeyboardOpen()</span></code> and passes in a callback function as well as some buffer data for use by the keyboard device. The buffer provided is used internally by the keyboard device and should not be used by the application. Once the device has been opened, the application should wait for a <strong>USB_EVENT_CONNECTED</strong> event to indicate that a keyboard has been successfully detected and enumerated. At this point the application should call the <code class="docutils literal notranslate"><span class="pre">USBHKeyboardInit()</span></code> function to initialize the actual keyboard device that is connected. After this, the application can expect to receive the following events via the callback that was provided in the <code class="docutils literal notranslate"><span class="pre">USBHKeyboardOpen()</span></code> call: <strong>USBH_EVENT_HID_KB_PRESS</strong>, <strong>USBH_EVENT_HID_KB_REL</strong>, or
<strong>USBH_EVENT_HID_KB_MOD</strong>.</p>
<p><strong>USBH_EVENT_HID_KB_PRESS</strong></p>
<p>The ui32MsgParam parameter has the USB usage identifier for the key that has been pressed. It is up to the application to map this usage identifier to an actual printable character using the <code class="docutils literal notranslate"><span class="pre">USBHKeyboardUsageToChar()</span></code> function, or it can simple respond to the key press without echoing the key to any output device. It should be noted that “special” keys like the Caps Lock key require notifying the actual keyboard device that the host application has detected that the key has been pressed.</p>
<p><strong>USBH_EVENT_HID_KB_REL</strong></p>
<p>The ui32MsgParam parameter has the USB usage identifier for the key that has been released.</p>
<p><strong>USBH_EVENT_HID_KB_MOD</strong></p>
<p>The ui32MsgParam parameter has the current state of all of the modifier keys on the connected keyboard. This value is a bit mapped representation of the modifier keys that can have any of the following bits set: * <strong>HID_KEYB_LEFT_CTRL</strong> * <strong>HID_KEYB_LEFT_SHIFT</strong> * <strong>HID_KEYB_LEFT_ALT</strong> * <strong>HID_KEYB_LEFT_GUI</strong> * <strong>HID_KEYB_RIGHT_CTRL</strong> * <strong>HID_KEYB_RIGHT_SHIFT</strong> * <strong>HID_KEYB_RIGHT_ALT</strong> * <strong>HID_KEYB_RIGHT_GUI</strong></p>
</div>
<div class="section" id="host-programming-examples">
<h2>Host Programming Examples<a class="headerlink" href="#host-programming-examples" title="Permalink to this headline">¶</a></h2>
<p>The USB library provides examples for three host applications that can access mass storage devices and HID keyboard and mouse devices. These next sections cover the basics of each of these three applications and how they interact with the USB library.</p>
<div class="section" id="application-initialization">
<h3>Application Initialization<a class="headerlink" href="#application-initialization" title="Permalink to this headline">¶</a></h3>
<p>The USB library host stack initialization is handled in the <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> function. This function should be called after registering class drivers using <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> and, optionally, configuring power pins using <code class="docutils literal notranslate"><span class="pre">USBHCDPowerConfigInit()</span></code>. Both of these functions are described later.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> function takes three parameters, the first of which specifies which USB controller to initialize. This value is a zero based index of the host controller to initialize. The next two parameters specify a memory pool for use by the host controller driver. The size of this buffer should be at least large enough to hold a typical configuration descriptor for devices that are going to be supported. This value is system dependent so it is left to the application to set the size, however it should never be less than 32 bytes and in most cases should be at least 64 bytes. If there is not enough memory to load a configuration descriptor from a device, the device is not recognized by USB library’s host controller driver. The USB library also provides a method to shut down an instance of the host controller driver by calling the <code class="docutils literal notranslate"><span class="pre">USBHCDTerm()</span></code> function. The <code class="docutils literal notranslate"><span class="pre">USBHCDTerm()</span></code> function should be called any time the application wants to shut down the USB host controller in
order to disable it, or possibly switch modes in the case of a dual role controller.</p>
<p>The USB library assumes that the power pin configuration has an active high signal for controlling the external power. If this is not the case or if the application wants control over the power fault logic provided by the library, then the application should call the <code class="docutils literal notranslate"><span class="pre">USBHCDPowerConfigInit()</span></code> function before calling <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> in order to properly configure the power control pins. The polarity of the power pin, the polarity of the the power fault pin and any actions taken in response to a power fault are all controlled by passing a combination of sets of values in the <code class="docutils literal notranslate"><span class="pre">ulPwrConfig</span></code> parameter. See the documentation for the <code class="docutils literal notranslate"><span class="pre">USBHCDPowerConfigInit()</span></code> function for more details on this function.</p>
</div>
<div class="section" id="application-interface">
<h3>Application Interface<a class="headerlink" href="#application-interface" title="Permalink to this headline">¶</a></h3>
<p>The USB library host stack requires some portion of the code to not run in the interrupt handler so it provides the <code class="docutils literal notranslate"><span class="pre">USBHCDMain()</span></code> function that must be called periodically in the main application. This can be as a result of a timer tick or just once per main loop in a simple application. It should not be called in an interrupt handler. Calling the function too often is harmless as it simply returns if the USB host stack has nothing to do. Calling <code class="docutils literal notranslate"><span class="pre">USBHCDMain()</span></code> too infrequently can cause enumeration to take longer than normal. It is up to the application to prioritize the importance of USB communications by calling <code class="docutils literal notranslate"><span class="pre">USBHCDMain()</span></code> at a rate that is reasonable to the application.</p>
<p>All support devices must have a host class driver loaded in order to communicate with each type of device that is supported. The details of interacting with these host class drivers is explained in the host class driver sections that follow in this document.</p>
</div>
<div class="section" id="application-termination">
<h3>Application Termination<a class="headerlink" href="#application-termination" title="Permalink to this headline">¶</a></h3>
<p>When the application needs to shut down the host controller it needs to shutdown all host class drivers and then shut down the host controller itself. This gives the host class drivers a chance to close cleanly by calling each host class driver’s close function. Then the <code class="docutils literal notranslate"><span class="pre">USBHCDTerm()</span></code> function should be called to shut down the host controller. This sequence leaves the USB controller and the USB library stack in a state so that it is ready to be re-initialized or in order to switch USB mode from host to device.</p>
</div>
<div class="section" id="example-application-setup">
<h3>Example Application Setup<a class="headerlink" href="#example-application-setup" title="Permalink to this headline">¶</a></h3>
<p>The following example shows the basic setup code needed for any application that is using the USB library in host mode. The <code class="docutils literal notranslate"><span class="pre">g_pui8HCDPool</span></code> array which is passed in to the <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> is used as heap memory for by the USB library and thus the memory should not be used by the application. In this example, the <code class="docutils literal notranslate"><span class="pre">g_ppsHostClassDrivers</span></code> array holds both HID and MSC class drivers making it possible for both types of devices to be supported. However if the application only needs to include the classes that it needs to support in order to save code and memory space. The pin and peripheral configuration is left to the application as the USB pins may not always be on the same physical pins for every part supported by the USB library. The macros provided in the pin_map.h file included with DriverLib can be used to indicate which pin and peripheral to use for a given part. See the DriverLib documentation on pin mapping for more details on how it provides mapping of peripherals to pins on
devices. The <code class="docutils literal notranslate"><span class="pre">USBHCDRegisterDrivers()</span></code> call passes in the static array of supported USB host class drivers that are supported by the application. As shown in the example, the application should always call the USB device interfaces open routines before calling <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> since this call enables the USB host controller and start enumerating any connected device. If the device interface has not been called it may miss the connection notification and could miss some state information that occurred before the device interface was ready.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The size of the host controller&#39;s memory pool in bytes.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="cp">#define HCD_MEMORY_SIZE         128</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The memory pool to provide to the Host controller driver.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="kt">uint8_t</span> <span class="n">g_pui8HCDPool</span><span class="p">[</span><span class="n">HCD_MEMORY_SIZE</span><span class="p">];</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// The global that holds all of the host drivers in use in the application.</span>
<span class="c1">// In this case, only the Keyboard class is loaded.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="n">tUSBHostClassDriver</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">g_ppsHostClassDrivers</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHIDClassDriver</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">g_sUSBHostMSCClassDriver</span>
<span class="p">};</span>

<span class="c1">//*****************************************************************************</span>
<span class="c1">//</span>
<span class="c1">// This global holds the number of class drivers in the g_ppsHostClassDrivers</span>
<span class="c1">// list.</span>
<span class="c1">//</span>
<span class="c1">//*****************************************************************************</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">g_ui32NumHostClassDrivers</span> <span class="o">=</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">g_ppsHostClassDrivers</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tUSBHostClassDriver</span> <span class="o">*</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Enable the GPIO peripherals used by the USB pins.</span>
<span class="c1">//</span>
<span class="n">MAP_SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_GPIOB</span><span class="p">);</span>
<span class="n">MAP_SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_GPIOG</span><span class="p">);</span>
<span class="n">MAP_SysCtlPeripheralEnable</span><span class="p">(</span><span class="n">SYSCTL_PERIPH_GPIOL</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Configure the USB EPEN as a USB pin.</span>
<span class="c1">//</span>
<span class="n">MAP_GPIOPinConfigure</span><span class="p">(</span><span class="n">GPIO_PG4_USB0EPEN</span><span class="p">);</span>
<span class="n">MAP_GPIOPinTypeUSBDigital</span><span class="p">(</span><span class="n">GPIO_PORTG_BASE</span><span class="p">,</span> <span class="n">GPIO_PIN_4</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Enable PB0 and PB1 as VBUS and ID pins.</span>
<span class="c1">//</span>
<span class="n">MAP_GPIOPinTypeUSBAnalog</span><span class="p">(</span><span class="n">GPIO_PORTB_BASE</span><span class="p">,</span> <span class="n">GPIO_PIN_0</span> <span class="o">|</span> <span class="n">GPIO_PIN_1</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Enable the D+/D- as USB pins.</span>
<span class="c1">//</span>
<span class="n">MAP_GPIOPinTypeUSBAnalog</span><span class="p">(</span><span class="n">GPIO_PORTL_BASE</span><span class="p">,</span> <span class="n">GPIO_PIN_6</span> <span class="o">|</span> <span class="n">GPIO_PIN_7</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the USB stack for host mode.</span>
<span class="c1">//</span>
<span class="n">USBStackModeSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">eUSBModeHost</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Register the host class drivers.</span>
<span class="c1">//</span>
<span class="n">USBHCDRegisterDrivers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_ppsUSBHostClassDrivers</span><span class="p">,</span> <span class="n">g_ui32NumHostClassDrivers</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Initialize the power configuration. This sets the power enable signal</span>
<span class="c1">// to be active high and does not enable the power fault.</span>
<span class="c1">//</span>
<span class="n">USBHCDPowerConfigInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">USBHCD_VBUS_AUTO_HIGH</span> <span class="o">|</span> <span class="n">USBHCD_VBUS_FILTER</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Call any open routines on the device class interfaces here so that they</span>
<span class="c1">// are ready to receive callbacks if the device is already inserted on</span>
<span class="c1">// power on.</span>
<span class="c1">//</span>
<span class="c1">// Eg: USBHMSCDriveOpen(0, MSCCallback);</span>
<span class="c1">//</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Initialize the host controller.</span>
<span class="c1">//</span>
<span class="n">USBHCDInit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g_pui8HCDPool</span><span class="p">,</span> <span class="n">HCD_MEMORY_SIZE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="host-hid-mouse-programming-example">
<h3>Host HID Mouse Programming Example<a class="headerlink" href="#host-hid-mouse-programming-example" title="Permalink to this headline">¶</a></h3>
<p>The USB library HID mouse example provides support for HID mouse devices that support the USB HID mouse BIOS protocol. Since most mice support the BIOS protocol nearly any mouse should be able to be connected and be supported. The initial call to <code class="docutils literal notranslate"><span class="pre">USBHMouseOpen()</span></code> prepares the mouse device application interface to receive notifications from any USB mouse device that is connected. Since the mouse interface needs some basic configuration after being connected the application needs to wait for the mouse to be connected and then call the <code class="docutils literal notranslate"><span class="pre">USBHMouseInit()</span></code> function to finish off the mouse configuration.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Open an instance of the mouse driver.  The mouse does not need</span>
<span class="c1">// to be present at this time, this just saves a place for it and allows</span>
<span class="c1">// the applications to be notified when a mouse is present.</span>
<span class="c1">//</span>
<span class="n">g_psMouseInstance</span> <span class="o">=</span> <span class="n">USBHMouseOpen</span><span class="p">(</span><span class="n">MouseCallback</span><span class="p">,</span> <span class="n">g_pui8Buffer</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Main loop of application.</span>
<span class="c1">//</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">iMouseState</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// This state is entered when they mouse is first detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">MOUSE_INIT</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// Initialized the newly connected mouse.</span>
            <span class="c1">//</span>
            <span class="n">USBHMouseInit</span><span class="p">(</span><span class="n">g_psMouseInstance</span><span class="p">);</span>

            <span class="c1">//</span>
            <span class="c1">// Proceed to the mouse connected state.</span>
            <span class="c1">//</span>
            <span class="n">iMouseState</span> <span class="o">=</span> <span class="n">MOUSE_CONNECTED</span><span class="p">;</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">MOUSE_CONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">MOUSE_NOT_CONNECTED</span><span class="p">:</span>
        <span class="k">default</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Periodic call the main loop for the Host controller driver.</span>
    <span class="c1">//</span>
    <span class="n">USBHCDMain</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Once the mouse has been configured the application’s mouse callback routine is notified any time there is a state change with the mouse. This includes the switching to the MOUSE_INIT state when a <strong>USB_EVENT_CONNECTED</strong> event occurs in order to trigger initialization of the mouse device. The <strong>USB_EVENT_DISCONNECTED</strong> simply switches the state of the application to let it know that the mouse is no longer present. The remaining events are mouse state changes that can be used by the application to move a cursor or make a selection based on a mouse click.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span>
<span class="nf">MouseCallback</span><span class="p">(</span><span class="n">tUSBHMouse</span> <span class="o">*</span><span class="n">psMsInstance</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
              <span class="kt">uint32_t</span> <span class="n">ui32MsgParam</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">ui32Event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// New mouse detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_CONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">iMouseState</span> <span class="o">=</span> <span class="n">MOUSE_INIT</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// Mouse has been unplugged.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_DISCONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">iMouseState</span> <span class="o">=</span> <span class="n">MOUSE_NOT_CONNECTED</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// New Mouse events detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_MS_PRESS</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_MS_REL</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_MS_X</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_MS_Y</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="host-hid-keyboard-programming-example">
<h3>Host HID Keyboard Programming Example<a class="headerlink" href="#host-hid-keyboard-programming-example" title="Permalink to this headline">¶</a></h3>
<p>The USB library HID keyboard example provides support for HID keyboard devices that support the USB HID keyboard BIOS protocol. Since most keyboards support the BIOS protocol most keyboards should be able to be connected and be supported. The initial call to <code class="docutils literal notranslate"><span class="pre">USBHKeyboardOpen()</span></code> prepares the keyboard device application interface to receive notifications from any USB keyboard device that is connected. The keyboard interface needs some basic configuration and needs to set the current state of LEDs on the keyboard, the application must wait for the keyboard to be connected and then call the <code class="docutils literal notranslate"><span class="pre">USBHKeyboardInit()</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Open an instance of the keyboard driver.  The keyboard does not need</span>
<span class="c1">// to be present at this time, this just save a place for it and allows</span>
<span class="c1">// the applications to be notified when a keyboard is present.</span>
<span class="c1">//</span>
<span class="n">g_psKeyboardInstance</span> <span class="o">=</span> <span class="n">USBHKeyboardOpen</span><span class="p">(</span><span class="n">KeyboardCallback</span><span class="p">,</span> <span class="n">g_pui8Buffer</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// The main loop for the application.</span>
<span class="c1">//</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">iKeyboardState</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// This state is entered when they keyboard is first detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">KEYBOARD_INIT</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// Initialized the newly connected keyboard.</span>
            <span class="c1">//</span>
            <span class="n">USBHKeyboardInit</span><span class="p">(</span><span class="n">g_psKeyboardInstance</span><span class="p">);</span>

            <span class="c1">//</span>
            <span class="c1">// Proceed to the keyboard connected state.</span>
            <span class="c1">//</span>
            <span class="n">iKeyboardState</span> <span class="o">=</span> <span class="n">KEYBOARD_CONNECTED</span><span class="p">;</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">KEYBOARD_UPDATE</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// If the application detected a change that required an</span>
            <span class="c1">// update to be sent to the keyboard to change the modifier</span>
            <span class="c1">// state then call it and return to the connected state.</span>
            <span class="c1">//</span>
            <span class="n">iKeyboardState</span> <span class="o">=</span> <span class="n">KEYBOARD_CONNECTED</span><span class="p">;</span>

            <span class="n">USBHKeyboardModifierSet</span><span class="p">(</span><span class="n">g_psKeyboardInstance</span><span class="p">,</span> <span class="n">g_ui32Modifiers</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">KEYBOARD_CONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">KEYBOARD_NOT_CONNECTED</span><span class="p">:</span>
        <span class="k">default</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">// Periodic call the main loop for the Host controller driver.</span>
    <span class="c1">//</span>
    <span class="n">USBHCDMain</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Much like the mouse, the keyboard handles the reception of events entirely in the callback handler. This function should receive and store the keyboard events and handle them in the main program loop when the device is in the connected state. The <strong>USB_EVENT_CONNECTED</strong> lets the main loop know that it is time to call the <code class="docutils literal notranslate"><span class="pre">USBHKeyboardInit()</span></code> routine to configure the keyboard. The <strong>USB_EVENT_DISCONNECTED</strong> event simply informs the application that the keyboard is not longer present and not to expect any more callbacks until another <strong>USB_EVENT_CONNECTED</strong> occurs. The remaining events all indicate that a key has been pressed or released. Normal key presses/releases generate <strong>USBH_EVENT_HID_KB_PRESS</strong> or <strong>USBH_EVENT_HID_KB_REL</strong> events while hitting keys like the shift, ctrl, alt and gui keys generate <strong>USBH_EVENT_HID_KB_MOD</strong> events.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span>
<span class="nf">KeyboardCallback</span><span class="p">(</span><span class="n">tUSBHKeyboard</span> <span class="o">*</span><span class="n">psKbInstance</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ui32Event</span><span class="p">,</span>
                 <span class="kt">uint32_t</span> <span class="n">ui32MsgParam</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pvMsgData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">ui8Char</span><span class="p">;</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">ui32Event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// New keyboard detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_CONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">iKeyboardState</span> <span class="o">=</span> <span class="n">KEYBOARD_INIT</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// Keyboard has been unplugged.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USB_EVENT_DISCONNECTED</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">iKeyboardState</span> <span class="o">=</span> <span class="n">KEYBOARD_NOT_CONNECTED</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//</span>
        <span class="c1">// New Key press detected.</span>
        <span class="c1">//</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_KB_PRESS</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// ui32MsgParam holds the USB Usage ID.</span>
            <span class="c1">//</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_KB_MOD</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// ui32MsgParam holds the USB Modifier bit mask.</span>
            <span class="c1">//</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">USBH_EVENT_HID_KB_REL</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// ui32MsgParam holds the USB Usage ID.</span>
            <span class="c1">//</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="host-mass-storage-programming-example">
<h3>Host Mass Storage Programming Example<a class="headerlink" href="#host-mass-storage-programming-example" title="Permalink to this headline">¶</a></h3>
<p>The following programming example demonstrates some of the basic interfaces that are available from the USB mass storage class application interface. See the “Basic Configuration as Host” example above for the initial configuration. The application should call <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveOpen()</span></code> in order for the application to be ready for a new mass storage device. The application should also wait for the mass storage device to be ready to receive commands by calling <code class="docutils literal notranslate"><span class="pre">USBHMSCDriveReady()</span></code> and waiting for the value returned to go to 0 before attempting to read or write the device. Typically the reading and writing of the device is left to a file system layer as is the case in the example application, however the calls to directly read or write a block are shown in the example below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Open an instance of the mass storage class driver.</span>
<span class="c1">//</span>
<span class="n">g_psMSCInstance</span> <span class="o">=</span> <span class="n">USBHMSCDriveOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MSCCallback</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Wait for the drive to become ready.</span>
<span class="c1">//</span>
<span class="k">while</span><span class="p">(</span><span class="n">USBHMSCDriveReady</span><span class="p">(</span><span class="n">g_psMSCInstance</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// System level delay call should be here to give the device time to</span>
    <span class="c1">// become ready.</span>
    <span class="c1">//</span>
    <span class="n">SysCtlDelay</span><span class="p">(</span><span class="n">g_ui32ClockRate</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Block Read example.</span>
<span class="c1">//</span>
<span class="n">USBHMSCBlockRead</span><span class="p">(</span><span class="n">g_psMSCInstance</span><span class="p">,</span> <span class="n">ui32LBA</span><span class="p">,</span> <span class="n">pui8Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// Block Write example.</span>
<span class="c1">//</span>
<span class="n">USBHMSCBlockWrite</span><span class="p">(</span><span class="n">g_psMSCInstance</span><span class="p">,</span> <span class="n">ui32LBA</span><span class="p">,</span> <span class="n">pui8Data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="host-cdc-serial-programming-example">
<h3>Host CDC Serial Programming Example<a class="headerlink" href="#host-cdc-serial-programming-example" title="Permalink to this headline">¶</a></h3>
<p>The following programming example demonstrates the transfer of data between CDC host and device. See the “Basic Configuration as Host” example above for the initial configuration.</p>
<p>The call to <code class="docutils literal notranslate"><span class="pre">USBHCDCSerialOpen()</span></code> prepares the host CDC application interface to receive notifications from any USB serial CDC device that is connected to it. The CDC host interfaces are intialized when the application calls <code class="docutils literal notranslate"><span class="pre">USBHCDInit()</span></code> and when a CDC device connects a call to <code class="docutils literal notranslate"><span class="pre">USBHCDCSerialInit()</span></code> is also made.</p>
<p>Once initialization has occured, the application begins to poll the data IN endpoint by calling <code class="docutils literal notranslate"><span class="pre">USBHCDCGetDataFromDevice()</span></code> API for any data sent from a connected CDC device. The application also can send data to the CDC device by calling <code class="docutils literal notranslate"><span class="pre">USBHCDCSendDataToDevice()</span></code> API.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="o">/</span>    <span class="c1">//</span>
    <span class="c1">// The main loop for the application.</span>
    <span class="c1">//</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//</span>
        <span class="c1">// Tell the OTG library code how much time has passed in</span>
        <span class="c1">// milliseconds since the last call.</span>
        <span class="c1">//</span>
        <span class="n">USBOTGMain</span><span class="p">(</span><span class="n">GetTickms</span><span class="p">());</span>

        <span class="k">switch</span><span class="p">(</span><span class="n">g_eUSBState</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="c1">// This state is entered when the CDC device is first detected.</span>
            <span class="c1">//</span>
            <span class="k">case</span> <span class="nl">STATE_CDC_DEVICE_INIT</span><span class="p">:</span>
            <span class="p">{</span>
                <span class="c1">//</span>
                <span class="c1">// Initialize the newly connected CDC device.</span>
                <span class="c1">//</span>
                <span class="n">USBHCDCSerialInit</span><span class="p">(</span><span class="n">g_psCDCSerialInstance</span><span class="p">);</span>

                <span class="c1">//</span>
                <span class="c1">// Proceed to the connected CDC device state.</span>
                <span class="c1">//</span>
                <span class="n">g_eUSBState</span> <span class="o">=</span> <span class="n">STATE_CDC_DEVICE_CONNECTED</span><span class="p">;</span>

                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">case</span> <span class="nl">STATE_CDC_DEVICE_CONNECTED</span><span class="p">:</span>
            <span class="p">{</span>

                <span class="c1">//</span>
                <span class="c1">// Start polling for data on interface 1</span>
                <span class="c1">//</span>
                <span class="n">USBHCDCGetDataFromDevice</span><span class="p">(</span><span class="n">g_psCDCSerialInstance</span><span class="p">,</span> <span class="n">INTERFACE_1</span><span class="p">);</span>

                <span class="c1">//</span>
                <span class="c1">// 10 sets of string of data has been received from device</span>
                <span class="c1">//</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ui8DataCounter</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">//Restart counter</span>
                    <span class="n">ui8DataCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="c1">//</span>
                    <span class="c1">// Press a key to acknowledge reception of data</span>
                    <span class="c1">//</span>
                    <span class="n">ui8SendArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;j&#39;</span><span class="p">;</span>
                    <span class="n">ui8DataSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="c1">//</span>
                    <span class="c1">// Send the key press to the device.</span>
                    <span class="c1">//</span>
                    <span class="n">USBHCDCSendDataToDevice</span><span class="p">(</span><span class="n">g_psCDCSerialInstance</span><span class="p">,</span> <span class="n">INTERFACE_1</span><span class="p">,</span> <span class="n">ui8SendArray</span><span class="p">,</span> <span class="n">ui8DataSize</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">case</span> <span class="nl">STATE_UNKNOWN_DEVICE</span><span class="p">:</span>
            <span class="p">{</span>
                <span class="c1">//</span>
                <span class="c1">// Nothing to do as the device is unknown.</span>
                <span class="c1">//</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">case</span> <span class="nl">STATE_NO_DEVICE</span><span class="p">:</span>
            <span class="p">{</span>
                <span class="c1">//</span>
                <span class="c1">// Nothing is currently done in the main loop when the CDC</span>
                <span class="c1">// device is not connected.</span>
                <span class="c1">//</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">default</span><span class="o">:</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="index.html" class="btn btn-neutral float-right" title="MSP432E4 USB Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="device_functions.html" class="btn btn-neutral float-left" title="Device Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>